<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unofficial Bevy Cheat Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script async defer src="https://buttons.github.io/buttons.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="nagbar.css">
        <link rel="stylesheet" href="sidebar.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="overview.html">Chapter Overview</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="builtins.html">List of Bevy Builtins</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">1.</strong> Bevy Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/guide.html"><strong aria-hidden="true">1.1.</strong> Guided Tour</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook.html"><strong aria-hidden="true">2.</strong> Bevy Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/print-framerate.html"><strong aria-hidden="true">2.1.</strong> Show Framerate</a></li><li class="chapter-item expanded "><a href="cookbook/cursor2world.html"><strong aria-hidden="true">2.2.</strong> Convert cursor to world coordinates</a></li><li class="chapter-item expanded "><a href="cookbook/custom-projection.html"><strong aria-hidden="true">2.3.</strong> Custom Camera Projection</a></li><li class="chapter-item expanded "><a href="cookbook/pan-orbit-camera.html"><strong aria-hidden="true">2.4.</strong> 3D Pan+Orbit Camera</a></li><li class="chapter-item expanded "><a href="cookbook/print-resources.html"><strong aria-hidden="true">2.5.</strong> List All Resource Types</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">3.</strong> Bevy Setup Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="setup/editor.html"><strong aria-hidden="true">3.2.</strong> Text Editor / IDE</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/editor/vscode.html"><strong aria-hidden="true">3.2.1.</strong> Visual Studio Code</a></li><li class="chapter-item expanded "><a href="setup/editor/jetbrains.html"><strong aria-hidden="true">3.2.2.</strong> JetBrains (RustRover, IntelliJ, CLion)</a></li><li class="chapter-item expanded "><a href="setup/editor/kak.html"><strong aria-hidden="true">3.2.3.</strong> Kakoune</a></li><li class="chapter-item expanded "><a href="setup/editor/vim.html"><strong aria-hidden="true">3.2.4.</strong> Vim</a></li><li class="chapter-item expanded "><a href="setup/editor/emacs.html"><strong aria-hidden="true">3.2.5.</strong> Emacs</a></li></ol></li><li class="chapter-item expanded "><a href="setup/bevy-config.html"><strong aria-hidden="true">3.3.</strong> Customizing Bevy (features, modularity)</a></li><li class="chapter-item expanded "><a href="setup/unofficial-plugins.html"><strong aria-hidden="true">3.4.</strong> Community Plugin Ecosystem</a></li><li class="chapter-item expanded "><a href="setup/bevy-tools.html"><strong aria-hidden="true">3.5.</strong> Dev Tools and Editors for Bevy</a></li><li class="chapter-item expanded "><a href="setup/perf.html"><strong aria-hidden="true">3.6.</strong> Performance Tunables</a></li><li class="chapter-item expanded "><a href="setup/bevy-git.html"><strong aria-hidden="true">3.7.</strong> Using bleeding-edge Bevy (main)</a></li></ol></li><li class="chapter-item expanded "><a href="pitfalls.html"><strong aria-hidden="true">4.</strong> Common Pitfalls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pitfalls/build-errors.html"><strong aria-hidden="true">4.1.</strong> Strange compile errors from Bevy or dependencies</a></li><li class="chapter-item expanded "><a href="pitfalls/performance.html"><strong aria-hidden="true">4.2.</strong> Slow Performance</a></li><li class="chapter-item expanded "><a href="pitfalls/into-system.html"><strong aria-hidden="true">4.3.</strong> Error adding function as system</a></li><li class="chapter-item expanded "><a href="pitfalls/3d-not-rendering.html"><strong aria-hidden="true">4.4.</strong> 3D objects not displaying</a></li><li class="chapter-item expanded "><a href="pitfalls/split-borrows.html"><strong aria-hidden="true">4.5.</strong> Borrow multiple fields from struct</a></li><li class="chapter-item expanded "><a href="pitfalls/time.html"><strong aria-hidden="true">4.6.</strong> Jittering Time (choppy movement/animation)</a></li><li class="chapter-item expanded "><a href="pitfalls/uv-coordinates.html"><strong aria-hidden="true">4.7.</strong> Textures/Images are flipped</a></li></ol></li><li class="chapter-item expanded "><a href="fundamentals.html"><strong aria-hidden="true">5.</strong> Game Engine Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/coords.html"><strong aria-hidden="true">5.1.</strong> Coordinate System</a></li><li class="chapter-item expanded "><a href="fundamentals/transforms.html"><strong aria-hidden="true">5.2.</strong> Transforms</a></li><li class="chapter-item expanded "><a href="fundamentals/visibility.html"><strong aria-hidden="true">5.3.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="fundamentals/time.html"><strong aria-hidden="true">5.4.</strong> Time and Timers</a></li><li class="chapter-item expanded "><a href="fundamentals/log.html"><strong aria-hidden="true">5.5.</strong> Logging, Console Messages</a></li><li class="chapter-item expanded "><a href="fundamentals/hierarchy.html"><strong aria-hidden="true">5.6.</strong> Parent/Child Hierarchies</a></li><li class="chapter-item expanded "><a href="fundamentals/fixed-timestep.html"><strong aria-hidden="true">5.7.</strong> Fixed Timestep</a></li><li class="chapter-item expanded "><a href="fundamentals/gizmos.html"><strong aria-hidden="true">5.8.</strong> Gizmos</a></li></ol></li><li class="chapter-item expanded "><a href="graphics.html"><strong aria-hidden="true">6.</strong> General Graphics Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphics/camera.html"><strong aria-hidden="true">6.1.</strong> Cameras</a></li><li class="chapter-item expanded "><a href="graphics/hdr-tonemap.html"><strong aria-hidden="true">6.2.</strong> HDR and Tonemapping</a></li><li class="chapter-item expanded "><a href="graphics/bloom.html"><strong aria-hidden="true">6.3.</strong> Bloom</a></li></ol></li><li class="chapter-item expanded "><a href="2d.html"><strong aria-hidden="true">7.</strong> Working with 2D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2d/camera.html"><strong aria-hidden="true">7.1.</strong> 2D Camera Setup</a></li><li class="chapter-item expanded "><a href="2d/sprites.html"><strong aria-hidden="true">7.2.</strong> Sprites and Atlases</a></li></ol></li><li class="chapter-item expanded "><a href="3d.html"><strong aria-hidden="true">8.</strong> Working with 3D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3d/camera.html"><strong aria-hidden="true">8.1.</strong> 3D Camera Setup</a></li><li class="chapter-item expanded "><a href="3d/gltf.html"><strong aria-hidden="true">8.2.</strong> 3D Models and Scenes (GLTF)</a></li></ol></li><li class="chapter-item expanded "><a href="input.html"><strong aria-hidden="true">9.</strong> Input Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input/keyboard.html"><strong aria-hidden="true">9.1.</strong> Keyboard</a></li><li class="chapter-item expanded "><a href="input/mouse.html"><strong aria-hidden="true">9.2.</strong> Mouse</a></li><li class="chapter-item expanded "><a href="input/gamepad.html"><strong aria-hidden="true">9.3.</strong> Gamepad (Controller, Joystick)</a></li><li class="chapter-item expanded "><a href="input/touch.html"><strong aria-hidden="true">9.4.</strong> Touchscreen</a></li><li class="chapter-item expanded "><a href="input/gesture.html"><strong aria-hidden="true">9.5.</strong> Gestures</a></li><li class="chapter-item expanded "><a href="input/dnd.html"><strong aria-hidden="true">9.6.</strong> Drag-and-Drop (Files)</a></li><li class="chapter-item expanded "><a href="input/ime.html"><strong aria-hidden="true">9.7.</strong> IME (Advanced Text)</a></li></ol></li><li class="chapter-item expanded "><a href="window.html"><strong aria-hidden="true">10.</strong> Window Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="window/props.html"><strong aria-hidden="true">10.1.</strong> Window Properties</a></li><li class="chapter-item expanded "><a href="window/clear-color.html"><strong aria-hidden="true">10.2.</strong> Change the Background Color</a></li><li class="chapter-item expanded "><a href="window/mouse-grab.html"><strong aria-hidden="true">10.3.</strong> Grab/Capture the Mouse Cursor</a></li><li class="chapter-item expanded "><a href="window/icon.html"><strong aria-hidden="true">10.4.</strong> Set the Window Icon</a></li></ol></li><li class="chapter-item expanded "><a href="assets.html"><strong aria-hidden="true">11.</strong> Asset Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="assets/handles.html"><strong aria-hidden="true">11.1.</strong> Handles</a></li><li class="chapter-item expanded "><a href="assets/assetserver.html"><strong aria-hidden="true">11.2.</strong> Load Assets from Files</a></li><li class="chapter-item expanded "><a href="assets/data.html"><strong aria-hidden="true">11.3.</strong> Access the Asset Data</a></li><li class="chapter-item expanded "><a href="assets/assetevent.html"><strong aria-hidden="true">11.4.</strong> React to Changes with Asset Events</a></li><li class="chapter-item expanded "><a href="assets/ready.html"><strong aria-hidden="true">11.5.</strong> Track Loading Progress</a></li><li class="chapter-item expanded "><a href="assets/hot-reload.html"><strong aria-hidden="true">11.6.</strong> Hot-Reloading Assets</a></li><li class="chapter-item expanded "><a href="assets/processing.html"><strong aria-hidden="true">11.7.</strong> Processing Assets</a></li></ol></li><li class="chapter-item expanded "><a href="audio.html"><strong aria-hidden="true">12.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="audio/basic.html"><strong aria-hidden="true">12.1.</strong> Playing Sounds</a></li><li class="chapter-item expanded "><a href="audio/spatial.html"><strong aria-hidden="true">12.2.</strong> Spatial Audio</a></li><li class="chapter-item expanded "><a href="audio/custom.html"><strong aria-hidden="true">12.3.</strong> Custom Audio Streams</a></li></ol></li><li class="chapter-item expanded "><a href="ui.html"><strong aria-hidden="true">13.</strong> Bevy UI Framework</a></li><li class="chapter-item expanded "><a href="programming.html"><strong aria-hidden="true">14.</strong> Bevy Core Programming Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/ecs-intro.html"><strong aria-hidden="true">14.1.</strong> Intro to ECS</a></li><li class="chapter-item expanded "><a href="programming/intro-data.html"><strong aria-hidden="true">14.2.</strong> Intro: Your Data</a></li><li class="chapter-item expanded "><a href="programming/intro-code.html"><strong aria-hidden="true">14.3.</strong> Intro: Your Code</a></li><li class="chapter-item expanded "><a href="programming/app-builder.html"><strong aria-hidden="true">14.4.</strong> The App</a></li><li class="chapter-item expanded "><a href="programming/systems.html"><strong aria-hidden="true">14.5.</strong> Systems</a></li><li class="chapter-item expanded "><a href="programming/res.html"><strong aria-hidden="true">14.6.</strong> Resources</a></li><li class="chapter-item expanded "><a href="programming/ec.html"><strong aria-hidden="true">14.7.</strong> Entities, Components</a></li><li class="chapter-item expanded "><a href="programming/bundle.html"><strong aria-hidden="true">14.8.</strong> Bundles</a></li><li class="chapter-item expanded "><a href="programming/queries.html"><strong aria-hidden="true">14.9.</strong> Queries</a></li><li class="chapter-item expanded "><a href="programming/commands.html"><strong aria-hidden="true">14.10.</strong> Commands</a></li><li class="chapter-item expanded "><a href="programming/events.html"><strong aria-hidden="true">14.11.</strong> Events</a></li><li class="chapter-item expanded "><a href="programming/plugins.html"><strong aria-hidden="true">14.12.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="programming/local.html"><strong aria-hidden="true">14.13.</strong> Local Resources</a></li><li class="chapter-item expanded "><a href="programming/exclusive.html"><strong aria-hidden="true">14.14.</strong> Exclusive Systems</a></li><li class="chapter-item expanded "><a href="programming/world.html"><strong aria-hidden="true">14.15.</strong> Direct ECS World Access</a></li><li class="chapter-item expanded "><a href="programming/schedules.html"><strong aria-hidden="true">14.16.</strong> Schedules</a></li><li class="chapter-item expanded "><a href="programming/system-order.html"><strong aria-hidden="true">14.17.</strong> System Order of Execution</a></li><li class="chapter-item expanded "><a href="programming/run-conditions.html"><strong aria-hidden="true">14.18.</strong> Run Conditions</a></li><li class="chapter-item expanded "><a href="programming/system-sets.html"><strong aria-hidden="true">14.19.</strong> System Sets</a></li><li class="chapter-item expanded "><a href="programming/states.html"><strong aria-hidden="true">14.20.</strong> States</a></li><li class="chapter-item expanded "><a href="programming/change-detection.html"><strong aria-hidden="true">14.21.</strong> Change Detection</a></li><li class="chapter-item expanded "><a href="programming/one-shot-systems.html"><strong aria-hidden="true">14.22.</strong> One-Shot Systems</a></li><li class="chapter-item expanded "><a href="programming/par-iter.html"><strong aria-hidden="true">14.23.</strong> Internal Parallelism</a></li><li class="chapter-item expanded "><a href="programming/system-piping.html"><strong aria-hidden="true">14.24.</strong> System Piping</a></li><li class="chapter-item expanded "><a href="programming/paramset.html"><strong aria-hidden="true">14.25.</strong> ParamSet</a></li><li class="chapter-item expanded "><a href="programming/non-send.html"><strong aria-hidden="true">14.26.</strong> Non-Send</a></li></ol></li><li class="chapter-item expanded "><a href="gpu.html"><strong aria-hidden="true">15.</strong> Bevy Render (GPU) Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gpu/intro.html"><strong aria-hidden="true">15.1.</strong> Render Architecture Overview</a></li><li class="chapter-item expanded "><a href="gpu/stages.html"><strong aria-hidden="true">15.2.</strong> Render Stages</a></li></ol></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">16.</strong> Programming Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/generic-systems.html"><strong aria-hidden="true">16.1.</strong> Generic Systems</a></li><li class="chapter-item expanded "><a href="patterns/component-storage.html"><strong aria-hidden="true">16.2.</strong> Component Storage (Table/Sparse-Set)</a></li><li class="chapter-item expanded "><a href="patterns/manual-event-clear.html"><strong aria-hidden="true">16.3.</strong> Manual Event Clearing</a></li><li class="chapter-item expanded "><a href="patterns/system-tests.html"><strong aria-hidden="true">16.4.</strong> Writing Tests for Systems</a></li></ol></li><li class="chapter-item expanded "><a href="platforms.html"><strong aria-hidden="true">17.</strong> Bevy on Different Platforms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/linux.html"><strong aria-hidden="true">17.1.</strong> Linux Desktop</a></li><li class="chapter-item expanded "><a href="platforms/macos.html"><strong aria-hidden="true">17.2.</strong> macOS Desktop</a></li><li class="chapter-item expanded "><a href="platforms/windows.html"><strong aria-hidden="true">17.3.</strong> Windows Desktop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/windows/wsl2.html"><strong aria-hidden="true">17.3.1.</strong> Working in WSL2</a></li></ol></li><li class="chapter-item expanded "><a href="platforms/wasm.html"><strong aria-hidden="true">17.4.</strong> Browser (WebAssembly)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/wasm/size-opt.html"><strong aria-hidden="true">17.4.1.</strong> Optimize for Size</a></li><li class="chapter-item expanded "><a href="platforms/wasm/webpage.html"><strong aria-hidden="true">17.4.2.</strong> Create a Custom Web Page</a></li><li class="chapter-item expanded "><a href="platforms/wasm/gh-pages.html"><strong aria-hidden="true">17.4.3.</strong> Hosting on GitHub Pages</a></li></ol></li><li class="chapter-item expanded "><a href="setup/cross.html"><strong aria-hidden="true">17.5.</strong> Cross-Compilation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/cross/linux-windows.html"><strong aria-hidden="true">17.5.1.</strong> From Linux to Windows</a></li><li class="chapter-item expanded "><a href="setup/cross/macos-windows.html"><strong aria-hidden="true">17.5.2.</strong> From macOS to Windows</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="credits.html">Credits</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contact.html">Contact Me</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing-bevy.html">Contribute to Bevy</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Contribute to this Book</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Unofficial Bevy Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="unofficial-bevy-cheat-book"><a class="header" href="#unofficial-bevy-cheat-book">Unofficial Bevy Cheat Book</a></h1>
<p>This is a reference-style book for the <a href="https://bevyengine.org">Bevy game engine</a>
(<a href="https://github.com/bevyengine/bevy">GitHub</a>).</p>
<p>It aims to teach Bevy concepts in a concise way, help you be productive,
and discover the knowledge you need.</p>
<p>This book aggregates a lot of community wisdom that is often not covered
by official documentation, saving you the need to struggle with issues that
others have figured out already!</p>
<p>While it aims to be exhaustive, documenting an entire game engine is
a monumental task. I focus my time on whatever I believe the community
needs most.</p>
<p>Therefore, there are still a lot of omissions, both for basics and advanced
topics. Nevertheless, I am confident this book will prove to be a valuable
resource to you!</p>
<p><em><strong>Welcome! May this book serve you well!</strong></em></p>
<p>(don't forget to
<a class="github-button" href="https://github.com/bevy-cheatbook/bevy-cheatbook" data-icon="octicon-star" aria-label="Star bevy-cheatbook/bevy-cheatbook on GitHub">Star</a>
the book's <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub repository</a>,
and consider <a href="https://github.com/sponsors/inodentry">donating</a> 🙂)</p>
<p>这是bevy的参考书,作者的目的是用简单的方式教授bevy的概念,提高我们的生产力,
快速发现所需知识.这里包含的大多是官方文档未提及,由社区已解决的问题.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>The pages in this book are not designed to be read in order. Each page covers
a standalone topic. Feel free to jump to whatever interests you.</p>
<p>If you have a specific topic in mind that you would like to learn about, you
can find it from the table-of-contents (sidebar) or using the search function
(in the top bar).</p>
<p>The <a href="/overview.html">Chapter Overview</a> page will give you a general idea
of how the book is structured.</p>
<p>The text on each page will link to other pages, where you can learn about other
things mentioned in the text. This helps you jump around the book.</p>
<p>If you are new to Bevy, or would like a more guided experience, try the
<a href="/tutorial/guide.html">Guided Tour tutorial</a>. It will help you navigate the book in
an order that makes sense for learning, from beginner to advanced topics.</p>
<p>The <a href="/builtins.html">Bevy Builtins</a> page is a concise cheatsheet of useful
information about types and features provided by Bevy.</p>
<p>本书是按主题分类,并无阅读顺序要求.</p>
<h2 id="recommended-additional-resources"><a class="header" href="#recommended-additional-resources">Recommended Additional Resources</a></h2>
<p>Bevy has a rich collection of <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official code
examples</a>.</p>
<p>Check out <a href="https://bevyengine.org/assets">bevy-assets</a>, for community-made resources.</p>
<p>Our community is very friendly and helpful. Feel welcome to join the <a href="https://discord.gg/bevy">Bevy
Discord</a> to chat, ask questions, or get involved in the project!</p>
<p>If you want to see some games made with Bevy, see <a href="https://itch.io/games/tag-bevy">itch.io</a>
or <a href="https://bevyengine.org/assets/#input">Bevy Assets</a>.</p>
<p>学习bevy推荐的其他资料: 官方文档/社区资源/itch.io的比赛.</p>
<h2 id="is-this-book-up-to-date"><a class="header" href="#is-this-book-up-to-date">Is this book up to date?</a></h2>
<p>Bevy has a very rapid pace of development, with new major releases roughly every
three months. Every version brings a lot of changes, so keeping this book
updated can be a major challenge.</p>
<p>To ease the maintenance burden, the policy of the project is that the book may
contain content for different versions of Bevy. However, mixing Bevy versions
on the same page is not allowed.</p>
<p>At the top of every page, you will see the version it was last updated for.
All content on that page must be relevant for the stated Bevy version.</p>
<p>bevy开发非常快,一个季度会发一个主版本, 本书也会即时更新.</p>
<h2 id="support-me"><a class="header" href="#support-me">Support Me</a></h2>
<p><a href="https://github.com/sponsors/inodentry"><button class="ghsponsors-button">GitHub Sponsors</button></a>
<a href="https://patreon.com/iyesgames"><button class="patreon-button">Patreon</button></a>
<a href="bitcoin:bc1qaf32uqsg6mngw9g4aqc3l2jvuv46qx0zw2438p"><button class="bitcoin-button">Bitcoin</button></a></p>
<p>If you like this book, please consider sponsoring me. Thank you! ❤️</p>
<p>I'd like to keep improving and maintaining this book, to provide a high-quality
independent learning resource for the Bevy community.</p>
<h2 id="support-bevy"><a class="header" href="#support-bevy">Support Bevy</a></h2>
<p><a href="https://github.com/sponsors/cart"><button class="ghsponsors-button">GitHub Sponsors</button></a></p>
<p>If you like the Bevy Game Engine, you should consider donating to the project.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright © 2021-2024 Ida Borisova (IyesGames)</p>
<p>All code in the book is provided under the
<a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 License</a>.
At your option, you may also use it under the regular MIT License.</p>
<p>The text of the book is provided under the
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</p>
<p>Exception: If used for the purpose of contribution to the "Official Bevy
Project", the entire content of the book may be used under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0
License</a>.</p>
<p>"Official Bevy Project" is defined as:</p>
<ul>
<li>Contents of the Git repository hosted at <a href="https://github.com/bevyengine/bevy">https://github.com/bevyengine/bevy</a></li>
<li>Contents of the Git repository hosted at <a href="https://github.com/bevyengine/bevy-website">https://github.com/bevyengine/bevy-website</a></li>
<li>Anything publicly visible on the <a href="https://bevyengine.org">bevyengine.org</a> website</li>
</ul>
<p>The MIT-0 license applies as soon as your contribution has been accepted upstream.</p>
<p>GitHub Forks and Pull Requests created for the purposes of contributing to
the Official Bevy Project are given the following license exception: the
Attribution requirements of CC BY-NC-SA 4.0 are waived for as long as the
work is pending upstream review (Pull Request Open). If upstream rejects
your contribution, you are given a period of 1 month to comply with the
full terms of the CC BY-NC-SA 4.0 license or delete your work. If upstream
accepts your contribution, the MIT-0 license applies.</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Development of this book is hosted on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<p>Please file GitHub Issues for any wrong/confusing/misleading information,
as well as suggestions for new content you'd like to be added to the book.</p>
<p>Please do not create PRs. Or if you do, be prepared for them to be ignored
or closed if I find that they take up too much of my time or don't help me
enough.</p>
<p>See the <a href="/contributing.html">Contributing</a> section for all the details.</p>
<h2 id="stability-warning"><a class="header" href="#stability-warning">Stability Warning</a></h2>
<p>Bevy is still a new and experimental game engine! It has only been public
since August 2020!</p>
<p>While improvements have been happening at an incredible pace, and development
is active, Bevy simply hasn't yet had the time to mature.</p>
<p><em>There are no stability guarantees and breaking changes happen often!</em></p>
<p>Usually, it not hard to adapt to changes with new releases, but you have been
warned!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="chapter-overview"><a class="header" href="#chapter-overview">Chapter Overview</a></h1>
<p>The <a href="/builtins.html">Bevy Builtins</a> page is a concise cheatsheet of useful
information about types and features provided by Bevy.</p>
<p>The <a href="/tutorial.html">Bevy Tutorials</a> chapter is for tutorials/guides
that you can follow from start to finish.</p>
<p>The <a href="/cookbook.html">Bevy Cookbook</a> is for more self-contained /
narrow-scoped examples that teach you how to solve specific problems.</p>
<p>The rest of the book is designed as a reference, covering different aspects of
working with Bevy. Feel free to jump around the book, to learn about any topic
that interests you. On every page of the book, any time other topics are
mentioned, the relevant pages or official API documentation is linked.</p>
<p>If you would like a guided experience, or to browse the book by relative
difficulty (from beginner to advanced), try the <a href="/tutorial.html">guided tutorial
page</a>. It recommends topics in a logical order for learning.</p>
<p>The book has the following general chapters:</p>
<ul>
<li><a href="/setup.html">Bevy Setup Tips</a>: project setup advice, recommendations for tools and plugins</li>
<li><a href="/pitfalls.html">Common Pitfalls</a>: solutions for common issues encountered by the community</li>
<li><a href="/platforms.html">Bevy on Different Platforms</a>: information about working with specific plaforms / OSs</li>
</ul>
<!-- - [Appendix: General Concepts][chapter::concepts]: various general gamedev knowledge, not specific to Bevy -->
<p>To learn how to program in Bevy, see these chapters:</p>
<ul>
<li><a href="/programming.html">Bevy Core Programming Framework</a>: the ECS+App frameworks, the foundation of everything</li>
<li><a href="/patterns.html">Programming Patterns</a>: opinionated advice, patterns, idioms</li>
<li><a href="/gpu.html">Bevy Render (GPU) Framework</a>: working with the GPU and Bevy's rendering</li>
</ul>
<p>The following chapters cover various Bevy feature areas:</p>
<ul>
<li><a href="/fundamentals.html">Game Engine Fundamentals</a></li>
<li><a href="/graphics.html">General Graphics Features</a></li>
<li><a href="/2d.html">Working with 2D</a></li>
<li><a href="/3d.html">Working with 3D</a></li>
<li><a href="/input.html">Input Handling</a></li>
<li><a href="/window.html">Window Management</a></li>
<li><a href="/assets.html">Asset Management</a></li>
<li><a href="/audio.html">Audio</a></li>
<li><a href="/ui.html">Bevy UI Framework</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="list-of-bevy-builtins"><a class="header" href="#list-of-bevy-builtins">List of Bevy Builtins</a></h1>
<p>This page is a quick condensed listing of all the important things provided
by Bevy.</p>
<ul>
<li><a href="builtins.html#systemparams">SystemParams</a></li>
<li><a href="builtins.html#assets">Assets</a></li>
<li><a href="builtins.html#file-formats">File Formats</a></li>
<li><a href="builtins.html#gltf-asset-labels">GLTF Asset Labels</a></li>
<li><a href="builtins.html#shader-imports">Shader Imports</a></li>
<li><a href="builtins.html#wgpu-backends"><code>wgpu</code> Backends</a></li>
<li><a href="builtins.html#schedules">Schedules</a></li>
<li><a href="builtins.html#run-conditions">Run Conditions</a></li>
<li><a href="builtins.html#plugins">Plugins</a></li>
<li><a href="builtins.html#bundles">Bundles</a></li>
<li><a href="builtins.html#configuration-resources">Resources (Configuration)</a></li>
<li><a href="builtins.html#engine-resources">Resources (Engine User)</a>
<ul>
<li><a href="builtins.html#engine-resources">Main World</a></li>
<li><a href="builtins.html#render-world-resources">Render World</a></li>
<li><a href="builtins.html#low-level-wgpu-resources">Low-Level <code>wgpu</code> access</a></li>
</ul>
</li>
<li><a href="builtins.html#input-handling-resources">Resources (Input)</a></li>
<li><a href="builtins.html#input-events">Events (Input)</a></li>
<li><a href="builtins.html#engine-events">Events (Engine)</a></li>
<li><a href="builtins.html#system-and-control-events">Events (System/Control)</a></li>
<li><a href="builtins.html#components">Components</a></li>
</ul>
<p>这里是对bevy重要概念的简要描述.</p>
<h2 id="systemparams"><a class="header" href="#systemparams">SystemParams</a></h2>
<p>These are all the special types that can be used as <a href="/programming/systems.html">system</a> parameters.</p>
<p>system参数,这里列出的都是特定的system参数.</p>
<p><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/trait.SystemParam.html#implementors">(List in API Docs)</a></p>
<p>In regular <a href="/programming/systems.html">systems</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>:
Manipulate the ECS using <a href="/programming/commands.html">commands</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Query.html"><code>Query&lt;T, F = ()&gt;</code></a> (can contain tuples of up to 15 types):
Access to <a href="/programming/intro-data.html#entities--components">entities and components</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>:
Shared access to a <a href="/programming/res.html">resource</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>:
Exclusive (mutable) access to a <a href="/programming/res.html">resource</a></li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code>:
Shared access to a resource that may not exist</li>
<li><code>Option&lt;ResMut&lt;T&gt;&gt;</code>:
Exclusive (mutable) access to a resource that may not exist</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="/programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>:
Receive <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>:
Send <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a>:
Read-only <a href="/programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet&lt;...&gt;</code></a> (with up to 8 params):
Resolve <a href="/programming/paramset.html">conflicts between incompatible system parameters</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Deferred.html"><code>Deferred&lt;T&gt;</code></a>:
Custom <a href="/programming/deferred.html">"deferred mutation"</a>, similar to <code>Commands</code>, but for your own things</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/removal_detection/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a>:
<a href="/programming/change-detection.html#removal-detection">Removal detection</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gizmos/gizmos/struct.Gizmos.html"><code>Gizmos</code></a>:
A way to <a href="/fundamentals/gizmos.html">draw lines and shapes</a> on the screen for debugging and dev purposes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/diagnostic/struct.Diagnostics.html"><code>Diagnostics</code></a>:
A way to <a href="/fundamentals/diagnostics.html">report measurements/debug data</a> to Bevy for tracking and visualization</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.SystemName.html"><code>SystemName</code></a>:
The name (string) of the system, may be useful for debugging</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ParallelCommands.html"><code>ParallelCommands</code></a>:
Abstraction to help use <code>Commands</code> when you will do your own parallelism</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/world/struct.WorldId.html"><code>WorldId</code></a>:
The World ID of the <a href="/programming/world.html">world</a> the system is running on</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.ComponentIdFor.html"><code>ComponentIdFor&lt;T&gt;</code></a>:
Get the <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.ComponentId.html"><code>ComponentId</code></a> of a given <a href="/programming/ec.html#components">component</a> type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/entity/struct.Entities.html"><code>Entities</code></a>:
Low-level ECS metadata: All entities</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.Components.html"><code>Components</code></a>:
Low-level ECS metadata: All components</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/bundle/struct.Bundles.html"><code>Bundles</code></a>:
Low-level ECS metadata: All bundles</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/archetype/struct.Archetypes.html"><code>Archetypes</code></a>:
Low-level ECS metadata: All archetypes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.SystemChangeTick.html"><code>SystemChangeTick</code></a>:
Low-level ECS metadata: Tick used for change detection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a>:
Shared access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>:
Exclusive access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><code>Option&lt;NonSend&lt;T&gt;&gt;</code>:
Shared access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data that may not exist</li>
<li><code>Option&lt;NonSendMut&lt;T&gt;&gt;</code>:
Exclusive access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data that may not exist</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.StaticSystemParam.html"><code>StaticSystemParam</code></a>:
Helper for generic system abstractions, to avoid lifetime annotations</li>
<li>tuples containing any of these types, with up to 16 members</li>
</ul>
<p>常规system,不独占ecs world.</p>
<ul>
<li><code>Commands</code>: 命令,维护ecs最常用的方式</li>
<li><code>Query&lt;T, F= ()&gt;</code>: 访问实体和组件的方式,最多可以访问15个组件,system最常使用的参数</li>
<li><code>Res&lt;T&gt;</code>: 共享访问资源的方式</li>
<li><code>ResMut&lt;T&gt;</code>: 独占访问资源的方式</li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code>: 共享访问资源的方式,资源可能不存在</li>
<li><code>Option&lt;ResMut&lt;T&gt;&gt;</code>: 独占访问资源的方式,资源可能不存在</li>
<li><code>Local&lt;T&gt;</code>: system自己的数据,local不保存在world中,而是在system中,在system后续运行中也存在</li>
<li><code>EventReader&lt;T&gt;</code>: 接收事件</li>
<li><code>EventWriter&lt;T&gt;</code>: 发送事件</li>
<li><code>&amp;world</code>: 直接访问world的方式,共享的</li>
<li><code>ParamSet&lt;...&gt;</code>: 解决system参数不兼容的方式,rust在编译期不知道bevy的ecs,运行时ecs要遵循rust的规则,通过此参数可以告诉bevy要处理不兼容</li>
<li><code>Deferred&lt;T&gt;</code>: 延时变更,Commands底层也是使用这个,有需要可以直接使用</li>
<li><code>RemovedComponents&lt;T&gt;</code>: 删除组件</li>
<li><code>Gizmos</code>: 在调试或开发时绘制的一些小玩意儿,线条或形状</li>
<li><code>Diagnostics</code>: 跟踪或显示bevy的诊断数据</li>
<li><code>SystemName</code>: 在调试可能用作识别system</li>
<li><code>ParallelCommands</code>: 并行命令</li>
<li><code>WorldId</code>: world id 标识</li>
<li><code>ComponentIdFor&lt;T&gt;</code>: 从组件类型获取组件ID</li>
<li><code>Entities</code>: ecs底层元数据: 所有实体</li>
<li><code>Components</code>: ecs底层元数据: 所有组件</li>
<li><code>Bundles</code>: ecs底层元数据: 所有bundle信息</li>
<li><code>Archetypes</code>: ecs底层元数据: 所有原型.一个原型表示共享同一组组件的实体集</li>
<li><code>SystemChangeTick</code>: ecs底层元数据: <code>变更检测</code>使用到的tick</li>
<li><code>NonSend&lt;T&gt;</code>: 共享访问Non-Send数据. Non-Send数据只能在主线程中访问,eg:窗口/图形/音频/和OS底层接口交互的.</li>
<li><code>NonSendMut&lt;T&gt;</code>: 独占访问Non-Send数据.</li>
<li><code>Option&lt;NonSend&lt;T&gt;&gt;</code>: 共享访问Non-Send数据, 数据可能不存在.</li>
<li><code>Option&lt;NonSendMut&lt;T&gt;&gt;</code>: 独占访问Non-Send数据, 数据可能不存在.</li>
<li><code>StaticSystemParam</code>: 简化生命周期写法的辅助器</li>
<li>元组,最多16个类型</li>
</ul>
<p>In <a href="/programming/exclusive.html">exclusive systems</a>:</p>
<ul>
<li>[<code>&amp;mut World</code>]:
Full <a href="/programming/world.html">direct access to the ECS World</a></li>
<li>[<code>Local&lt;T&gt;</code>]:
Data <a href="/programming/local.html">local</a> to the system</li>
<li>[<code>&amp;mut SystemState&lt;P&gt;</code>][<code>SystemState</code>]:
Emulates a regular system, allowing you to easily access data from the World.
<code>P</code> are the system parameters.</li>
<li>[<code>&amp;mut QueryState&lt;Q, F = ()&gt;</code>][<code>QueryState</code>]:
Allows you to perform queries on the World, similar to a [<code>Query</code>] in regular systems.</li>
</ul>
<p>独占system的参数(此类system在执行时会独占world):</p>
<ul>
<li><code>&amp;mut world</code>: 直接访问world的方式,独占的</li>
<li><code>Local&lt;T&gt;</code>: system自己的数据,local不保存在world中,而是在system中,在system后续运行中也存在</li>
<li><code>&amp;mut SystemState&lt;P&gt;</code> <code>SystemState</code>: 模拟普通system,可以简单从world访问数据,P就是system参数</li>
<li><code>&amp;mut QueryState&lt;Q, F= ()&gt;</code> <code>QueryState</code>: 从world执行查询,类似普通system的Query</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<p>函数最多有16个参数,如果需要更多,就使用元组来突破限制.
元组同样最多只能有16个参数,但没有嵌套限制.</p>
<p>Systems running during the <a href="/TODO.html">Extract schedule</a> can also use
<a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Extract.html"><code>Extract&lt;T&gt;</code></a>, to access data from the Main World instead of the
Render World. <code>T</code> can be any read-only system parameter type.</p>
<p>在外部调度器中的system也可以使用<code>Extract&lt;T&gt;</code>从Main(不是Render)中访问数据,
T可以是任意system 参数类型.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p><a href="/assets.html">(more info about working with assets)</a></p>
<p>These are the Asset types registered by Bevy by default.</p>
<p>这里的asset类型(资产类型)都是bevy默认注册的.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a>:
Pixel data, used as a texture for 2D and 3D rendering;
also contains the <a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a> for texture filtering settings</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a>:
2D "Sprite Sheet" defining sub-images within a single larger image</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a>:
3D Mesh (geometry data), contains vertex attributes (like position, UVs, normals)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a>:
GPU shader code, in one of the supported languages (WGSL/SPIR-V/GLSL)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.ColorMaterial.html"><code>ColorMaterial</code></a>:
Basic "2D material": contains color, optionally an image</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>:
"3D material" with support for Physically-Based Rendering</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a>:
Data for a single animation sequence, can be used with <a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationPlayer.html"><code>AnimationPlayer</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Font.html"><code>Font</code></a>:
Font data used for text rendering</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.Scene.html"><code>Scene</code></a>:
Scene composed of literal ECS entities to instantiate</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.DynamicScene.html"><code>DynamicScene</code></a>:
Scene composed with dynamic typing and reflection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a>:
<a href="/3d/gltf.html#gltf-master-asset">GLTF Master Asset</a>: index of the entire contents of a GLTF file</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a>:
Logical GLTF object in a scene</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>:
Logical GLTF 3D model, consisting of multiple <code>GltfPrimitive</code>s</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfPrimitive.html"><code>GltfPrimitive</code></a>:
Single unit to be rendered, contains the Mesh and Material to use</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a>:
Audio data for <code>bevy_audio</code></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.FontAtlasSet.html"><code>FontAtlasSet</code></a>:
(internal use for text rendering)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a>:
(internal use for skeletal animation)</li>
</ul>
<p>目前资产asset类型包含以下:</p>
<ul>
<li><code>Image</code>: 像素数据,在2d/3d渲染中用作纹理,也包含纹理过滤的GPU采样描述</li>
<li><code>TextureAtlas</code>: 纹理图集,多个对象可以从一个大图中取Image,这样可以减少纹理切换的开销</li>
<li><code>Mesh</code>: 3D Mesh对象是一种几何数据,包含顶点属性(eg:位置/UV/法线)</li>
<li><code>Shader</code>: 着色器,支持WGSL/SPIRV/GLSL语法</li>
<li><code>ColorMaterial</code>: 基础的2d材质,包含Image中的颜色/透明度</li>
<li><code>StandardMaterial</code>: 支持基于物理渲染的3d材质</li>
<li><code>AnimationClip</code>: 单个动画序列帧, 由<code>AnimationPlayer</code>使用</li>
<li><code>Font</code>: 文本渲染使用到的字体数据</li>
<li><code>Scene</code>: 一组实体/组件/资产的几何,world可复用的一部分</li>
<li><code>DynamicScene</code>: 可序列资产和动态实体的集合</li>
<li><code>Gltf</code>: gltf主要资产,gltf文件全部内容的索引.gltf是opengl传递格式,用于传输和加载3d场景和模型</li>
<li><code>GltfNode</code>: scene中的逻辑gltf对象</li>
<li><code>GltfMesh</code>: gltf 3d模型</li>
<li><code>GltfPrimitive</code>: gltf原语,单个可渲染单元,包括Mesh和Material</li>
<li><code>AudioSource</code>: bevy_audio使用的音频数据</li>
<li><code>FontAtlasSet</code>: 内部使用的,用于文本渲染</li>
<li><code>SkinnedMeshInverseBindposes</code>: 内部使用的,骨骼动画</li>
</ul>
<h2 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h2>
<p>These are the asset file formats (asset loaders) supported by Bevy. Support
for each one can be enabled/disabled using <a href="/setup/bevy-config.html">cargo features</a>. Some
are enabled by default, many are not.</p>
<p>以下是bevy支持的asset资源文件格式,默认启用了一批,通过<code>功能</code>开启其他的.</p>
<p>Image formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>PNG</td><td><code>"png"</code></td><td>Yes</td><td><code>.png</code></td></tr>
<tr><td>HDR</td><td><code>"hdr"</code></td><td>Yes</td><td><code>.hdr</code></td></tr>
<tr><td>KTX2</td><td><code>"ktx2"</code></td><td>Yes</td><td><code>.ktx2</code></td></tr>
<tr><td>KTX2+zstd</td><td><code>"ktx2", "zstd"</code></td><td>Yes</td><td><code>.ktx2</code></td></tr>
<tr><td>JPEG</td><td><code>"jpeg"</code></td><td>No</td><td><code>.jpg</code>, <code>.jpeg</code></td></tr>
<tr><td>WebP</td><td><code>"webp"</code></td><td>No</td><td><code>.webp</code></td></tr>
<tr><td>OpenEXR</td><td><code>"exr"</code></td><td>No</td><td><code>.exr</code></td></tr>
<tr><td>TGA</td><td><code>"tga"</code></td><td>No</td><td><code>.tga</code></td></tr>
<tr><td>PNM</td><td><code>"pnm"</code></td><td>No</td><td><code>.pam</code>, <code>.pbm</code>, <code>.pgm</code>, <code>.ppm</code></td></tr>
<tr><td>BMP</td><td><code>"bmp"</code></td><td>No</td><td><code>.bmp</code></td></tr>
<tr><td>DDS</td><td><code>"dds"</code></td><td>No</td><td><code>.dds</code></td></tr>
<tr><td>KTX2+zlib</td><td><code>"ktx2", "zlib"</code></td><td>No</td><td><code>.ktx2</code></td></tr>
<tr><td>Basis</td><td><code>"basis-universal"</code></td><td>No</td><td><code>.basis</code></td></tr>
</tbody></table>
</div>
<p>常见的图片格式包括:png/jpeg/webp/bmp.</p>
<ul>
<li>hdr是高动态范围图像（High-Dynamic Range Image）的文件格式,能存储更多亮度和色彩信息</li>
<li>ktx2是(Khronos Texture Container)格式的第二代版本，专为高效存储和传输纹理数据而设计,特别是3d和有效开发领域</li>
<li>exr是一种高动态范围(HDR)图像格式,是OpenEXR标准的一部分</li>
<li>tga的全称为Tagged Image File Format或Tagged Graphics，一家美国公司开发的,在图形设计/视频编辑/游戏开发有广泛应用</li>
<li>pnm是Netpbm（Network Portable Graphics）图像文件格式家族的一部分,使用简单便携的方式来存储和交换图像数据</li>
<li>dds全称为DirectDraw Surface,微软开发的一种图像文件格式,主要用于directX程序,可优化3d图形渲染的性能</li>
<li>basis是google开发的Basis Universal贴图格式,转为webgl和其他3d实时应用设计,保持高质量的同时还减少了文件大小,适合游戏/vr/网络场景,可作为jpeg/png的代替品,存储效率和跨平台兼容性都非常优秀</li>
</ul>
<p><em><strong>KTX2格式由Khronos Group开发，这个组织也负责维护OpenGL、Vulkan和Gltf等图形API标准。</strong></em></p>
<p>Audio formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>OGG Vorbis</td><td><code>"vorbis"</code></td><td>Yes</td><td><code>.ogg</code>, <code>.oga</code>, <code>.spx</code></td></tr>
<tr><td>FLAC</td><td><code>"flac"</code></td><td>No</td><td><code>.flac</code></td></tr>
<tr><td>WAV</td><td><code>"wav"</code></td><td>No</td><td><code>.wav</code></td></tr>
<tr><td>MP3</td><td><code>"mp3"</code></td><td>No</td><td><code>.mp3</code></td></tr>
</tbody></table>
</div>
<p>音频格式,默认启用的ogg.</p>
<ul>
<li>ogg: 开源,音质比mp3好;兼容性不好. 在网络流媒体场景下特别能打</li>
<li>flac: 无损;文件体积大. 在音乐库,高质量流媒体场景下特别能打</li>
<li>wav: 无损; 未压缩体积非常大. 专业录音,音频编辑场景下特别能打</li>
<li>mp3: 体积小; 有损音质差. 音乐下载,在线音乐服务场景下特别能打</li>
</ul>
<p>3D asset (model or scene) formats:</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>GLTF</td><td><code>"bevy_gltf"</code></td><td>Yes</td><td><code>.gltf</code>, <code>.glb</code></td></tr>
</tbody></table>
</div>
<p>3d资源格式只支持gltf.</p>
<p>Shader formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>WGSL</td><td>n/a</td><td>Yes</td><td><code>.wgsl</code></td></tr>
<tr><td>GLSL</td><td><code>"shader_format_glsl"</code></td><td>No</td><td><code>.vert</code>, <code>.frag</code>, <code>.comp</code></td></tr>
<tr><td>SPIR-V</td><td><code>"shader_format_spirv"</code></td><td>No</td><td><code>.spv</code></td></tr>
</tbody></table>
</div>
<p>着色器默认支持wgsl.</p>
<ul>
<li>wgsl: WebGPU Shading Language, 是WebGPU编写着色器的语法</li>
<li>glsl: 是OpenGL 着色器语法</li>
<li>spir-v: 是khronos group 为vulkan设计的,是一种着色器的低级中间件表示(ir格式),跨平台,高性能</li>
</ul>
<p>其中vert是顶点着色器,frag是段着色器,geom是几何着色器.</p>
<p>Font formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Font.html"><code>Font</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>TrueType</td><td>n/a</td><td>Yes</td><td><code>.ttf</code></td></tr>
<tr><td>OpenType</td><td>n/a</td><td>Yes</td><td><code>.otf</code></td></tr>
</tbody></table>
</div>
<p>字体ttf/otf两种都是默认支持的.</p>
<p>Bevy Scenes:</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>RON-serialized scene</td><td><code>.scn</code>,<code>.scn.ron</code></td></tr>
</tbody></table>
</div>
<p>场景格式支持scn,scn通常是游戏场景文件,包含了场景必要的信息,
如地形/单位位置/胜利条件,最初被实时策略游戏使用,现在使用非常广泛.
<code>.scn.ron</code>是使用rust对象标记格式进行编码的,ron是一种类似json的格式,
rust原生支持ron.</p>
<p>There are unofficial plugins available for adding support for even more file formats.</p>
<p>还有非官方的插件支持了不少其他文件格式.</p>
<h2 id="gltf-asset-labels"><a class="header" href="#gltf-asset-labels">GLTF Asset Labels</a></h2>
<p><a href="/3d/gltf.html#assetpath-with-labels">Asset path labels to refer to GLTF sub-assets.</a></p>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Mesh{}/Primitive{}/MorphTargets</code>: Morph target animation data for a GLTF Primitive</li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<p>GLTF (Graphics Library Transmission Format)资源中使用的标签主要涉及以下几方面:
描述3D模型、场景结构、材质、纹理等元素的元数据。
这些标签帮助组织和定义了GLTF文件中的不同组件，
使得它们能够在不同的平台和应用程序间有效传输和渲染。
以下是一些关键的GLTF资源标签及其用途概述：</p>
<ul>
<li>asset: 包含了GLTF文件的基本元数据，如版本号、版权信息、生成工具等。</li>
<li>scene: 定义场景的基本构成，一个GLTF文件可以包含多个场景，每个场景可以引用不同的节点集合。</li>
<li>scenes: 场景列表，每个场景定义了场景的根节点，以及初始默认场景。</li>
<li>nodes: 节点列表，定义了3D空间中的对象（如模型、灯光、相机等）及其变换（位置、旋转、缩放）。</li>
<li>meshes: 网格列表，描述了3D对象的几何形状，包括顶点、索引和顶点属性（如法线、UV坐标）。</li>
<li>materials: 材质列表，定义了如何渲染网格表面，包括颜色、纹理、光照模型等属性。</li>
<li>textures: 纹理列表，存储图像数据，用于材质贴图、环境映射等。</li>
<li>images: 图像数据列表，可以是图片文件的引用或直接嵌入的图像数据。</li>
<li>samplers: 定义了如何采样纹理，如过滤和环绕方式。</li>
<li>accessors: 数据访问器，描述如何从缓冲区视图中读取和解释数组数据（如顶点坐标、颜色数据等）。</li>
<li>bufferViews: 缓冲区视图，指定缓冲区中数据的偏移量和长度，以及数据的字节排列方式。</li>
<li>buffers: 缓冲区，存储大量的原始二进制数据，如顶点坐标、索引等。</li>
<li>cameras: 相机定义，描述了如何从3D场景渲染到2D图像，包括透视相机和正交相机。</li>
<li>animations: 动画列表，定义了场景中节点或材质随时间变化的动画序列。</li>
<li>skins: 皮肤信息，用于绑定网格顶点到骨骼，实现蒙皮动画。</li>
<li>extensions: 扩展，允许在GLTF规范基础上添加额外的功能或特定平台的支持。</li>
<li>extras: 附加数据，用于存储不被GLTF规范直接定义的信息，通常供特定应用程序或工具使用。</li>
</ul>
<p>bevy中使用到了: scene/node/mesh/mesh原语/变形动画数据/纹理/材质/默认材质/动画/皮肤.</p>
<h2 id="shader-imports"><a class="header" href="#shader-imports">Shader Imports</a></h2>
<p>TODO</p>
<h2 id="wgpu-backends"><a class="header" href="#wgpu-backends"><code>wgpu</code> Backends</a></h2>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Backends (in order of priority)</th></tr></thead><tbody>
<tr><td>Linux</td><td>Vulkan, GLES3</td></tr>
<tr><td>Windows</td><td>DirectX 12, Vulkan, GLES3</td></tr>
<tr><td>macOS</td><td>Metal</td></tr>
<tr><td>iOS</td><td>Metal</td></tr>
<tr><td>Android</td><td>Vulkan, GLES3</td></tr>
<tr><td>Web</td><td>WebGPU, WebGL2</td></tr>
</tbody></table>
</div>
<p>On GLES3 and WebGL2, some renderer features are unsupported and performance is worse.</p>
<p>WebGPU is experimental and few browsers support it.</p>
<p><code>wgpu</code>是rust编写的图形库,实现了WebGPU规范,为web和原生应用提供了跨平台一致的api,
性能很高,相比WebGL,WebGPU更加底层,对于GPU是直接访问,性能和灵活性都高很多.
跨平台是wgpu的特点,目前安卓到linux/web/macOS/windows都是支持的.
是下一代图形处理技术.复杂图形渲染/三维实时可视化场景下是强项,
适用于游戏开发/数据可视化/科学计算.<code>可以说bevy能起飞,wgpu就是核心基石之一</code>.
wgpu跨平台,Vulkan(通用跨平台图像库,下一代的技术)/Metal(Apple)/D3D12(windows)/
OpenGL/WebGL2和WebGPU(wasm),所以可以跨平台.</p>
<p>从上面的表格上看各个平台都有了支持.未来不知道是否可以支持主机平台.</p>
<h2 id="schedules"><a class="header" href="#schedules">Schedules</a></h2>
<p>Internally, Bevy has these built-in <a href="/programming/schedules.html">schedules</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Main.html"><code>Main</code></a>:
runs every frame update cycle, to perform general app logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.ExtractSchedule.html"><code>ExtractSchedule</code></a>:
runs after <code>Main</code>, to copy data from the Main World into the Render World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Render.html"><code>Render</code></a>:
runs after <code>ExtractSchedule</code>, to perform all rendering/graphics, in parallel with the next <code>Main</code> run</li>
</ul>
<p>在bevy内置了如下调度器:</p>
<ul>
<li><code>Main</code>主调度器,每帧都会运行,用于执行app的一般逻辑.</li>
<li><code>ExtractSchedule</code>外部调度器,在Main之后运行,用于将Main世界的数据拷贝到Render世界.</li>
<li><code>Render</code>渲染调度器,在ExtractSchedule之后运行,执行巡染操作,与下一个Main并行执行.</li>
</ul>
<p>The <code>Main</code> schedule simply runs a sequence of other schedules:</p>
<p>On the first run (first frame update of the app):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PreStartup.html"><code>PreStartup</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Startup.html"><code>Startup</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PostStartup.html"><code>PostStartup</code></a></li>
</ul>
<p>On every run (controlled via the <a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> <a href="/programming/res.html">resource</a>):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.First.html"><code>First</code></a>: any initialization that must be done at the start of every frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>: for engine-internal systems intended to run before user logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a>: perform any pending <a href="/programming/states.html">state</a> transitions</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.RunFixedUpdateLoop.html"><code>RunFixedUpdateLoop</code></a>: runs the <a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> schedule as many times as needed</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Update.html"><code>Update</code></a>: for all user logic (your systems) that should run every frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>: for engine-internal systems intended to run after user logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Last.html"><code>Last</code></a>: any final cleanup that must be done at the end of every frame</li>
</ul>
<p><code>FixedUpdate</code> is for all user logic (your systems) that should run at a <a href="/fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<p><code>StateTransition</code> runs the
<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter(...)</code></a>/<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition(...)</code></a>/<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit(...)</code></a>
schedules for your <a href="/programming/states.html">states</a>, when you want to change state.</p>
<p>Main调度器的工作仅仅是按顺序调用以下调度器:</p>
<p>首帧运行:</p>
<ul>
<li>PreStartup</li>
<li>Startup</li>
<li>PostStartup</li>
</ul>
<p>每帧运行:</p>
<ul>
<li>First: 帧初始化</li>
<li>PreUpdate: 引擎内部的前置处理,会先于用户逻辑执行</li>
<li>StateTransition: 执行挂起状态的转换</li>
<li>RunFixedUpdateLoop: 按需执行多次FixedUpdate调度器</li>
<li>Update: 所有用户逻辑(我们编写的system)</li>
<li>PostUpdate: 引擎内部的后置处理</li>
<li>Last: 帧清理</li>
</ul>
<p><code>FixedUpdate</code>调度器适合这种system:不依赖显示器刷新率,而是有自己固定的频率,
app如果执行快,就可能跳过FixedUpdate,如果执行慢,就可能执行多次FixedUpdate.</p>
<p>当你想要改变状态时,StateTransition会运行OnEnter/OnTransition/OnExit调度器.</p>
<p>The <a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Render.html"><code>Render</code></a> schedule is organized using <a href="/programming/system-sets.html">sets</a> (<a href="https://docs.rs/bevy/0.11.0/bevy/render/enum.RenderSet.html"><code>RenderSet</code></a>):</p>
<ul>
<li><code>ExtractCommands</code>: apply <a href="/programming/deferred.html">deferred</a> buffers from systems that ran in <code>ExtractSchedule</code></li>
<li><code>Prepare</code>/<code>PrepareFlush</code>: set up data on the GPU (buffers, textures, etc.)</li>
<li><code>Queue</code>/<code>QueueFlush</code>: generate the render jobs to be run (usually <a href="/TODO.html">phase items</a>)</li>
<li><code>PhaseSort</code>/<code>PhaseSortFlush</code>: sort and batch <a href="/TODO.html">phase items</a> for efficient rendering</li>
<li><code>Render</code>/<code>RenderFlush</code>: execute the <a href="/TODO.html">render graph</a> to actually trigger the GPU to do work</li>
<li><code>Cleanup</code>/<code>CleanupFlush</code>: clear any data from the render World that should not persist to the next frame</li>
</ul>
<p>The <code>*Flush</code> variants are just to apply any <a href="/programming/deferred.html">deferred</a> buffers after every step, if needed.</p>
<p>Render调度器是使用RenderSet组织的:</p>
<ul>
<li>ExtractCommands: 外部命令, 从ExtractSchedule外部调度器中获取buffer</li>
<li>Prepare/PrepareFlush: 在GPU上设置数据(buffer/纹理等)</li>
<li>Queue/QueueFlush: 生成渲染任务</li>
<li>PhaseSort/PhaseSortFlush: 分阶段处理, 为了更有效的渲染做必要的排序和分批次处理</li>
<li>Render/RenderFlush: 触发GPU开始工作</li>
<li>Cleanup/CleanupFlush: 在渲染世界中,清除下一帧不需要的持久化的数据</li>
</ul>
<p><code>Flush</code>系列操作是在每步中,延时对buffer进行处理.</p>
<h2 id="run-conditions"><a class="header" href="#run-conditions">Run Conditions</a></h2>
<p>TODO</p>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>TODO</p>
<h2 id="bundles"><a class="header" href="#bundles">Bundles</a></h2>
<p>Bevy's built-in <a href="/programming/bundle.html">bundle</a> types, for spawning different common
kinds of entities.</p>
<p>Bundle是bevy内置的类型,用于生成实体,生成实体时需要指定绑定的组件,
这个Bundle里保存的就是各种组件.</p>
<p><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/bundle/trait.Bundle.html#implementors">(List in API Docs)</a></p>
<p>Any tuples of up to 15 <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/trait.Component.html"><code>Component</code></a> types are valid bundles.</p>
<p>General:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a>:
Contains the required <a href="/fundamentals/transforms.html">transform</a> and <a href="/fundamentals/visibility.html">visibility</a>
components that must be included on <em>all</em> entities that need rendering or <a href="/fundamentals/hierarchy.html">hierarchy</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a>:
Contains only the transform types, subset of <code>SpatialBundle</code></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a>:
Contains only the visibility types, subset of <code>SpatialBundle</code></li>
</ul>
<p>bevy提供了实现Bundle的具体类型,都是元组类型,最多能指定15个组件,
bevy依据不同的场景内置了一些Bundle实现,下面看看具体有哪些实现.</p>
<p>通用Bundle包含以下类型:</p>
<p><code>SpatialBundle</code>: 空间Bundle. (如果要继承,需要包含下面4个组件),下列组件应包含在内:</p>
<ul>
<li><code>Visibility</code> 实体是否要显示</li>
<li><code>ComputedVisibility</code> 由算法决定实体是否要显示或提取出来做渲染</li>
<li><code>Transform</code> 放置或移动实体,表示实体基于父对象的的位置.(如果没有父对象,就是基于帧的位置)</li>
<li><code>GlobalTransform</code> 实体的全局变换,表示实体基于帧的位置</li>
</ul>
<p><em><strong>在Main调度中Update之后是PostUpdate,在PostUpdate中会执行TransformPropagate(这是一个system集合),
TransformPropagate集合中有个system是Transform,在这个Transform system中会执行GlobalTransform的处理.</strong></em></p>
<p><code>Main调度</code> -- <code>PostUpdate调度</code> -- <code>TransformPropagate系统集</code> -- <code>Transform系统</code> -- <code>处理GlobalTransform</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpatialBundle {
    pub visibility: Visibility,
    pub transform: Transform,
    pub computed: ComputedVisibility,
    pub global_transform: GlobalTransform,
}
<span class="boring">}</span></code></pre></pre>
<p><code>TransformBundle</code>: 变换Bundle,是<code>SpatialBundle</code>的变换子集.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TransformBundle {
    pub local: Transform,
    pub global: GlobalTransform,
}
<span class="boring">}</span></code></pre></pre>
<p><code>VisibilityBundle</code>: 可视Bundle,是<code>SpatialBundle</code>的可视子集.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VisibilityBundle {
    pub visibility: Visibility,
    pub computed: ComputedVisibility,
}
<span class="boring">}</span></code></pre></pre>
<p>Scenes:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.SceneBundle.html"><code>SceneBundle</code></a>:
Used for spawning scenes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.DynamicSceneBundle.html"><code>DynamicSceneBundle</code></a>:
Used for spawning dynamic scenes</li>
</ul>
<p>场景Bundle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SceneBundle {
    pub scene: Handle&lt;Scene&gt;,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub visibility: Visibility,
    pub computed_visibility: ComputedVisibility,
}

pub struct DynamicSceneBundle {
    pub scene: Handle&lt;DynamicScene&gt;,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub visibility: Visibility,
    pub computed_visibility: ComputedVisibility,
}
<span class="boring">}</span></code></pre></pre>
<p>scene是描述场景的数据,主要是实体/组件的数据,可以进行序列号和反序列,
有了场景数据,就能进行存盘或从磁盘加载.关卡设计都可以用到scene.
静态场景常表示静态的,在设计时就定义好的场景;动态场景则是动态生成,运行时更新的场景.
动态场景提供了更加灵活的更新和增量修改能力.</p>
<p>Audio:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/type.AudioBundle.html"><code>AudioBundle</code></a>:
Play [audio][cb::audio] from an <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> asset</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/type.SpatialAudioBundle.html"><code>SpatialAudioBundle</code></a>:
Play <a href="/audio/spatial.html">positional audio</a> from an <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> asset</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSourceBundle.html"><code>AudioSourceBundle</code></a>:
Play audio from a <a href="/audio/custom.html">custom data source/stream</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.SpatialAudioSourceBundle.html"><code>SpatialAudioSourceBundle</code></a>:
Play positional audio from a <a href="/audio/custom.html">custom data source/stream</a></li>
</ul>
<p>音频Bundle.</p>
<ul>
<li><code>AudioBundle</code> 从AudioSource资源播放音频</li>
<li><code>SpatialAudioBundle</code> 从AudioSource资源播放空间音频</li>
<li><code>AudioSourceBundle</code> 从<code>自定义源/自定义流</code>播放音频</li>
<li><code>SpatialAudioSourceBundle</code> 从<code>自定义源/自定义流</code>播放空间音频</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AudioSource {
    // 音频的原始数据,格式为wav/ogg/flac/mp3中的一种,
    // bevy默认开启支持的ogg,其他格式需要在功能出开启支持.
    pub bytes: Arc&lt;[u8]&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Bevy 3D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/core_3d/struct.Camera3dBundle.html"><code>Camera3dBundle</code></a>:
3D camera, can use perspective (default) or orthographic projection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/experimental/taa/struct.TemporalAntiAliasBundle.html"><code>TemporalAntiAliasBundle</code></a>:
Add this to a 3D camera to enable TAA</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.ScreenSpaceAmbientOcclusionBundle.html"><code>ScreenSpaceAmbientOcclusionBundle</code></a>:
Add this to a 3D camera to enable SSAO</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>:
3D Object/Primitive: a Mesh and a custom Material to draw it with</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/type.PbrBundle.html"><code>PbrBundle</code></a>:
<code>MaterialMeshBundle</code> with the default Physically-Based Material (<a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.DirectionalLightBundle.html"><code>DirectionalLightBundle</code></a>:
3D directional light (like the sun)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.PointLightBundle.html"><code>PointLightBundle</code></a>:
3D point light (like a lamp or candle)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.SpotLightBundle.html"><code>SpotLightBundle</code></a>:
3D spot light (like a projector or flashlight)</li>
</ul>
<p>bevy 3d Bundle.</p>
<ul>
<li><code>Camera3dBundle</code> 3d摄像头,用于透视投影(默认)或正交投影</li>
<li><code>TemporalAntiAliasBundle</code> taa(抗锯齿),可用于3d摄像头</li>
<li><code>ScreenSpaceAmbientOcclusionBundle</code> ssao(屏幕空间环境光遮蔽),可用于3d摄像头</li>
<li><code>MaterialMeshBundle</code> 网格和材质,3d原语</li>
<li><code>PbrBundle</code> 是<code>MaterialMeshBundle</code>的一种,材质是<code>StandardMaterial</code>(一种基于pbr的材质,可从Color/Image中直接生成)</li>
<li><code>DirectionalLightBundle</code> 3d定向光(eg:阳光).(定向光在现实中并不存在,但近似为很远的光,月光就属于定向光)</li>
<li><code>PointLightBundle</code> 3d点光源(eg:蜡烛/台灯).(点光源是从中心点向各个方向发射光的灯)</li>
<li><code>SpotLightBundle</code> 3d聚光灯(eg:投影仪/手电筒).</li>
</ul>
<p>透视投影（Perspective Projection）和3D正交投影（Orthographic Projection）是计算机图形学中两种基本的投影方式，
用于将三维场景投影到二维平面上。它们在视觉效果和应用场景上有显著的区别。<br />
<code>透视投影</code>模拟了人类眼睛和相机的视角特性，即远处的物体看起来会更小，近处的物体会更大。
这种投影方式能够提供逼真的深度感。<br />
<code>正交投影</code>不会根据物体距离相机的远近而缩放物体大小。
它适合于需要精确测量和对比的场景，如CAD软件、2D游戏和某些类型的策略游戏。</p>
<p>Temporal Anti-Aliasing(<code>TAA</code>)是一种抗锯齿技术，用于计算机图形学中，以减少动态场景中出现的锯齿状边缘。
TAA 利用多帧信息来平滑对象边缘，从而在运动中保持高质量的视觉效果。</p>
<p>屏幕空间环境光遮蔽 (Screen Space Ambient Occlusion, <code>SSAO</code>) 是一种在实时渲染中常用的技术，
用于模拟环境光遮蔽（Ambient Occlusion, AO）的效果。
AO 是一种全局光照效果，用于模拟光线在物体之间反弹时被遮挡的情况，
通常用于增强物体之间的阴影和细节，使场景看起来更加真实和立体。</p>
<p>物理基础渲染（Physically Based Rendering, <code>PBR</code>）
是一种通过模拟光与物体表面交互的物理现象来实现更逼真和一致视觉效果的渲染方法。
PBR广泛应用于游戏、电影和虚拟现实等领域，它能在各种光照条件下生成一致且逼真的图像。</p>
<p>Bevy 2D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>:
2D camera, uses orthographic projection + other special configuration for 2D</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.SpriteBundle.html"><code>SpriteBundle</code></a>:
2D sprite (<a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.SpriteSheetBundle.html"><code>SpriteSheetBundle</code></a>:
2D sprite (<a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.MaterialMesh2dBundle.html"><code>MaterialMesh2dBundle</code></a>:
2D shape, with custom Mesh and Material (similar to 3D objects)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Text2dBundle.html"><code>Text2dBundle</code></a>:
Text to be drawn in the 2D world (not the UI)</li>
</ul>
<p>bevy 2d Bundle.</p>
<ul>
<li><code>Camera2dBundle</code> 2d摄像头,用于正交投影和其他2D的特殊配置</li>
<li><code>SpriteBundle</code> 精灵.Image asset资源表示</li>
<li><code>SpriteSheetBundle</code> 精灵. TextureAtlas asset资源表示. TextureAtlas(包含多个纹理图集,eg: spritesheet 精灵表,tilemap 瓦片图)</li>
<li><code>MaterialMesh2dBundle</code> 2d形状,带网格和材质.(和3d的MaterialMeshBundle类似)</li>
<li><code>Text2dBundle</code> 2d世界要渲染的文本(通过2d Camera2dBundle在2d scene要渲染的文本)</li>
</ul>
<p><code>sprite</code> 精灵,一个独立的图像元素,通常用于表示游戏中的角色、道具、背景元素等。
精灵可以在屏幕上移动、旋转、缩放，并且可以进行动画以展现各种效果。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpriteBundle {
    pub sprite: Sprite,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub texture: Handle&lt;Image&gt;,
    pub visibility: Visibility,
    pub computed_visibility: ComputedVisibility,
}
<span class="boring">}</span></code></pre></pre>
<p>Bevy UI:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.NodeBundle.html"><code>NodeBundle</code></a>:
Empty node element (like HTML <code>&lt;div&gt;</code>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.ButtonBundle.html"><code>ButtonBundle</code></a>:
Button element</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.ImageBundle.html"><code>ImageBundle</code></a>:
Image element (<a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.AtlasImageBundle.html"><code>AtlasImageBundle</code></a>:
Image element (<a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.TextBundle.html"><code>TextBundle</code></a>:
Text element</li>
</ul>
<p>ui Bundle.</p>
<ul>
<li><code>NodeBundle</code> 空Node元素,可包含各种子node的容器,是最基础的ui元素</li>
<li><code>ButtonBundle</code> 按钮</li>
<li><code>ImageBundle</code> Image图像</li>
<li><code>AtlasImageBundle</code> TextureAtlas图像.(包含多个纹理图集)</li>
<li><code>TextBundle</code> 文本</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p><a href="/programming/res.html">(more info about working with resources)</a></p>
<p>资源主要分配置资源/引擎资源/渲染资源/wgpu资源/输入处理资源,以下逐个分析.</p>
<h3 id="configuration-resources"><a class="header" href="#configuration-resources">Configuration Resources</a></h3>
<p>These resources allow you to change the settings for how various parts of Bevy work.</p>
<p>These may be inserted at the start, but should also be fine to change at runtime (from a
<a href="/programming/systems.html">system</a>):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/clear_color/struct.ClearColor.html"><code>ClearColor</code></a>:
Global renderer background color to clear the window at the start of each frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.GlobalVolume.html"><code>GlobalVolume</code></a>:
The overall volume for playing audio</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.AmbientLight.html"><code>AmbientLight</code></a>:
Global renderer "fake lighting", so that shadows don't look too dark / black</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/enum.Msaa.html"><code>Msaa</code></a>:
Global renderer setting for Multi-Sample Anti-Aliasing (some platforms might only support the values 1 and 4)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/struct.UiScale.html"><code>UiScale</code></a>:
Global scale value to make all UIs bigger/smaller</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gizmos/struct.GizmoConfig.html"><code>GizmoConfig</code></a>:
Controls how <a href="/fundamentals/gizmos.html">gizmos</a> are rendered</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/wireframe/struct.WireframeConfig.html"><code>WireframeConfig</code></a>:
Global toggle to make everything be rendered as wireframe</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a>:
Gamepad input device settings, like joystick deadzones and button sensitivities</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/winit/struct.WinitSettings.html"><code>WinitSettings</code></a>:
Settings for the OS Windowing backend, including update loop / power-management settings</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/enum.TimeUpdateStrategy.html"><code>TimeUpdateStrategy</code></a>:
Used to control how the <a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Time</code></a> is updated</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.Schedules.html"><code>Schedules</code></a>:
Stores all <a href="/programming/schedules.html">schedules</a>, letting you register additional functionality at runtime</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a>:
The sequence of <a href="/programming/schedules.html">schedules</a> that will run every frame update</li>
</ul>
<p>以下是常用的配置资源.</p>
<ul>
<li><code>ClearColor</code> 背景色</li>
<li><code>GlobalVolume</code> 音量大小</li>
<li><code>AmbientLight</code> 环境光(有了环境光,阴影就不会太暗或直接是黑色)</li>
<li><code>Msaa</code> 多重采样抗锯齿,部分平台只支持1-4个样本.bevy默认是4个样本</li>
<li><code>UiScale</code> UI缩放值,可影响所有UI</li>
<li><code>GizmoConfig</code> 小玩意的配置</li>
<li><code>WireframeConfig</code> 网格线框是否显示</li>
<li><code>GamepadSettings</code> 手柄设置(eg:摇杆死区和按钮灵敏度)</li>
<li><code>WinitSettings</code> 窗口后端设置,包括更新循环/电源管理设置(winit封装了各个平台窗口的功能)</li>
<li><code>TimeUpdateStrategy</code> 时间更新策略.默认的<code>自动策略</code>就很好了;在测试/网络处理,可以手动设置下一个时间.(每个游戏系统都有一个时间系统的)</li>
<li><code>Schedules</code> 存储了所有的调度器,在运行时可以注册附加逻辑</li>
<li><code>MainScheduleOrder</code> 指定每帧调度器执行顺序(当然是在Main调度器中的,因为每帧逻辑更新就是在Main调度器中)</li>
</ul>
<p>多重采样抗锯齿（Multisample Anti-Aliasing，<code>MSAA</code>）是一种图形处理技术，
用于减少在渲染3D图形时出现的锯齿边缘（aliasing）。
锯齿边缘是由于有限的分辨率和像素数量在描绘斜线或曲线时造成的。
MSAA通过在每个像素内采样多个位置并平均这些样本的颜色来平滑这些锯齿边缘。</p>
<p>Settings that are not modifiable at runtime are not represented using resources. Instead,
they are configured via the respective <a href="builtins.html#plugins">plugins</a>.</p>
<p>bevy内置的配置影响了bevy各个模块的运行方式.配置资源应该在程序启动时添加,在运行期间也要支持修改(通过system).
<code>运行时不修改的设置不要用资源表示,而应该使用插件表示</code>.</p>
<h3 id="engine-resources"><a class="header" href="#engine-resources">Engine Resources</a></h3>
<p>These resources provide access to different features of the game engine at runtime.</p>
<p>Access them from your <a href="/programming/systems.html">systems</a>, if you need their state, or to control the respective
parts of Bevy. These resources are in the <a href="/gpu/intro.html">Main World</a>. <a href="builtins.html#render-world">See here for the
resources in the Render World</a>.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Time</code></a>:
Global time-related information (current frame delta time, time since startup, etc.)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/fixed_timestep/struct.FixedTime.html"><code>FixedTime</code></a>:
Tracks remaining time until the next <a href="/fundamentals/fixed-timestep.html">fixed update</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>:
Control the asset system: Load assets, check load status, etc.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a>:
Contains the actual data of the loaded assets of a given type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.State.html"><code>State&lt;T&gt;</code></a>:
The current value of a <a href="/programming/states.html">states type</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.NextState.html"><code>NextState&lt;T&gt;</code></a>:
Used to queue a transition to another <a href="/programming/states.html">state</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a>:
Tracks the IDs for all currently-detected (connected) gamepad devices</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.SceneSpawner.html"><code>SceneSpawner</code></a>:
Direct control over spawning Scenes into the main app World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core/struct.FrameCount.html"><code>FrameCount</code></a>:
The total number of frames</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/window/screenshot/struct.ScreenshotManager.html"><code>ScreenshotManager</code></a>:
Used to request a screenshot of a window to be taken/saved</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/reflect/struct.AppTypeRegistry.html"><code>AppTypeRegistry</code></a>:
Access to the Reflection Type Registry</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.AsyncComputeTaskPool.html"><code>AsyncComputeTaskPool</code></a>:
Task pool for running background CPU tasks</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.ComputeTaskPool.html"><code>ComputeTaskPool</code></a>:
Task pool where the main app schedule (all the systems) runs</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.IoTaskPool.html"><code>IoTaskPool</code></a>:
Task pool where background i/o tasks run (like asset loading)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> (<a href="/programming/non-send.html">non-send</a>):
Raw state of the <code>winit</code> backend for each window</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/struct.NonSendMarker.html"><code>NonSendMarker</code></a>:
Dummy resource to ensure a system always runs on the main thread</li>
</ul>
<p>以下是常用的引擎资源.</p>
<ul>
<li><code>Time</code> 全局和时间相关的信息(当前帧的增量时间,启动到现在的时间等)</li>
<li><code>FixedTime</code> 跟踪到下一次FixedUpdate的剩余时间</li>
<li><code>AssetServer</code> Asset资产服务,控制着asset资产的加载/检查加载状态等</li>
<li><code>Assets&lt;T&gt;</code> 指定资产的实际数据</li>
<li><code>State&lt;T&gt;</code> 状态类型的当前值</li>
<li><code>NextState&lt;T&gt;</code> 要转换到另一个状态,就将转换进行排队</li>
<li><code>Gamepads</code> 跟踪当前已连接的手柄设备ID列表(ebiten中还需要自己查,这个就直接自己处理了,棒)</li>
<li><code>SceneSpawner</code> 场景生成,直接生成场景到main world</li>
<li><code>FrameCount</code> 总帧数</li>
<li><code>ScreenshotManager</code> 窗口截屏(目前大部分游戏都支持截屏), 此资源是开关控制</li>
<li><code>AppTypeRegistry</code> 访问注册类型</li>
<li><code>AsyncComputeTaskPool</code> 异步GPU任务池</li>
<li><code>ComputeTaskPool</code> Main调度中system运行的任务池</li>
<li><code>IoTaskPool</code> 后台IO任务池(eg:资产加载)</li>
<li><code>WinitWindows</code> (non-send),窗口的原始状态</li>
<li><code>NonSendMarker</code> 确保system运行在main线程的虚拟资源</li>
</ul>
<p>bevy内置的引擎资源可以访问不同的功能,通过system访问这些资源,
这些资源都是在Main world中.</p>
<h4 id="render-world-resources"><a class="header" href="#render-world-resources">Render World Resources</a></h4>
<p>These resources are present in the <a href="/gpu/intro.html">Render World</a>. They can be accessed
from rendering systems (that run during <a href="/gpu/stages.html">render stages</a>).</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.MainWorld.html"><code>MainWorld</code></a>:
(extract schedule only!) access data from the Main World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_graph/struct.RenderGraph.html"><code>RenderGraph</code></a>:
<a href="/TODO.html">The Bevy Render Graph</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.PipelineCache.html"><code>PipelineCache</code></a>:
Bevy's manager of render pipelines. Used to store render pipelines used by the app, to avoid
recreating them more than once.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.TextureCache.html"><code>TextureCache</code></a>:
Bevy's manager of temporary textures. Useful when you need textures to use internally
during rendering.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_phase/struct.DrawFunctions.html"><code>DrawFunctions&lt;P&gt;</code></a>:
Stores draw functions for a given phase item type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_asset/struct.RenderAssets.html"><code>RenderAssets&lt;T&gt;</code></a>:
Contains handles to the GPU representations of currently loaded asset data</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.DefaultImageSampler.html"><code>DefaultImageSampler</code></a>:
The default sampler for <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset textures</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.FallbackImage.html"><code>FallbackImage</code></a>:
Dummy 1x1 pixel white texture. Useful for shaders that normally need a texture, when
you don't have one available.</li>
</ul>
<p>以下是常用的渲染资源.</p>
<ul>
<li><code>MainWrold</code> <strong>仅提取调度器</strong>, 访问Main world的数据</li>
<li><code>RenderGraph</code> 渲染图</li>
<li><code>PipelineCache</code> 渲染管道,要避免重复创建</li>
<li><code>TextureCache</code> 临时纹理管理,渲染时非常有用</li>
<li><code>DrawFunctions</code> 绘制函数, 存储指定阶段元素的类型对应的绘制函数</li>
<li><code>RenderAssets&lt;T&gt;</code> 渲染资产</li>
<li><code>DefaultImageSampler</code> Image资产问题的默认采样器</li>
<li><code>FallbackImage</code> 1x1的虚拟白色纹理,对于着色器来说,需要纹理但没有纹理时,使用这个</li>
</ul>
<p>There are many other resources in the Render World, which are not mentioned
here, either because they are internal to Bevy's rendering algorithms, or
because they are just extracted copies of the equivalent resources in the Main
World.</p>
<p>render world中的资源,在render system中访问.
还有很多渲染资源没列出来,要么是因为bevy内部的渲染算法用到,要么是Main world中拷贝过来的副本.</p>
<h4 id="low-level-wgpu-resources"><a class="header" href="#low-level-wgpu-resources">Low-Level <code>wgpu</code> Resources</a></h4>
<p>Using these resources, you can have direct access to the <code>wgpu</code> APIs for controlling the GPU.
These are available in both the Main World and the Render World.</p>
<p>使用wgpu资源,可以直接访问wgpu的API,这样就可以直接控制GPU了,
在main world和render world都能使用.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderDevice.html"><code>RenderDevice</code></a>:
The GPU device, used for creating hardware resources for rendering/compute</li>
<li>[<code>RenderQueue</code>][bevy::RenderQueue]:
The GPU queue for submitting work to the hardware</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderAdapter.html"><code>RenderAdapter</code></a>:
Handle to the physical GPU hardware</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderAdapterInfo.html"><code>RenderAdapterInfo</code></a>:
Information about the GPU hardware that Bevy is running on</li>
</ul>
<p>以下是常用的wgpu资源.</p>
<ul>
<li><code>RenderDevice</code> GPU设备,用于创建渲染/计算的硬件资源</li>
<li><code>RenderQueue</code> 提交任务给硬件的GPU队列</li>
<li><code>RenderAdapter</code> 物理GPU硬件句柄</li>
<li><code>RenderAdapterInfo</code> bevy正在使用的GPU硬件信息</li>
</ul>
<h3 id="input-handling-resources"><a class="header" href="#input-handling-resources">Input Handling Resources</a></h3>
<p>These resources represent the current state of different input devices. Read them from your
<a href="/programming/systems.html">systems</a> to <a href="/input.html">handle user input</a>.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/keyboard/enum.KeyCode.html"><code>Input&lt;KeyCode&gt;</code></a>:
Keyboard key state, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseButton.html"><code>Input&lt;MouseButton&gt;</code></a>:
Mouse button state, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Input&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadAxis.html"><code>Axis&lt;GamepadAxis&gt;</code></a>:
Analog <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Axis.html">Axis</a> gamepad inputs (joysticks and triggers)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Axis&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, represented as an analog <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Axis.html">Axis</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>:
The state of all fingers currently touching the touchscreen</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a>:
Registry of all the connected <a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepad.html"><code>Gamepad</code></a> IDs</li>
</ul>
<p>以下是常用的输入资源.</p>
<ul>
<li><code>Input&lt;KeyCode&gt;</code> 键盘按键状态(KeyCode表示某个键,状态为已按下/刚刚按下/刚刚释放)</li>
<li><code>Input&lt;MouseButton&gt;</code> 鼠标按键</li>
<li><code>Input&lt;GamepadButton&gt;</code> 手柄按键</li>
<li><code>Axis&lt;GamepadAxis&gt;</code> 手柄摇杆方向</li>
<li><code>Axis&lt;GamepadButton&gt;</code> 手柄遥感按键</li>
<li><code>Touches</code> 触摸状态</li>
<li><code>Gamepads</code> 已连接手柄的ID列表</li>
</ul>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p><a href="/programming/events.html">(more info about working with events)</a></p>
<p>事件用于system传递数据,主要有输入事件/引擎事件/OS和控制事件.</p>
<h3 id="input-events"><a class="header" href="#input-events">Input Events</a></h3>
<p>These <a href="/programming/events.html">events</a> fire on activity with input devices. Read them to [handle user input][cb::input].</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a>:
Changes in the state of mouse buttons</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a>:
Scrolling by a number of pixels or lines (<a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a>:
Relative movement of the mouse (pixels from previous frame), regardless of the OS pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a>:
New position of the OS mouse pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a>:
Changes in the state of keyboard keys (keypresses, not text)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.ReceivedCharacter.html"><code>ReceivedCharacter</code></a>:
Unicode text input from the OS (correct handling of the user's language and layout)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/enum.Ime.html"><code>Ime</code></a>:
Unicode text input from IME (support for advanced text input in different scripts)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a>:
Change in the state of a finger touching the touchscreen</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/enum.GamepadEvent.html"><code>GamepadEvent</code></a>:
Changes in the state of a gamepad or any of its buttons or axes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/enum.GamepadRumbleRequest.html"><code>GamepadRumbleRequest</code></a>:
Send these events to control gamepad rumble</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadMagnify.html"><code>TouchpadMagnify</code></a>:
Pinch-to-zoom gesture on laptop touchpad (macOS)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadRotate.html"><code>TouchpadRotate</code></a>:
Two-finger rotate gesture on laptop touchpad (macOS)</li>
</ul>
<p>以下是常用的输入事件.</p>
<ul>
<li><code>MouseButtonInput</code> 鼠标事件</li>
<li><code>MouseWheel</code> 鼠标滚轮事件</li>
<li><code>MouseMotion</code> 鼠标的相对(上帧)移动事件</li>
<li><code>CursorMoved</code> 光标移动事件</li>
<li><code>KeyboardInput</code> 键盘事件(按键不是输入)</li>
<li><code>ReceivedCharacter</code> 输入Unicode文本事件</li>
<li><code>Ime</code> 输入法输入Unicode文本事件</li>
<li><code>TouchInput</code> 触摸板事件</li>
<li><code>GamepadEvent</code> 手柄事件</li>
<li><code>GamepadRumbleRequest</code> 控制手柄震动的事件</li>
<li><code>TouchpadMagnify</code> 触摸板捏合缩放事件(macOS支持)</li>
<li><code>TouchpadRotate</code> 触摸板二指旋转事件(macOS支持)</li>
</ul>
<p>输入事件由输入设备触发,从input回调中读取.</p>
<h3 id="engine-events"><a class="header" href="#engine-events">Engine Events</a></h3>
<p><a href="/programming/events.html">Events</a> related to various internal things happening during the
normal runtime of a Bevy app.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/enum.AssetEvent.html"><code>AssetEvent&lt;T&gt;</code></a>:
Sent by Bevy when <a href="/assets.html">asset data</a> has been added/modified/removed; <a href="/assets/assetevent.html">can be used to detect changes to assets</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/hierarchy/enum.HierarchyEvent.html"><code>HierarchyEvent</code></a>:
Sent by Bevy when entity <a href="/fundamentals/hierarchy.html">parents/children</a> change</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.AppExit.html"><code>AppExit</code></a>:
Tell Bevy to shut down</li>
</ul>
<p>以下是常用的引擎事件.</p>
<ul>
<li><code>AssetEvent&lt;T&gt;</code> 资产增删改事件,可用于检测资产变化</li>
<li><code>HierarchyEvent</code> 实体父子关系变更事件</li>
<li><code>AppExit</code> 让bevy关闭的事件</li>
</ul>
<p>bevy程序正常运行过程中会产生的各种内部事件.</p>
<h3 id="system-and-control-events"><a class="header" href="#system-and-control-events">System and Control Events</a></h3>
<p>Events from the OS / windowing system, or to control Bevy.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.RequestRedraw.html"><code>RequestRedraw</code></a>:
In an app that does not refresh continuously, request one more update before going to sleep</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a>:
The user drag-and-dropped a file into our app</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a>:
OS mouse pointer/cursor entered one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a>:
OS mouse pointer/cursor exited one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowCloseRequested.html"><code>WindowCloseRequested</code></a>:
OS wants to close one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowCreated.html"><code>WindowCreated</code></a>:
New application window opened</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowClosed.html"><code>WindowClosed</code></a>:
Bevy window closed</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowDestroyed.html"><code>WindowDestroyed</code></a>:
OS window freed/dropped after window close</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowFocused.html"><code>WindowFocused</code></a>:
One of our windows is now focused</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowMoved.html"><code>WindowMoved</code></a>:
OS/user moved one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowResized.html"><code>WindowResized</code></a>:
OS/user resized one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowScaleFactorChanged.html"><code>WindowScaleFactorChanged</code></a>:
One of our windows has changed its DPI scaling factor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowBackendScaleFactorChanged.html"><code>WindowBackendScaleFactorChanged</code></a>:
OS reports change in DPI scaling factor for a window</li>
</ul>
<p>以下是常用的OS/窗口/控制事件.</p>
<ul>
<li><code>RequestRedraw</code> 在不连续刷新的app中,在sleep之前请求1次或多次更新的事件</li>
<li><code>FileDragAndDrop</code> 文件拖拽事件</li>
<li><code>CursorEntered</code> 光标移入窗口的事件</li>
<li><code>CursorLeft</code> 光标移出窗口的事件</li>
<li><code>WindowCloseRequested</code> OS想要关闭一个窗口的事件</li>
<li><code>WindowCreated</code> 新窗口已打开事件</li>
<li><code>WindowClosed</code> 窗口已关闭事件</li>
<li><code>WindowDestroyed</code> 窗口关闭后,OS已释放窗口的事件</li>
<li><code>WindowFocused</code> 窗口聚焦事件</li>
<li><code>WindowMoved</code> 窗口移动事件</li>
<li><code>WindowResized</code> 窗口resize事件</li>
<li><code>WindowScaleFactorChanged</code> DPI缩放因子修改导致窗口变更事件</li>
<li><code>WindowBackendScaleFactorChanged</code> 系统报告的窗口DPI缩放因子改变事件</li>
</ul>
<p>OS/窗口系统产生的事件,或控制bevy程序的事件.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The complete list of individual component types is too specific to be useful to list here.</p>
<p>See: <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/trait.Component.html#implementors">(List in API Docs)</a></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-tutorials"><a class="header" href="#bevy-tutorials">Bevy Tutorials</a></h1>
<p>This chapter of the book contains tutorials. Tutorials teach you things in a
logical order from start to finish. If you are looking for something to guide
you through learning Bevy, maybe some of them will be useful to you.</p>
<p>The rest of this book is designed to be used as a reference, so you can jump
around to specific topics you want to learn about.</p>
<p>The first tutorial in this chapter, <a href="/tutorial/guide.html">Guided Tour</a>, simply
organizes all the topics in this book in an order suggested for learning, from
the basics to advanced concepts. You can use it as an alternative to the main
table of contents (the left side bar), if you are just learning Bevy and don't
know how to progress. If you are new to Bevy, you can start here to find your
way around.</p>
<p>If you would like more narrow-scoped examples that teach you how to solve
specific problems, those can be found in the <a href="/cookbook.html">Bevy Cookbook</a>
chapter.</p>
<p>You should also look at Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official collection of
examples</a>. There is something for almost every area of the
engine, though they usually only show simple usage of the APIs without much
explanation.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="tutorial//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="new-to-bevy-guided-tutorial"><a class="header" href="#new-to-bevy-guided-tutorial">New to Bevy? Guided Tutorial!</a></h1>
<p>Welcome to Bevy! :) We are glad to have you in our community!</p>
<p>This page will guide you through this book, to help you gain comprehensive
knowledge of how to work with Bevy. The topics are structured in an order
that makes sense for learning: from basics to advanced.</p>
<p>It is just a suggestion to help you navigate. Feel free to jump around the book
and read whatever interests you. The main table-of-contents (the left sidebar)
was designed to be a reference for Bevy users of any skill level.</p>
<hr />
<p>Make sure to also look at <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">the official Bevy examples</a>. If
you need help, use <a href="https://github.com/bevyengine/bevy/discussions">GitHub Discussions</a>, or feel welcome
to join us to chat and ask for help in <a href="https://discord.gg/bevy">Discord</a>.</p>
<p>If you run into issues, be sure to check the
<a href="tutorial//pitfalls.html">Common Pitfalls</a> chapter, to see if this book has something
to help you. Solutions to some of the most common issues that Bevy community
members have encountered are documented there.</p>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>These are the absolute essentials of using Bevy. Every Bevy project, even a
simple one, would require you to be familiar with these concepts.</p>
<p>You could conceivably make something like a simple game-jam game or prototype,
using just this knowledge. Though, as your project grows, you will likely
quickly need to learn more.</p>
<p>基础部分,每个bevy项目都会包含的,利用这些知识可以快速做出一个原型,
如果项目要增长,还需要额外的知识.</p>
<ul>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/getting-started.html">Getting Started</a></li>
</ul>
</li>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/ecs-intro.html">Intro to ECS</a></li>
<li><a href="tutorial//programming/intro-data.html#entities--components">Entities, Components</a></li>
<li><a href="tutorial//programming/bundle.html">Bundles</a></li>
<li><a href="tutorial//programming/res.html">Resources</a></li>
<li><a href="tutorial//programming/systems.html">Systems</a></li>
<li><a href="tutorial//programming/app-builder.html">App Builder</a></li>
<li><a href="tutorial//programming/queries.html">Queries</a></li>
<li><a href="tutorial//programming/commands.html">Commands</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/coords.html">Coordinate System</a></li>
<li><a href="tutorial//fundamentals/transforms.html">Transforms</a></li>
<li><a href="tutorial//fundamentals/time.html">Time and Timers</a></li>
</ul>
</li>
<li><a href="tutorial//graphics.html">General Graphics Features</a>
<ul>
<li><a href="tutorial//graphics/camera.html">Cameras</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/assetserver.html">Load Assets with AssetServer</a></li>
<li><a href="tutorial//assets/handles.html">Handles</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//input/keyboard.html">Keyboard</a></li>
<li><a href="tutorial//input/mouse.html">Mouse</a></li>
<li><a href="tutorial//input/gamepad.html">Gamepad (Controller)</a></li>
<li><a href="tutorial//input/touch.html">Touchscreen</a></li>
</ul>
</li>
<li><a href="tutorial//window.html">Window Management</a>
<ul>
<li><a href="tutorial//window/props.html">Window Properties</a></li>
<li><a href="tutorial//window/clear-color.html">Change the Background Color</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>
<ul>
<li><a href="tutorial//audio/basic.html">Playing Sounds</a></li>
</ul>
</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>You will likely need to learn most of these topics to make a non-trivial Bevy
project. After you are confident with the basics, you should learn these.</p>
<p>要想卓越,在熟悉了基础知识的基础上,还需要学习以下知识.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/events.html">Events</a></li>
<li><a href="tutorial//programming/system-order.html">System Order of Execution</a></li>
<li><a href="tutorial//programming/run-criteria.html">Run Conditions</a></li>
<li><a href="tutorial//programming/system-sets.html">System Sets</a></li>
<li><a href="tutorial//programming/local.html">Local Resources</a></li>
<li><a href="tutorial//programming/schedules.html">Schedules</a></li>
<li><a href="tutorial//programming/states.html">States</a></li>
<li><a href="tutorial//programming/plugins.html">Plugins</a></li>
<li><a href="tutorial//programming/change-detection.html">Change Detection</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/hierarchy.html">Parent/Child Hierarchies</a></li>
<li><a href="tutorial//fundamentals/visibility.html">Visibility</a></li>
<li><a href="tutorial//fundamentals/log.html">Logging / Console Messages</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//cookbook/cursor2world.html">Convert cursor to world coordinates</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/data.html">Access the Asset Data</a></li>
<li><a href="tutorial//assets/hot-reload.html">Hot-Reloading Assets</a></li>
</ul>
</li>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/bevy-tools.html">Bevy Dev Tools and Editors</a></li>
<li><a href="tutorial//setup/unofficial-plugins.html">Community Plugin Ecosystem</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>:
<ul>
<li><a href="tutorial//audio/spatial.html">Spatial Audio</a></li>
</ul>
</li>
</ul>
<h2 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h2>
<p>These are more specialized topics. You may need some of them, depending on your
project.</p>
<p>更多具体场景下的主题,不是每个项目都需要,看实际需要.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/world.html">Direct World Access</a></li>
<li><a href="tutorial//programming/exclusive.html">Exclusive Systems</a></li>
<li><a href="tutorial//programming/paramset.html">Param Sets</a></li>
<li><a href="tutorial//programming/system-piping.html">System Piping</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/fixed-timestep.html">Fixed Timestep</a></li>
</ul>
</li>
<li><a href="tutorial//graphics.html">General Graphics Features</a>
<ul>
<li><a href="tutorial//graphics/hdr-tonemap.html">HDR, Tonemapping</a></li>
<li><a href="tutorial//graphics/bloom.html">Bloom</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/assetevent.html">React to Changes with Asset Events</a></li>
<li><a href="tutorial//assets/ready.html">Track asset loading progress</a></li>
</ul>
</li>
<li><a href="tutorial//patterns.html">Programming Patterns</a>
<ul>
<li><a href="tutorial//patterns/system-tests.html">Write tests for systems</a></li>
<li><a href="tutorial//patterns/generic-systems.html">Generic Systems</a></li>
<li><a href="tutorial//patterns/manual-event-clear.html">Manual Event Clearing</a></li>
</ul>
</li>
<li><a href="tutorial//window.html">Window Management</a>
<ul>
<li><a href="tutorial//window/mouse-grab.html">Grab/Capture the Mouse Cursor</a></li>
<li><a href="tutorial//window/icon.html">Set the Window Icon</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>
<ul>
<li><a href="tutorial//audio/custom.html">Custom Audio Streams</a></li>
</ul>
</li>
</ul>
<h2 id="advanced"><a class="header" href="#advanced">Advanced</a></h2>
<p>These topics are for niche technical situations. You can learn them, if you want
to know more about how Bevy works internally, extend the engine with custom
functionality, or do other advanced things with Bevy.</p>
<p>一些技术方案主题,可以了解bevy内部的工作机制,方便自定义功能或做些高级事情.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/non-send.html">Non-Send</a></li>
</ul>
</li>
<li><a href="tutorial//patterns.html">Programming Patterns</a>
<ul>
<li><a href="tutorial//patterns/component-storage.html">Component Storage</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//input/dnd.html">Drag-and-Drop files</a></li>
<li><a href="tutorial//input/ime.html">IME for advanced text input</a></li>
</ul>
</li>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/bevy-config.html">Customizing Bevy (cargo crates and features)</a></li>
<li><a href="tutorial//setup/bevy-git.html">Using bleeding-edge Bevy (main)</a></li>
</ul>
</li>
<li><a href="tutorial//gpu.html">Bevy Render (GPU) Framework</a>
<ul>
<li><a href="tutorial//gpu/intro.html">Render Architecture Overview</a></li>
<li><a href="tutorial//gpu/stages.html">Render Sets</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-cookbook"><a class="header" href="#bevy-cookbook">Bevy Cookbook</a></h1>
<p>This chapter shows you how to do various practical things using Bevy.</p>
<p>Every page is focused on a specific problem and provides explanations and
example code to teach you how to solve it.</p>
<p>It is assumed that you are already familiar with
<a href="/programming.html">Bevy Programming</a>.</p>
<p>You should also look at Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official collection of
examples</a>. There is something for almost every area of the
engine, though they usually only show simple usage of the APIs without much
explanation.</p>
<p>If you would like step-by-step tutorials that you can follow from start to
finish, those are in the <a href="/tutorial.html">Bevy Tutorials</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="show-framerate"><a class="header" href="#show-framerate">Show Framerate</a></h1>
<p>You can use Bevy's builtin diagnostics to measure framerate (FPS), for
monitoring performance.</p>
<p>To enable it, add Bevy's diagnostic plugin to your <a href="cookbook//programming/app-builder.html">app</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::FrameTimeDiagnosticsPlugin;
app.add_plugins(FrameTimeDiagnosticsPlugin::default());</code></pre>
<p>为了监控性能,可以使用bevy内置的诊断系统来测量FPS.</p>
<h2 id="print-to-console--log"><a class="header" href="#print-to-console--log">Print to Console / Log</a></h2>
<p>The simplest way to use it is to print the diagnostics to the console
(<a href="cookbook//fundamentals/log.html">log</a>). If you want to only do it in dev builds, you can add
a conditional-compilation attribute.</p>
<pre><code class="language-rust no_run noplayground">#[cfg(debug_assertions)] // debug/dev builds only
{
    use bevy::diagnostic::LogDiagnosticsPlugin;
    app.add_plugins(LogDiagnosticsPlugin::default());
}</code></pre>
<h2 id="in-game--on-screen-fps-counter"><a class="header" href="#in-game--on-screen-fps-counter">In-Game / On-Screen FPS counter</a></h2>
<p>UPDATE! I have now released a Bevy plugin which provides a much better
version of the code on this page, ready for you to use! Consider trying
my <a href="https://github.com/IyesGames/iyes_perf_ui"><code>iyes_perf_ui</code></a> plugin!</p>
<p>Bevy maintainers have expressed interest in upstreaming it, and we will
try to make it official in the next Bevy release (0.14)!</p>
<p>For now, I am also keeping the old code example below in the book, for
completeness:</p>
<hr />
<p>You can use Bevy UI to create an in-game FPS counter.</p>
<p>It is recommended that you create a new UI root (entity without
a parent) with absolute positioning, so that you can control the
exact position where the FPS counter appears, and so it doesn't
affect the rest of your UI.</p>
<p>Here is some example code showing you how to make a very nice-looking and
readable FPS counter:</p>
<details>
  <summary>
  <code>Code Example (Long):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::DiagnosticsStore;
use bevy::diagnostic::FrameTimeDiagnosticsPlugin;

/// Marker to find the container entity so we can show/hide the FPS counter
#[derive(Component)]
struct FpsRoot;

/// Marker to find the text entity so we can update it
#[derive(Component)]
struct FpsText;

fn setup_fps_counter(
    mut commands: Commands,
) {
    // create our UI root node
    // this is the wrapper/container for the text
    let root = commands.spawn((
        FpsRoot,
        NodeBundle {
            // give it a dark background for readability
            background_color: BackgroundColor(Color::BLACK.with_a(0.5)),
            // make it "always on top" by setting the Z index to maximum
            // we want it to be displayed over all other UI
            z_index: ZIndex::Global(i32::MAX),
            style: Style {
                position_type: PositionType::Absolute,
                // position it at the top-right corner
                // 1% away from the top window edge
                right: Val::Percent(1.),
                top: Val::Percent(1.),
                // set bottom/left to Auto, so it can be
                // automatically sized depending on the text
                bottom: Val::Auto,
                left: Val::Auto,
                // give it some padding for readability
                padding: UiRect::all(Val::Px(4.0)),
                ..Default::default()
            },
            ..Default::default()
        },
    )).id();
    // create our text
    let text_fps = commands.spawn((
        FpsText,
        TextBundle {
            // use two sections, so it is easy to update just the number
            text: Text::from_sections([
                TextSection {
                    value: "FPS: ".into(),
                    style: TextStyle {
                        font_size: 16.0,
                        color: Color::WHITE,
                        // if you want to use your game's font asset,
                        // uncomment this and provide the handle:
                        // font: my_font_handle
                        ..default()
                    }
                },
                TextSection {
                    value: " N/A".into(),
                    style: TextStyle {
                        font_size: 16.0,
                        color: Color::WHITE,
                        // if you want to use your game's font asset,
                        // uncomment this and provide the handle:
                        // font: my_font_handle
                        ..default()
                    }
                },
            ]),
            ..Default::default()
        },
    )).id();
    commands.entity(root).push_children(&amp;[text_fps]);
}

fn fps_text_update_system(
    diagnostics: Res&lt;DiagnosticsStore&gt;,
    mut query: Query&lt;&amp;mut Text, With&lt;FpsText&gt;&gt;,
) {
    for mut text in &amp;mut query {
        // try to get a "smoothed" FPS value from Bevy
        if let Some(value) = diagnostics
            .get(&amp;FrameTimeDiagnosticsPlugin::FPS)
            .and_then(|fps| fps.smoothed())
        {
            // Format the number as to leave space for 4 digits, just in case,
            // right-aligned and rounded. This helps readability when the
            // number changes rapidly.
            text.sections[1].value = format!("{value:&gt;4.0}");

            // Let's make it extra fancy by changing the color of the
            // text according to the FPS value:
            text.sections[1].style.color = if value &gt;= 120.0 {
                // Above 120 FPS, use green color
                Color::rgb(0.0, 1.0, 0.0)
            } else if value &gt;= 60.0 {
                // Between 60-120 FPS, gradually transition from yellow to green
                Color::rgb(
                    (1.0 - (value - 60.0) / (120.0 - 60.0)) as f32,
                    1.0,
                    0.0,
                )
            } else if value &gt;= 30.0 {
                // Between 30-60 FPS, gradually transition from red to yellow
                Color::rgb(
                    1.0,
                    ((value - 30.0) / (60.0 - 30.0)) as f32,
                    0.0,
                )
            } else {
                // Below 30 FPS, use red color
                Color::rgb(1.0, 0.0, 0.0)
            }
        } else {
            // display "N/A" if we can't get a FPS measurement
            // add an extra space to preserve alignment
            text.sections[1].value = " N/A".into();
            text.sections[1].style.color = Color::WHITE;
        }
    }
}

/// Toggle the FPS counter when pressing F12
fn fps_counter_showhide(
    mut q: Query&lt;&amp;mut Visibility, With&lt;FpsRoot&gt;&gt;,
    kbd: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    if kbd.just_pressed(KeyCode::F12) {
        let mut vis = q.single_mut();
        *vis = match *vis {
            Visibility::Hidden =&gt; Visibility::Visible,
            _ =&gt; Visibility::Hidden,
        };
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_fps_counter);
app.add_systems(Update, (
    fps_text_update_system,
    fps_counter_showhide,
));</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="convert-cursor-to-world-coordinates"><a class="header" href="#convert-cursor-to-world-coordinates">Convert cursor to world coordinates</a></h1>
<h2 id="2d-games"><a class="header" href="#2d-games">2D games</a></h2>
<p>If you only have one window (the primary window), as is the case for most apps
and games, you can do this:</p>
<details>
  <summary>
  <code>Code (simple version):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::window::PrimaryWindow;

/// We will store the world position of the mouse cursor here.
#[derive(Resource, Default)]
struct MyWorldCoords(Vec2);

/// Used to help identify our main camera
#[derive(Component)]
struct MainCamera;

fn setup(mut commands: Commands) {
    // Make sure to add the marker component when you set up your camera
    commands.spawn((Camera2dBundle::default(), MainCamera));
}

fn my_cursor_system(
    mut mycoords: ResMut&lt;MyWorldCoords&gt;,
    // query to get the window (so we can read the current cursor position)
    q_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get camera transform
    q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform), With&lt;MainCamera&gt;&gt;,
) {
    // get the camera info and transform
    // assuming there is exactly one main camera entity, so Query::single() is OK
    let (camera, camera_transform) = q_camera.single();

    // There is only one primary window, so we can similarly get it from the query:
    let window = q_window.single();

    // check if the cursor is inside the window and get its position
    // then, ask bevy to convert into world coordinates, and truncate to discard Z
    if let Some(world_position) = window.cursor_position()
        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
        .map(|ray| ray.origin.truncate())
    {
        mycoords.0 = world_position;
        eprintln!("World coords: {}/{}", world_position.x, world_position.y);
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyWorldCoords&gt;();
app.add_systems(Startup, setup);
app.add_systems(Update, my_cursor_system);</code></pre>
</details>
<p>If you have a more complex application with multiple windows, here is a more
complex version of the code that can handle that:</p>
<details>
  <summary>
  <code>Code (multi-window version):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::RenderTarget;
use bevy::window::WindowRef;

/// We will add this to each camera we want to compute cursor position for.
/// Add the component to the camera that renders to each window.
#[derive(Component, Default)]
struct WorldCursorCoords(Vec2);

fn setup_multiwindow(mut commands: Commands) {
    // TODO: set up multiple cameras for multiple windows.
    // See bevy's example code for how to do that.

    // Make sure we add our component to each camera
    commands.spawn((Camera2dBundle::default(), WorldCursorCoords::default()));
}

fn my_cursor_system_multiwindow(
    // query to get the primary window
    q_window_primary: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get other windows
    q_window: Query&lt;&amp;Window&gt;,
    // query to get camera transform
    mut q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform, &amp;mut WorldCursorCoords)&gt;,
) {
    for (camera, camera_transform, mut worldcursor) in &amp;mut q_camera {
        // get the window the camera is rendering to
        let window = match camera.target {
            // the camera is rendering to the primary window
            RenderTarget::Window(WindowRef::Primary) =&gt; {
                q_window_primary.single()
            },
            // the camera is rendering to some other window
            RenderTarget::Window(WindowRef::Entity(e_window)) =&gt; {
                q_window.get(e_window).unwrap()
            },
            // the camera is rendering to something else (like a texture), not a window
            _ =&gt; {
                // skip this camera
                continue;
            }
        };

        // check if the cursor is inside the window and get its position
        // then, ask bevy to convert into world coordinates, and truncate to discard Z
        if let Some(world_position) = window.cursor_position()
            .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
            .map(|ray| ray.origin.truncate())
        {
            worldcursor.0 = world_position;
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_multiwindow);
app.add_systems(Update, my_cursor_system_multiwindow);</code></pre>
</details>
<h2 id="3d-games"><a class="header" href="#3d-games">3D games</a></h2>
<p>If you'd like to be able to detect what 3D object the cursor is pointing at, select
objects, etc., there is a good (unofficial) plugin:
<a href="https://github.com/aevyrie/bevy_mod_picking"><code>bevy_mod_picking</code></a>.</p>
<p>For a simple top-down camera view game with a flat ground plane, it might be
sufficient to just compute the coordinates on the ground under the cursor.</p>
<p><button class="button_wasm_cbexample" id="button_cursor_3d_ground_plane">Load Interactive Example</button></p>
<p>In the interactive example, there is a ground plane with a non-default position
and rotation. There is a red cube, which is positioned using the global
coordinates, and a blue cube, which is a <a href="cookbook//fundamentals/hierarchy.html">child entity</a> of the
ground plane and positioned using local coordinates. They should both follow the
cursor.</p>
<details>
  <summary>
  <code>Code and explanation:</code>
  </summary>
<pre><code class="language-rust no_run noplayground">/// Here we will store the position of the mouse cursor on the 3D ground plane.
#[derive(Resource, Default)]
struct MyGroundCoords {
    // Global (world-space) coordinates
    global: Vec3,
    // Local (relative to the ground plane) coordinates
    local: Vec2,
}

/// Used to help identify our main camera
#[derive(Component)]
struct MyGameCamera;

/// Used to help identify our ground plane
#[derive(Component)]
struct MyGroundPlane;

fn setup_3d_scene(mut commands: Commands) {
    // Make sure to add the marker component when you set up your camera
    commands.spawn((
        MyGameCamera,
        Camera3dBundle {
            // ... your camera configuration ...
            ..default()
        },
    ));
    // Spawn the ground
    commands.spawn((
        MyGroundPlane,
        PbrBundle {
            // feel free to change this to rotate/tilt or reposition the ground
            transform: Transform::default(),
            // TODO: set up your mesh / visuals for rendering:
            // mesh: ...
            // material: ...
            ..default()
        },
    ));
}

fn cursor_to_ground_plane(
    mut mycoords: ResMut&lt;MyGroundCoords&gt;,
    // query to get the window (so we can read the current cursor position)
    // (we will only work with the primary window)
    q_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get camera transform
    q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform), With&lt;MyGameCamera&gt;&gt;,
    // query to get ground plane's transform
    q_plane: Query&lt;&amp;GlobalTransform, With&lt;MyGroundPlane&gt;&gt;,
) {
    // get the camera info and transform
    // assuming there is exactly one main camera entity, so Query::single() is OK
    let (camera, camera_transform) = q_camera.single();

    // Ditto for the ground plane's transform
    let ground_transform = q_plane.single();

    // There is only one primary window, so we can similarly get it from the query:
    let window = q_window.single();

    // check if the cursor is inside the window and get its position
    let Some(cursor_position) = window.cursor_position() else {
        // if the cursor is not inside the window, we can't do anything
        return;
    };

    // Mathematically, we can represent the ground as an infinite flat plane.
    // To do that, we need a point (to position the plane) and a normal vector
    // (the "up" direction, perpendicular to the ground plane).

    // We can get the correct values from the ground entity's GlobalTransform
    let plane_origin = ground_transform.translation();
    let plane = Plane3d::new(ground_transform.up());

    // Ask Bevy to give us a ray pointing from the viewport (screen) into the world
    let Some(ray) = camera.viewport_to_world(camera_transform, cursor_position) else {
        // if it was impossible to compute for whatever reason; we can't do anything
        return;
    };

    // do a ray-plane intersection test, giving us the distance to the ground
    let Some(distance) = ray.intersect_plane(plane_origin, plane) else {
        // If the ray does not intersect the ground
        // (the camera is not looking towards the ground), we can't do anything
        return;
    };

    // use the distance to compute the actual point on the ground in world-space
    let global_cursor = ray.get_point(distance);

    mycoords.global = global_cursor;
    eprintln!("Global cursor coords: {}/{}/{}",
        global_cursor.x, global_cursor.y, global_cursor.z
    );

    // to compute the local coordinates, we need the inverse of the plane's transform
    let inverse_transform_matrix = ground_transform.compute_matrix().inverse();
    let local_cursor = inverse_transform_matrix.transform_point3(global_cursor);

    // we can discard the Y coordinate, because it should always be zero
    // (our point is supposed to be on the plane)
    mycoords.local = local_cursor.xz();
    eprintln!("Local cursor coords: {}/{}", local_cursor.x, local_cursor.z);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyGroundCoords&gt;();
app.add_systems(Startup, setup_3d_scene);
app.add_systems(Update, cursor_to_ground_plane);</code></pre>
<p>If the ground is tilted/rotated or moved, the global and local coordinates
will differ, and may be useful for different use cases, so we compute both.</p>
<p>For some examples:</p>
<ul>
<li>if you want to spawn a <a href="cookbook//fundamentals/hierarchy.html">child</a> entity, or to quantize
the coordinates to a grid (for a tile-based game, to detect the grid tile under the cursor),
the local coordinates will be more useful</li>
<li>if you want to spawn some overlays, particle effects, other independent game entities,
at the position of the cursor, the global coordinates will be more useful</li>
</ul>
</details>
<script type="module" src="/loadwasm.js"/>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="custom-camera-projection"><a class="header" href="#custom-camera-projection">Custom Camera Projection</a></h1>
<p><strong>Note</strong>: this example is showing you how to do something not officially
supported/endorsed by Bevy. Do at your own risk.</p>
<p>Camera with a custom projection (not using one of Bevy's standard perspective
or orthographic projections).</p>
<p>You could also use this to change the coordinate system, if you insist on
using something other than <a href="cookbook//fundamentals/coords.html">Bevy's default coordinate system</a>,
for whatever reason.</p>
<p>Here we implement a simple orthographic projection that maps <code>-1.0</code> to <code>1.0</code>
to the vertical axis of the window, and respects the window's aspect ratio
for the horizontal axis:</p>
<p>See how Bevy constructs its camera bundles, for reference:</p>
<ul>
<li><a href="https://github.com/bevyengine/bevy/blob/v0.9.0/crates/bevy_core_pipeline/src/core_2d/camera_2d.rs#L46">2d</a></li>
<li><a href="https://github.com/bevyengine/bevy/blob/v0.9.0/crates/bevy_core_pipeline/src/core_3d/camera_3d.rs#L72">3d</a></li>
</ul>
<p>This example is based on the setup for a 2D camera:</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::Tonemapping;
use bevy::render::primitives::Frustum;
use bevy::render::camera::{Camera, CameraProjection};
use bevy::render::view::VisibleEntities;

#[derive(Component, Debug, Clone, Reflect)]
#[reflect(Component, Default)]
struct SimpleOrthoProjection {
    near: f32,
    far: f32,
    aspect: f32,
}

impl CameraProjection for SimpleOrthoProjection {
    fn get_projection_matrix(&amp;self) -&gt; Mat4 {
        Mat4::orthographic_rh(
            -self.aspect, self.aspect, -1.0, 1.0, self.near, self.far
        )
    }

    // what to do on window resize
    fn update(&amp;mut self, width: f32, height: f32) {
        self.aspect = width / height;
    }

    fn far(&amp;self) -&gt; f32 {
        self.far
    }
}

impl Default for SimpleOrthoProjection {
    fn default() -&gt; Self {
        Self { near: 0.0, far: 1000.0, aspect: 1.0 }
    }
}

fn setup(mut commands: Commands) {
    // We need all the components that Bevy's built-in camera bundles would add
    // Refer to the Bevy source code to make sure you do it correctly:

    // here we show a 2d example

    let projection = SimpleOrthoProjection::default();

    // position the camera like bevy would do by default for 2D:
    let transform = Transform::from_xyz(0.0, 0.0, projection.far - 0.1);

    // frustum construction code copied from Bevy
    let view_projection =
        projection.get_projection_matrix() * transform.compute_matrix().inverse();
    let frustum = Frustum::from_view_projection(
        &amp;view_projection,
        &amp;transform.translation,
        &amp;transform.back(),
        projection.far,
    );

    commands.spawn((
        bevy::render::camera::CameraRenderGraph::new(bevy::core_pipeline::core_2d::graph::NAME),
        projection,
        frustum,
        transform,
        GlobalTransform::default(),
        VisibleEntities::default(),
        Camera::default(),
        Camera2d::default(),
        Tonemapping::Disabled,
    ));
}

fn main() {
    // need to add bevy-internal camera projection management functionality
    // for our custom projection type
    use bevy::render::camera::CameraProjectionPlugin;

    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup)
        .add_plugin(CameraProjectionPlugin::&lt;SimpleOrthoProjection&gt;::default())
        .run();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="pan--orbit-camera"><a class="header" href="#pan--orbit-camera">Pan + Orbit Camera</a></h1>
<p>This is a camera controller similar to the ones in 3D editors like Blender.</p>
<p>To make the implementation simpler, we do not manipulate the
<a href="cookbook//fundamentals/transforms.html">transform</a> directly. Instead, we work with values inside of
a custom <a href="cookbook//programming/ec.html#components">component</a> struct and then compute the transform
at the end.</p>
<p>Furthermore, for completeness, this example will also show a simple way of
making the input controls reconfigurable / rebindable.</p>
<hr />
<p>First, let's define our data. Create some <a href="cookbook//programming/ec.html#components">component</a>
types, which we will store on the <a href="cookbook//3d/camera.html">3D camera</a>
<a href="cookbook//programming/intro-data.html">entity</a>, and a <a href="cookbook//programming/bundle.html">bundle</a> to make it easy to
spawn the camera:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">// Bundle to spawn our custom camera easily
#[derive(Bundle, Default)]
pub struct PanOrbitCameraBundle {
    pub camera: Camera3dBundle,
    pub state: PanOrbitState,
    pub settings: PanOrbitSettings,
}

// The internal state of the pan-orbit controller
#[derive(Component)]
pub struct PanOrbitState {
    pub center: Vec3,
    pub radius: f32,
    pub upside_down: bool,
    pub pitch: f32,
    pub yaw: f32,
}

/// The configuration of the pan-orbit controller
#[derive(Component)]
pub struct PanOrbitSettings {
    /// World units per pixel of mouse motion
    pub pan_sensitivity: f32,
    /// Radians per pixel of mouse motion
    pub orbit_sensitivity: f32,
    /// Exponent per pixel of mouse motion
    pub zoom_sensitivity: f32,
    /// Key to hold for panning
    pub pan_key: Option&lt;KeyCode&gt;,
    /// Key to hold for orbiting
    pub orbit_key: Option&lt;KeyCode&gt;,
    /// Key to hold for zooming
    pub zoom_key: Option&lt;KeyCode&gt;,
    /// What action is bound to the scroll wheel?
    pub scroll_action: Option&lt;PanOrbitAction&gt;,
    /// For devices with a notched scroll wheel, like desktop mice
    pub scroll_line_sensitivity: f32,
    /// For devices with smooth scrolling, like touchpads
    pub scroll_pixel_sensitivity: f32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PanOrbitAction {
    Pan,
    Orbit,
    Zoom,
}</code></pre>
</details>
<p>We can implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> to give them reasonable default values:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">impl Default for PanOrbitState {
    fn default() -&gt; Self {
        PanOrbitState {
            center: Vec3::ZERO,
            radius: 1.0,
            upside_down: false,
            pitch: 0.0,
            yaw: 0.0,
        }
    }
}

impl Default for PanOrbitSettings {
    fn default() -&gt; Self {
        PanOrbitSettings {
            pan_sensitivity: 0.001, // 1000 pixels per world unit
            orbit_sensitivity: 0.1f32.to_radians(), // 0.1 degree per pixel
            zoom_sensitivity: 0.01,
            pan_key: Some(KeyCode::ControlLeft),
            orbit_key: Some(KeyCode::AltLeft),
            zoom_key: Some(KeyCode::ShiftLeft),
            scroll_action: Some(PanOrbitAction::Zoom),
            scroll_line_sensitivity: 16.0, // 1 "line" == 16 "pixels of motion"
            scroll_pixel_sensitivity: 1.0,
        }
    }
}</code></pre>
</details>
<p>We need a setup <a href="cookbook//programming/systems.html">system</a> to spawn our camera:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">fn spawn_camera(mut commands: Commands) {
    let mut camera = PanOrbitCameraBundle::default();
    // Position our camera using our component,
    // not Transform (it would get overwritten)
    camera.state.center = Vec3::new(1.0, 2.0, 3.0);
    camera.state.radius = 50.0;
    camera.state.pitch = 15.0f32.to_radians();
    camera.state.yaw = 30.0f32.to_radians();
    commands.spawn(camera);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, spawn_camera);</code></pre>
</details>
<p>And finally, the actual implementation of the camera controller:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::{MouseMotion, MouseScrollUnit, MouseWheel};

use std::f32::consts::{FRAC_PI_2, PI, TAU};

fn pan_orbit_camera(
    kbd: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    mut evr_motion: EventReader&lt;MouseMotion&gt;,
    mut evr_scroll: EventReader&lt;MouseWheel&gt;,
    mut q_camera: Query&lt;(
        &amp;PanOrbitSettings,
        &amp;mut PanOrbitState,
        &amp;mut Transform,
    )&gt;,
) {
    // First, accumulate the total amount of
    // mouse motion and scroll, from all pending events:
    let mut total_motion: Vec2 = evr_motion.read()
        .map(|ev| ev.delta).sum();

    // Reverse Y (Bevy's Worldspace coordinate system is Y-Up,
    // but events are in window/ui coordinates, which are Y-Down)
    total_motion.y = -total_motion.y;

    let mut total_scroll_lines = Vec2::ZERO;
    let mut total_scroll_pixels = Vec2::ZERO;
    for ev in evr_scroll.read() {
        match ev.unit {
            MouseScrollUnit::Line =&gt; {
                total_scroll_lines.x += ev.x;
                total_scroll_lines.y -= ev.y;
            }
            MouseScrollUnit::Pixel =&gt; {
                total_scroll_pixels.x += ev.x;
                total_scroll_pixels.y -= ev.y;
            }
        }
    }

    for (settings, mut state, mut transform) in &amp;mut q_camera {
        // Check how much of each thing we need to apply.
        // Accumulate values from motion and scroll,
        // based on our configuration settings.

        let mut total_pan = Vec2::ZERO;
        if settings.pan_key.map(|key| kbd.pressed(key)).unwrap_or(false) {
            total_pan -= total_motion * settings.pan_sensitivity;
        }
        if settings.scroll_action == Some(PanOrbitAction::Pan) {
            total_pan -= total_scroll_lines
                * settings.scroll_line_sensitivity * settings.pan_sensitivity;
            total_pan -= total_scroll_pixels
                * settings.scroll_pixel_sensitivity * settings.pan_sensitivity;
        }

        let mut total_orbit = Vec2::ZERO;
        if settings.orbit_key.map(|key| kbd.pressed(key)).unwrap_or(false) {
            total_orbit -= total_motion * settings.orbit_sensitivity;
        }
        if settings.scroll_action == Some(PanOrbitAction::Orbit) {
            total_orbit -= total_scroll_lines
                * settings.scroll_line_sensitivity * settings.orbit_sensitivity;
            total_orbit -= total_scroll_pixels
                * settings.scroll_pixel_sensitivity * settings.orbit_sensitivity;
        }

        let mut total_zoom = Vec2::ZERO;
        if settings.zoom_key.map(|key| kbd.pressed(key)).unwrap_or(false) {
            total_zoom -= total_motion * settings.zoom_sensitivity;
        }
        if settings.scroll_action == Some(PanOrbitAction::Zoom) {
            total_zoom -= total_scroll_lines
                * settings.scroll_line_sensitivity * settings.zoom_sensitivity;
            total_zoom -= total_scroll_pixels
                * settings.scroll_pixel_sensitivity * settings.zoom_sensitivity;
        }

        // Upon starting a new orbit maneuver (key is just pressed),
        // check if we are starting it upside-down
        if settings.orbit_key.map(|key| kbd.just_pressed(key)).unwrap_or(false) {
            state.upside_down = state.pitch &lt; -FRAC_PI_2 || state.pitch &gt; FRAC_PI_2;
        }

        // If we are upside down, reverse the X orbiting
        if state.upside_down {
            total_orbit.x = -total_orbit.x;
        }

        // Now we can actually do the things!

        let mut any = false;

        // To ZOOM, we need to multiply our radius.
        if total_zoom != Vec2::ZERO {
            any = true;
            // in order for zoom to feel intuitive,
            // everything needs to be exponential
            // (done via multiplication)
            // not linear
            // (done via addition)

            // so we compute the exponential of our
            // accumulated value and multiply by that
            state.radius *= (-total_zoom.y).exp();
        }

        // To ORBIT, we change our pitch and yaw values
        if total_orbit != Vec2::ZERO {
            any = true;
            state.yaw += total_orbit.x;
            state.pitch += total_orbit.y;
            // wrap around, to stay between +- 180 degrees
            if state.yaw &gt; PI {
                state.yaw -= TAU; // 2 * PI
            }
            if state.yaw &lt; -PI {
                state.yaw += TAU; // 2 * PI
            }
            if state.pitch &gt; PI {
                state.pitch -= TAU; // 2 * PI
            }
            if state.pitch &lt; -PI {
                state.pitch += TAU; // 2 * PI
            }
        }

        // To PAN, we can get the UP and RIGHT direction
        // vectors from the camera's transform, and use
        // them to move the center point. Multiply by the
        // radius to make the pan adapt to the current zoom.
        if total_pan != Vec2::ZERO {
            any = true;
            let radius = state.radius;
            state.center += transform.right() * total_pan.x * radius;
            state.center += transform.up() * total_pan.y * radius;
        }

        // Finally, compute the new camera transform.
        // (if we changed anything, or if the pan-orbit
        // controller was just added and thus we are running
        // for the first time and need to initialize)
        if any || state.is_added() {
            // YXZ Euler Rotation performs yaw/pitch/roll.
            transform.rotation =
                Quat::from_euler(EulerRot::YXZ, state.yaw, state.pitch, 0.0);
            // To position the camera, get the backward direction vector
            // and place the camera at the desired radius from the center.
            transform.translation = state.center + transform.back() * state.radius;
        }
    }
}</code></pre>
<p>We can add a <a href="cookbook//programming/run-criteria.html">Run Condition</a> to tell Bevy to run
our system only if pan-orbit entities exist:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(Update,
    pan_orbit_camera
        .run_if(any_with_component::&lt;PanOrbitState&gt;),
);</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="list-all-resource-types"><a class="header" href="#list-all-resource-types">List All Resource Types</a></h1>
<p>This example shows how to print a list of all types that have been added as
<a href="cookbook//programming/res.html">resources</a>.</p>
<pre><code class="language-rust no_run noplayground">fn print_resources(world: &amp;World) {
    let components = world.components();

    let mut r: Vec&lt;_&gt; = world
        .storages()
        .resources
        .iter()
        .map(|(id, _)| components.get_info(id).unwrap())
        .map(|info| info.name())
        .collect();

    // sort list alphebetically
    r.sort();
    r.iter().for_each(|name| println!("{}", name));
}</code></pre>
<pre><code class="language-rust no_run noplayground">// print main world resources
app.add_systems(Last, print_resources);

// print render world resources
app.sub_app_mut(RenderApp)
    .add_systems(Render, print_resources.in_set(RenderSet::Render));</code></pre>
<p>It lists the types of all the resources <em>that currently exist</em> in your <a href="cookbook//programming/intro-data.html">ECS
World</a> (by all registered plugins, your own, etc.).</p>
<p>Note that this does <em>not</em> give you a list of every type that is
useful as a resource. For that, you should consult API documentation,
looking for implementers of the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/trait.Resource.html"><code>Resource</code></a> trait.</p>
<p><a href="cookbook//builtins.html">See here for a summary of types provided in Bevy.</a></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-setup-tips"><a class="header" href="#bevy-setup-tips">Bevy Setup Tips</a></h1>
<p>This chapter is a collection of additional tips for configuring
your project or development tools, collected from the Bevy
community, beyond what is covered in Bevy's <a href="https://bevyengine.org/learn/book/getting-started/setup/">official setup
documentation</a>.</p>
<p>Feel free to suggest things to add under this chapter.</p>
<hr />
<p>Also see the following other relevant content from this book:</p>
<ul>
<li><a href="/platforms.html">Platform-specific information</a></li>
<li><a href="/pitfalls/performance.html">Configuration to fix slow performance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This page covers the basic setup needed for Bevy development.</p>
<hr />
<p>For the most part, Bevy is just like any other Rust library. You need to
install Rust and setup your dev environment just like for any other Rust
project. You can install Rust using <a href="https://rustup.rs">Rustup</a>. See
<a href="https://www.rust-lang.org/learn/get-started">Rust's official setup page</a>.</p>
<p>On Linux, you need the development files for some system libraries. See the
<a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">official Bevy Linux dependencies page</a>.</p>
<p>Also see the <a href="https://bevyengine.org/learn/book/getting-started/setup/">Setup page in the official Bevy Book</a>
and the <a href="https://github.com/bevyengine/bevy/blob/main/README.md">official Bevy Readme</a>.</p>
<h2 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a New Project</a></h2>
<p>You can simply create a new Rust project, either from your IDE/editor, or the commandline:</p>
<pre><code class="language-sh">cargo new --bin my_game
</code></pre>
<p>(creates a project called <code>my_game</code>)</p>
<p>The <code>Cargo.toml</code> file contains all the configuration of your project.
Add the latest version of <code>bevy</code> as a dependency. Your file should now
look something like this:</p>
<pre><code class="language-toml">[package]
name = "my_game"
version = "0.1.0"
edition = "2021"

[dependencies]
bevy = "0.13"
</code></pre>
<p>The <code>src/main.rs</code> file is your main source code file. This is where you
start writing your Rust code. For a minimal Bevy <a href="setup//programming/app-builder.html">app</a>, you need
at least the following:</p>
<pre><code class="language-rust no_run noplayground">use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .run();
}</code></pre>
<p>You can now compile and run your project. The first time, this will take a
while, as it needs to build the whole Bevy engine and dependencies. Subsequent
runs should be fast. You can do this from your IDE/editor, or the commandline:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>You can generate your own docs (like what is on <a href="https://docs.rs">docs.rs</a>), for
offline use, including everything from your own project and all dependencies, in
one place.</p>
<pre><code class="language-sh">cargo doc --open
</code></pre>
<p>This will build all the HTML docs and open them in your web browser.</p>
<p>It does not require an internet connection, and gives you an easy way to search
the API docs for all crates in your dependency tree all at once. It is more
useful than the online version of the docs.</p>
<h2 id="optional-extra-setup"><a class="header" href="#optional-extra-setup">Optional Extra Setup</a></h2>
<p>You will likely quickly run into unusably slow performance with the default
Rust unoptimized dev builds. <a href="setup//pitfalls/performance.html">See here how to fix.</a></p>
<p>Iterative recompilation speed is important to keep you productive, so you don't
have to wait long for the Rust compiler to rebuild your project every time you
want to test your game. <a href="https://bevyengine.org/learn/book/getting-started/setup/">Bevy's getting started page</a>
has advice about how to speed up compile times.</p>
<p>Also have a look in the <a href="setup//setup/bevy-tools.html">Dev Tools and Editors</a> page for suggestions
about additional external dev tools that may be helpful.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>Have a look at the <a href="setup//tutorial.html">guided tutorial</a> page of this book,
and Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official examples</a>.</p>
<p>Check out the <a href="https://bevyengine.org/assets">Bevy Assets Website</a> to find other tutorials
and learning resources from the community, and <a href="setup//setup/unofficial-plugins.html">plugins</a>
to use in your project.</p>
<p>Join the community on <a href="https://discord.gg/bevy">Discord</a> to chat with us!</p>
<h2 id="running-into-issues"><a class="header" href="#running-into-issues">Running into Issues?</a></h2>
<p>If something is not working, be sure to check the <a href="setup//pitfalls.html">Common
Pitfalls</a> chapter, to see if this book has something to
help you. Solutions to some of the most common issues that Bevy community
members have encountered are documented there.</p>
<p>If you need help, use <a href="https://github.com/bevyengine/bevy/discussions">GitHub Discussions</a>, or feel
welcome to come chat and ask for help in <a href="https://discord.gg/bevy">Discord</a>.</p>
<h2 id="gpu-drivers"><a class="header" href="#gpu-drivers">GPU Drivers</a></h2>
<p>To work at its best, Bevy needs DirectX 12 (Windows) or Vulkan (Linux, Android,
Windows). macOS/iOS should just work, without any special driver setup, using
Metal.</p>
<p>OpenGL (GLES3) can be used as a fallback, but will likely have issues (some
bugs, unsupported features, worse performance).</p>
<p>Make sure you have compatible hardware and drivers installed on your system.
Your users will also need to satisfy this requirement.</p>
<p>If Bevy is not working, install the latest drivers for your OS, or check with
your Linux distribution whether Vulkan needs additional packages to be
installed.</p>
<p>Web games are supported and should work in any modern browser, using WebGL2.
Performance is limited and some Bevy features will not work. The new
experimental high-performance WebGPU API is also supported, but browser adoption
is still limited.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="text-editor--ide"><a class="header" href="#text-editor--ide">Text Editor / IDE</a></h1>
<p>This sub-chapter contains tips for different text editors and IDEs.</p>
<p>Bevy is, for the most part, like any other Rust project. If your editor/IDE
is set up for Rust, that might be all you need. This sub-chapter contains
additional information that may be useful for Bevy specifically.</p>
<p>If you have any tips/advice/configurations for your editor of choice,
that you'd like to share with the community, please create a
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>, so we can add it to the book.
If your editor is not in the list, I will add it.</p>
<ul>
<li><a href="setup//setup/editor/vscode.html">Visual Studio Code</a></li>
<li><a href="setup//setup/editor/jetbrains.html">JetBrains (RustRover, IntelliJ, CLion)</a></li>
<li><a href="setup//setup/editor/kak.html">Kakoune</a></li>
<li><a href="setup//setup/editor/vim.html">Vim</a></li>
<li><a href="setup//setup/editor/emacs.html">Emacs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h1>
<p>If you are a VSCode user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support"><a class="header" href="#rust-language-support">Rust Language Support</a></h2>
<p>For good Rust support, install the Rust Analyzer plugin.</p>
<h3 id="speed-up-rust-analyzer"><a class="header" href="#speed-up-rust-analyzer">Speed Up Rust Analyzer</a></h3>
<p>If you have used <code>.cargo/config.toml</code> to set a non-default linker for fast
compiles, Rust Analyzer will ignore it unfortunately. You need to also
configure RA to use it, with the following setting (in VSCode <code>settings.json</code>):</p>
<p>Windows:</p>
<pre><code class="language-json">"rust-analyzer.cargo.extraEnv": {
    "RUSTFLAGS": "-Clinker=rust-lld.exe"
}
</code></pre>
<p>Linux (mold):</p>
<pre><code class="language-json">"rust-analyzer.cargo.extraEnv": {
    "RUSTFLAGS": "-Clinker=clang -Clink-arg=-fuse-ld=mold"
}
</code></pre>
<p>Linux (lld):</p>
<pre><code class="language-json">"rust-analyzer.cargo.extraEnv": {
    "RUSTFLAGS": "-Clinker=clang -Clink-arg=-fuse-ld=lld"
}
</code></pre>
<h2 id="cargo_manifest_dir"><a class="header" href="#cargo_manifest_dir"><code>CARGO_MANIFEST_DIR</code></a></h2>
<p>When running your app/game, Bevy will search for the <code>assets</code> folder in the path
specified in the <code>BEVY_ASSET_ROOT</code> or <code>CARGO_MANIFEST_DIR</code> environment variable.
This allows <code>cargo run</code> to work correctly from the terminal.</p>
<p>If you want to run your project from VSCode in a non-standard way (say, inside a
debugger), you have to be sure to set that correctly.</p>
<p>If this is not set, Bevy will search for <code>assets</code> alongside the executable
binary, in the same folder where it is located. This makes things easy for
distribution. However, during development, since your executable is located
in the <code>target</code> directory where <code>cargo</code> placed it, Bevy will be unable to
find the <code>assets</code>.</p>
<p>Here is a snippet showing how to create a run configuration for debugging Bevy
(with <code>lldb</code>):</p>
<p>(this is for development on Bevy itself, and testing with the <code>breakout</code> example)</p>
<p>(adapt to your needs if using for your project)</p>
<pre><code class="language-json">{
    "type": "lldb",
    "request": "launch",
    "name": "Debug example 'breakout'",
    "cargo": {
        "args": [
            "build",
            "--example=breakout",
            "--package=bevy"
        ],
        "filter": {
            "name": "breakout",
            "kind": "example"
        }
    },
    "args": [],
    "cwd": "${workspaceFolder}",
    "env": {
        "CARGO_MANIFEST_DIR": "${workspaceFolder}",
    }
}
</code></pre>
<p>To support dynamic linking, you should also add the following, inside the <code>"env"</code> section:</p>
<p>Linux:</p>
<pre><code class="language-json">"LD_LIBRARY_PATH": "${workspaceFolder}/target/debug/deps:${env:HOME}/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib",
</code></pre>
<p>(replace <code>stable-x86_64-unknown-linux-gnu</code> if you use a different toolchain/architecture)</p>
<p>Windows: I don't know. If you do, please <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">file an issue</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="jetbrains-rustrover-intellij-clion"><a class="header" href="#jetbrains-rustrover-intellij-clion">JetBrains (RustRover, IntelliJ, CLion)</a></h1>
<p>If you are a JetBrains user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support-1"><a class="header" href="#rust-language-support-1">Rust Language Support</a></h2>
<p>When using <a href="setup/editor//programming/queries.html">queries</a>, type information gets lost due to Bevy relying
on procedural macros. You can fix this by enabling <a href="https://github.com/intellij-rust/intellij-rust/issues/6908">procedural macro
support</a> in the IDE.</p>
<ol>
<li>type <code>Experimental feature</code> in the dialog of the <code>Help | Find Action</code> action</li>
<li>enable the features <code>org.rust.cargo.evaluate.build.scripts</code> and <code>org.rust.macros.proc</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="kakoune"><a class="header" href="#kakoune">Kakoune</a></h1>
<p>If you are a Kakoune user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support-2"><a class="header" href="#rust-language-support-2">Rust Language Support</a></h2>
<p>You can use <code>kak-lsp</code> with <code>rust-analyzer</code>.</p>
<p>You want to install just the RA server, without the official VSCode plugin.</p>
<p>You can manage it via <code>rustup</code>:</p>
<pre><code class="language-sh">rustup component add rust-analyzer
</code></pre>
<p>Or you can build/install it yourself from git:</p>
<pre><code class="language-sh">git clone https://github.com/rust-lang/rust-analyzer
cd rust-analyzer
git checkout release # use the `release` branch instead of `main`
cargo xtask install --server
</code></pre>
<p>The easiest way to set up <code>kak-lsp</code> is using <code>plug.kak</code>.</p>
<p>If you don't have <code>plug.kak</code>, put the following in <code>~/.config/kak/kakrc</code>:</p>
<pre><code class="language-kak">evaluate-commands %sh{
    plugins="$kak_config/plugins"
    mkdir -p "$plugins"
    [ ! -e "$plugins/plug.kak" ] &amp;&amp; \
        git clone -q https://github.com/andreyorst/plug.kak.git "$plugins/plug.kak"
    printf "%s\n" "source '$plugins/plug.kak/rc/plug.kak'"
}
plug "andreyorst/plug.kak" noload
</code></pre>
<p>And then to set up <code>kak-lsp</code> with Rust support:</p>
<pre><code class="language-kak">plug "kak-lsp/kak-lsp" do %{
    cargo install --force --path .
} config %{
    set global lsp_cmd "kak-lsp -s %val{session}"

    # create a command to let you restart LSP if anything goes wrong / gets glitched
    define-command lsp-restart -docstring 'restart lsp server' %{ lsp-stop; lsp-start }

    # helper command to enable LSP
    define-command -hidden lsp-init %{
        lsp-enable-window
        # preferences:
        set window lsp_auto_highlight_references true
        lsp-auto-signature-help-enable
        # keybind: use "," to get a menu of available LSP commands
        map global normal "," ": enter-user-mode lsp&lt;ret&gt;" -docstring "LSP mode"
    }

    hook global KakEnd .* lsp-exit

    # autoenable LSP when opening Rust files
    hook global WinSetOption filetype=rust %{
        lsp-init
    }
}
# formatting settings for Rust files
hook global BufSetOption filetype=rust %{
    set buffer tabstop 4
    set buffer indentwidth 4
    set buffer formatcmd 'rustfmt'
    set buffer autowrap_column 100
    expandtab
}
</code></pre>
<p>Put the following in <code>~/.config/kak-lsp/kak-lsp.toml</code> to use <code>rust-analyzer</code>:</p>
<pre><code class="language-toml">[server]
# Shut down the `rust-analyzer` process after a period of inactivity
timeout = 900

[language.rust]
filetypes = ["rust"]
roots = ["Cargo.toml"]
command = "rust-analyzer"
settings_section = "rust-analyzer"

[language.rust.settings.rust-analyzer]
# Proc Macro support is important for Bevy projects
procMacro.enable = true
# disable hover actions, can be laggy on complex projects like Bevy
hoverActions.enable = false
# do not use the data generated by `cargo check`, again, because it can be slow and laggy
cargo.loadOutDirsFromCheck = false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="vim"><a class="header" href="#vim">Vim</a></h1>
<p>If you are a Vim user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="emacs"><a class="header" href="#emacs">Emacs</a></h1>
<p>If you are an Emacs user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="configuring-bevy"><a class="header" href="#configuring-bevy">Configuring Bevy</a></h1>
<p>Bevy is very modular and configurable. It is implemented as many separate
cargo crates, allowing you to remove the parts you don't need. Higher-level
functionality is built on top of lower-level foundational crates, and can
be disabled or replaced with alternatives.</p>
<p>The lower-level core crates (like the Bevy ECS) can also be used completely
standalone, or integrated into otherwise non-Bevy projects.</p>
<p>bevy是模块化和配置化的,由很多单独的crate组成,可按需移除.
高层次功能依赖低层次功能,均可以替换或disable.</p>
<p>ECS就是bevy底层的功能,可单独拿出来使用,甚至在非bevy项目中使用.</p>
<h2 id="bevy-cargo-features"><a class="header" href="#bevy-cargo-features">Bevy Cargo Features</a></h2>
<p>In Bevy projects, you can enable/disable various parts of Bevy using cargo features.</p>
<p>Many common features are enabled by default. If you want to disable some of
them, you need to disable all of them and re-enable the ones you need.
Unfortunately, Cargo does not let you just disable individual default features.</p>
<p>Here is how you might configure your Bevy:</p>
<pre><code class="language-toml">[dependencies.bevy]
version = "0.12"
# Disable the default features if there are any that you do not want
default-features = false
features = [
  # These are the default features:
  # (re-enable whichever you like)

  # Bevy functionality:
  "multi-threaded",     # Run with multithreading
  "bevy_asset",         # Assets management
  "bevy_audio",         # Builtin audio
  "bevy_gilrs",         # Gamepad input support
  "bevy_scene",         # Scenes management
  "bevy_winit",         # Window management (cross-platform Winit backend)
  "bevy_render",        # Rendering framework core
  "bevy_core_pipeline", # Common rendering abstractions
  "bevy_gizmos",        # Support drawing debug lines and shapes
  "bevy_sprite",        # 2D (sprites) rendering
  "bevy_pbr",           # 3D (physically-based) rendering
  "bevy_gltf",          # GLTF 3D assets format support
  "bevy_text",          # Text/font rendering
  "bevy_ui",            # UI toolkit
  "animation",          # Animation support
  "tonemapping_luts",   # Support different camera Tonemapping modes (enables KTX2+zstd)
  "default_font",       # Embed a minimal default font for text/UI

  # File formats:
  "png",    # PNG image format for simple 2D images
  "hdr",    # HDR images
  "ktx2",   # Preferred format for GPU textures
  "zstd",   # ZSTD compression support in KTX2 files
  "vorbis", # Audio: OGG Vorbis

  # Platform-specific:
  "x11",                   # Linux: Support X11 windowing system
  "android_shared_stdcxx", # Android: use shared C++ library
  "webgl2",                # Web: use WebGL2 instead of WebGPU

  # These are other (non-default) features that may be of interest:
  # (add any of these that you need)

  # Bevy functionality:
  "asset_processor",      # Asset processing
  "filesystem_watcher",   # Asset hot-reloading
  "subpixel_glyph_atlas", # Subpixel antialiasing for text/fonts
  "serialize",            # Support for `serde` Serialize/Deserialize
  "async-io",             # Make bevy use `async-io` instead of `futures-lite`
  "pbr_transmission_textures", # Enable Transmission textures in PBR materials
                               # (may cause issues on old/lowend GPUs)

  # File formats:
  "dds",  # Alternative DirectX format for GPU textures, instead of KTX2
  "jpeg", # JPEG lossy format for 2D photos
  "webp", # WebP image format
  "bmp",  # Uncompressed BMP image format
  "tga",  # Truevision Targa image format
  "exr",  # OpenEXR advanced image format
  "pnm",  # PNM (pam, pbm, pgm, ppm) image format
  "basis-universal", # Basis Universal GPU texture compression format
  "zlib", # zlib compression support in KTX2 files
  "flac", # Audio: FLAC lossless format
  "mp3",  # Audio: MP3 format (not recommended)
  "wav",  # Audio: Uncompressed WAV
  "symphonia-all", # All Audio formats supported by the Symphonia library
  "shader_format_glsl", # GLSL shader support
  "shader_format_spirv", # SPIR-V shader support

  # Platform-specific:
  "wayland",              # (Linux) Support Wayland windowing system
  "accesskit_unix",       # (Unix-like) AccessKit integration for UI Accessibility
  "bevy_dynamic_plugin",  # (Desktop) support for loading of `DynamicPlugin`s

  # Development/Debug features:
  "dynamic_linking",   # Dynamic linking for faster compile-times
  "trace",             # Enable tracing for performance measurement
  "detailed_trace",    # Make traces more verbose
  "trace_tracy",       # Tracing using `tracy`
  "trace_tracy_memory", # + memory profiling
  "trace_chrome",      # Tracing using the Chrome format
  "wgpu_trace",        # WGPU/rendering tracing
  "debug_glam_assert", # Assertions to validate math (glam) usage
  "embedded_watcher",  # Hot-reloading for Bevy's internal/builtin assets
]
</code></pre>
<p>(See <a href="https://docs.rs/crate/bevy/0.12.0/features">here</a> for a full list of Bevy's cargo features.)</p>
<p>bevy的思想是crate组合,这就让bevy提供的功能能按需启用,默认的plugin包含了大量常用功能,
也可以自己按需包含.</p>
<p>下面是默认启用的功能,可以在Cargo.toml中通过<code>default-features = false</code>进行disable.
功能主要分类为: bevy功能,文件格式,具体平台绑定值.</p>
<p>默认支持的bevy功能:</p>
<ul>
<li><code>multi-threaded</code>: 多线程</li>
<li><code>bevy_asset</code>: 资产管理</li>
<li><code>bevy_audio</code>: 内置音频</li>
<li><code>bevy_gilrs</code>: 手柄输入支持</li>
<li><code>bevy_scene</code>: scene管理</li>
<li><code>bevy_winit</code>: 窗口管理(跨平台)</li>
<li><code>bevy_render</code>: 渲染框架核心</li>
<li><code>bevy_core_pipeline</code>: 通用渲染抽象层</li>
<li><code>bevy_gizmos</code>: 调试用,绘制线条和形状的小玩意</li>
<li><code>bevy_sprite</code>: 2d 精灵渲染</li>
<li><code>bevy_pbr</code>: 3d(基于物理的)的渲染</li>
<li><code>bevy_gltf</code>: gltf 3d资产格式支持. (gltf是免费3d传输存储格式,跨平台,对GL图形api友好)</li>
<li><code>bevy_text</code>: 文本/字体渲染</li>
<li><code>bevy_ui</code>: ui工具包</li>
<li><code>animation</code>: 动画</li>
<li><code>tonemapping_luts</code>: 支持不同的相机色调映射模式(支持启动ktx2+zstd)</li>
<li><code>default_font</code>: 内嵌一个最小字体,用于支持text/ui</li>
</ul>
<p>默认支持的文件格式:</p>
<ul>
<li><code>png</code>: 简单2d图</li>
<li><code>hdr</code>: 高分辨率图</li>
<li><code>ktx2</code>: GPU纹理推荐格式</li>
<li><code>zstd</code>: 支持zstd压缩的ktx2文件</li>
<li><code>vorbis</code>: 音频ogg格式(vorbis ogg)</li>
</ul>
<p>默认支持的具体平台绑定值:</p>
<ul>
<li><code>x11</code>: linux默认支持的窗口后端</li>
<li><code>android_shared_stdcxx</code>: android默认后端</li>
<li><code>webgl2</code>: web端默认使用WebGL2代替WebGPU</li>
</ul>
<p>非默认支持的bevy功能:</p>
<ul>
<li><code>asset_processor</code>: 资产处理</li>
<li><code>filesystem_watcher</code> 资产热加载</li>
<li><code>subpixel_glyph_atlas</code> 文本字体的<code>子像素抗锯齿</code></li>
<li><code>serialize</code>: serder序列化(serder是rust中的一个序列化/反序列化库)</li>
<li><code>async-io</code>: 使用async-io代替futures-lite</li>
<li><code>pbr_transmission_textures</code> : 在bpr物料中启用传输纹理(bpr是基于物理的渲染,让物料在各种光照下都能呈现逼真效果)</li>
</ul>
<p>非默认支持的文件格式:</p>
<ul>
<li><code>dds</code>: GPU纹理,代替directx格式,不是ktx2</li>
<li><code>jpeg</code>: 有损2d图片</li>
<li><code>webp</code>: webp图片格式</li>
<li><code>bmp</code>: 未压缩bmp图片格式</li>
<li><code>tga</code>: 一家美国公司开发的图片格式</li>
<li><code>exr</code>: OpenEXR标准中的高动态范围图片</li>
<li><code>pnm</code>: 便携且简单存储的图片格式</li>
<li><code>basis-universal</code>: google开发的贴图格式</li>
<li><code>zlib</code>: ktx2,外加zlib压缩</li>
<li><code>flac</code>: 有损音频格式</li>
<li><code>mp3</code>: 适用于音乐下载和存储,游戏场景不推荐</li>
<li><code>wav</code>: 未压缩音频格式</li>
<li><code>symphonia-all</code>: rust音频库,支持多种音频格式的编解码库</li>
<li><code>shader_format_glsl</code>: glsl着色器</li>
<li><code>shader_format_spirv</code> spri-着色器(默认支持的着色器是wgsl)</li>
</ul>
<p>非默认支持的具体平台绑定值:</p>
<ul>
<li><code>wayland</code>: linux支持的窗口后端(sway/hyprland均是基于wayland的)</li>
<li><code>accesskit_unix</code>: unix-like ui无障碍交互工具包</li>
<li><code>bevy_dynamic_plugin</code>: 桌面,支持动态插件加载</li>
</ul>
<p>非默认支持的开发/调试功能:</p>
<ul>
<li><code>dynamic_linking</code>: 动态链接: 编译会更快</li>
<li><code>trace</code>: 开启性能观测跟踪</li>
<li><code>detailed_trace</code>: 更详细的跟踪数据</li>
<li><code>trace_tracy</code>: 跟踪使用tracy(tracy是一个可视化帧分析和性能调试工具)</li>
<li><code>trace_chrome</code>: 跟踪数据使用chrome格式(rust跟踪数据可导出到chrome中查看)</li>
<li><code>wgpu_trace</code>: 开启 wgpu/渲染 跟踪</li>
<li><code>embedded_watcher</code>: bevy内部资产/内置资产的热加载</li>
</ul>
<h3 id="graphics--rendering"><a class="header" href="#graphics--rendering">Graphics / Rendering</a></h3>
<p>For a graphical application or game (most Bevy projects), you can include
<code>bevy_winit</code> and your selection of Rendering features. For
<a href="setup//platforms/linux.html">Linux</a> support, you need at least one of <code>x11</code> or <code>wayland</code>.</p>
<p><code>bevy_render</code> and <code>bevy_core_pipeline</code> are required for any application using
Bevy rendering.</p>
<p>If you only need 2D and no 3D, add <code>bevy_sprite</code>.</p>
<p>If you only need 3D and no 2D, add <code>bevy_pbr</code>. If you are <a href="setup//3d/gltf.html">loading 3D models
from GLTF files</a>, add <code>bevy_gltf</code>.</p>
<p>If you are using Bevy UI, you need <code>bevy_text</code> and <code>bevy_ui</code>. <code>default_font</code>
embeds a simple font file, which can be useful for prototyping, so you don't
need to have a font asset in your project. In a real project, you probably
want to use your own fonts, so your text can look good with your game's art
style. In that case, you can disable the <code>default_font</code> feature.</p>
<p>If you want to draw debug lines and shapes on-screen, add <code>bevy_gizmos</code>.</p>
<p>If you don't need any graphics (like for a dedicated game server, scientific
simulation, etc.), you may remove all of these features.</p>
<p>对于带界面的程序,需要带<code>bevy_winit</code>.如果是linux,<code>x11</code>和<code>wayland</code>至少选一个.</p>
<p>只要是渲染的,都需要<code>bevy_render</code>和<code>bevy_core_pipeline</code>.</p>
<p>如果只是2d不包含3d的,<code>bevy_sprite</code>要包含;
如果只是3d而不是2d的,<code>bevy_pbr</code>要包含,如果3d资产是通过gltf文件加载的,
<code>bevy_gltf</code>要包含.</p>
<p>如果使用bevy ui,<code>bevy_text</code>和<code>bevy_ui</code>是需要的,
<code>default_font</code>内嵌了一个简单的字体,原型开发很用,
真实项目中,还需要将其替换成自己的字体,那时就不需要<code>default_font</code>了.</p>
<p>如果要画一些调试的线或形状,<code>bevy_gizmos</code>有帮助.</p>
<p>如果不需要图像(eg:只是一个游戏服务器),上面这些都可以移除.</p>
<h3 id="file-formats-1"><a class="header" href="#file-formats-1">File Formats</a></h3>
<p>You can use the relevant cargo features to enable/disable support for loading
assets with various different file formats.</p>
<p>See <a href="setup//builtins.html#file-formats">here</a> for more information.</p>
<h3 id="input-devices"><a class="header" href="#input-devices">Input Devices</a></h3>
<p>If you do not care about <a href="setup//input/gamepad.html">gamepad (controller/joystick)</a>
support, you can disable <code>bevy_gilrs</code>.</p>
<p><code>bevy_gilrs</code>是手柄支持,默认是支持的,可依需求去掉.</p>
<h3 id="platform-specific"><a class="header" href="#platform-specific">Platform-specific</a></h3>
<h4 id="linux-windowing-backend"><a class="header" href="#linux-windowing-backend">Linux Windowing Backend</a></h4>
<p>On <a href="setup//platforms/linux.html">Linux</a>, you can choose to support X11, Wayland,
or both. Only <code>x11</code> is enabled by default, as it is the legacy system
that should be compatible with most/all distributions, to make your builds
smaller and compile faster. You might want to additionally enable <code>wayland</code>,
to fully and natively support modern Linux environments. This will add a few
extra transitive dependencies to your project.</p>
<p>Some Linux distros or platforms might struggle with X11 and work better with
Wayland. You should enable both for best compatibility.</p>
<p>linux下默认启用的是x11,虽然是老一代的产物,但稳定性和兼容性依然最强.
大多数发行版都安装了x11,能让程序小很多.wayland是新标准,需要额外的依赖.</p>
<p>并不是说wayland一定好于x11,看发行版对窗口后端的兼容性.</p>
<h4 id="webgpu-vs-webgl2"><a class="header" href="#webgpu-vs-webgl2">WebGPU vs WebGL2</a></h4>
<p>On [Web/WASM][platform::web], you have a choice between these two rendering backends.</p>
<p>WebGPU is the modern experimental solution, offering good performance and
full feature support, but browser support for it is limited (only known to
work in very recent versions of Chrome and Firefox nightly).</p>
<p>WebGL2 gives the best compatibility with all browsers, but has worse performance
and some limitations on what kinds of graphics features you can use in Bevy.</p>
<p>The <code>webgl2</code> cargo feature selects WebGL2 if enabled. If disabled, WebGPU is used.</p>
<p>web/wasm上能打的就WebGPU和WebGL2.
WebGPU是高性能,且功能支持全面,但只有最近几个版本的chrome/firefox才支持.
WebGL2对所有浏览器都兼容的非常好,但性能差了不少.</p>
<p>虽然webgl2是默认开启的,但可以按需替换.</p>
<h3 id="development-features"><a class="header" href="#development-features">Development Features</a></h3>
<p>While you are developing your project, these features might be useful:</p>
<p>开发中以下几个功能可能非常有用.</p>
<h4 id="asset-hot-reloading-and-processing"><a class="header" href="#asset-hot-reloading-and-processing">Asset hot-reloading and processing</a></h4>
<p>The <code>filesystem_watcher</code> feature enables support for <a href="setup//assets/hot-reload.html">hot-reloading of
assets</a>, supported on desktop platforms.</p>
<p>The <code>asset_processor</code> feature enables support for <a href="setup//assets/processing.html">asset
processing</a>, allowing you to automatically convert and
optimize assets during development.</p>
<p>资产的热加载和处理.
桌面平台,<code>filesystem_watcher</code>支持资产的热加载.
<code>asset_processor</code>允许自动转换和优化资产.</p>
<h4 id="dynamic-linking"><a class="header" href="#dynamic-linking">Dynamic Linking</a></h4>
<p><code>dynamic_linking</code> causes Bevy to be built and linked as a shared/dynamic
library. This will make recompilation <em>much</em> faster during development.</p>
<p>This is only supported on desktop platforms. Known to work very well on Linux.
Windows and macOS are also supported, but are less tested and have had issues in
the past.</p>
<p>It is not recommended to enable this for release builds you intend to publish
to other people, unless you have a very good special reason to and you know
what you are doing. It introduces unneeded complexity (you need to bundle
extra files) and potential for things to not work correctly. You should only
use it during development.</p>
<p>For this reason, it may be convenient to specify the feature as a commandline
option to <code>cargo</code>, instead of putting it in your <code>Cargo.toml</code>. Simply run your
project like this:</p>
<pre><code class="language-sh">cargo run --features bevy/dynamic_linking
</code></pre>
<p>You could also add this to your <a href="setup//setup/editor.html">IDE/editor configuration</a>.</p>
<p><code>动态链接</code>只在桌面系统支持,运行最好的是linux,至于windows和macOS刚刚60分.
release版本不推荐开启<code>动态链接</code>,要开启这个功能,只能从命令行操作,Cargo.toml是不行的.</p>
<pre><code class="language-shell">cargo run --features bevy_dynamic_plugin
</code></pre>
<h4 id="tracing"><a class="header" href="#tracing">Tracing</a></h4>
<p>The features <code>trace</code> and <code>wgpu_trace</code> may be useful for profiling and
diagnosing performance issues.</p>
<p><code>trace_chrome</code> and <code>trace_tracy</code> choose the backend you want to use to
visualize the traces.</p>
<p>See <a href="https://github.com/bevyengine/bevy/blob/main/docs/profiling.md">Bevy's official docs on profiling</a> to learn more.</p>
<p>跟踪,主要是在性能剖析和诊断上非常有效.
<code>trace</code>和<code>wgpu_trace</code>可开启跟踪,<code>trace_chrome</code>和<code>trace_tracy</code>是可选的跟踪可视化后端,用一个就行.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="community-plugins-ecosystem"><a class="header" href="#community-plugins-ecosystem">Community Plugins Ecosystem</a></h1>
<p>There is a growing ecosystem of unofficial community-made plugins for Bevy.
They provide a lot of functionality that is not officially included with the
engine. You might greatly benefit from using some of these in your projects.</p>
<p>To find such plugins, you should search the <a href="https://bevyengine.org/assets">Bevy Assets</a>
page on the official Bevy website. This is the official registry of known
community-made things for Bevy. If you publish your own plugins for Bevy,
you should <a href="https://github.com/bevyengine/bevy-assets">contribute a link to be added to that page</a>.</p>
<p>Beware that some 3rd-party plugins may use unusual licenses! Be sure to
check the license before using a plugin in your project.</p>
<p>bevy的生态中有很多插件,在<a href="https://bevyengine.org/assets/">这里</a>.
<em><strong>使用第三方插件,需要注意许可证</strong></em>.</p>
<hr />
<p>Other pages in this book with valuable information when using 3rd-party plugins:</p>
<ul>
<li>Some plugins may require you to <a href="setup//setup/bevy-config.html">configure Bevy in some specific way</a>.</li>
<li>If you are <a href="setup//setup/bevy-git.html">using bleeding-edge unreleased Bevy (main)</a>, you may encounter difficulties with plugin compatibility.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="dev-tools-and-editors-for-bevy"><a class="header" href="#dev-tools-and-editors-for-bevy">Dev Tools and Editors for Bevy</a></h1>
<p>Bevy does not yet have an official editor or other such tools. An official
editor is planned as a long-term future goal. In the meantime, here are
some community-made tools to help you.</p>
<p>bevy官方没有编辑器或类似工具,但社区提供了.</p>
<hr />
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy-inspector-egui"><code>bevy_inspector_egui</code></a> gives you a simple
editor-like property inspector window in-game. It lets you modify the values of
your components and resources in real-time as the game is running.</p>
<p><code>bevy_inspector_egui</code>在游戏中提供了一个类似编辑器的属性检查器窗口,
可以实时修改组件/资源的值.目前有3k+项目在使用这个工具.</p>
<p><a href="https://github.com/jakobhellermann/bevy_editor_pls"><code>bevy_editor_pls</code></a> is an editor-like interface that
you can embed into your game. It has even more features, like switching app
states, fly camera, performance diagnostics, and inspector panels.</p>
<p><code>bevy_editor_pls</code>提供了类似编辑器的接口,可内嵌到游戏中,
调试功能特别多:切换app状态,相机fly,性能诊断,平面检查.
目前有500+项目在使用.</p>
<p><a href="https://github.com/rewin123/space_editor"><code>space_editor</code></a> is another such editor that can be
embedded into your game. It seems to be designed for a Unity-inspired prefab
workflow.</p>
<p><code>space_editor</code>是又一个可以内嵌到游戏中的编辑器,受unity的启发而产生的项目.</p>
<p>You can also use <a href="https://www.blender.org/">Blender</a> as a level/scene editor,
by exporting your scenes to <a href="setup//3d/gltf.html">GLTF</a>. The <a href="https://github.com/kaosat-dev/Blender_bevy_components_workflow">Blender Bevy Components
Workflow</a> project improves on this
experience, by allowing you to setup your Bevy ECS <a href="setup//programming/ec.html#components">Components</a>
in Blender, include them in the exported GLTF, and use them in Bevy.</p>
<p><code>blender</code>也可用作等级/场景编辑器,适用于将scene导出到gltf的场景.</p>
<p>blender是一个开源的三维计算机图形软件,广泛用于动画制作,视觉特效,建模,渲染和游戏开发等领域.
blender停止了自己的游戏引擎开发,但支持导出数据给其他游戏引擎使用.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy_mod_debugdump"><code>bevy_mod_debugdump</code></a> is a tool to help visualize
your <a href="setup/../programming/app-builder.html">App Schedules</a> (all of the registered
<a href="setup/../programming/systems.html">systems</a> with their <a href="setup/../programming/system-order.html">ordering
dependencies</a>), and the Bevy Render Graph.</p>
<p><code>bevy_mod_debugdump</code>是调度可视化的诊断工具,还包含了bevy的渲染图诊断.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="performance-tunables"><a class="header" href="#performance-tunables">Performance Tunables</a></h1>
<p>Bevy offers a lot of features that should improve performance in most cases, and
most of them are enabled by default. However, they might be detrimental to some
projects.</p>
<p>Luckily, most of them are configurable. Most users should probably not touch
these settings, but if your game does not perform well with Bevy's default
configuration, this page will show you some things you can try to change, to see
if they help your project.</p>
<p>Bevy's default configruation is designed with <em>scalability</em> in mind. That is, so
that you don't have to worry too much about performance, as you add more
features and complexity to your project. Bevy will automatically take care to
distribute the workload as to make good use of the available hardware (GPU, CPU
multithreading).</p>
<p>However, it might hurt simpler projects or have undesirable implications in some
cases.</p>
<p>This trade-off is good, because small and simple games will probably be fast
enough anyway, even with the additional overhead, but large and complex games
will benefit from the advanced scheduling to avoid bottlenecks. You can
develop your game without performance degrading much as you add more stuff.</p>
<p>性能可调参数.</p>
<p>bevy提供了大量功能,在大多数场景下都能提高性能,这些大多是默认开启的.
在部分项目中,这些默认开启的可能会起到反效果.</p>
<p>这些参数都是可调的.</p>
<p>bevy的设计权衡是可扩展,有些机制启用后在简单项目中不是最优,但消耗也能接受,
在复杂项目中就能得到很好的收益,eg:多线程(在自定义bevy一节中,多线程是第一个默认启用的功能).</p>
<h2 id="multithreading-overhead"><a class="header" href="#multithreading-overhead">Multithreading Overhead</a></h2>
<p>Bevy has a smart multithreaded executor, so that your <a href="setup//programming/systems.html">systems</a> can
automatically <a href="setup//programming/intro-code.html">run in parallel</a> across multiple CPU cores,
when they don't need conflicting access to the same data, while <a href="setup//programming/system-order.html">honoring ordering
constraints</a>. This is great, because you can just keep adding
more systems to do different things and implement more features in your game,
and Bevy will make good use of modern multi-core CPUs with no effort from you!</p>
<p>However, the smart scheduling adds some overhead to all common operations (such
as every time a <a href="setup//programming/systems.html">system</a> runs). In projects that have little work to
do every frame, especially if all of your systems complete very quickly, the
overhead can add up to overshadow the actual useful work you are doing!</p>
<p>You might want to try disabling multithreading, to see if your game might
perform better without it.</p>
<p>多线程,这样多个system就可以在多个cpu并行处理,配合system的<code>顺序约定</code>,
bevy就自动处理了多核调度.</p>
<p>bevy自动调度不是没有代价的,而且还很大,如果system都是执行简单任务,
多线程的收益不一定能覆盖住bevy自动调度的消耗.
换言之,system任务越复杂,多线程调度的收益越高.</p>
<h3 id="disabling-multithreading-for-update-schedule-only"><a class="header" href="#disabling-multithreading-for-update-schedule-only">Disabling Multithreading for Update Schedule Only</a></h3>
<p>Multithreading can be disabled per-<a href="setup//programming/schedules.html">schedule</a>. This means it
is easy to disable it only for your code / game logic (in the <code>Update</code> schedule),
while still leaving it enabled for all the Bevy engine internal systems.</p>
<p>This could speed up simple games that don't have much gameplay logic, while still
letting the engine run with multithreading.</p>
<p>You can edit the settings of a specific <a href="setup//programming/schedules.html">schedule</a> via the <a href="setup//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">    use bevy::ecs::schedule::ExecutorKind;

    App::new()
        .add_plugins(DefaultPlugins)
        .edit_schedule(Update, |schedule| {
            schedule.set_executor_kind(ExecutorKind::SingleThreaded);
        })
        // ...</code></pre>
<p>bevy中有很多调度器,其中Update就是我们自定义的游戏逻辑,其他很多是bevy内置的system,
这里提供了一种方式只让Update调度器禁止使用多线程.这对简单项目是有性能提高的.</p>
<p>如上图所示,指定调度器类型为单线程即可.</p>
<h3 id="disabling-multithreading-completely"><a class="header" href="#disabling-multithreading-completely">Disabling Multithreading Completely</a></h3>
<p>If you want to try to completely disable multithreading for everything,
you can do so by removing the <code>multi-threaded</code> default Cargo feature.</p>
<p>In <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies.bevy]
version = "0.12"
default-features = false
features = [
   # re-enable everything you need, without `multi-threaded`
   # ...
]
</code></pre>
<p><a href="setup//setup/bevy-config.html">(see here for how to configure Bevy's cargo features)</a></p>
<p>This is generally not recommended. Bevy is designed to work with multithreading.
Only consider it if you really need it (like if you are making a special build
of your project to run on a system where it makes sense, like WASM or old
hardware).</p>
<p>如果要禁止所有system的多线程运行,通过features禁用<code>multi-threaded</code>即可.
这个一般出现在wasm或老旧硬件的项目中.</p>
<h2 id="multithreading-configuration"><a class="header" href="#multithreading-configuration">Multithreading Configuration</a></h2>
<p>You can configure how many CPU threads Bevy uses.</p>
<p>Bevy creates threads for 3 different purposes:</p>
<ul>
<li>Compute: where all your systems and all per-frame work is run</li>
<li>AsyncCompute: for background processing independent from framerate</li>
<li>I/O: for loading of assets and other disk/network activity</li>
</ul>
<p>By default, Bevy <em>splits/partitions</em> the available CPU threads as follows:</p>
<ul>
<li>I/O: 25% of the available CPU threads, minimum 1, maximum 4</li>
<li>AsyncCompute: 25% of the available CPU threads, minimum 1, maximum 4</li>
<li>Compute: all remaining threads</li>
</ul>
<p>This means <em>no overprovisioning</em>. Every hardware CPU thread is used
for one specific purpose.</p>
<p>This provides a good balance for mixed CPU workloads. Particularly for games
that load a lot of assets (especially if assets are loaded dynamically during
gameplay), the dedicated I/O threads will reduce stuttering and load times.
Background computation will not affect your framerate. Etc.</p>
<p>Examples:</p>
<div class="table-wrapper"><table><thead><tr><th>CPU Cores/Threads</th><th># I/O</th><th># AsyncCompute</th><th># Compute</th></tr></thead><tbody>
<tr><td>1-3</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>4</td><td>1</td><td>1</td><td>2</td></tr>
<tr><td>6</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>8</td><td>2</td><td>2</td><td>4</td></tr>
<tr><td>10</td><td>3</td><td>3</td><td>4</td></tr>
<tr><td>12</td><td>3</td><td>3</td><td>6</td></tr>
<tr><td>16</td><td>4</td><td>4</td><td>8</td></tr>
<tr><td>24</td><td>4</td><td>4</td><td>16</td></tr>
<tr><td>32</td><td>4</td><td>4</td><td>24</td></tr>
</tbody></table>
</div>
<p>Note: Bevy does not currently have any special handling for asymmetric
(big.LITTLE or Intel P/E cores) CPUs. In an ideal world, maybe it would be nice
to use the number of big/P cores for Compute and little/E cores for I/O.</p>
<p>进一步还可以配置bevy能使用到的线程数,bevy创建的线程一般要干3件事:</p>
<ul>
<li>计算,所有的system和每帧前置的工作</li>
<li>异步计算,独立于帧率的后台处理逻辑</li>
<li>io,资产加载或活跃的磁盘网络活动</li>
</ul>
<p>默认bevy是按如下方式分配cpu线程的:</p>
<ul>
<li>io: 25%可用线程数,最少1个,最多4个</li>
<li>异步计算: 25%可用线程数,最少1个,最多4个</li>
<li>计算:剩下线程数</li>
</ul>
<p>这个配置很平衡,资源加载(大一点的游戏都是动态加载资源的)和io会减少游戏卡顿和加载时间,
后台的异步计算也不会受帧率影响,这是这么设计的考虑.</p>
<p>如上表所示: 8核的分配是2/2/4(对着表格看),24核的分配是4/4/16.</p>
<h3 id="overprovisioning"><a class="header" href="#overprovisioning">Overprovisioning</a></h3>
<p>However, if your game does very little I/O (asset loading) or background
computation, this default configuration might be sub-optimal. Those threads will
be sitting idle a lot of the time. Meanwhile, Compute, which is your frame
update loop and is important to your game's overall framerate, is limited to
fewer threads. This can be especially bad on CPUs with few cores (less than 4
total threads).</p>
<p>For example, in my projects, I usually load all my assets during a loading
screen, so the I/O threads are unused during normal gameplay. I rarely use
AsyncCompute.</p>
<p>If your game is like that, you might want to make all CPU threads available for
Compute. This could boost your framerate, especially on CPUs with few cores.
However, any AsyncCompute or I/O workloads during gameplay could impact your
game's performance / framerate consistency.</p>
<p>Here is how to do that:</p>
<pre><code class="language-rust no_run noplayground">    use bevy::core::TaskPoolThreadAssignmentPolicy;
    use bevy::tasks::available_parallelism;

    App::new()
        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
            // DefaultPlugins.set() 就是自定义某个插件,
            // TaskPoolPlugin 里面包含了3个任务池,分别是异步计算/计算/io.
            task_pool_options: TaskPoolOptions {
                compute: TaskPoolThreadAssignmentPolicy {
                    // set the minimum # of compute threads
                    // to the total number of available threads
                    // 通过设置最小线程数为最大可用线程数来屏蔽异步计算和io的线程数.
                    min_threads: available_parallelism(),
                    max_threads: std::usize::MAX, // unlimited max threads
                    percent: 1.0,                 // this value is irrelevant in this case
                },
                // keep the defaults for everything else
                ..default()
            },
        }))
        // ...</code></pre>
<p>And here is an example of an entirely custom configuration:</p>
<pre><code class="language-rust no_run noplayground">    App::new()
        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
            task_pool_options: TaskPoolOptions {
                min_total_threads: 1,
                max_total_threads: std::usize::MAX, // unlimited threads
                io: TaskPoolThreadAssignmentPolicy {
                    // say we know our app is i/o intensive (asset streaming?)
                    // so maybe we want lots of i/o threads
                    // io密集型程序.
                    min_threads: 4,
                    max_threads: std::usize::MAX,
                    percent: 0.5, // use 50% of available threads for I/O
                },
                async_compute: TaskPoolThreadAssignmentPolicy {
                    // say our app never does any background compute,
                    // so we don't care, but keep one thread just in case
                    // 异步计算虽然没有,可以指定为1个.
                    min_threads: 1,
                    max_threads: 1,
                    percent: 0.0,
                },
                compute: TaskPoolThreadAssignmentPolicy {
                    // say we want to use at least half the CPU for compute
                    // (maybe over-provisioning if there are very few cores)
                    // 最少保证一半的线程在计算上.
                    min_threads: available_parallelism() / 2,
                    // but limit it to a maximum of 8 threads
                    max_threads: 8,
                    // 1.0 in this case means "use all remaining threads"
                    // (that were not assigned to io/async_compute)
                    // (clamped to min_threads..=max_threads)
                    percent: 1.0,
                },
            },
        }))
        // ...</code></pre>
<p>当然,如果我们的游戏在资产加载(io)和异步计算方面的任务非常少,默认配置就不是最优的,
在很多时间内,分配给io和异步计算的线程就是闲着的,如果cpu线程数多一点,
这点闲置对游戏还没啥大影响,如果cpu线程数很少(小于4个),这点浪费就是巨大的浪费.</p>
<p>eg:在屏幕加载画面中,资产已经加载完毕,这意味着没啥io,如果异步计算也少,
这种情况下,调整默认配置就是很有必要的.</p>
<h2 id="pipelined-rendering"><a class="header" href="#pipelined-rendering">Pipelined Rendering</a></h2>
<p>Bevy has a <a href="setup//gpu/intro.html">pipelined rendering architecture</a>. This
means Bevy's GPU-related <a href="setup//programming/systems.html">systems</a> (that run on the CPU to prepare
work for the GPU every frame) will run in parallel with all the normal systems
for the next frame. Bevy will render the previous frame in parallel with the
next frame update.</p>
<p>This will improve GPU utilization (make it less likely the GPU will sit idle
waiting for the CPU to give it work to do), by making better use of CPU
multithreading. Typically, it can result in 10-30% higher framerate, sometimes
more.</p>
<p>However, it can also affect perceived input latency ("click-to-photon"
latency), often for the worse. The effects of the player's input might be
shown on screen delayed by one frame. It might be compensated by the faster
framerate, or it might not be. Here is a diagram to visualize what happens:</p>
<p><img src="setup/../img/pipelined-latency.png" alt="Timeline comparing pipelined and non-pipelined rendering. In the pipelined case, one additional frame is displayed before the effects of the mouse click can be seen on-screen." /></p>
<p>The actual mouse click happens in-between frames. In both cases, frame #4 is
when the input is detected by Bevy. In the pipelined case, rendering
of the previous frame is done in parallel, so an additional frame without
the input appears on-screen.</p>
<p>Without pipelining, the user will see their input delayed by 1 frame. With
pipelining, it will be delayed by 2 frames.</p>
<p>However, in the diagram above, the frame rate increase from pipelining is
big enough that overall the input is processed and displayed sooner. Your
application might not be so lucky.</p>
<p>bevy的渲染是管道式架构.GPU在显卡上,运行在cpu的system会将每帧要投递给GPU数据准备好,
GPU和CPU是并行运行的.这类system称为<code>GPU相关的system</code>,
其特点是当前帧的GPU system和下帧的普通system是并行执行的.</p>
<p>这种设计提高了GPU的利用率,配合多线程,总体能提高10-30%的帧率.</p>
<p>因为GPU system的实际上工作在下帧,在低延时的场景下, 对输入的感知会造成影响,
这是提高帧率的代价之一.高帧率比低帧率的影响小一些.</p>
<p>如上图所示,鼠标点击后,在4处bevy感知到了点击事件,
在没有pipeline机制时,在5处就通过画面反馈到玩家了,用了1帧;
在使用pipeline机制时,在6处才反馈到玩家,用了2帧.</p>
<p>在高帧率下,pipeline机制的代价会被收益覆盖,我们的程序具体是咋样的,
需要具体分析.</p>
<hr />
<p>If you care more about latency than framerate, you might want to disable
pipelined rendering. For the best latency, you probably also want to
<a href="setup//window/props.html#vsync">disable VSync</a>.</p>
<p>Here is how to disable pipelined rendering:</p>
<pre><code class="language-rust no_run noplayground">    use bevy::render::pipelined_rendering::PipelinedRenderingPlugin;

    App::new()
        .add_plugins(DefaultPlugins.build().disable::&lt;PipelinedRenderingPlugin&gt;())
        // ...
        .run();</code></pre>
<p>pipeline的开关如上图操作.</p>
<h2 id="clustered-forward-rendering"><a class="header" href="#clustered-forward-rendering">Clustered Forward Rendering</a></h2>
<p>By default, Bevy uses a Clustered Forward Rendering architecture for 3D.  The
viewport (on-screen area where the game is displayed) is split into
rectangles/voxels, so that the lighting can be handled separately for each small
portion of the scene. This allows you to use many lights in your 3D scenes,
without destroying performance.</p>
<p>The dimensions of these clusters can affect rendering performance. The default
settings are good for most 3D games, but fine-tuning them could improve
performance, depending on your game.</p>
<p>In games with a top-down-view camera (such as many strategy and simulation
games), most of the lights tend to be a similar distance away from the camera.
In such cases, you might want to reduce the number of Z slices (so that the
screen is split into smaller X/Y rectangles, but each one covering more
distance/depth):</p>
<pre><code class="language-rust no_run noplayground">    use bevy::pbr::ClusterConfig;

    commands.spawn((
        Camera3dBundle {
            // ... your 3D camera configruation
            ..Default::default()
        },
        ClusterConfig::FixedZ {
            // 固定z, 适合从上到下视角的游戏,eg:策略或模拟游戏.

            // 4096 clusters is the Bevy default
            // if you don't have many lights, you can reduce this value
            // 灯光数少,就减少total值. 默认集群分组数是4096.
            total: 4096,
            // Bevy default is 24 Z-slices
            // For a top-down-view game, 1 is probably optimal.
            // 从上到下视角的游戏中,设置z为1.
            z_slices: 1,
            dynamic_resizing: true,
            z_config: Default::default(),
        },
    ));</code></pre>
<p>For games that use very few lights, or where lights affect the entire scene (
such as inside a small room / indoor area), you might want to try disabling
clustering:</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn((
        Camera3dBundle {
            // ... your 3D camera configruation
            ..Default::default()
        },
        ClusterConfig::Single, // 如果是室内,光源单一,可以disable集群.
    ));</code></pre>
<p>Changing these settings will probably result in bad performance for many games,
outside of the specific scenarios described above.</p>
<p>默认bevy在3d渲染中使用<code>集群向前渲染</code>,
视口（显示游戏的屏幕区域）被分割成矩形/体素，这样可以针对场景的每个小部分单独处理照明。
这样，可以在 3D 场景中使用许多灯光，而不会影响性能。</p>
<p>集群分组的尺寸会影响渲染性能,适合的设置会提升性能.
在采用自上而下视角的游戏中（例如许多策略和模拟游戏），大多数灯光与相机的距离都差不多。
在这种情况下，您可能需要减少 Z 切片的数量
(以便将屏幕分割成更小的 X/Y 矩形，但每个矩形覆盖更大的距离/深度).</p>
<p><em><strong>大多数场景下不需要这么设置,只在特殊场景下使用会提高性能.</strong></em></p>
<p>集群向前渲染是一种现代渲染技术.<br />
结合了传统的前向渲染（Forward Rendering）和集群（Clustered）分组的方法，
以更高效地处理复杂场景中的光源和阴影。
它在处理大量光源时比传统的前向渲染更高效，
并且在性能和灵活性上比延迟渲染（Deferred Rendering）有一些优势。</p>
<p>前向渲染（Forward Rendering）:<br />
传统的渲染技术，其中每个对象在渲染时直接应用所有影响它的光源。
这种方法在处理少量光源时比较高效，但随着光源数量的增加，性能会显著下降。</p>
<p>延迟渲染（Deferred Rendering）：<br />
延迟渲染首先渲染场景几何信息到多个缓冲区，然后在一个单独的光照阶段应用光源。
它能很好地处理大量光源，但需要更多的内存带宽和较复杂的后期处理。</p>
<p>集群分组（Clustered）：<br />
场景被分割成多个小的三维区域（集群）。
光源和物体的关系只在这些集群内进行计算，从而减少每个对象需要处理的光源数量。
这种方法提高了光源管理的效率。</p>
<p>Clustered Forward Rendering 的流程:</p>
<p>空间划分：将视锥（视图体积）划分为多个集群，
这些集群通常是视锥内的固定大小的体积单元（如立方体）。</p>
<p>光源分配：遍历所有光源，并将每个光源分配到其影响的集群中。
每个光源的影响范围通过简单的几何计算确定，这样每个集群只会存储影响它的光源列表。</p>
<p>渲染阶段：在渲染每个像素时，首先确定该像素所在的集群，
然后仅应用该集群中的光源进行光照计算。
这减少了每个像素需要处理的光源数量，提高了渲染效率。</p>
<p>优点: 处理大量光源, 灵活, 性能优化.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="using-bleeding-edge-bevy-bevy-main"><a class="header" href="#using-bleeding-edge-bevy-bevy-main">Using bleeding-edge Bevy (bevy main)</a></h1>
<p>Bevy development moves very fast, and there are often exciting new things that
are yet unreleased. This page will give you advice about using development
versions of bevy.</p>
<p>使用开发分支的bevy.这样可以体验未发布的新奇功能.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>If you are <em>not</em> using any 3rd-party plugins and just want to use the bevy
main development branch:</p>
<pre><code class="language-toml">[dependencies]
bevy = { git = "https://github.com/bevyengine/bevy" }
</code></pre>
<p>However, if you <em>are</em> working with external plugins, you should read the rest
of this page. You will likely need to do more to make everything compatible.</p>
<p>如果不想使用第三方插件,直接制定bevy的版本为main分支即可;
如果想要使用第三方插件,为了兼容性,还是需要将下文看完.</p>
<h2 id="should-you-use-bleeding-edge-bevy-what-version-of-bevy-should-you-use"><a class="header" href="#should-you-use-bleeding-edge-bevy-what-version-of-bevy-should-you-use">Should you use bleeding-edge Bevy? What version of Bevy should you use?</a></h2>
<p>Bevy follows a "train release" model, with loose deadlines. Every 3 months,
a new major release is prepared, which will contain all new developments
(features, fixes, etc.) since the last release. The release date is not
strict and is often delayed by a few weeks to tie up loose ends.</p>
<p>Further, Bevy usually follows up every major release with a patch release
or two, as needed, to fix any bugs discovered soon after release. It will
not contain all fixes, just small non-breaking things that are considered
critical enough.</p>
<p>Most Bevy projects should use the latest release on crates.io. If you want
to play it safe, you can wait until the first patch release (<code>0.*.1</code>),
before upgrading to a new major version. You might also want to wait for
any 3rd-party plugins you are using to support the new Bevy version.</p>
<p>On the other hand, for experimentation and for Bevy development, you are
encouraged to try the latest in-development code from git! The latest
release is often missing the freshest bug fixes, usability improvements,
and features. It may be compelling to join in on the action!</p>
<p>If you are new to Bevy, this might not be for you. You will be more
comfortable using the released version. It will have the best compatibility
with community plugins and documentation.</p>
<p>The in-development version of Bevy has frequent breaking changes. Therefore,
it can be very annoying to use for real projects. Also, 3rd-party plugin
authors often don't bother to stay compatible. You will face breakage often
and probably have to fix it yourself.</p>
<p>It is only recommended to do this for more experimental or toy projects.</p>
<p>Though, there are ways you can manage the breakage and make it less of a
problem. Thanks to cargo, you can update bevy at your convenience, whenever you
feel ready to handle any possible breaking changes.</p>
<p>You may want to consider forking the repositories of Bevy and any plugins you
use. Using your own forks allows you to easily apply fixes if needed, or edit
their <code>Cargo.toml</code> for any special configuration to make your project work.</p>
<p>If you choose to use Bevy main, you are highly encouraged to interact with
the Bevy community on <a href="https://discord.gg/bevy">Discord</a> and <a href="https://github.com/bevyengine/bevy">GitHub</a>, so
you can keep track of what's going on, get help, or participate in discussions.</p>
<p>bevy采用<code>火车发布</code>模式,期限很短.每3个月就发布一个主版本,通常会延时几周发布,
用以解决发布问题.每个版本也不是长期支持,基本会有两个修复版本出来,
就算是修复也只会修复重要且非破坏性的内容.
大部分使用bevy的项目都是使用最新的主版本.如果追求稳定性,可以考虑使用修复版本.
eg:v0.13.2.还可能需要等使用的插件也同步支持到bevy的版本.</p>
<p>通常使用最新版本是最好的,因为bug修复,新增功能都是最聚焦的.
对于新手来说并不是如此,选一个稳定的版本,能使用大多数插件,这可能更重要一些.
最新的main分支还可能有破坏性变更,这点是最烦人的,
另外第三方插件如果不及时更新保持兼容性,也是非常烦人的,这就是bevy生态还很欠缺的由来.
当然最终还是可以自己从插件分支拉代码,自己来修复,但这条路是托底操作.</p>
<h2 id="common-pitfall-mysterious-compile-errors"><a class="header" href="#common-pitfall-mysterious-compile-errors">Common pitfall: mysterious compile errors</a></h2>
<p>When changing between different versions of Bevy (say, transitioning an existing
project from the released version to the git version), you might get lots of
strange unexpected build errors.</p>
<p>You can typically fix them by removing <code>Cargo.lock</code> and the <code>target</code> directory:</p>
<pre><code class="language-sh">rm -rf Cargo.lock target
</code></pre>
<p>See <a href="setup//pitfalls/build-errors.html">this page</a> for more info.</p>
<p>If you are still getting errors, it is probably because cargo is trying
to use multiple different versions of bevy in your dependency tree
simultaneously. This can happen if some of the plugins you use have specified
a different Bevy version/commit from your project.</p>
<p>If you are using any 3rd-party plugins, please consider forking them, so you can
edit their <code>Cargo.toml</code> and have control over how everything is configured.</p>
<p>使用main分支,常见的编译错误是编译出现问题,此时删除Cargo.toml和target目录,
如果还不行,可能就是插件使用了具体的bevy版本,
总之,使用bevy的main分支时,推荐fork插件,并变更插件以来的bevy版本.有点复杂.</p>
<h2 id="cargo-patches"><a class="header" href="#cargo-patches">Cargo Patches</a></h2>
<p>In some cases, you might be able to use "cargo patches" to locally override
dependencies. For example, you might be able to point plugins to use your
fork of bevy, without forking and editing the plugin's <code>Cargo.toml</code>, by
doing something like this:</p>
<pre><code class="language-toml"># replace the bevy git URL source with ours
[patch."https://github.com/bevyengine/bevy"]
# if we have our own fork
bevy = { git = "https://github.com/me/bevy" }
# if we want to use a local path
bevy = { path = "../bevy" }
# some plugins might depend on individual bevy crates,
# instead of all of bevy, which means we need to patch
# every individual bevy crate specifically:
bevy_ecs = { path = "../bevy/crates/bevy_ecs" }
bevy_app = { path = "../bevy/crates/bevy_app" }
# ...

# replace released versions of crates (crates.io source) with ours
[patch.crates-io]
bevy_some_plugin = { git = "https://github.com/me/bevy_some_plugin", branch = "bevy_main" }
# also replace bevy itself
bevy = { path = "../bevy" }
# ...
</code></pre>
<p>也可以先fork插件,再通过cargo patch打补丁的方式来引用bevy.</p>
<h2 id="updating-bevy"><a class="header" href="#updating-bevy">Updating Bevy</a></h2>
<p>It is recommended that you specify a known-good Bevy commit in your
<code>Cargo.toml</code>, so that you can be sure that you only update it when you
actually want to do so, avoiding unwanted breakage.</p>
<pre><code class="language-toml">bevy = { git = "https://github.com/bevyengine/bevy", rev = "7a1bd34e" }
</code></pre>
<p>When you change anything, be sure to run:</p>
<pre><code class="language-sh">cargo update
</code></pre>
<p>(or delete <code>Cargo.lock</code>)</p>
<p>Otherwise you risk errors from cargo not resolving dependencies correctly.</p>
<p>使用main分支,最好是制定git提交号,固定版本才是最明确的.</p>
<h2 id="advice-for-plugin-authors"><a class="header" href="#advice-for-plugin-authors">Advice for plugin authors</a></h2>
<p>If you are publishing a plugin crate, here are some recommendations:</p>
<ul>
<li>Use the main branch in your repository for targeting the released version of Bevy</li>
<li>Have a separate branch in your repository, to keep support for bevy main
separate from your version for the released version of bevy</li>
<li>Put information in your README to tell people how to find it</li>
<li>Set up CI to notify you if your plugin is broken by new changes in bevy</li>
</ul>
<p>Feel free to follow all the advice from this page, including cargo patches
as needed. Cargo patches only apply when you build your project directly,
not as a dependency, so they do not affect your users and can be safely kept
in your <code>Cargo.toml</code>.</p>
<p>对于插件作者,有以下建议:</p>
<ul>
<li>使用bevy的main分支</li>
<li>插件仓库最好有个单独的分支来支持bevy的main分支</li>
<li>在README中添加描述信息,让别人能很好找到这个信息</li>
<li>通过CI来提醒失败</li>
</ul>
<h3 id="ci-setup"><a class="header" href="#ci-setup">CI Setup</a></h3>
<p>Here is an example for GitHub Actions. This will run at 8:00 AM (UTC) every day
to verify that your code still compiles. GitHub will notify you when it fails.</p>
<pre><code class="language-yaml">name: check if code still compiles

on:
  schedule:
    - cron: '0 8 * * *'

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'my-bevy-main-support-branch'

      - name: Install Dependencies
        run: sudo apt-get update &amp;&amp; sudo apt-get install g++ pkg-config libx11-dev libasound2-dev libudev-dev

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Check code
        run: cargo update &amp;&amp; cargo check --lib --examples
</code></pre>
<p>此处是github action 每天早早点进行编译的例子.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h1>
<p>This chapter covers some common issues or surprises that you might be
likely to encounter when working with Bevy, with specific advice about how
to address them.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="strange-build-errors"><a class="header" href="#strange-build-errors">Strange Build Errors</a></h1>
<p>Sometimes, you can get strange and confusing build errors when trying to
compile your project.</p>
<p>编译出现奇怪的错误,可按以下方式尝试解决.</p>
<h2 id="update-your-rust"><a class="header" href="#update-your-rust">Update your Rust</a></h2>
<p>First, make sure your Rust is up-to-date. Bevy only supports the latest
stable version of Rust, or nightly.</p>
<p>If you are using <a href="https://rustup.rs"><code>rustup</code></a> to manage your Rust installation, you
can run:</p>
<pre><code class="language-shell">rustup update
</code></pre>
<p>更新rust版本,因为bevy只支持最新rust版本.</p>
<h2 id="clear-the-cargo-state"><a class="header" href="#clear-the-cargo-state">Clear the cargo state</a></h2>
<p>Many kinds of build errors can often be fixed by forcing <code>cargo</code> to regenerate
its internal state (recompute dependencies, etc.). You can do this by deleting
the <code>Cargo.lock</code> file and the <code>target</code> directory.</p>
<pre><code class="language-shell">rm -rf target Cargo.lock
</code></pre>
<p>Try building your project again after doing this. It is likely that the
mysterious errors will go away.</p>
<p>If not, another reason might be that you have multiple versions of Bevy if
your dependency tree. If you are using 3rd-party plugins, make sure you have
specified the correct versions of all the plugins you use and that they are
compatible with the Bevy version you are using.</p>
<p>If none of this helps you, your issue might require further
investigation. Reach out to the Bevy community via GitHub or
<a href="https://discord.gg/bevy">Discord</a>, and ask for help.</p>
<p>If you are using bleeding-edge Bevy ("main"), and the above does not solve
the problem, your errors might be caused by 3rd-party plugins. See <a href="pitfalls/../setup/bevy-git.html#how-to-use-bleeding-edge-bevy">this
page</a> for solutions.</p>
<h2 id="new-cargo-resolver"><a class="header" href="#new-cargo-resolver">New Cargo Resolver</a></h2>
<p>Cargo recently added a new dependency resolver algorithm, that is incompatible
with the old one. Bevy <em>requires</em> the new resolver.</p>
<p>If you are just creating a new blank Cargo project, don't worry. This should
already be setup correctly by <code>cargo new</code>.</p>
<p>If you are getting weird compiler errors from Bevy dependencies, read on. Make sure
you have the correct configuration, and then <a href="pitfalls//pitfalls/build-errors.html#clear-the-cargo-state">clear the cargo state</a>.</p>
<h3 id="single-crate-projects"><a class="header" href="#single-crate-projects">Single-Crate Projects</a></h3>
<p>In a single-crate project (if you only have one <code>Cargo.toml</code> file in your project),
if you are using the latest Rust2021 Edition, the new resolver is automatically
enabled.</p>
<p>So, you need either one of these settings in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
edition = "2021"
</code></pre>
<p>or</p>
<pre><code class="language-toml">[package]
resolver = "2"
</code></pre>
<h3 id="multi-crate-workspaces"><a class="header" href="#multi-crate-workspaces">Multi-Crate Workspaces</a></h3>
<p>In a multi-crate Cargo workspace, the resolver is a global setting for the
whole workspace. It will <em>not</em> be enabled by default.</p>
<p>This can bite you if you are transitioning a single-crate project into a workspace.</p>
<p>You <em>must</em> add it manually to the top-level <code>Cargo.toml</code> for your Cargo Workspace:</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
</code></pre>
<p>很多编译错误都是因为cargo内部状态导致的,清理之后重新生成可解决大部分问题.
<code>rm -rf target Cargo.lock</code> 之后重新编译即可.
如果这步还不行,就需要排除多bevy版本的问题,特别是使用第三方插件时,
需要注意多bevy版本的问题.</p>
<p>如果到这步还不能解决问题,需要到社区寻找方法.</p>
<hr />
<p>新的cargo解析器</p>
<p>Cargo 最近添加了一种新的依赖解析器算法，该算法与旧算法不兼容。 Bevy 需要新的解析器。
如果要新建项目,使用cargo new, 这样就启用了新的解析算法.</p>
<p>如果项目是单包项目(项目中只有一个Cargo.toml),下面两个设置都会自动使用新的解析算法:</p>
<pre><code class="language-toml">[package]
edition = "2021"

# 或是,二选一即可.
[package]
resolver = "2"
</code></pre>
<p>如果项目是多包项目工作空间,在workspace的顶级Cargo.toml中要添加:</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<h2 id="unoptimized-debug-builds"><a class="header" href="#unoptimized-debug-builds">Unoptimized debug builds</a></h2>
<p>You can partially enable compiler optimizations in debug/dev mode!</p>
<p>You can enable higher optimizations for dependencies (incl. Bevy), but not
your own code, to keep recompilations fast!</p>
<p>In <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml"># Enable max optimizations for dependencies, but not for our code:
[profile.dev.package."*"]
opt-level = 3
</code></pre>
<p>The above is enough to make Bevy run fast. It will only slow down clean
builds, without affecting recompilation times for your project.</p>
<p>If your own code does CPU-intensive work, you might want to also enable some
optimization for it.</p>
<pre><code class="language-toml"># Enable only a small amount of optimization in debug mode
[profile.dev]
opt-level = 1
</code></pre>
<p><strong>Warning!</strong> If you are using a debugger (like <code>gdb</code> or <code>lldb</code>) to step through
your code, any amount of compiler optimization can mess with the experience.
Your breakpoints might be skipped, and the code flow might jump around in
unexpected ways. If you want to debug / step through your code, you might want
<code>opt-level = 0</code>.</p>
<p>在调试模式和开发模式,可部分启用编译器优化.常用的是对依赖进行最高优化,
对自己的代码逻辑不进行优化,方便调试.在Cargo.toml中启用下面配置,
或是在.cargo/config.toml中进行全局启用.</p>
<pre><code class="language-toml"># Enable max optimizations for dependencies, but not for our code:
[profile.dev.package."*"]
opt-level = 3
</code></pre>
<p>如果代码是cpu密集型,还可以进一步优化.(哪个游戏逻辑不是CPU密集型呢?)</p>
<pre><code class="language-toml"># Enable only a small amount of optimization in debug mode
[profile.dev]
opt-level = 1
</code></pre>
<p>上面的优化在使用gdb/lldb的场景下<code>不适用</code>. 在gdb/lldb要想断点不乱,
需要是哦那个<code>opt-level = 0</code>.</p>
<h3 id="why-is-this-necessary"><a class="header" href="#why-is-this-necessary">Why is this necessary?</a></h3>
<p>Rust without compiler optimizations is <em>very slow</em>. With Bevy in
particular, the default cargo build debug settings will lead to <em>awful</em> runtime
performance. Assets are slow to load and FPS is low.</p>
<p>Common symptoms:</p>
<ul>
<li>Loading high-res 3D models with a lot of large textures, from GLTF
files, can take minutes! This can trick you into thinking
that your code is not working, because you will not see anything on
the screen until it is ready.</li>
<li>After spawning even a few 2D sprites or 3D models, framerate may drop
to unplayable levels.</li>
</ul>
<p>众所周知,没有编译器优化的rust程序非常慢,在bevy中,rust的默认编译配置太慢.</p>
<ul>
<li>从gltf文件中加载大量纹理的3d模型,要几分钟.</li>
<li>在生成几个2d/3d精灵后,帧率会急速下降.</li>
</ul>
<h3 id="why-not-use---release"><a class="header" href="#why-not-use---release">Why not use <code>--release</code>?</a></h3>
<p>You may have heard the advice: just run with <code>--release</code>! However, this is
bad advice. Don't do it.</p>
<p>Release mode also disables "debug assertions": extra checks useful during
development. Many libraries also include additional stuff under that
setting. In Bevy and WGPU that includes validation for shaders and GPU API
usage. Release mode disables these checks, causing less-informative crashes,
issues with hot-reloading, or potentially buggy/invalid logic going unnoticed.</p>
<p>Release mode also makes incremental recompilation slow. That negates
Bevy's fast compile times, and can be very annoying while you develop.</p>
<p>既然调试模式下性能差,为啥不直接使用release版本? 答案是不建议这么做.
因为rust的原因,发布版是减少很多检查为代价的,前置的debug检查都会被忽略,
可能会导致panic/热加载异常/错误逻辑/无效逻辑.
这么看来,release模式并不是覆盖debug模式的,而是debug严格检查模式排雷,
release模式丢弃检查来换取高性能.</p>
<p>再者,release的编译是全量编译,一般的bevy项目也要花很长时间,这个代价也很大.</p>
<hr />
<p>With the advice at the top of this page, you don't need to build with
<code>--release</code>, just to test your game with adequate performance. You can use
it for <em>actual</em> release builds that you send to your users.</p>
<p>If you want, you can also enable LTO (Link-Time-Optimization) for the actual
release builds, to squeeze out even more performance at the cost of very
slow compile times.</p>
<p>Here is a configuration for the most aggressive optimizations possible:</p>
<pre><code class="language-toml">[profile.release]
lto = true
opt-level = 3
codegen-units = 1
incremental = false
debug = false
</code></pre>
<p>当然,release版本下还可以使用LTO(链接时间优化)来加快release的构建.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="obscure-rust-compiler-errors"><a class="header" href="#obscure-rust-compiler-errors">Obscure Rust compiler errors</a></h1>
<p>You can get scary-looking compiler errors when you try to add <a href="pitfalls//programming/systems.html">systems</a>
to your Bevy <a href="pitfalls//programming/app-builder.html">app</a>.</p>
<p>向app添加system可能遇到以下错误.</p>
<h2 id="common-beginner-mistakes"><a class="header" href="#common-beginner-mistakes">Common beginner mistakes</a></h2>
<ul>
<li>Using <code>commands: &amp;mut Commands</code> instead of <code>mut commands: Commands</code>.</li>
<li>Using <code>Query&lt;MyStuff&gt;</code> instead of <code>Query&lt;&amp;MyStuff&gt;</code> or <code>Query&lt;&amp;mut MyStuff&gt;</code>.</li>
<li>Using <code>Query&lt;&amp;ComponentA, &amp;ComponentB&gt;</code> instead of <code>Query&lt;(&amp;ComponentA, &amp;ComponentB)&gt;</code>
(forgetting the tuple)</li>
<li>Using your <a href="pitfalls//programming/res.html">resource</a> types directly without <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res</code></a> or <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>.</li>
<li>Using your <a href="pitfalls//programming/ec.html#components">component</a> types directly without putting them in a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Query.html"><code>Query</code></a>.</li>
<li>Using a <a href="pitfalls//programming/bundle.html">bundle</a> type in a <a href="pitfalls//programming/queries.html">query</a>. You want individual components.</li>
<li>Using other arbitrary types in your function.</li>
</ul>
<p>Note that <code>Query&lt;Entity&gt;</code> is correct, because the Entity ID is special;
it is not a component.</p>
<p>新手常见错误主要在system参数上:</p>
<ul>
<li>错将<code>mut commands: Commands</code> 写成<code>commands: &amp;mut Commands</code>, mut是修饰变量的,而不是修饰类型的</li>
<li>错写为<code>Query&lt;MyStuff&gt;</code>, 应该用引用或可变引用,不然查一次就变更了所有权,下一次查就会出错</li>
<li>错写为<code>Query&lt;&amp;A,&amp;B&gt;</code>, 应该写为(&amp;A,&amp;B),作为元组来过滤实体</li>
<li>资源需要使用Res/ResMut来访问</li>
<li>组件需要通过Query封装来访问实体</li>
<li>Query中不能使用Bundle,Bundle只能在实体构造的逻辑中使用</li>
<li>在system函数中使用其他任意类型(system是游戏逻辑,所有的数据均自函数入参)</li>
</ul>
<h2 id="error-adding-function-as-system"><a class="header" href="#error-adding-function-as-system">Error adding function as system</a></h2>
<p>The errors can look like this:</p>
<pre><code>error[E0277]: `for&lt;'a, 'b, 'c&gt; fn(…) {my_system}` does not describe a valid system configuration
   --&gt; src/main.rs:11:30
    |
11  |         .add_systems(Update, my_system)
    |          -----------         ^^^^^^^^^ invalid system configuration
    |          |
    |          required by a bound introduced by this call
    |
    = help: the trait `IntoSystem&lt;(), (), _&gt;` is not implemented for fn item `for&lt;'a, 'b, 'c&gt; fn(…) {my_system}`, which is required by `for&lt;'a, 'b, 'c&gt; fn(…) {my_system}: IntoSystemConfigs&lt;_&gt;`
    = help: the following other types implement trait `IntoSystemConfigs&lt;Marker&gt;`:
              &lt;(S0, S1) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1)&gt;&gt;
              &lt;(S0, S1, S2) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2)&gt;&gt;
              &lt;(S0, S1, S2, S3) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5, S6) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5, P6)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5, S6, S7) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5, P6, P7)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5, S6, S7, S8) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;&gt;
            and 14 others
    = note: required for `for&lt;'a, 'b, 'c&gt; fn(…) {my_system}` to implement `IntoSystemConfigs&lt;_&gt;`
note: required by a bound in `bevy::prelude::App::add_systems`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_app-0.14.0-rc.2/src/app.rs:287:23
    |
284 |     pub fn add_systems&lt;M&gt;(
    |            ----------- required by a bound in this associated function
...
287 |         systems: impl IntoSystemConfigs&lt;M&gt;,
    |                       ^^^^^^^^^^^^^^^^^^^^ required by this bound in `App::add_systems`
</code></pre>
<p>The error (confusingly) points to the place in your code where you try to add the system,
but in reality, the problem is actually in the <code>fn</code> function definition!</p>
<p>This is caused by your function having invalid parameters. <a href="pitfalls//builtins.html#systemparams">Bevy can
only accept special types as system parameters!</a></p>
<p>上面的错误意思是system函数有无效参数.</p>
<h2 id="error-on-malformed-queries"><a class="header" href="#error-on-malformed-queries">Error on malformed queries</a></h2>
<p>You might also errors that look like this:</p>
<pre><code>error[E0277]: `bevy::prelude::AnimationPlayer` is not valid to request as data in a `Query`
   --&gt; src/main.rs:60:18
    |
60  |     mut players: Query&lt;AnimationPlayer, &amp;Transform&gt;,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid `Query` data
    |
    = help: the trait `QueryData` is not implemented for `bevy::prelude::AnimationPlayer`
    = help: the following other types implement trait `QueryData`:
              &amp;'__w mut T
              &amp;Archetype
              &amp;T
              ()
              (F0, F1)
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
            and 41 others
note: required by a bound in `bevy::prelude::Query`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.14.0-rc.2/src/system/query.rs:349:37
    |
349 | pub struct Query&lt;'world, 'state, D: QueryData, F: QueryFilter = ()&gt; {
    |                                     ^^^^^^^^^ required by this bound in `Query`

error[E0277]: `&amp;bevy::prelude::Transform` is not a valid `Query` filter
   --&gt; src/main.rs:60:18
    |
60  |     mut query: Query&lt;AnimationPlayer, &amp;Transform&gt;,
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid `Query` filter
    |
    = help: the trait `QueryFilter` is not implemented for `&amp;bevy::prelude::Transform`
    = note: a `QueryFilter` typically uses a combination of `With&lt;T&gt;` and `Without&lt;T&gt;` statements
    = help: the following other types implement trait `QueryFilter`:
              ()
              (F0, F1)
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
              (F0, F1, F2, F3, F4, F5)
              (F0, F1, F2, F3, F4, F5, F6)
              (F0, F1, F2, F3, F4, F5, F6, F7)
            and 28 others
note: required by a bound in `bevy::prelude::Query`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.14.0-rc.2/src/system/query.rs:349:51
    |
349 | pub struct Query&lt;'world, 'state, D: QueryData, F: QueryFilter = ()&gt; {
    |                                                   ^^^^^^^^^^^ required by this bound in `Query`

error[E0107]: struct takes at most 2 generic arguments but 3 generic arguments were supplied
   --&gt; src/main.rs:60:18
    |
60  |     mut query: Query&lt;AnimationPlayer, &amp;Transform, &amp;mut GlobalTransform&gt;,
    |                ^^^^^                              -------------------- help: remove this generic argument
    |                |
    |                expected at most 2 generic arguments
    |
note: struct defined here, with at most 2 generic parameters: `D`, `F`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.14.0-rc.2/src/system/query.rs:349:12
    |
349 | pub struct Query&lt;'world, 'state, D: QueryData, F: QueryFilter = ()&gt; {
    |            ^^^^^                 -             -------------------
</code></pre>
<p>To access your components, you need to use reference syntax (<code>&amp;</code> or <code>&amp;mut</code>).</p>
<p>When you want to query for multiple components, you need to put them in a tuple:
<code>Query&lt;(&amp;mut Transform, &amp;Camera, &amp;MyComponent)&gt;</code>.</p>
<p>这个就是Query里的参数不是引用类型.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="3d-objects-not-displaying"><a class="header" href="#3d-objects-not-displaying">3D objects not displaying</a></h1>
<p>This page will list some common issues that you may encounter, if you are
trying to spawn a 3D object, but cannot see it on the screen.</p>
<p>3d对象没有在屏幕上渲染出来,可能是以下错误.</p>
<h2 id="missing-visibility-components-on-parent"><a class="header" href="#missing-visibility-components-on-parent">Missing visibility components on parent</a></h2>
<p>If your entity is in a hierarchy, all its parents need to have
<a href="pitfalls//fundamentals/visibility.html">visibility</a> components. It is required even if those parent
entities are not supposed to render anything.</p>
<p>Fix it by inserting a <a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.entity(parent)
    .insert(VisibilityBundle::default());
<span class="boring">}</span></code></pre></pre>
<p>Or better, make sure to spawn the parent entities correctly in the first place.
You can use a <a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a> or
<a href="https://docs.rs/bevy/0.11.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> (with <a href="pitfalls//fundamentals/transforms.html">transforms</a>) if you
are not using a bundle that already includes these components.</p>
<p>如果实体是继承的,需要检查父辈的<code>可见性</code>,即使父辈实体不需要任何渲染,也需要<code>可见性</code>组件.
解决方法是1:给父辈实体添加<code>可见性</code>组件;2:尽量在父辈实体构造时设置可见性.</p>
<p>可见性的组件有两种内置的:SpatialBundle(空间Bundle)和VisibilityBundle(可见性Bundle).</p>
<h2 id="too-far-from-camera"><a class="header" href="#too-far-from-camera">Too far from camera</a></h2>
<p>If something is further away than a certain distance from the camera, it will be
culled (not rendered). The default value is <code>1000.0</code> units.</p>
<p>You can control this using the <code>far</code> field of
<a href="https://docs.rs/bevy/0.11.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.spawn(Camera3dBundle {
    projection: Projection::Perspective(PerspectiveProjection {
        far: 10000.0, // change the maximum render distance
        ..default()
    }),
    ..default()
});
<span class="boring">}</span></code></pre></pre>
<p>如果物体离相机有1000个单位,在渲染时会被过滤掉的,所以要渲染就不要里相机太远.
当然也可以将1000单位改为更大的数值.</p>
<h2 id="missing-vertex-attributes"><a class="header" href="#missing-vertex-attributes">Missing Vertex Attributes</a></h2>
<p>Make sure your <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> includes all vertex attributes required
by your shader/material.</p>
<p>Bevy's default PBR <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
requires <em>all</em> meshes to have:</p>
<ul>
<li>Positions</li>
<li>Normals</li>
</ul>
<p>Some others that may be required:</p>
<ul>
<li>UVs (if using textures in the material)</li>
<li>Tangents (only if using normal maps, otherwise not required)</li>
</ul>
<p>If you are generating your own mesh data, make sure to provide everything
you need.</p>
<p>If you are loading meshes from asset files, make sure they include everything
that is needed (check your export settings).</p>
<p>If you need Tangents for normal maps, it is recommended that you include them
in your GLTF files. This avoids Bevy having to autogenerate them at runtime.
Many 3D editors (like Blender) do not enable this option by default.</p>
<p>确保着色器/材质包含的Mesh拥有所需要的顶点信息.</p>
<p>bevy的默认pbr(基于物理的渲染)是标准材质StandardMaterial,包含位置和法线.
其他材质可能需要UV(材质使用纹理时才需要)和切线(法线贴图时才需要).</p>
<p>如果自己生成mesh时,确保提供所需信息.如果从资产文件中导入mesh时,
确保其提供了所需信息.</p>
<p>尽量避免让bevy在运行时自动生成这些信息,不然性能就拉低了.
很多3d模型编辑器(eg:blender)是默认不启用这些选项的.</p>
<h2 id="incorrect-usage-of-bevy-gltf-assets"><a class="header" href="#incorrect-usage-of-bevy-gltf-assets">Incorrect usage of Bevy GLTF assets</a></h2>
<p>Refer to the <a href="pitfalls//3d/gltf.html">GLTF page</a> to learn how to correctly
use GLTF with Bevy.</p>
<p>GLTF files are complex. They contain many sub-assets, represented by
different Bevy types. Make sure you are using the correct thing.</p>
<p>Make sure you are spawning a GLTF Scene, or using the correct
<a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
associated with the correct GLTF Primitive.</p>
<p>If you are using an asset path, be sure to include a label for the sub-asset you want:</p>
<pre><code class="language-rust no_run noplayground">let handle_scene: Handle&lt;Scene&gt; = asset_server.load("my.gltf#Scene0");</code></pre>
<p>If you are spawning the top-level <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="pitfalls//3d/gltf.html#gltf-master-asset">master asset</a>, it won't work.</p>
<p>If you are spawning a GLTF Mesh, it won't work.</p>
<p>gltf 3d模型文件非常复杂,包含各种bevy需要的资产,gltf场景需要使用正确的原语来生成.
资产生成好了,在bevy中引用时,路径需要注意.</p>
<p>不能生成顶级gltf主资产,不能生成gltf mesh,这些都不能正常工作.</p>
<h2 id="unsupported-gltf"><a class="header" href="#unsupported-gltf">Unsupported GLTF</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this yet. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<p>bevy只支持gltf的部分功能,并不是所有的gltf文件都能加载进bevy.
在部分场景下,还得不到任何错误的诊断信息:</p>
<ul>
<li>gltf文件中,纹理经过了base64编码,这种文件无法加载</li>
<li>mip贴图之在ktx2/dds纹理文件中支持</li>
</ul>
<p>这个列表并不全,还有些错误未包含进来.</p>
<h2 id="vertex-order-and-culling"><a class="header" href="#vertex-order-and-culling">Vertex Order and Culling</a></h2>
<p>By default, the Bevy renderer assumes Counter-Clockwise vertex order and has
back-face culling enabled.</p>
<p>If you are generating your <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> from code, make sure your
vertices are in the correct order.</p>
<p>默认情况下,bevy渲染假设逆时针顶点顺序,背面剔除.
如果是在代码中生成mesh,需要确保顶点的顺序是正确的.</p>
<h2 id="unoptimized--debug-builds"><a class="header" href="#unoptimized--debug-builds">Unoptimized / Debug builds</a></h2>
<p>Maybe your asset just takes a while to load? Bevy is very slow without
compiler optimizations. It's actually possible that complex GLTF files with
big textures can take over a minute to load and show up on the screen. It
would be almost instant in optimized builds. <a href="pitfalls//pitfalls/performance.html">See here</a>.</p>
<p>未优化的代码,可能需要几分钟来加载资源.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="borrow-multiple-fields-from-struct"><a class="header" href="#borrow-multiple-fields-from-struct">Borrow multiple fields from struct</a></h1>
<p>When you have a <a href="pitfalls//programming/ec.html#components">component</a> or <a href="pitfalls//programming/res.html">resource</a>, that is
larger struct with multiple fields, sometimes you want to borrow several of
the fields at the same time, possibly mutably.</p>
<pre><code class="language-rust no_run noplayground">struct MyThing {
    a: Foo,
    b: Bar,
}

fn my_system(mut q: Query&lt;&amp;mut MyThing&gt;) {
    for thing in q.iter_mut() {
        // 只有在这里重新借用,才不会引用规则冲突(同时出现共享引用和独占可变引用).
        helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    }
}

// 如果这两个参数引用同一个结构体的多各字段,那么会出现冲突
fn helper_func(foo: &amp;Foo, bar: &amp;mut Bar) {
    // do something
}</code></pre>
<p>This can result in a compiler error about conflicting borrows:</p>
<pre><code>error[E0502]: cannot borrow `thing` as mutable because it is also borrowed as immutable
    |
    |         helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    |         -----------  -----         ^^^^^ mutable borrow occurs here
    |         |            |
    |         |            immutable borrow occurs here
    |         immutable borrow later used by call
</code></pre>
<p>The solution is to use the "reborrow" idiom, a common but non-obvious trick in Rust programming:</p>
<pre><code class="language-rust no_run noplayground">// add this at the start of the for loop, before using `thing`:
let thing = &amp;mut *thing;

// or, alternatively, Bevy provides a method, which does the same:
let thing = thing.into_inner();</code></pre>
<p>Note that this line triggers <a href="pitfalls//programming/change-detection.html">change detection</a>. Even if
you don't modify the data afterwards, the component gets marked as changed.</p>
<p>通过重新引用来绕开<code>变更检测</code>,
重新引用本身就是为了在不同的作用域内使用同一个对象，而无需放弃当前的借用。</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>Bevy typically gives you access to your data via special wrapper types (like
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, and <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.Mut.html"><code>Mut&lt;T&gt;</code></a> (when <a href="pitfalls//programming/queries.html">querying</a> for
components mutably)). This lets Bevy track access to the data.</p>
<p>These are "smart pointer" types that use the Rust <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>Deref</code></a> trait to dereference
to your data. They usually work seamlessly and you don't even notice them.</p>
<p>However, in a sense, they are opaque to the compiler. The Rust language allows
fields of a struct to be borrowed individually, when you have direct access to
the struct, but this does not work when it is wrapped in another type.</p>
<p>The "reborrow" trick shown above, effectively converts the wrapper into a
regular Rust reference. <code>*thing</code> dereferences the wrapper via <a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>, and
then <code>&amp;mut</code> borrows it mutably. You now have <code>&amp;mut MyStuff</code> instead of
<code>Mut&lt;MyStuff&gt;</code>.</p>
<p>bevy是通过不同的封装类型来访问不同的数据的.
这些封装类型有点向智能指针,会自动解引用.</p>
<p>上面的重新引用就是将封装类型转换成rust引用类型.
rust的是允许结构体的字段被单独引用的.bevy的封装类型使用时就需要注意了.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-time-vs-rustos-time"><a class="header" href="#bevy-time-vs-rustos-time">Bevy Time vs. Rust/OS time</a></h1>
<p>Do <em>not</em> use <a href="https://doc.rust-lang.org/stable/std/time/struct.Instant.html"><code>std::time::Instant::now()</code></a> to get the
current time. <a href="pitfalls//fundamentals/time.html">Get your timing information from Bevy</a>, using
<a href="https://docs.rs/bevy/0.13.0/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a>.</p>
<p>Rust (and the OS) give you the precise time of the moment you call that
function. However, that's not what you want.</p>
<p>Your game systems are run by Bevy's parallel scheduler, which means that they
could be called at vastly different instants every frame! This will result in
inconsistent / jittery timings and make your game misbehave or look stuttery.</p>
<p>Bevy's <a href="https://docs.rs/bevy/0.13.0/bevy/time/struct.Time.html"><code>Time</code></a> gives you timing information that is consistent throughout the
frame update cycle. It is intended to be used for game logic.</p>
<p>This is not Bevy-specific, but applies to game development in general. Always
get your time from your game engine, not from your programming language or
operating system.</p>
<p>抖动时间,不要使用标准库来获取当前时间,而是要用<code>Res&lt;Time&gt;</code>来获取.</p>
<p>在游戏中需要使用游戏中的时间,因为游戏可以暂停,可以快放,可以慢放.
使用rust或OS的时间都会出现异常.</p>
<p>bevy负责在不同的时间调度system,如果使用非bevy时间,会导致游戏异常或卡顿.
bevy内置的时间就是用来解决Update一致性问题的.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="uv-coordinates-in-bevy"><a class="header" href="#uv-coordinates-in-bevy">UV coordinates in Bevy</a></h1>
<p>In Bevy, the vertical axis for the pixels of textures / images, and when
sampling textures in a shader, points <em>downwards</em>, from top to bottom. The
origin is at the top left.</p>
<p>This is inconsistent with the <a href="pitfalls//fundamentals/coords.html">World-coordinate system used everywhere else
in Bevy</a>, where the Y axis points up.</p>
<p>It is, however, consistent with how most image file formats store pixel data,
and with how most graphics APIs work (including DirectX, Vulkan, Metal,
WebGPU, but <em>not</em> OpenGL).</p>
<p>OpenGL (and frameworks based on it) is different. If your prior experience
is with that, you may find that your textures appear flipped vertically.</p>
<hr />
<p>If you are using a mesh, make sure it has the correct UV values. If it was
created with other software, be sure to select the correct settings.</p>
<p>If you are writing a custom shader, make sure your UV arithmetic is correct.</p>
<p>3d中的UV是将2d纹理映射到3d模型表面的一种方式,UV坐标用于定位纹理坐标,
和3d空间的xyz对应.</p>
<p>在 Bevy 中，纹理/图像像素的垂直轴以及在着色器中采样纹理时，从上到下向下指向。
原点位于左上角。</p>
<p>大部分图片格式都是符合这种设计的, 包括DirectX, Vulkan, Metal, WebGPU,
但不包括OpenGL. OpenGL中看起来是垂直翻转的.</p>
<h2 id="sprites"><a class="header" href="#sprites">Sprites</a></h2>
<p>If the images of your 2D sprites are flipped (for whatever reason), you can
correct that using Bevy's sprite-flipping feature:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn(SpriteBundle {
    sprite: Sprite {
        flip_y: true,
        flip_x: false,
        ..Default::default()
    },
    ..Default::default()
});</code></pre>
<p>如果2d中的精灵图像看起来翻转了,可通过上面的例子处理一下.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="game-engine-fundamentals"><a class="header" href="#game-engine-fundamentals">Game Engine Fundamentals</a></h1>
<p>This chapter covers the fundamentals of using Bevy as a game engine.</p>
<p>You are expected to be familiar with Bevy programming in general. For that,
see the <a href="/programming.html">Bevy Programming Framework</a> chapter.</p>
<p>The topics covered in this chapter are applicable to all projects that want
to use Bevy as more than just an ECS library. If you are making a game or
other app using Bevy, this is for you.</p>
<p>This chapter only covers the general fundamentals. Complex topics that
deserve more extensive coverage have their own chapters in the book:</p>
<ul>
<li><a href="/input.html">Input Handling</a></li>
<li><a href="/window.html">Window Management</a></li>
<li><a href="/assets.html">Asset Management</a></li>
<li><a href="/graphics.html">General Graphics Features</a></li>
<li><a href="/2d.html">2D Graphics</a></li>
<li><a href="/3d.html">3D Graphics</a></li>
<li><a href="/audio.html">Audio</a></li>
<li><a href="/ui.html">Bevy UI Framework</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h1>
<h2 id="2d-and-3d-scenes-and-cameras"><a class="header" href="#2d-and-3d-scenes-and-cameras">2D and 3D scenes and cameras</a></h2>
<p>Bevy uses a right-handed Y-up coordinate system for the game world. The
coordinate system is the same for 3D and 2D, for consistency.</p>
<p>It is easiest to explain in terms of 2D:</p>
<ul>
<li>The X axis goes from left to right (+X points right).</li>
<li>The Y axis goes from bottom to top (+Y points up).</li>
<li>The Z axis goes from far to near (+Z points towards you, out of the screen).</li>
<li>For 2D, the origin (X=0.0; Y=0.0) is at the <em>center of the screen</em> by default.</li>
</ul>
<p>When you are working with 2D sprites, you can put the background on Z=0.0, and
place other sprites at increasing positive Z coordinates to layer them on top.</p>
<p>In 3D, the axes are oriented the same way:</p>
<ul>
<li>Y points up</li>
<li>The forward direction is -Z</li>
</ul>
<p>This is a right-handed coordinate system. You can use the fingers of your right
hand to visualize the 3 axes: thumb=X, index=Y, middle=Z.</p>
<p>It is the same as Godot, Maya, and OpenGL. Compared to Unity, the Z axis
is inverted.</p>
<p><img src="fundamentals/../img/handedness.png" alt="Chart comparing coordinate system orientation in different game engines and 3D software" /></p>
<p>(graphic modifed and used with permission; original by <a href="https://twitter.com/FreyaHolmer">@FreyaHolmer</a>)</p>
<p>bevy中的坐标系统和中学数学的坐标系是一致的,
对于2d来说,原点位于屏幕中心,背景图的z为他,其他精灵的z依次增加,意味着前后的差别.
对于3d来说,xyz分别表示3各轴向,前进方向为-z.</p>
<h2 id="ui"><a class="header" href="#ui">UI</a></h2>
<p>For UI, Bevy follows the same convention as most other UI toolkits, the Web, etc.</p>
<ul>
<li>The origin is at the top left corner of the screen</li>
<li>The Y axis points downwards</li>
<li>X goes from 0.0 (left screen edge) to the number of screen pixels (right screen edge)</li>
<li>Y goes from 0.0 (top screen edge) to the number of screen pixels (bottom screen edge)</li>
</ul>
<p>The units represent logical (compensated for DPI scaling) screen pixels.</p>
<p>UI layout flows from top to bottom, similar to a web page.</p>
<p>对于UI,bevy遵循的规则和大多数UI工具/web遵循的规则一致.</p>
<ul>
<li>原点位于屏幕左上角</li>
<li>y轴指向下方</li>
<li>x轴是沿着屏幕边缘从左到右,最大数值为屏幕像素值</li>
</ul>
<p>单位是逻辑像素值, UI布局是从上到下,类似web页面.</p>
<h2 id="cursor-and-screen"><a class="header" href="#cursor-and-screen">Cursor and Screen</a></h2>
<p>The cursor position and any other window (screen-space) coordinates follow the same
conventions as UI, as described above.</p>
<p>光标和屏幕的坐标和UI的坐标体系保持一致.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/transform.rs"><code>transform</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/translation.rs"><code>translation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/2d/rotation.rs"><code>rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/3d_rotation.rs"><code>3d_rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/scale.rs"><code>scale</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/2d/move_sprite.rs"><code>move_sprite</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/3d/parenting.rs"><code>parenting</code></a>,
anything that spawns 2D or 3D objects.</p>
<hr />
<p>First, a quick definition, if you are new to game development:</p>
<p>A Transform is what allows you to place an object in the game world. It
is a combination of the object's "translation" (position/coordinates),
"rotation", and "scale" (size adjustment).</p>
<p>You move objects around by modifying the translation, rotate them by modifying
the rotation, and make them larger or smaller by modifying the scale.</p>
<pre><code class="language-rust no_run noplayground">// To simply position something at specific coordinates
let xf_pos567 = Transform::from_xyz(5.0, 6.0, 7.0);

// To scale an object, making it twice as big in all dimensions
let xf_scale = Transform::from_scale(Vec3::splat(2.0));

// To rotate an object in 2D (Z-axis rotation) by 30°
// (angles are in radians! must convert from degrees!)
let xf_rot2d = Transform::from_rotation(Quat::from_rotation_z((30.0_f32).to_radians()));

// 3D rotations can be complicated; explore the methods available on `Quat`

// Simple 3D rotation by Euler-angles (X, Y, Z)
let xf_rot2d = Transform::from_rotation(Quat::from_euler(
    // YXZ order corresponds to the common
    // "yaw"/"pitch"/"roll" convention
    EulerRot::YXZ,
    (20.0_f32).to_radians(),
    (10.0_f32).to_radians(),
    (30.0_f32).to_radians(),
));

// Everything:
let xf = Transform::from_xyz(1.0, 2.0, 3.0)
    .with_scale(Vec3::new(0.5, 0.5, 1.0))
    .with_rotation(Quat::from_rotation_y(0.125 * std::f32::consts::PI));</code></pre>
<p>变换的定义是:在游戏世界中,将一个对象如何放置.
她由对象的位置/坐标/旋转/缩放的一个组合.</p>
<p>在英文中,transform是变换,意义更广,涵盖了对物体位置、旋转和缩放等属性的综合操作。
translation也是变换,但更多的是表示平移(仅仅是位置移动),不涉及旋转和缩放.</p>
<h2 id="transform-components"><a class="header" href="#transform-components">Transform Components</a></h2>
<p>In Bevy, transforms are represented by <strong>two</strong> <a href="fundamentals//programming/ec.html#components">components</a>:
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>.</p>
<p>Any <a href="fundamentals//programming/ecs-intro.html">Entity</a> that represents an object in the game world
needs to have both. All of Bevy's <a href="fundamentals//builtins.html#bundles">built-in bundle types</a>
include them.</p>
<p>If you are creating a custom entity without using those <a href="fundamentals//programming/bundle.html">bundles</a>,
you can use one of the following to ensure you don't miss them:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> for transforms + <a href="fundamentals//fundamentals/visibility.html">visibility</a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a> for just the transforms</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn spawn_special_entity(
    mut commands: Commands,
) {
    // create an entity that does not use one of the common Bevy bundles,
    // but still needs transforms and visibility
    commands.spawn((
        ComponentA,
        ComponentB,
        SpatialBundle {
            transform: Transform::from_scale(Vec3::splat(3.0)),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}</code></pre>
<p>在bevy中,变换有两个基础组件<code>Transform</code>和<code>GlobalTransform</code>,
两者组合还有空间Bunlde,变换Bundle.</p>
<p>world中的任何实体都需要这两个基础组件,实体构造时不能缺.</p>
<h3 id="transform"><a class="header" href="#transform"><code>Transform</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> is what you typically work with. It is a <code>struct</code> containing the
translation, rotation, and scale. To read or manipulate these values, access it
from your <a href="fundamentals//programming/systems.html">systems</a> using a <a href="fundamentals//programming/queries.html">query</a>.</p>
<p>If the entity has a <a href="fundamentals//fundamentals/hierarchy.html">parent</a>, the <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> component is
relative to the parent. This means that the child object will move/rotate/scale
along with the parent.</p>
<pre><code class="language-rust no_run noplayground">fn inflate_balloons(
    mut query: Query&lt;&amp;mut Transform, With&lt;Balloon&gt;&gt;,
    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    // every time the Spacebar is pressed,
    // make all the balloons in the game bigger by 25%
    if keyboard.just_pressed(KeyCode::Space) {
        for mut transform in &amp;mut query {
            transform.scale *= 1.25;
        }
    }
}

fn throwable_fly(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;&amp;mut Transform, With&lt;ThrowableProjectile&gt;&gt;,
) {
    // every frame, make our projectiles fly across the screen and spin
    for mut transform in &amp;mut query {
        // do not forget to multiply by the time delta!
        // this is required to move at the same speed regardless of frame rate!
        transform.translation.x += 100.0 * time.delta_seconds();
        transform.rotate_z(2.0 * time.delta_seconds());
    }
}</code></pre>
<p>通常使用Transform就够了,这个结构体里包含了移动/旋转/缩放.
如果实体有继承关系,则Transform是基于父实体的.</p>
<h3 id="globaltransform"><a class="header" href="#globaltransform"><code>GlobalTransform</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> represents the absolute global position in the world.</p>
<p>If the entity does not have a <a href="fundamentals//fundamentals/hierarchy.html">parent</a>, then this will match the
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>.</p>
<p>The value of <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> is calculated/managed internally by Bevy
(<a href="fundamentals/transforms.html#transform-propagation">"transform propagation"</a>).</p>
<p>Unlike <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, the translation/rotation/scale are not accessible
directly. The data is stored in an optimized way (using <a href="https://docs.rs/bevy/0.13.0/bevy/math/struct.Affine3A.html"><code>Affine3A</code></a>) and it is
possible to have complex transformations in a hierarchy that cannot be
represented as a simple transform. For example, a combination of rotation and
scale across multiple parents, resulting in shearing.</p>
<p>If you want to try to convert a <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> back into a workable
translation/rotation/scale representation, you can try the methods:</p>
<ul>
<li><code>.translation()</code></li>
<li><code>.to_scale_rotation_translation()</code> (may be invalid)</li>
<li><code>.compute_transform()</code> (may be invalid)</li>
</ul>
<p>GlobalTransform 是针对world世界的绝对位置. 值的计算和管理直接由bevy内部管理,
这也是正常的,毕竟bevy是跨多个平台,自身就是要维护不同平台的不一致,
基于world的正好交给bevy管理.而Transform则是为了简化开发而独立出来的.</p>
<p>GlobalTransform的移动/旋转/缩放不是简单的改值,处理起来也很麻烦,
多个顶级父对象之前还存在遮挡,计算也颇为麻烦,优化也是采用<code>Affine3A</code>技术.</p>
<h2 id="transform-propagation"><a class="header" href="#transform-propagation">Transform Propagation</a></h2>
<p>The two components are synchronized by a bevy-internal system (the "transform
propagation system"), which runs in the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> <a href="fundamentals//programming/schedules.html">schedule</a>.</p>
<p>Beware: When you mutate the <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, the <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> is not
updated immediately. They will be out-of-sync until the transform propagation
system runs.</p>
<p>If you need to work with <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> directly, you should <a href="fundamentals//programming/app-builder.html">add</a>
your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> <a href="fundamentals//programming/schedules.html">schedule</a> and
<a href="fundamentals//programming/system-order.html">order it after</a> <a href="https://docs.rs/bevy/0.13.0/bevy/transform/enum.TransformSystem.html"><code>TransformSystem::TransformPropagate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Print the up-to-date global coordinates of the player
fn debug_globaltransform(
    query: Query&lt;&amp;GlobalTransform, With&lt;Player&gt;&gt;,
) {
    let gxf = query.single();
    debug!("Player at: {:?}", gxf.translation());
}</code></pre>
<pre><code class="language-rust no_run noplayground">// the label to use for ordering
use bevy::transform::TransformSystem;

app.add_systems(PostUpdate,
    debug_globaltransform
        // we want to read the GlobalTransform after
        // it has been updated by Bevy for this frame
        .after(TransformSystem::TransformPropagate)
);</code></pre>
<p>变换传播,这两个基础组件在bevy内部system中调用,时机是PostUpdate调度中.
通过Transform修改值后,GlobalTransform并不会立马更新,而是等变换传播执行完才进行同步.</p>
<p>如果要直接操作GlobalTransform,需要在PostUpdate调度中添加system,
并将system的顺序放在变换传播(TransformSystem::TransformPropagate)后面.</p>
<h2 id="transformhelper"><a class="header" href="#transformhelper"><code>TransformHelper</code></a></h2>
<p>If you need to get an up-to-date <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> in a <a href="fundamentals//programming/systems.html">system</a>
that has to run before transform propagation, you can use the special
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a> system parameter.</p>
<p>It allows you to compute a specific entity's <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> immediately, on
demand.</p>
<p>An example of where this could be useful might be a system to make a camera
follow an entity on-screen. You need to update the camera's <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> (which
means you have to do it before Bevy's transform propagation, so it can account
for the camera's new transform), but you also need to know the current
up-to-date position of the entity you are following.</p>
<pre><code class="language-rust no_run noplayground">fn camera_look_follow(
    q_target: Query&lt;Entity, With&lt;MySpecialMarker&gt;&gt;,
    mut transform_params: ParamSet&lt;(
        TransformHelper,
        Query&lt;&amp;mut Transform, With&lt;MyGameCamera&gt;&gt;,
    )&gt;,
) {
    // get the Entity ID we want to target
    let e_target = q_target.single();
    // compute its actual current GlobalTransform
    // (could be Err if entity doesn't have transforms)
    let Ok(global) = transform_params.p0().compute_global_transform(e_target) else {
        return;
    };
    // get camera transform and make it look at the global translation
    transform_params.p1().single_mut().look_at(global.translation(), Vec3::Y);
}</code></pre>
<p>Internally, <a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a> behaves like two read-only <a href="fundamentals//programming/queries.html">queries</a>.
It needs access to the <a href="https://docs.rs/bevy/0.13.0/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> components to do its job. It
would conflict with our other <code>&amp;mut Transform</code> query. That's why we have to use
a <a href="fundamentals//programming/paramset.html">param set</a> in the example above.</p>
<p>Note: if you over-use <a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a>, it could become a performance issue.
It calculates the global transform for you, but it does not update the data
stored in the entity's <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>. Bevy will still do the same
computation again later, during transform propagation. It leads to repetitive
work. If your system can run after transform propagation, so it can just read
the value after Bevy updates it, you should prefer to do that instead of using
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a>.</p>
<p>如果要在变换传播之前获取最新的GlobalTransform值,需要借助TransformHelper system参数.</p>
<p>一个常用的场景是:相机要跟随屏幕上的实体,就需要更新相机的Transform,
而且这个操作要在变换传播之前处理完.</p>
<p>代码如上图所示,使用了system参数: ParamSet/TransformHelper.</p>
<p>TransformHelper的行为类似两个只读query,分别访问Parent和Transform组件.
因为已经有了一个camera的Transform,直接使用两个query会导致冲突,
所以使用ParamSet来避免冲突.</p>
<p>TransformHelper过度使用会有性能问题,因为只计算,不更新GlobalTransform的数据,
在变换传播时,bevy也是要进行同样的计算.这样就存在重复计算.
如果是在传播变换之后获取GlobalTransform,直接读就行,不需要TransformHelper,
这样性能会更高.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Visibility is used to control if something is to be rendered or not. If you
want an entity to exist in the world, just not be displayed, you can hide it.</p>
<pre><code class="language-rust no_run noplayground">/// Prepare the game map, but do not display it until later
fn setup_map_hidden(
    mut commands: Commands,
) {
    commands.spawn((
        GameMapEntity,
        SceneBundle {
            scene: todo!(),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}

/// When everything is ready, un-hide the game map
fn reveal_map(
    mut query: Query&lt;&amp;mut Visibility, With&lt;GameMapEntity&gt;&gt;,
) {
    let mut vis_map = query.single_mut();
    *vis_map = Visibility::Visible;
}</code></pre>
<p>可视化控制一个对象是否进行渲染,不进行可视化,等同于隐藏.</p>
<h2 id="visibility-components"><a class="header" href="#visibility-components">Visibility Components</a></h2>
<p>In Bevy, visibility is represented by <strong>multiple</strong> <a href="fundamentals//programming/ec.html#components">components</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/enum.Visibility.html"><code>Visibility</code></a>: the user-facing toggle (here is where you set what you want)</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a>: used by Bevy to keep track of the state from any <a href="fundamentals//fundamentals/hierarchy.html">parent entities</a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a>: used by Bevy to track if the entity should actually be displayed</li>
</ul>
<p>Any <a href="fundamentals//programming/ecs-intro.html">Entity</a> that represents a renderable object in
the game world needs to have them all. All of Bevy's <a href="fundamentals//builtins.html#bundles">built-in bundle
types</a> include them.</p>
<p>If you are creating a custom entity without using those <a href="fundamentals//programming/bundle.html">bundles</a>,
you can use one of the following to ensure you don't miss them:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> for <a href="fundamentals//fundamentals/transforms.html">transforms</a> + visibility</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a> for just visibility</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn spawn_special_entity(
    mut commands: Commands,
) {
    // create an entity that does not use one of the common Bevy bundles,
    // but still needs transforms and visibility
    commands.spawn((
        ComponentA,
        ComponentB,
        SpatialBundle {
            transform: Transform::from_scale(Vec3::splat(3.0)),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}</code></pre>
<p>If you don't do this correctly (say, you manually add just the <code>Visibility</code>
component and forget the others, because you don't use a bundle), your entities
will not render!</p>
<p>可视化由多个可视化组件表示:</p>
<ul>
<li><code>Visibility</code> 面对用户的开关</li>
<li><code>InheritedVisibility</code> 由bevy跟踪的实体状态,从继承体系上得到</li>
<li><code>ViewVisibility</code> 由bevy跟踪,看实体实际上是否应该显示</li>
</ul>
<h3 id="visibility-1"><a class="header" href="#visibility-1"><code>Visibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/enum.Visibility.html"><code>Visibility</code></a> is the "user-facing toggle". This is where you specify what you
want for the current entity:</p>
<ul>
<li><code>Inherited</code> (default): show/hide depending on <a href="fundamentals//fundamentals/hierarchy.html">parent</a></li>
<li><code>Visible</code>: always show the entity, regardless of parent</li>
<li><code>Hidden</code>: always hide the entity, regardless of parent</li>
</ul>
<p>If the current entity has any <a href="fundamentals//fundamentals/hierarchy.html">children</a> that have <code>Inherited</code>,
their visibility will be affected if you set the current entity to <code>Visible</code>
or <code>Hidden</code>.</p>
<p>If an entity has a parent, but the parent entity is missing the
visibility-related components, things will behave as if there was no parent.</p>
<p>对于实体,可设置3个值:</p>
<ul>
<li><code>Inherited</code> 默认, 是否显示跟着父对象走</li>
<li><code>Visible</code> 不受父对象影响,显示</li>
<li><code>Hidden</code> 不受父对象影响,隐藏</li>
</ul>
<p>当前实体有子实体,那么变更设置会影响子实体的显示效果.
如果当前实体有父实体,但父实体没有<code>可视组件</code>,那么当前实体的行为就和没有父实体类似.</p>
<h3 id="inheritedvisibility"><a class="header" href="#inheritedvisibility"><code>InheritedVisibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a> represents the state the current entity would have based
on its <a href="fundamentals//fundamentals/hierarchy.html">parent</a>'s visibility.</p>
<p>The value of <a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a> should be considered read-only. It is
managed internally by Bevy, in a manner similar to <a href="fundamentals//fundamentals/transforms.html#transform-propagation">transform
propagation</a>. A "visibility propagation"
<a href="fundamentals//programming/systems.html">system</a> runs in the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> <a href="fundamentals//programming/schedules.html">schedule</a>.</p>
<p>If you want to read the up-to-date value for the current frame, you should
<a href="fundamentals//programming/app-builder.html">add</a> your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> and <a href="fundamentals//programming/system-order.html">order it after</a>
<a href="https://docs.rs/bevy/0.13.0/bevy/render/view/visibility/enum.VisibilitySystems.html"><code>VisibilitySystems::VisibilityPropagate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Check if a specific UI button is visible
/// (could be hidden if the whole menu is hidden?)
fn debug_player_visibility(
    query: Query&lt;&amp;InheritedVisibility, With&lt;MyAcceptButton&gt;&gt;,
) {
    let vis = query.single();

    debug!("Button visibility: {:?}", vis.get());
}</code></pre>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::VisibilitySystems;

app.add_systems(PostUpdate,
    debug_player_visibility
        .after(VisibilitySystems::VisibilityPropagate)
);</code></pre>
<p>继承可视化,可视状态跟着父实体走.InheritedVisibility的值是只读,由bevy维护.
和变换传播类似,可视传播的system也是在PostUpdate调度中.</p>
<p>如果要获取当前帧的可视状态,需要添加system在PostUpdate调度中,
且放在可视传播(VisibilitySystems::VisibilityPropagate)的后面.</p>
<h3 id="viewvisibility"><a class="header" href="#viewvisibility"><code>ViewVisibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a> represents the actual final decision made by Bevy about
whether this entity needs to be rendered.</p>
<p>The value of <a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a> is read-only. It is managed internally by Bevy.</p>
<p>It is used for "culling": if the entity is not in the range of
any Camera or Light, it does not need to be rendered, so Bevy will hide it
to improve performance.</p>
<p>Every frame, after "visibility propagation", Bevy will check what entities
can be seen by what view (camera or light), and store the outcome in these
components.</p>
<p>If you want to read the up-to-date value for the current frame, you should
<a href="fundamentals//programming/app-builder.html">add</a> your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> and <a href="fundamentals//programming/system-order.html">order it after</a>
<a href="https://docs.rs/bevy/0.13.0/bevy/render/view/visibility/enum.VisibilitySystems.html"><code>VisibilitySystems::CheckVisibility</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Check if balloons are seen by any Camera, Light, etc… (not culled)
fn debug_balloon_visibility(
    query: Query&lt;&amp;ViewVisibility, With&lt;Balloon&gt;&gt;,
) {
    for vis in query.iter() {
        if vis.get() {
            debug!("Balloon will be rendered.");
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::VisibilitySystems;

app.add_systems(PostUpdate,
    debug_balloon_visibility
        .after(VisibilitySystems::CheckVisibility)
);</code></pre>
<p>最终可视化,最终能不能显示就看这个值,只读,由bevy内部维护.</p>
<p>有个剔除规则: 如果当前对象不在Camera的范围内,或不在灯光范围内,
那这个对象就不用渲染.这样可以提高性能,也符合逻辑.</p>
<p>每帧,在可视传播执行完后,bevy会检查Camera/灯光和实体的关系,
然后将结果存储在ViewVisibility组件的值中.</p>
<p>如果想要获取最终可视的值,在PostUpdate中添加system,
在VisibilitySystems::CheckVisibility之后获取值即可.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="time-and-timers"><a class="header" href="#time-and-timers">Time and Timers</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/timers.rs"><code>timers</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/2d/move_sprite.rs"><code>move_sprite</code></a>.</p>
<hr />
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> <a href="fundamentals//programming/res.html">resource</a> is your main global source
of timing information, that you can access from any <a href="fundamentals//programming/systems.html">system</a>
that does anything that needs time. <a href="fundamentals//pitfalls/time.html">You should derive all timings from
it</a>.</p>
<p>Bevy updates these values at the beginning of every frame.</p>
<p>bevy中的时间是资源,可通过任意system访问,bevy会在每帧之前更新这个值.</p>
<h3 id="delta-time"><a class="header" href="#delta-time">Delta Time</a></h3>
<p>The most common use case is "delta time" – how much time passed between
the previous frame update and the current one. This tells you how fast the
game is running, so you can scale things like movement and animations. This
way everything can happen smoothly and run at the same speed, regardless of
the game's frame rate.</p>
<pre><code class="language-rust no_run noplayground">fn asteroids_fly(time: Res&lt;Time&gt;, mut q: Query&lt;&amp;mut Transform, With&lt;Asteroid&gt;&gt;) {
    for mut transform in q.iter_mut() {
        // move our asteroids along the X axis
        // at a speed of 10.0 units per second
        transform.translation.x += 10.0 * time.delta_seconds();
    }
}</code></pre>
<p>时间最常用的场景是:增量时间,上一帧到现在过去了多长时间.
有了这个时间就可以控制物体的移动和动画的播放,这样无论游戏帧率是多少,
所有的显示都是顺滑,并按同样的速度进行的.</p>
<p>上图所示,就是1秒移动的10个单位,这种处理方式大大减少了开发难度.</p>
<h3 id="ongoing-time"><a class="header" href="#ongoing-time">Ongoing Time</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> can also give you the total running time since startup.
Use this if you need a cumulative, increasing, measurement of time.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Instant;

/// Say, for whatever reason, we want to keep track
/// of when exactly some specific entities were spawned.
#[derive(Component)]
struct SpawnedTime(Instant);

fn spawn_my_stuff(mut commands: Commands, time: Res&lt;Time&gt;) {
    commands
        .spawn((/* ... */))
        // we can use startup time and elapsed duration
        .insert(SpawnedTime(time.startup() + time.elapsed()))
        // or just the time of last update
        .insert(SpawnedTime(time.last_update().unwrap()));
}</code></pre>
<p>持续时间,如果要想计算:累计/增量/测量时间,使用这个.</p>
<h2 id="timers-and-stopwatches"><a class="header" href="#timers-and-stopwatches">Timers and Stopwatches</a></h2>
<p>There are also facilities to help you track specific intervals or timings:
<a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Timer.html"><code>Timer</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Stopwatch.html"><code>Stopwatch</code></a>. You can create
many instances of these, to track whatever you want. You can use them in
your own <a href="fundamentals//programming/ec.html#components">component</a> or <a href="fundamentals//programming/res.html">resource</a> types.</p>
<p>Timers and Stopwatches need to be ticked. You need to have some system
calling <code>.tick(delta)</code>, for it to make progress, or it will be inactive.
The delta should come from the <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> resource.</p>
<p>定时器和秒表. 这是两个跟踪固定间隔的工具,可以创建很多来跟踪各种事物,
可以在组件或资源中使用.</p>
<p>不管是定时器还是秒表,都需要在system中调用<code>.tick(delta)</code>进行启动或取消,
其中参数delta就来自于Time资源.</p>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Timer.html"><code>Timer</code></a> allows you to detect when a certain interval of time
has elapsed. Timers have a set duration. They can be "repeating" or
"non-repeating".</p>
<p>Both kinds can be manually "reset" (start counting the time interval from the
beginning) and "paused" (they will not progress even if you keep ticking them).</p>
<p>Repeating timers will automatically reset themselves after they reach their
set duration.</p>
<p>Use <code>.finished()</code> to detect when a timer has reached its set duration. Use
<code>.just_finished()</code>, if you need to detect only on the exact tick when the
duration was reached.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Duration;

#[derive(Component)]
struct FuseTime {
    /// track when the bomb should explode (non-repeating timer)
    timer: Timer,
}

fn explode_bombs(mut commands: Commands, mut q: Query&lt;(Entity, &amp;mut FuseTime)&gt;, time: Res&lt;Time&gt;) {
    for (entity, mut fuse_timer) in q.iter_mut() {
        // timers gotta be ticked, to work
        fuse_timer.timer.tick(time.delta());

        // if it finished, despawn the bomb
        if fuse_timer.timer.finished() {
            commands.entity(entity).despawn();
        }
    }
}

#[derive(Resource)]
struct BombsSpawnConfig {
    /// How often to spawn a new bomb? (repeating timer)
    timer: Timer,
}

/// Spawn a new bomb in set intervals of time
fn spawn_bombs(mut commands: Commands, time: Res&lt;Time&gt;, mut config: ResMut&lt;BombsSpawnConfig&gt;) {
    // tick the timer
    config.timer.tick(time.delta());

    if config.timer.finished() {
        commands.spawn((
            FuseTime {
                // create the non-repeating fuse timer
                timer: Timer::new(Duration::from_secs(5), TimerMode::Once),
            },
            // ... other components ...
        ));
    }
}

/// Configure our bomb spawning algorithm
fn setup_bomb_spawning(mut commands: Commands) {
    commands.insert_resource(BombsSpawnConfig {
        // create the repeating timer
        timer: Timer::new(Duration::from_secs(10), TimerMode::Repeating),
    })
}</code></pre>
<p>Note that Bevy's timers do <em>not</em> work like typical real-life timers (which
count downwards toward zero). Bevy's timers start from zero and count <em>up</em>
towards their set duration. They are basically like stopwatches with extra
features: a maximum duration and optional auto-reset.</p>
<p>定时器,允许检查某个间隔的时间是否已经到了.定时器除了可以设置时长,
还可以添加是否重复的标签,不管是不是重复的定时器,都可以进行reset/paused操作.</p>
<p>重复性定时器在达到时长后,会自动调用reset来重置状态.</p>
<p>使用<code>.finished()</code>来检测定时有没有到达.
使用<code>.just_finished()</code>仅在定时到达时返回true.</p>
<h3 id="stopwatch"><a class="header" href="#stopwatch">Stopwatch</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Stopwatch.html"><code>Stopwatch</code></a> allow you to track how much time has passed
since a certain point.</p>
<p>It will just keep accumulating time, which you can check with
<code>.elapsed()</code>/<code>.elapsed_secs()</code>. You can manually reset it at any time.</p>
<pre><code class="language-rust no_run noplayground">use bevy::time::Stopwatch;

#[derive(Component)]
struct JumpDuration {
    time: Stopwatch,
}

fn jump_duration(
    time: Res&lt;Time&gt;,
    mut q_player: Query&lt;&amp;mut JumpDuration, With&lt;Player&gt;&gt;,
    kbd: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    // assume we have exactly one player that jumps with Spacebar
    let mut jump = q_player.single_mut();

    if kbd.just_pressed(KeyCode::Space) {
        jump.time.reset();
    }

    // 这个例子非常有意思,按下空格表秒重置,
    // 持续按下,持续累积时间.
    // 这个和跳格子游戏非常像.有意思.
    if kbd.pressed(KeyCode::Space) {
        println!("Jumping for {} seconds.", jump.time.elapsed_secs());
        // stopwatch has to be ticked to progress
        jump.time.tick(time.delta());
    }
}</code></pre>
<p>秒表可以用来跟踪某个时间点到现在过了多长时间.
秒表会一直累积时间.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="logging-console-messages"><a class="header" href="#logging-console-messages">Logging, Console Messages</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/app/logs.rs"><code>logs</code></a>.</p>
<hr />
<p>You may have noticed how, when you run your Bevy project, you get messages
in your console window. For example:</p>
<pre><code>2022-06-12T13:28:25.445644Z  WARN wgpu_hal::vulkan::instance: Unable to find layer: VK_LAYER_KHRONOS_validation
2022-06-12T13:28:25.565795Z  INFO bevy_render::renderer: AdapterInfo { name: "AMD Radeon RX 6600 XT", vendor: 4098, device: 29695, device_type: DiscreteGpu, backend: Vulkan }
2022-06-12T13:28:25.565795Z  INFO mygame: Entered new map area.
</code></pre>
<p>Log messages like this can come from Bevy, dependencies (like wgpu), and
also from your own code.</p>
<p>Bevy offers a logging framework that is much more advanced than simply using
<code>println</code>/<code>eprintln</code> from Rust. Log messages can have metadata, like the
level, timestamp, and Rust module where it came from. You can see that this
metadata is printed alongside the contents of the message.</p>
<p>This is set up by Bevy's <a href="https://docs.rs/bevy/0.12.0/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>. It is part of the
<a href="https://docs.rs/bevy/0.12.0/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> plugin group, so most Bevy users
will have it automatically in every typical Bevy project.</p>
<p>上图中的日志来自于bevy,确切说是wgpu.
相比rust提供的println/eprintln宏,bevy提供了一个高级的日志库.
DefaultPlugins插件列表中包含了LogPlugin插件.</p>
<h2 id="levels"><a class="header" href="#levels">Levels</a></h2>
<p>Levels determine how important a message is, and allow messages to be filtered.</p>
<p>The available levels are: <code>off</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code>.</p>
<p>A rough guideline for when to use each level, could be:</p>
<ul>
<li><code>off</code>: disable all log messages</li>
<li><code>error</code>: something happened that prevents things from working correctly</li>
<li><code>warn</code>: something unusual happened, but things can continue to work</li>
<li><code>info</code>: general informational messages</li>
<li><code>debug</code>: for development, messages about what your code is doing</li>
<li><code>trace</code>: for very verbose debug data, like dumping values</li>
</ul>
<p>日志等级,off表示不要日志,剩下的依次丰富.</p>
<h2 id="printing-your-own-log-messages"><a class="header" href="#printing-your-own-log-messages">Printing your own log messages</a></h2>
<p>To display a message, just use the macro named after the level of the
message. The syntax is exactly the same as with Rust's <code>println</code>. See the
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> documentation for more details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error!("Unknown condition!");
warn!("Something unusual happened!");
info!("Entered game level: {}", level_id);
debug!("x: {}, state: {:?}", x, state);
trace!("entity transform: {:?}", transform);
<span class="boring">}</span></code></pre></pre>
<p>使用也非常简单,使用宏即可.</p>
<h2 id="filtering-messages"><a class="header" href="#filtering-messages">Filtering messages</a></h2>
<p>To control what messages you would like to see, you can configure Bevy's
<a href="https://docs.rs/bevy/0.12.0/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::log::LogPlugin;

app.add_plugins(DefaultPlugins.set(LogPlugin {
    filter: "info,wgpu_core=warn,wgpu_hal=warn,mygame=debug".into(),
    level: bevy::log::Level::DEBUG,
}));
<span class="boring">}</span></code></pre></pre>
<p>The <code>filter</code> field is a string specifying a list of rules for what level to
enable for different Rust modules/crates. In the example above, the string
means: show up to <code>info</code> by default, limit <code>wgpu_core</code> and <code>wgpu_hal</code>
to <code>warn</code> level, for <code>mygame</code> show <code>debug</code>.</p>
<p>All levels higher than the one specified are also enabled. All levels lower
than the one specified are disabled, and those messages will not be displayed.</p>
<p>The <code>level</code> filter is a global limit on the lowest level to use. Messages
below that level will be ignored and most of the performance overhead avoided.</p>
<p>filter可进一步指定各个模块的日志等级.</p>
<h3 id="environment-variable"><a class="header" href="#environment-variable">Environment Variable</a></h3>
<p>You can override the filter string when running your app, using the <code>RUST_LOG</code>
environment variable.</p>
<pre><code class="language-sh">RUST_LOG="warn,mygame=debug" ./mygame
</code></pre>
<p>Note that other Rust projects, such as <code>cargo</code>, also use the same
environment variable to control their logging. This can lead to unexpected
consequences. For example, doing:</p>
<pre><code class="language-sh">RUST_LOG="debug" cargo run
</code></pre>
<p>will cause your console to also be filled with debug messages from <code>cargo</code>.</p>
<p>不想代码指定日志等级,也可以使用环境变量RUST_LOG来指定.不推荐这种方式.</p>
<h3 id="different-settings-for-debug-and-release-builds"><a class="header" href="#different-settings-for-debug-and-release-builds">Different settings for debug and release builds</a></h3>
<p>If you want to do different things in your Rust code for debug/release
builds, an easy way to achieve it is using conditional compilation on
"debug assertions".</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::log::LogPlugin;

// this code is compiled only if debug assertions are enabled (debug mode)
#[cfg(debug_assertions)]
app.add_plugins(DefaultPlugins.set(LogPlugin {
    level: bevy::log::Level::DEBUG,
    filter: "debug,wgpu_core=warn,wgpu_hal=warn,mygame=debug".into(),
}));

// this code is compiled only if debug assertions are disabled (release mode)
#[cfg(not(debug_assertions))]
app.add_plugins(DefaultPlugins.set(LogPlugin {
    level: bevy::log::Level::INFO,
    filter: "info,wgpu_core=warn,wgpu_hal=warn".into(),
}));
<span class="boring">}</span></code></pre></pre>
<p>This is a good reason why <a href="fundamentals//pitfalls/performance.html">you should not use release mode during development
just for performance reasons</a>.</p>
<p>On Microsoft Windows, your game EXE will also launch with a console window for
displaying log messages by default. You might not want that in release builds.
<a href="fundamentals//platforms/windows.html#disabling-the-windows-console">See here.</a></p>
<p>使用条件编译来分别控制debug/release的不同日志等级.这也是提高性能的一种方式.</p>
<p>windows中,你肯定不想release版本弹出一个命令窗口来吧.</p>
<h2 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h2>
<p>Printing messages to the console is a relatively slow operation.</p>
<p>However, if you are not printing a large volume of messages, don't worry
about it. Just avoid spamming lots of messages from performance-sensitive
parts of your code like inner loops.</p>
<p>You can disable log levels like <code>trace</code> and <code>debug</code> in release builds.</p>
<p>控制台打印日志是非常慢的操作.
如果不是大量打印日志,这点影响不算什么.
循环多的地方,就是性能敏感的地方,不要在这里打大量的日志.</p>
<p>release版本可是从info级别开始打起.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="hierarchical-parentchild-entities"><a class="header" href="#hierarchical-parentchild-entities">Hierarchical (Parent/Child) Entities</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/hierarchy.rs"><code>hierarchy</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Technically, the <a href="fundamentals//programming/intro-data.html#entities--components">Entities/Components</a> themselves cannot form a
hierarchy (the <a href="fundamentals//programming/ecs-intro.html">ECS</a> is a flat data structure). However,
logical hierarchies are a common pattern in games.</p>
<p>Bevy supports creating such a logical link between entities, to form
a virtual "hierarchy", by simply adding <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and
<a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> components on the respective entities.</p>
<p>When using <a href="fundamentals//programming/commands.html">Commands</a> to spawn entities,
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> has methods for adding children to entities,
which automatically add the correct components:</p>
<pre><code class="language-rust no_run noplayground">    // spawn the parent and get its Entity id
    let parent = commands.spawn(MyParentBundle::default()).id();

    // do the same for the child
    let child = commands.spawn(MyChildBundle::default()).id();

    // add the child to the parent
    commands.entity(parent).push_children(&amp;[child]);

    // you can also use `with_children`:
    commands
        .spawn(MyParentBundle::default())
        .with_children(|parent| {
            parent.spawn(MyChildBundle::default());
        });</code></pre>
<p>Note that this only sets up the <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and
<a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> components, and nothing else. Notably, it does not
add <a href="fundamentals//fundamentals/transforms.html">transforms</a> or <a href="fundamentals//fundamentals/visibility.html">visibility</a> for you.  If you
need that functionality, you need to add those components yourself, using
something like <a href="https://docs.rs/bevy/0.9.1/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a>.</p>
<p>You can despawn an entire hierarchy with a single <a href="fundamentals//programming/commands.html">command</a>:</p>
<pre><code class="language-rust no_run noplayground">fn close_menu(mut commands: Commands, query: Query&lt;Entity, With&lt;MainMenuUI&gt;&gt;) {
    for entity in query.iter() {
        // despawn the entity and its children
        commands.entity(entity).despawn_recursive();
    }
}</code></pre>
<p>技术上讲,ECS的实体/组件没有继承关系,因为这两者都是扁平化的结构.</p>
<p>实体,逻辑上还是有一些继承关系的,bevy就是这么设计的.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Parent 仅仅是将Entity封装了一层.
#[derive(Component, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "reflect", derive(bevy_reflect::Reflect))]
#[cfg_attr(feature = "reflect", reflect(Component, MapEntities, PartialEq))]
pub struct Parent(pub(crate) Entity);

// Children 就是一个Entity列表
#[derive(Component, Debug)]
#[cfg_attr(feature = "reflect", derive(bevy_reflect::Reflect))]
#[cfg_attr(feature = "reflect", reflect(Component, MapEntities))]
pub struct Children(pub(crate) SmallVec&lt;[Entity; 8]&gt;);
<span class="boring">}</span></code></pre></pre>
<p>上图的例子就通过两种方式来人为创建了一对父子关系.
例子中并没有添加变换/可视等特性,需要我们自己单独添加.
有继承关系的实体,通过<code>despawn_recursive</code>可以将当前实体和子实体都销毁.</p>
<h2 id="accessing-the-parent-or-children"><a class="header" href="#accessing-the-parent-or-children">Accessing the Parent or Children</a></h2>
<p>To make a system that works with the hierarchy, you typically need two <a href="fundamentals//programming/queries.html">queries</a>:</p>
<ul>
<li>one with the components you need from the child entities</li>
<li>one with the components you need from the parent entities</li>
</ul>
<p>One of the two queries should include the appropriate component, to obtain the
entity ids to use with the other one:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> in the child query, if you want to iterate entities
and look up their parents, or</li>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> in the parent query, if you want to iterate entities
and look up their children</li>
</ul>
<p>For example, if we want to get the <a href="https://docs.rs/bevy/0.9.1/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>
of cameras (<a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.Camera.html"><code>Camera</code></a>) that have a parent, and the
<a href="https://docs.rs/bevy/0.9.1/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> of their parent:</p>
<pre><code class="language-rust no_run noplayground">fn camera_with_parent(
    q_child: Query&lt;(&amp;Parent, &amp;Transform), With&lt;Camera&gt;&gt;,
    q_parent: Query&lt;&amp;GlobalTransform&gt;,
) {
    for (parent, child_transform) in q_child.iter() {
        // `parent` contains the Entity ID we can use
        // to query components from the parent:
        let parent_global_transform = q_parent.get(parent.get());

        // do something with the components
    }
}</code></pre>
<p>As another example, say we are making a strategy game, and we have Units
that are children of a Squad. Say we need to make a system that works on
each Squad, and it needs some information about the children:</p>
<pre><code class="language-rust no_run noplayground">fn process_squad_damage(
    q_parent: Query&lt;(&amp;MySquadDamage, &amp;Children)&gt;,
    q_child: Query&lt;&amp;MyUnitHealth&gt;,
) {
    // get the properties of each squad
    for (squad_dmg, children) in q_parent.iter() {
        // `children` is a collection of Entity IDs
        for &amp;child in children.iter() {
            // get the health of each child unit
            let health = q_child.get(child);

            // do something
        }
    }
}</code></pre>
<p>如果要访问父/子实体,需要两个query(父实体对应的组件列表,子实体对应的组件列表),
随便找到哪个就能找到对应的父子了.</p>
<p>上面的例子展示了一父多子和多个一父多子的例子.</p>
<h2 id="transform-and-visibility-propagation"><a class="header" href="#transform-and-visibility-propagation">Transform and Visibility Propagation</a></h2>
<p>If your entities represent "objects in the game world", you probably expect
the children to be affected by the parent.</p>
<p><a href="fundamentals//fundamentals/transforms.html">Transform</a> propagation allows children to be positioned
relative to their parent and move with it.</p>
<p><a href="fundamentals//fundamentals/visibility.html">Visibility</a> propagation allows children to be hidden if
you manually hide their parent.</p>
<p>Most <a href="fundamentals//builtins.html#bundles">Bundles that come with Bevy</a> provide these behaviors
automatically. Check the docs for the bundles you are using.  Camera bundles,
for example, have transforms, but not visibility.</p>
<p>Otherwise, you can use <a href="https://docs.rs/bevy/0.9.1/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> to make sure
your entities have all the necessary components.</p>
<p>如果要实体能显示出来,还需要受父实体来影响,就可以使用变形传播/可视传播.</p>
<p>bevy提供的很多Bundle都自动添加了这些行为.eg:CamearBundle,添加了变换,没有添加可视.
或者简单点,添加空间Bundle SpatialBundle,这样变换和可视都添加了.</p>
<h2 id="known-pitfalls"><a class="header" href="#known-pitfalls">Known Pitfalls</a></h2>
<h3 id="despawning-child-entities"><a class="header" href="#despawning-child-entities">Despawning Child Entities</a></h3>
<p>If you despawn an entity that has a parent, Bevy does not remove it from the
parent's <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a>.</p>
<p>If you then query for that parent entity's children, you will get an invaild
entity, and any attempt to manipulate it will likely lead to this error:</p>
<pre><code>thread 'main' panicked at 'Attempting to create an EntityCommands for entity 7v0, which doesn't exist.'
</code></pre>
<p>The workaround is to manually call <code>remove_children</code> alongside the <code>despawn</code>:</p>
<pre><code class="language-rust no_run noplayground">    commands
        .entity(parent_entity)
        .remove_children(&amp;[child_entity]);
    commands.entity(child_entity).despawn();</code></pre>
<p>常见失败场景:子实体销毁.</p>
<p>如果子实体销毁了,但父实体没有销毁其关系,这就是问题.
报错和解决方法如上所示.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="fixed-timestep"><a class="header" href="#fixed-timestep">Fixed Timestep</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/fixed_timestep.rs"><code>fixed_timestep</code></a>.</p>
<hr />
<p>If you need to run some <a href="fundamentals//programming/systems.html">systems</a> at a fixed rate, independent
of the display frame rate, Bevy provides a solution.</p>
<pre><code class="language-rust no_run noplayground">    // These systems will run every frame
    // (at the framerate being rendered to your screen)
    app.add_systems(Update, (camera_movement, animation, juicy_explosions));

    // These systems will run as many times as needed
    // as to maintain a fixed rate on average
    app.add_systems(
        FixedUpdate,
        (physics_collisions, enemy_ai, gameplay_simulation),
    );</code></pre>
<p>Every frame update, Bevy will run the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> schedule as many times as
needed to catch up. If the game is running slow, it might run multiple times. If
the game is running fast, it might be skipped.</p>
<p>This happens before the regular <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> schedule runs for that frame, but
after <a href="fundamentals//programming/states.html">state transitions</a>.</p>
<p>The default fixed timestep interval is 64 Hz. If you want something else,
you can configure it as follows:</p>
<pre><code class="language-rust no_run noplayground">    // Set the Fixed Timestep interval to 96 Hz
    app.insert_resource(Time::&lt;Fixed&gt;::from_hz(96.0));

    // Set the Fixed Timestep interval to 250 milliseconds
    app.insert_resource(Time::&lt;Fixed&gt;::from_seconds(0.25));</code></pre>
<p>如果部分system不需要以来帧率,bevy也提供了方案:<code>固定时间戳</code>.
这类system放在FixedUpdate调度中,bevy会评估当前帧的可用时间,
如果时间够用就会多次执行system,如果时间不够用就跳过.
但不管单帧运行多次次,bevy会努力保证调用的平均固定速率.
默认调度间隔是64Hz.也可以调整为96Hz或以时间为间隔,如上图.</p>
<h2 id="checking-the-time"><a class="header" href="#checking-the-time">Checking the Time</a></h2>
<p>Just use <a href="https://docs.rs/bevy/0.13.0/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a> as normal. When your system is running in
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, Bevy will automatically detect that, and all the timing
information (such as delta) will represent the fixed timestep instead of the
display frame rate.</p>
<pre><code class="language-rust no_run noplayground">fn print_time_delta(time: Res&lt;Time&gt;) {
    // If we add this system to `Update`, this will print the time delta
    // between subsequent frames (the display frame rate)
    // 在Update中,delta_seconds获取的是两帧之间的时间差.

    // If we add this system to `FixedUpdate`, this will always print the
    // same value (equal to the fixed timestep interval).
    // 在FixedUpdate中,delta_seconds获取的是固定时间戳的间隔(最开始设定的固定值).

    println!("Elapsed seconds: {}", time.delta_seconds());
}

// This system will access the Fixed time
// regardless of what schedule it runs in
fn print_fixed_time_info(time_fixed: Res&lt;Time&lt;Fixed&gt;&gt;) {
    // Time&lt;Fixed&gt;,访问的是固定时间戳

    // `Time&lt;Fixed&gt;` gives us some additional methods, such as checking
    // the overstep (partial timestep / amount of extra time accumulated)
    println!(
        "Time remaining until the next fixed update run: {}",
        time_fixed.delta_seconds() - time_fixed.overstep().as_secs_f32()
    );
}

// This system will access the regular frame time regardless
// of what schedule it runs in
fn check_virtual_time(time_fixed: Res&lt;Time&lt;Virtual&gt;&gt;) { // Time&lt;Virtual&gt;,访问的是普通时间
                                                        // ...
}</code></pre>
<p>If you need to access the regular frame-time from a system running under
fixed timestep, you can use <code>Res&lt;Time&lt;Virtual&gt;&gt;</code> instead. <code>Res&lt;Time&lt;Real&gt;&gt;</code>
gives you the real (wall-clock) time, without pausing or scaling.</p>
<p>If you need to access the fixed-timestep-time from a system running outside
of fixed timestep, you can use <code>Res&lt;Time&lt;Fixed&gt;&gt;</code> instead.</p>
<p>在system中也可以使用Time,bevy会自动维护这个资源,但这个资源里的数据含义会有变化,
从帧率改为了时间步长.</p>
<p>Time提供了3种内置时间:</p>
<ul>
<li>Virtual, bevy内置的普通时间</li>
<li>Fixed, bevy基于Virtual继续封装的固定时间戳</li>
<li>Real, 真实世界的时间,这个可能用的非常少,在日志打印时会用到</li>
</ul>
<h2 id="should-i-put-my-systems-in-update-or-fixedupdate"><a class="header" href="#should-i-put-my-systems-in-update-or-fixedupdate">Should I put my systems in <code>Update</code> or <code>FixedUpdate</code>?</a></h2>
<p>The purpose of fixed timestep is to make gameplay code behave predictably
and reliably. Things such as physics and simulation work best if they are
computed with fixed time intervals, as that avoids floating point errors
from accumulating and glitchy behavior from variable framerate.</p>
<p>The following things should probably be done in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>:</p>
<ul>
<li>Physics and collision detection</li>
<li>Networking / netcode</li>
<li>AI for enemies and NPCs (pathfinding, decisions, etc.)</li>
<li>Spawning/despawning gameplay-related entities</li>
<li>Other simulation and decision-making</li>
</ul>
<p>However, anything that directly affects what is displayed on-screen should
run per-frame, in order to look smooth. If you do movement or animation under
fixed timestep, it will look choppy, especially on high-refresh-rate screens.</p>
<p>The following things should probably be done in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>:</p>
<ul>
<li>Camera movement and controls</li>
<li>Animations</li>
<li>UI</li>
<li>Visual effects</li>
<li>Anything that is part of your game's graphics/visuals or interactivity</li>
<li><a href="fundamentals//programming/states.html">App state</a> transitions</li>
</ul>
<p>固定时间戳引入的目的是为了让游戏代码更具有可预测性和可靠性.
诸如物理和模拟之类的事情如果以固定的时间间隔进行计算，效果最好，
因为这可以避免浮点错误的累积和可变帧速率的故障行为。</p>
<p>下列场景应该使用固定时间戳:</p>
<ul>
<li>物理和碰撞检测</li>
<li>网络代码</li>
<li>敌人和NPC的AI,包括(寻路/决策等)</li>
<li>实体的生成和销毁(FixedUpdate调度在Update之前,在挂起状态调整之后)</li>
<li>其他模拟和决策</li>
</ul>
<p>任何在屏幕上显示的都应该按帧运行,这样看起来就会很流畅.
这句话的意思是(能渲染的放在Update中,决策渲染的逻辑放在FixedUpdate中).</p>
<p>下列场景因该使用Update:</p>
<ul>
<li>Camera的移动和控制</li>
<li>动画</li>
<li>UI</li>
<li>显示效果</li>
<li>图形/视觉效果/交互</li>
<li>app状态转换</li>
</ul>
<h3 id="bridging-the-gap"><a class="header" href="#bridging-the-gap">Bridging the Gap</a></h3>
<p>Sometimes there is a logical conflict:</p>
<p>For something like player movement, you want it to be computed reliably as part
of your gameplay/physics simulation, but you also want it to look smooth on-screen.</p>
<p>For input handling, you want it to be responsive and handled every frame, but
you also have game mechanics that need to respond to it.</p>
<p>The most elegant solution to both of these problems is to handle synchonization
yourself using custom types.</p>
<p>并不是所有的system都有个明显的划分,经常会出现逻辑冲突,常见的有:</p>
<p>角色移动,可以作为游戏物理模拟的的可靠计算逻辑,也希望在屏幕上看起来丝滑.
输入处理,既需要每帧都处理,也希望游戏机制能响应.</p>
<p>类似的问题,最优雅的方式是使用自定义的类型来完成同步.</p>
<h4 id="movement"><a class="header" href="#movement">Movement</a></h4>
<p>For player (and other) movement, you could create your own custom component type
to use instead of <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>. Implement your player movement using your own
types. Then have a system in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> to sync/update <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> from that,
with some interpolation to make it look smooth.</p>
<pre><code class="language-rust no_run noplayground">// TODO show how to do this</code></pre>
<p>Transform组件负责移动,优雅的方式是创建一个类似的组件来负责移动,
FixedUpdate负责决策,中间的卡顿通过在Update中进行<code>插值</code>来更新Transform,
通过这种方式来达到界面顺滑不卡顿的目的.</p>
<h4 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h4>
<p>If you use <a href="https://docs.rs/bevy/0.13.0/bevy/input/struct.ButtonInput.html"><code>Res&lt;ButtonInput&lt;...&gt;&gt;</code></a> and
<code>.just_pressed</code>/<code>.just_released</code> to check for key/button presses, beware that
the state is updated once per frame. This API is not reliable inside
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>. Use <a href="fundamentals//programming/events.html">events</a> for input handling instead, or roll
your own abstractions.</p>
<p>One way to do this is to put your input handling systems in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>, order
them after Bevy's <a href="https://docs.rs/bevy/0.13.0/bevy/input/struct.InputSystem.html"><code>InputSystem</code></a> <a href="fundamentals//programming/system-sets.html">set</a>, and do your input
handling there. Convert it into your own custom <a href="fundamentals//programming/events.html">event</a> types or some
other useful representation, which you can then handle from your gameplay code
in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">// TODO show how to do this</code></pre>
<p>按钮的按键检测是每帧检测,放在调用次数不确定的FixedUpdate中,也不能确保逻辑已经能执行,
所以放在FixedUpdate并不可靠.该使用事件代替,或自己手搓抽象层来完成.</p>
<p>有种实现方式是这样的:在PreUpdate(每帧调度中,仅在First之后,在挂起状态处理之后)处理输入,
通过bevy的InputSystem set中进行排序,将输入变为自定义事件,然后在FixedUpdate中处理.</p>
<h2 id="timing-caveats"><a class="header" href="#timing-caveats">Timing Caveats</a></h2>
<p>Fixed timestep does not run in real-world time! You cannot rely on it for timing!</p>
<p>For example, if you try to play audio from it, or send network packets, you will
notice that they don't actually occur at the fixed timestep interval. They will
not be evenly spaced!</p>
<p>Your <a href="fundamentals//programming/systems.html">systems</a> are still called as part of the regular frame-update
cycle. Every frame update, Bevy will run the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> as many times as needed to catch up.</p>
<p>This means if you specify, for example, a 60 Hz fixed timestep interval, your
systems will not actually run in 1/60 second intervals in real time.</p>
<p>What will happen is the following:</p>
<ul>
<li>If the display frame rate is faster than the timestep, some frame update cycles
will skip the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> schedule entirely.</li>
<li>If the display frame rate is slower than the timestep, some frame update cycles
will run the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> multiple times.</li>
</ul>
<p>In any case, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> will run right before
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>, where your per-frame systems live.</p>
<p>固定时间戳不是真实时间,计时不能依赖这个.</p>
<p>音频播放/网络发包,这些都不能以来固定时间戳,这个运行间隔并不是固定步长,
只是平均起来是固定步长.</p>
<p>实际上的运行可能是以下几类:</p>
<ul>
<li>帧率比固定时间戳快,FixedUpdate可能会忽略</li>
<li>帧率比固定时间戳慢,FixedUpdate可能会执行多次</li>
</ul>
<h2 id="additional-schedules"><a class="header" href="#additional-schedules">Additional Schedules</a></h2>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> is actually part of a larger <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a>, which also contains other <a href="fundamentals//programming/schedules.html">schedules</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedFirst.html"><code>FixedFirst</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPreUpdate.html"><code>FixedPreUpdate</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPostUpdate.html"><code>FixedPostUpdate</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedLast.html"><code>FixedLast</code></a></li>
</ul>
<p>They are analogous to the <a href="fundamentals//programming/schedules.html">schedules</a> in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>, that run every
frame update. They can be used for analogous purposes (to contain "engine
systems" from Bevy and plugins).</p>
<p>上面是主调度(Main)在每帧的调度顺序(不是首帧的).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="gizmos"><a class="header" href="#gizmos">Gizmos</a></h1>
<p>// TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="general-graphics-features"><a class="header" href="#general-graphics-features">General Graphics Features</a></h1>
<p>This chapter covers general graphics-related features in Bevy, that are
relevant to both 2D and 3D games.</p>
<p>Bevy's rendering is driven by / configured via <a href="/graphics/camera.html">cameras</a>. Each
camera <a href="/programming/ec.html#entities">entity</a> will cause Bevy to render your game world,
as configured via the various <a href="/programming/ec.html#components">components</a> on the
<a href="/graphics/camera.html">camera</a>. You can enable all kinds of different workflows, as
well as optional effects, by adding the relevant components to your camera
and configuring them.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="cameras"><a class="header" href="#cameras">Cameras</a></h1>
<p>Cameras drive all rendering in Bevy. They are responsible for configuring what
to draw, how to draw it, and where to draw it.</p>
<p>Cameras驱动着Bevy内的全部渲染. 这些相机负责配置: 绘制什么, 如何绘制, 以及在哪里绘制.</p>
<p>You must have at least one camera entity, in order for anything to be displayed
at all! If you forget to spawn a camera, you will get an empty black screen.</p>
<p>你至少需要一个相机实体, 为了显示任何东西! 如果你忘记spawn一个相机, 那么你将会得到一个空空的黑色屏幕.</p>
<p>In the simplest case, you can create a camera with the default settings. Just
spawn an entity using <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a> or
<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_3d/struct.Camera3dBundle.html"><code>Camera3dBundle</code></a>. It will simply draw all renderable
entities that are <a href="graphics//fundamentals/visibility.html">visible</a>.</p>
<p>最简单的例子是, 你能用默认的配置创建一个相机. 比如使用Camera2dBundle或Camera3dBundle,
它将会绘制任何可见的实体.</p>
<p>This page gives a general overview of cameras in Bevy. Also see the dedicated
pages for <a href="graphics//2d/camera.html">2D cameras</a> and <a href="graphics//3d/camera.html">3D cameras</a>.</p>
<p>Practical advice: always create <a href="graphics//programming/ec.html#marker-components">marker components</a> for
your camera entities, so that you can <a href="graphics//programming/queries.html">query</a> your cameras easily!</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyGameCamera;

fn setup(mut commands: Commands) {
    commands.spawn((
        Camera3dBundle::default(),
        MyGameCamera,
    ));
}</code></pre>
<p>相机驱动 Bevy 中的所有渲染.他们负责配置绘制什么、如何绘制以及在哪里绘制.</p>
<blockquote>
<p>我理解的游戏是一个世界,相机是观看世界的一个视角,或一双眼睛.整个世界都在运行着,
但我们的视角只能看到一部分,boss的刷新不在我们视角中,但在世界中确实发生了,
一个玩家在打怪,不在我们视角中,我们的电脑上的程序不会处理这个,
但当我们走近时,服务端会将这部分数据同步过来,我也看到了一个玩家在打怪.</p>
</blockquote>
<p>要看到渲染的东西,至少需要一个camera实体,如果忘了创建camera实体,啥都看不到.</p>
<p>在一些简单的例子中,camera可以使用默认配置,bevy会简单绘制所有可视且能渲染的实体.</p>
<p>有个建议:给创建的Camera贴一个标签,这样方便Query.这样的标签还有个名词:<code>标签组件</code>.</p>
<h2 id="the-camera-transform"><a class="header" href="#the-camera-transform">The Camera Transform</a></h2>
<p>Cameras have <a href="graphics//fundamentals/transforms.html">transforms</a>, which can be used to position or
rotate the camera. This is how you move the camera around.</p>
<p>For examples, see these <a href="graphics//cookbook.html">cookbook</a> pages:</p>
<ul>
<li><a href="graphics//cookbook/pan-orbit-camera.html">3D pan-orbit camera</a>, like in 3D editor apps</li>
</ul>
<p>If you are making a game, you should implement your own custom camera controls
that feel appropriate to your game's genre and gameplay.</p>
<p>camera也有变换,也能移动位置和旋转相机,也就是相机移动的方式.
制作bevy游戏,应该自定义相机控制使其更加服务和自己的游戏和玩法.</p>
<h3 id="zooming-the-camera"><a class="header" href="#zooming-the-camera">Zooming the camera</a></h3>
<p>Do not use the transform scale to "zoom" a camera! It just stretches the image,
which is not "zooming". It might also cause other issues and incompatibilities.
Use the <a href="graphics//graphics/camera.html#projection">projection</a> to zoom.</p>
<p>For an orthographic projection, change the scale. For a perspective projection,
change the FOV. The FOV mimics the effect of zooming with a lens.</p>
<p>Learn more about how to do this in <a href="graphics//2d/camera.html#projection">2D</a> or
<a href="graphics//3d/camera.html#projection">3D</a>.</p>
<p>相机的聚焦(zoom)不是缩放,缩放是拉伸,不是聚焦,使用缩放来实现聚焦会有各种问题,
正确的方式应该是<code>投影</code>.</p>
<p>对于<code>正交投影</code>,应该改为缩放;对于<code>透视投影</code>,改为<code>FOV</code>,FOV模仿了镜头变焦的效果.</p>
<ul>
<li>正交投影的特点是随着远近,投影物体没有大小变化</li>
<li>透视投影则有远小近大的特点</li>
</ul>
<h2 id="projection"><a class="header" href="#projection">Projection</a></h2>
<p>The camera projection is responsible for mapping the coordinate system to the
viewport (commonly, the screen/window). It is what configures the coordinate
space, as well as any scaling/stretching of the image.</p>
<p>Bevy provides two kinds of projections:
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> and
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>. They are configurable,
to be able to serve a variety of different use cases.</p>
<p>Orthographic means that everything always appears the same size, regardless of
how far away it is from the camera.</p>
<p>Perspective means that things appear smaller the further away they are from
the camera. This is the effect that gives 3D graphics a sense of depth and
distance.</p>
<p><a href="graphics//2d/camera.html">2D cameras</a> are always orthographic.</p>
<p><a href="graphics//3d/camera.html">3D cameras</a> can use either kind of projection. Perspective is
the most common (and default) choice. Orthographic is useful for applications
such as CAD and engineering, where you want to accurately represent the
dimensions of an object, instead of creating a realistic sense of 3D space. Some
games (notably simulation games) use orthographic as an artistic choice.</p>
<p>It is possible to implement your own <a href="graphics//cookbook/custom-projection.html">custom camera
projections</a>. This can give you full control over
the coordinate system. However, beware that things might behave in unexpected
ways if you violate Bevy's <a href="graphics//fundamentals/coords.html">coordinate system conventions</a>!</p>
<p>相机投影负责将坐标系映射到窗口视角(通常是屏幕或窗口),这里的相机投影就是配置坐标系,
以及图像的缩放和拉伸.
bevy提供了<code>OrthographicProjection</code>正交投影和<code>PerspectiveProjection</code>透视投影两种,
两者均可配置,适用于不同场景.</p>
<p>正交意味着所有物体始终显示相同的尺寸,无论距相机有多远.<br />
透视意味着物体距离相机越远,看起来就越小.这种效果赋予 3D 图形深度感和距离感.</p>
<p>2d游戏使用正交,3d游戏两种都可以使用,但透视更加常用.</p>
<p>正交对于 CAD 和工程等应用程序非常有用,在这些应用程序中,您希望准确表示对象的尺寸,
而不是创建逼真的 3D 空间感.一些游戏（尤其是模拟游戏）使用正交文字作为艺术选择.</p>
<p>也可以自定义相机属性,这样就可以完全控制坐标体系,但需要注意:遵循bevy的坐标体系规则.</p>
<h2 id="hdr-and-tonemapping"><a class="header" href="#hdr-and-tonemapping">HDR and Tonemapping</a></h2>
<p><a href="graphics//graphics/hdr-tonemap.html">See here!</a></p>
<p>高动态范围图片和色调映射,见下一章.</p>
<h2 id="render-target"><a class="header" href="#render-target">Render Target</a></h2>
<p>The render target of a camera determines where the GPU will draw things to. It
could be a window (for outputting directly to the screen) or an
<a href="https://docs.rs/bevy/0.12.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> <a href="graphics//assets.html">asset</a> (render-to-texture).</p>
<p>By default, cameras output to the primary window.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::RenderTarget;

fn debug_render_targets(
    q: Query&lt;&amp;Camera&gt;,
) {
    for camera in &amp;q {
        match &amp;camera.target {
            RenderTarget::Window(wid) =&gt; {
                eprintln!("Camera renders to window with id: {:?}", wid);
            }
            RenderTarget::Image(handle) =&gt; {
                eprintln!("Camera renders to image asset with id: {:?}", handle);
            }
            RenderTarget::TextureView(_) =&gt; {
                eprintln!("This is a special camera that outputs to something outside of Bevy.");
            }
        }
    }
}</code></pre>
<p>相机的渲染目标决定了GPU会绘制那些对象,可能是窗口(直接渲染到屏幕),可能是图片资产(渲染到纹理).
默认,相机输出到主窗口.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RenderTarget {
    Window(WindowRef),
    Image(Handle&lt;Image&gt;),
    TextureView(ManualTextureViewHandle),
}
<span class="boring">}</span></code></pre></pre>
<p>这3种对象依次是:</p>
<ul>
<li>相机渲染到窗口</li>
<li>相机渲染到Image</li>
<li>相机渲染到纹理视图,特别适合在bevy之外产生纹理试图的场景(eg:外部XR中创建和管理纹理试图,传给bevy做渲染)</li>
</ul>
<h2 id="viewport"><a class="header" href="#viewport">Viewport</a></h2>
<p>The viewport is an (optional) way to restrict a camera to a sub-area of its
render target, defined as a rectangle. That rectangle is effectively treated as
the "window" to draw in.</p>
<p>An obvious use-case are split-screen games, where you want a camera to only draw
to one half of the screen.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::Viewport;

fn setup_minimap(mut commands: Commands) {
    commands.spawn((
        Camera2dBundle {
            camera: Camera {
                // renders after / on top of other cameras
                order: 2,
                // set the viewport to a 256x256 square in the top left corner
                viewport: Some(Viewport {
                    physical_position: UVec2::new(0, 0),
                    physical_size: UVec2::new(256, 256),
                    ..default()
                }),
                ..default()
            },
            ..default()
        },
        MyMinimapCamera,
    ));
}</code></pre>
<p>If you need to find out the area a camera renders to (the viewport, if
configured, or the entire window, if not):</p>
<pre><code class="language-rust no_run noplayground">fn debug_viewports(
    q: Query&lt;&amp;Camera, With&lt;MyExtraCamera&gt;&gt;,
) {
    let camera = q.single();

    // the size of the area being rendered to
    let view_dimensions = camera.logical_viewport_size().unwrap();

    // the coordinates of the rectangle covered by the viewport
    let rect = camera.logical_viewport_rect().unwrap();
}</code></pre>
<p>视窗是一种将取部分相机视角的方案之一.视窗通常是矩形,是矩形所以作为窗口绘制时就很高效.
一个常见的应用场景是分屏游戏,一个相机只绘制到半个屏幕.</p>
<p>上面的例子显示了相机制定视窗属性的例子,并取相机视窗的的矩形坐标大小和渲染区域大小.</p>
<h2 id="coordinate-conversion"><a class="header" href="#coordinate-conversion">Coordinate Conversion</a></h2>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a> provides methods to help with coordinate conversion
between on-screen coordinates and world-space coordinates. For an example, see
the <a href="graphics//cookbook/cursor2world.html">"cursor to world"</a> cookbook page.</p>
<p>相机提供了不少方法来进行屏幕坐标和世界坐标的转换.</p>
<h2 id="clear-color"><a class="header" href="#clear-color">Clear Color</a></h2>
<p>This is the "background color" that the whole viewport will be cleared to,
before a camera renders anything.</p>
<p>You can also disable clearing on a camera, if you want to preserve all the
pixels as they were before.</p>
<p><a href="graphics//window/clear-color.html">See this page for more info.</a></p>
<p>背景色其实是整个视窗刷上的颜色,在相机渲染之前就完成了.</p>
<p>相机可以disable颜色擦除,做局部更新时可以用到.</p>
<h2 id="render-layers"><a class="header" href="#render-layers">Render Layers</a></h2>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/struct.RenderLayers.html"><code>RenderLayers</code></a> is a way to filter what entities should be
drawn by what cameras. Insert this <a href="graphics//programming/ec.html#components">component</a> onto your entities
to place them in specific "layers". The layers are integers from 0 to 31 (32
total available).</p>
<p>Inserting this component onto a camera entity selects what layers that camera
should render. Inserting this component onto renderable entities selects what
cameras should render those entities. An entity will be rendered if there is any
overlap between the camera's layers and the entity's layers (they have at least
one layer in common).</p>
<p>If an entity does not have the <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/struct.RenderLayers.html"><code>RenderLayers</code></a> component,
it is assumed to belong to layer 0 (only).</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::visibility::RenderLayers;
// This camera renders everything in layers 0, 1
commands.spawn((
    Camera2dBundle::default(),
    RenderLayers::from_layers(&amp;[0, 1])
));
// This camera renders everything in layers 1, 2
commands.spawn((
    Camera2dBundle::default(),
    RenderLayers::from_layers(&amp;[1, 2])
));
// This sprite will only be seen by the first camera
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(0),
));
// This sprite will be seen by both cameras
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(1),
));
// This sprite will only be seen by the second camera
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(2),
));
// This sprite will also be seen by both cameras
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::from_layers(&amp;[0, 2]),
));</code></pre>
<p>You can also modify the render layers of entities after they are spawned.</p>
<p>通过渲染分层这个组件,相机可以过滤掉一些实体.
分层有32个,构建相机时通过RenderLayers组件设置分层,就配置相机关心的分层列表.
同理,构建实体时也需要指定分层列表.如果相机和可渲染实体的分层列表有重叠,
则进行渲染.</p>
<p>在实体构建后是可以修改这个分层属性的.</p>
<blockquote>
<p>渲染分层描述了一个实体属于哪些渲染层.相机可以可以利用分层来过滤其他层的实体,
关于渲染分层有以下几条规则:</p>
</blockquote>
<ol>
<li>实体可以属于多个层,也可以一个层都不指定</li>
<li>第一层为 layer 0, 带RenderLayers组件的实体,其默认分层就是0</li>
<li>不带RenderLayers组件的实体,bevy会给个默认分层:0</li>
<li>带RenderLayers组件的实体,如果不带任何分层,则不可见</li>
</ol>
<h2 id="camera-ordering"><a class="header" href="#camera-ordering">Camera Ordering</a></h2>
<p>A camera's <code>order</code> is a simple integer value that controls the order relative
to any other cameras with the same render target.</p>
<p>For example, if you have multiple cameras that all render to the primary window,
they will behave as multiple "layers". Cameras with a higher order value will render
"on top of" cameras with a lower value. <code>0</code> is the default.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::clear_color::ClearColorConfig;

commands.spawn((
    Camera2dBundle {
        camera_2d: Camera2d {
            // no "background color", we need to see the main camera's output
            clear_color: ClearColorConfig::None,
            ..default()
        },
        camera: Camera {
            // renders after / on top of the main camera
            order: 1,
            ..default()
        },
        ..default()
    },
    MyOverlayCamera,
));</code></pre>
<p>相机顺序.</p>
<p>可能有这样的需求: 多个相机都渲染到主窗口,这样多个相机就相当于多层,
在渲染时通过相机属性order(一个整数,默认为0)来决定顺序,
order越大,渲染在最前面.</p>
<hr />
<p>多相机就是多视角,有以下场景都会包含多相机,可以说最最常见了:</p>
<ul>
<li>除了上面提到的分屏游戏,还有驾驶游戏(驾驶员视角和后视镜视角)</li>
<li>UI 层和游戏世界层分离(ui是用户界面,也就是游戏设置界面,如果要显示,一定是在游戏世界之上)</li>
<li>后处理效果(一个相机渲染场景,另一个相机将渲染结果应用到屏幕上,并添加后处理效果,如模糊、色彩校正,目的是实现复杂的效果)</li>
<li>深度图和阴影图生成(一个相机正常渲染,另一个相机渲染深度图和阴影图,实现光照和阴影效果)</li>
<li>小地图或镜像</li>
</ul>
<p>多相机可以创建更加丰富和复杂的游戏体验.</p>
<h2 id="ui-rendering"><a class="header" href="#ui-rendering">UI Rendering</a></h2>
<p>Bevy UI rendering is integrated into the cameras! Every camera will, by default,
also draw UI.</p>
<p>However, if you are working with multiple cameras, you probably only want your
UI to be drawn once (probably by the main camera). You can disable UI rendering
on your other cameras.</p>
<p>Also, UI on multiple cameras is currently broken in Bevy. Even if you want
multiple UI cameras (say, to display UI in an app with multiple windows), it
does not work correctly.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle::default(),
    // UI config is a separate component
    UiCameraConfig {
        show_ui: false,
    },
    MyExtraCamera,
));</code></pre>
<p>ui渲染已经集成到相机中了,所以在相机中就能使用ui.
如果是多相机模式,大部分场景下,我们只需要一个ui显示在主相机中.</p>
<p>另外bevy现在在多相机中显示ui的功能有坏损,即使想这么干,也会运行异常.</p>
<hr />
<p>bevy的ui是一个框架,ui中包含按钮/图片/文本/布局,基于ECS实现的.主要包含以下元素.</p>
<ul>
<li>节点(Node):定义 UI 元素的大小和位置.节点是所有 UI 元素的基础组件.</li>
<li>样式(Style):定义 UI 元素的布局和对齐方式,包括大小、位置、边距、填充等.</li>
<li>颜色(Color):定义 UI 元素的背景颜色.</li>
<li>文本(Text):显示文字内容,可以设置字体、大小、颜色等属性.</li>
<li>图片(Image):显示图片内容.</li>
<li>交互(Interaction):用于处理用户交互,如点击和悬停.</li>
</ul>
<p>ui常用于以下场景:</p>
<ul>
<li>主菜单和设置界面：创建游戏的主菜单、选项菜单和设置界面,允许玩家选择游戏模式、调整音量、设置图像质量等.</li>
<li>HUD（Heads-Up Display）：显示游戏中的实时信息,例如玩家的生命值、分数、剩余时间、弹药数量等.</li>
<li>对话框和提示：展示游戏中的对话、任务提示、提示信息等.</li>
<li>交互界面：创建按钮、滑块、复选框等交互元素,允许玩家与游戏进行互动.</li>
<li>信息面板和统计数据：显示详细信息和统计数据,例如角色属性、物品描述、战斗结果等.</li>
<li>暂停菜单：在游戏过程中允许玩家暂停游戏,并显示暂停菜单,提供继续游戏、退出游戏等选项.</li>
</ul>
<p>也可以基于ui做游戏:</p>
<ul>
<li>卡牌游戏：例如扑克牌、纸牌游戏等,可以通过 UI 系统创建卡牌、牌堆、按钮等元素,实现拖拽、点击等交互.</li>
<li>棋盘游戏：例如国际象棋、围棋等,可以通过 UI 系统创建棋盘、棋子,并处理玩家的点击和移动操作.</li>
<li>文字冒险游戏：通过 UI 系统创建文本对话框、选择按钮等,玩家可以通过选择不同的选项推动故事发展.</li>
<li>点击游戏：例如点击模拟器,通过 UI 系统创建按钮、计分板等元素,玩家通过点击按钮进行游戏.</li>
</ul>
<h2 id="disabling-cameras"><a class="header" href="#disabling-cameras">Disabling Cameras</a></h2>
<p>You can deactivate a camera without despawning it. This is useful when you want
to preserve the camera entity and all the configuration it carries, so you can
easily re-enable it later.</p>
<p>Some example use cases: toggling an overlay, switching between a 2D and 3D view.</p>
<pre><code class="language-rust no_run noplayground">fn toggle_overlay(
    mut q: Query&lt;&amp;mut Camera, With&lt;MyOverlayCamera&gt;&gt;,
) {
    let mut camera = q.single_mut();
    camera.is_active = !camera.is_active;
}</code></pre>
<p>可以在不销毁相机实体的情况下,<code>停用</code>.保留相机实体以及配置,方便后面重用.</p>
<p>有些例子是通过开关控制2d/3d的切换,反复切换中,<code>停用</code>就很好用.</p>
<h2 id="multiple-cameras"><a class="header" href="#multiple-cameras">Multiple Cameras</a></h2>
<p>This is an overview of different scenarios where you would need more than one
camera entity.</p>
<p>下面是需要使用多相机的场景.</p>
<h3 id="multiple-windows"><a class="header" href="#multiple-windows">Multiple Windows</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/window/multiple_windows.rs"><code>multiple_windows</code></a>.</p>
<p>If you want to create a Bevy app with multiple windows, you need to spawn
multiple cameras, one for each window, and set their render targets
respectively. Then, you can use your cameras to control what to display in each
window.</p>
<p>多窗口必须要要多相机.</p>
<h3 id="split-screen"><a class="header" href="#split-screen">Split-Screen</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/3d/split_screen.rs"><code>split_screen</code></a>.</p>
<p>You can set the camera <a href="graphics/camera.html#viewport">viewport</a> to only render to a part of the
render target. This way, a camera can be made to render one half of the screen
(or any other area). Use a separate camera for each view in a split-screen game.</p>
<p>分屏.相机只渲染到渲染对象的一部分区域.</p>
<h3 id="overlays"><a class="header" href="#overlays">Overlays</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/3d/two_passes.rs"><code>two_passes</code></a>.</p>
<p>You might want to render multiple "layers" (passes) to the same render target.
An example of this might be an overlay/HUD to be displayed on top of the
main game.</p>
<p>The overlay camera could be completely different from the main camera. For
example, the main camera might draw a 3D scene, and the overlay camera might
draw 2D shapes. Such use cases are possible!</p>
<p>Use a separate camera to create the overlay. Set the <a href="graphics/camera.html#priority">priority</a>
higher, to tell Bevy to render it after (on top of) the main camera. Make sure
to disable <a href="graphics/camera.html#clear-color">clearing</a>!</p>
<p>Think about which camera you want to be responsible for <a href="graphics/camera.html#ui-rendering">rendering the
UI</a>. Use the overlay camera if you want it to be unaffected,
or use the main camera if you want the overlay to be on top of the UI. Disable
it on the other camera.</p>
<p>Use <a href="graphics/camera.html#render-layers">Render Layers</a> to control what entities should be rendered
by each camera.</p>
<p>覆盖.游戏顶部的覆盖层,是另一个相机做的渲染,因为在顶部,还有个名词HUD(抬头显).</p>
<p>覆盖相机和主相机很不一样,主相机可能是3d游戏,覆盖相机大多是2d的.</p>
<p>多个相机覆盖时,要确保顺序更高的相机要禁止清理背景色.</p>
<p>思考一下,ui应该通过那个相机显示:</p>
<ul>
<li>如果想不受影响,使用覆盖相机</li>
<li>如果想做成hud,使用主相机,并在其他相机中disabe ui</li>
</ul>
<p>用渲染分层来控制每个相机要渲染的实体.</p>
<h3 id="render-to-image"><a class="header" href="#render-to-image">Render to Image</a></h3>
<p>(aka Render to Texture)</p>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/3d/render_to_texture.rs"><code>render_to_texture</code></a>.</p>
<p>If you want to generate an image in memory, you can output to an <code>Image</code> asset.</p>
<p>This is useful for intermediate steps in games, such as rendering a minimap or
the gun in a shooter game. You can then use that image as part of the final
scene to render to the screen. Item previews are a similar use case.</p>
<p>Another use case is window-less applications that want to generate image files.
For example, you could use Bevy to render something, and then export it to a PNG
file.</p>
<p>渲染到Image,也称作渲染到纹理.</p>
<p>如果在内存中生成了一张图,可以输出到Image的资产中.
这对于游戏中的中间步骤非常有用,例如在射击游戏中渲染小地图或枪.
然后,您可以使用该图像作为最终场景的一部分渲染到屏幕上.物品预览是一个类似的用例.</p>
<p>另一个场景是生成图片,eg:到处一张png图片.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="hdr"><a class="header" href="#hdr">HDR</a></h1>
<p>HDR (High Dynamic Range) refers to the ability of the game engine to handle
very bright lights or colors. Bevy's rendering is HDR internally. This means
you can have objects with colors that go above <code>1.0</code>, very bright lights,
or bright emissive materials. All of this is supported for both 3D and 2D.</p>
<p>This is not to be confused with HDR display output, which is the ability to
produce a HDR image to be displayed by a modern monitor or TV with HDR
capabilities. Bevy has no support for this yet.</p>
<p>The internal HDR image has to be converted down to SDR (Standard Dynamic
Range) before it can be displayed on the screen. This process is called
<a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a>. Bevy supports different algorithms that can
result in a different look. It is an artistic choice what tonemapping
algorithm to use for your game.</p>
<p>HDR(高动态范围)是指游戏引擎处理非常明亮的灯光或颜色的能力.
bevy内部渲染支持hdr,也就是说对象的颜色可调节到1.0之上,非常亮的那种,
灯光/发光材质均如此.2d/3d均支持.</p>
<p>这里的hdr不是hdr显示输出(生成 HDR 图像并由具有 HDR 功能的现代显示器或电视显示的能力),
bevy还不支持hdr显示输出.</p>
<p>在屏幕显示之前,内部的hdr会转换称标准动态范围(sdr)这个处理过程成为<code>色调映射</code>.
bevy支持多种<code>色调映射</code>算法,看起来都不一样,选哪一种需要尝试一二.</p>
<h2 id="camera-hdr-configuration"><a class="header" href="#camera-hdr-configuration">Camera HDR configuration</a></h2>
<p>There is a per-camera toggle that lets you decide whether you want Bevy to
preserve the HDR data internally, to make it possible for subsequent passes
(such as postprocessing effects) to use it.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle {
        camera: Camera {
            hdr: true,
            ..default()
        },
        ..default()
    },
));</code></pre>
<p>If it is enabled, Bevy's intermediate textures will be in HDR format. The
shaders output HDR values and Bevy will store them, so they can be used in later
rendering passes. This allows you to enable effects like <a href="graphics//graphics/bloom.html">Bloom</a>,
that make use of the HDR data. <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> will happen as a
post-processing step, after the HDR data is no longer needed for anything.</p>
<p>If it is disabled, the shaders are expected to output standard RGB colors in
the 0.0 to 1.0 range. <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> happens in the shader. The
HDR information is not preserved. Effects that require HDR data, like Bloom,
will not work.</p>
<p>It is disabled by default, because this results in better performance and
reduced VRAM usage for applications with simple graphics that do not need it.</p>
<p>If you have both HDR and MSAA enabled, it is possible you might encounter
issues. There might be visual artifacts in some cases. It is also unsupported on
Web/WASM, crashing at runtime. Disable MSAA if you experience any such issues.</p>
<p>相机的hdr配置.如果启用,中间的纹理将启用hdr格式,着色器输出dhr值,由bevy存储,
并进行后续的渲染操作.bloom特效就使用到了这些hdr数据.
当后续操作不再使用hdr数据时,色调映射就会将hdr转换为sdr,作为后处理的一部分.</p>
<p>如果不启用hdr,着色器输出的颜色就是[0.0,1.0],色调映射在着色器就完成了.
bevy也不会存储hdr数据,依赖hdr数据的特效(eg:bloom盛开的效果)就不起作用.</p>
<p>hdr默认是disabled的.因为简单一点的程序并不需要,且可以减少内存使用,性能也高一点.
追求高质量效果的,可以添加上dhr.</p>
<p>hdr和msaa(多重抗锯齿)同时使用会导致问题(视觉残影);
hdr+msaa还不支持wasm/web(这两个平台会导致panic),
如果出现异常,建议disable msaa.</p>
<h2 id="tonemapping"><a class="header" href="#tonemapping">Tonemapping</a></h2>
<p>Tonemapping is the step of the rendering process where the colors of pixels are
converted from their in-engine intermediate repesentation into the final values
as they should be displayed on-screen.</p>
<p>This is very important with HDR applications, as in that case the image can
contain very bright pixels (above 1.0) which need to be remapped into a range
that can be displayed.</p>
<p>Tonemapping is enabled by default. Bevy allows you to configure it via the
(<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/tonemapping/enum.Tonemapping.html"><code>Tonemapping</code></a>) component, per-camera. Disabling it is not
recommended, unless you know you only have very simple graphics that don't need
it. It can make your graphics look incorrect.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::Tonemapping;

commands.spawn((
    Camera3dBundle {
        // no tonemapping
        tonemapping: Tonemapping::None,
        ..default()
    },
));
commands.spawn((
    Camera3dBundle {
        // this is the default:
        tonemapping: Tonemapping::TonyMcMapface,
        ..default()
    },
));
commands.spawn((
    Camera3dBundle {
        // another common choice:
        tonemapping: Tonemapping::ReinhardLuminance,
        ..default()
    },
));</code></pre>
<p>Bevy supports many different tonemapping algorithms. Each of them results in a
different look, affecting colors and brightness. It can be an artistic choice. You
can decide what algorithm looks best for your game. Bevy's default is TonyMcMapface,
which, despite the silly name, provides very good results for a wide variety of
graphics styles. See the (<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/tonemapping/enum.Tonemapping.html"><code>Tonemapping</code></a>) documentation for
an explanation of each of the available choices.</p>
<p>Some tonemapping algorithms (incl. the default TonyMcMapface) require the
<code>tonemapping_luts</code> <a href="graphics//setup/bevy-config.html">cargo feature</a>. It is enabled by default. Be
sure to re-enable it if you disable default features and you need it. Enabling
it also enables the <code>ktx2</code> and <code>zstd</code> features, because it works by embedding
special data in KTX2 format into your game, which is used during tonemapping.</p>
<p>The following tonemapping algorithms <em>DO NOT</em> require the special data from
<code>tonemapping_luts</code>:</p>
<ul>
<li>Reinhard</li>
<li>ReinhardLuminance</li>
<li>AcesFitted</li>
<li>SomewhatBoringDisplayTransform</li>
</ul>
<p>The following tonemapping algorithms <em>require</em> the special data from <code>tonemapping_luts</code>:</p>
<ul>
<li>AgX</li>
<li>TonyMcMapface</li>
<li>BlenderFilmic</li>
</ul>
<p>If you want to make a smaller game binary (might be important for Web games),
you could reduce bloat by changing the default tonemapping to something
simpler and disabling the <a href="graphics//setup/bevy-config.html">cargo features</a>.</p>
<p>色调映射是渲染过程中其中一个步骤,
负责将bevy引擎的像素颜色(中间表示形式)转换为屏幕最终渲染的状态.</p>
<p>对于hdr来说,色调映射尤为重要,因为hdr的颜色都太亮了,必须重新映射为sdr才能显示.
色调映射默认已经开启了,bevy通过Tonemapping组件来配置色调映射,
每个相机都可以配置,不推荐disable,除非我们的图形非常简单.</p>
<p>bevy支持多重色调映射算法,不同的算法对颜色和亮度的影响不同.按需选择.
默认是<code>TonyMcMapface</code>. 部分算法依赖<code>tonemapping_luts</code>功能,这个功能是默认开启的.
如果禁用了DefaultPlugins,记得re-enable这个功能.这个功能还启用了ktx2/zstd的支持,
因为它的工作原理是将KTX2格式的特殊数据嵌入到游戏中,在色调映射过程中使用.</p>
<p>依赖<code>tonemapping_luts</code>的算法包括:默认的<code>TonyMcMapface</code>,以及<code>Agx</code>和<code>BlenderFilmic</code>.
如果对程序大小特别敏感的,可以换成其他算法,然后禁用<code>tonemapping_luts</code>功能.</p>
<hr />
<p>色调映射是一个着色器,尝试将线性输入刺激映射到给定相机实体的感知均匀的图像中.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Tonemapping {
    None,
    Reinhard,
    ReinhardLuminance,
    AcesFitted,
    AgX,
    SomewhatBoringDisplayTransform,
    TonyMcMapface,
    BlenderFilmic,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="color-grading"><a class="header" href="#color-grading">Color Grading</a></h2>
<p>Color Grading is a manipulation of the overall look of the image.</p>
<p>Together with tonemapping, this affects the "tone"/"mood" of the final image.</p>
<p>This is also how you can implement a "retina" effect, where the camera
dynamically adapts to very dark (such as inside a cave) and very bright
(such as in daylight) scenes, by adjusting exposure/gamma.</p>
<p>You can also adjust color saturation. Heavily desaturating the image can
result in a greyscale or muted appearance, which can be a great artistic
choice for apocalyptic or horror games.</p>
<p>You can configure these parameters via the <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.ColorGrading.html"><code>ColorGrading</code></a>
component:</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::ColorGrading;

commands.spawn((
    Camera3dBundle {
        color_grading: ColorGrading {
            exposure: 0.0,
            gamma: 1.0,
            pre_saturation: 1.0,
            post_saturation: 1.0,
        },
        ..default()
    },
));</code></pre>
<p>颜色分级是对图像整体外观的处理,常配合色调映射一起使用.</p>
<p>这也是实现“视网膜”效果的方法,
其中相机通过调整曝光/伽玛动态适应非常黑暗(例如在洞穴内)和非常明亮(例如在日光下)的场景.</p>
<p>还可以调整颜色饱和度.严重降低图像的饱和度可能会导致灰度或柔和的外观,
这对于世界末日或恐怖游戏来说是一个很好的艺术选择.</p>
<p>通过ColorGrading组件来配置颜色分级的参数.</p>
<hr />
<p>Retina 效果指的是苹果公司在其设备上使用的一种高分辨率显示技术,
目的是使屏幕上的像素密度达到或超过人眼在正常视距下无法分辨的程度,
从而提供更清晰/更细腻的显示效果.</p>
<p>Retina 显示技术本身并不直接涉及自动调节曝光(exposure)或伽马(gamma)值.
True Tone 显示:这种技术使用多个传感器来监测周围环境光线的颜色和亮度,
然后自动调整显示屏的白平衡和色温,使屏幕颜色看起来更自然.</p>
<h2 id="deband-dithering"><a class="header" href="#deband-dithering">Deband Dithering</a></h2>
<p>Deband dithering helps color gradients or other areas with subtle changes in
color to appear higher-quality, without a "color banding" effect.</p>
<p>It is enabled by default, and can be disabled per-camera.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::DebandDither;

commands.spawn((
    Camera3dBundle {
        dither: DebandDither::Disabled,
        ..default()
    },
));</code></pre>
<p>Here is an example image without dithering (top) and with dithering (bottom).
Pay attention to the quality/smoothness of the green color gradient on the
ground plane. In games with photorealistic graphics, similar situations can
arise in the sky, in dark rooms, or lights glowing with a bloom effect.</p>
<p><img src="graphics/../img/dithering.png" alt="Visual comparison of a scene simple cube on a flat green plane, with dithering disabled/enabled." /></p>
<p>去色带抖动有助于颜色渐变或其他颜色发生细微变化的区域显得更高质量,而不会出现“色带”效果.</p>
<p>去色带抖动是通过组件DebandDither来配置的.</p>
<p>上图是这是没有抖动（顶部）和有抖动（底部）的示例图像.
请注意地面上的绿色渐变的质量/平滑度.
在具有逼真图形的游戏中,天空/黑暗的房间或具有绽放效果的灯光中也会出现类似的情况.</p>
<hr />
<p>Deband 和 Dithering 是图像处理中的两个技术,用于不同的目的.</p>
<p>Debanding 是一种减少或消除图像中颜色条纹（banding）现象的技术.
颜色条纹是指在颜色渐变区域中,由于颜色深度不足而产生的明显色带.
这种现象通常出现在具有平滑渐变的区域,如天空/阴影或渐变背景中.</p>
<p>Debanding 技术通过在图像中引入微小的颜色变化,打破这些明显的色带,
从而使颜色过渡看起来更加平滑和自然.</p>
<p>Dithering 是一种通过引入伪随机噪声来模拟更多颜色和灰度级别的技术,
特别是在颜色深度较低的情况下.
Dithering 的目的是通过在相邻像素间引入细微的颜色变化,
使得整体效果看起来更加平滑,减少颜色量化引起的视觉伪影.</p>
<p>在一些场景中,debanding 和 dithering 可以结合使用.
首先,应用 debanding 技术消除明显的颜色条纹,
然后通过 dithering 技术进一步平滑颜色过渡,模拟更多的颜色和灰度级别.</p>
<p>总结</p>
<p>Debanding:用于减少或消除图像中的颜色条纹现象,使颜色过渡更加平滑.<br />
Dithering:通过引入伪随机噪声模拟更多颜色和灰度级别,减少颜色量化引起的伪影.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bloom"><a class="header" href="#bloom">Bloom</a></h1>
<p>The "Bloom" effect creates a glow around bright lights. It is not a
physically-accurate effect, though it is inspired by how light looks through
a dirty or imperfect lens.</p>
<p>Bloom does a good job of helping the perception of very bright light,
especially when outputting HDR to the display hardware is not supported.
Your monitor can only display a certain maximum brightness, so Bloom is a
common artistic choice to try to convey light intensity brighter than can
be displayed.</p>
<p>Bloom looks best with a <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> algorithm that desaturates
very bright colors. Bevy's default is a good choice.</p>
<p>Bloom requires <a href="graphics//graphics/hdr-tonemap.html">HDR mode</a> to be enabled on your camera. Add the
<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/bloom/struct.BloomSettings.html"><code>BloomSettings</code></a> component to the camera to enable
bloom and configure the effect.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::bloom::BloomSettings;

commands.spawn((
    Camera3dBundle {
        camera: Camera {
            hdr: true,
            ..default()
        },
        ..default()
    },
    BloomSettings::NATURAL,
));</code></pre>
<p>bloom(绽放)效果会在明亮的灯光周围产生辉光.
尽管它的灵感来自光线透过肮脏或不完美的镜头的样子,但它并不是物理上精确的效果.</p>
<p>bloom 可以很好地帮助人们感知非常明亮的光线,
尤其是在不支持将 HDR 输出到显示硬件的情况下.
您的显示器只能显示特定的最大亮度,因此 Bloom 是一种常见的艺术选择,
可以尝试传达比可显示的更亮的光强度.</p>
<p>bloom一般配合色调映射一起使用,能对非常明亮的光纤<code>去饱和</code>,
bevy默认的色调映射算法就是很好的选择.</p>
<p>bloom是通过BloomSettings组件启用的,bloom是依赖hdr的.
hdr默认是disabled的,要使用bloom就需要打开hdr.</p>
<h2 id="bloom-settings"><a class="header" href="#bloom-settings">Bloom Settings</a></h2>
<p>Bevy offers many parameters to tweak the look of the bloom effect.</p>
<p>The default mode is "energy-conserving", which is closer to how real light
physics might behave. It tries to mimic the effect of light scattering,
without brightening the image artificially. The effect is more subtle and "natural".</p>
<p>There is also an "additive" mode, which will brighten everything and make it feel
like bright lights are "glowing" unnaturally. This sort of effect is quite common
in many games, especially older games from the 2000s.</p>
<p>Bevy offers three bloom "presets":</p>
<ul>
<li><code>NATURAL</code>: energy-conerving, subtle, natural look.</li>
<li><code>OLD_SCHOOL</code>: "glowy" effect, similar to how older games looked.</li>
<li><code>SCREEN_BLUR</code>: very intense bloom that makes everything look blurred.</li>
</ul>
<p>You can also create an entirely custom configuration by tweaking all the
parameters in <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/bloom/struct.BloomSettings.html"><code>BloomSettings</code></a> to your taste. Use the
presets for inspiration.</p>
<p>Here are the settings for the Bevy presets:</p>
<pre><code class="language-rust no_run noplayground">// NATURAL
BloomSettings {
    intensity: 0.15,
    low_frequency_boost: 0.7,
    low_frequency_boost_curvature: 0.95,
    high_pass_frequency: 1.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.0,
        threshold_softness: 0.0,
    },
    composite_mode: BloomCompositeMode::EnergyConserving,
};

// OLD_SCHOOL
BloomSettings {
    intensity: 0.05,
    low_frequency_boost: 0.7,
    low_frequency_boost_curvature: 0.95,
    high_pass_frequency: 1.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.6,
        threshold_softness: 0.2,
    },
    composite_mode: BloomCompositeMode::Additive,
};

// SCREEN_BLUR
BloomSettings {
    intensity: 1.0,
    low_frequency_boost: 0.0,
    low_frequency_boost_curvature: 0.0,
    high_pass_frequency: 1.0 / 3.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.0,
        threshold_softness: 0.0,
    },
    composite_mode: BloomCompositeMode::EnergyConserving,
};</code></pre>
<p>bevy 提供了许多参数来调整光晕效果的外观.
默认效果是<code>energy-conserving</code>,这更接近真实光物理的表现.
它试图模仿光散射的效果,而不人为地使图像变亮.效果更加微妙和“自然”.</p>
<p>另一种效果是<code>additive</code>,这会照亮一切,让人感觉明亮的灯光不自然地发光.
这种效果在许多游戏中都很常见,尤其是 2000 年代的老游戏.</p>
<p>bevy提供3种默认配置:</p>
<ul>
<li>NATURAL, 看起来是自然的, <code>energy-conserving</code></li>
<li>OLD_SCHOOL, 发光效果, 和以前的老游戏类似</li>
<li>SCREEN_BLUR, 非常强烈的绽放,让一切看起来都很模糊.</li>
</ul>
<p>不喜欢预设的可以自己调节.</p>
<hr />
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum BloomCompositeMode {
    EnergyConserving,
    Additive,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="visualization"><a class="header" href="#visualization">Visualization</a></h2>
<p>Here is an example of Bloom in 3D:</p>
<p><img src="graphics/../img/bloom_3d.png" alt="The Bloom effect on street lamps." /></p>
<p>And here is a 2D example:</p>
<p><img src="graphics/../img/bloom_2d.png" alt="The Bloom effect on a simple hexagon." /></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-2d"><a class="header" href="#bevy-2d">Bevy 2D</a></h1>
<p>This chapter covers topics relevant to making 2D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="2d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="2d-camera-setup"><a class="header" href="#2d-camera-setup">2D Camera Setup</a></h1>
<p><a href="2d//graphics/camera.html">Cameras</a> in Bevy are mandatory to see anything: they configure the
rendering.</p>
<p>This page will teach you about the specifics of 2D cameras. If you want to learn about
general non-2D specific functionality, see the <a href="2d//graphics/camera.html">general page on cameras</a>.</p>
<p>bevy中, 必须使用相机来看一切东西, 因为相机配置着渲染</p>
<h2 id="creating-a-2d-camera"><a class="header" href="#creating-a-2d-camera">Creating a 2D Camera</a></h2>
<p>Bevy provides a <a href="2d//programming/bundle.html">bundle</a> (<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>)
that you can use to <a href="2d//programming/commands.html">spawn</a> a camera <a href="2d//programming/ec.html#entities">entity</a>. It
has reasonable defaults to set up everything correctly.</p>
<p>You might want to set the <a href="2d//fundamentals/transforms.html">transform</a>, to position the camera.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyCameraMarker;

fn setup_camera(mut commands: Commands) {
    commands.spawn((
        Camera2dBundle {
            transform: Transform::from_xyz(100.0, 200.0, 0.0),
            ..default()
        },
        MyCameraMarker,
    ));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup_camera)
        .run();
}</code></pre>
<p><code>Camera2dBundle</code>就是用于生成2d相机实体的,构造时就能指定相机的位置和变换.</p>
<h2 id="projection-1"><a class="header" href="#projection-1">Projection</a></h2>
<p>The <a href="2d//graphics/camera.html#projection">projection</a> is what determines how coordinates map to the
<a href="2d//graphics/camera.html#viewport">viewport</a> (commonly, the screen/window).</p>
<p>2D cameras always use an Orthographic projection.</p>
<p>When you spawn a 2D camera using <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>,
it adds the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a>
<a href="2d//programming/ec.html#components">component</a> to your <a href="2d//programming/ec.html#entities">entity</a>. When
you are working with 2D cameras and you want to access
the projection, you should <a href="2d//programming/queries.html">query</a> for
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn debug_projection(
    query_camera: Query&lt;&amp;OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let projection = query_camera.single();
    // ... do something with the projection
}</code></pre>
<p>Note that this is different from <a href="2d//3d/camera.html#projection">3D</a>. If you are
making a library or some other code that should be able to handle both 2D and
3D, you cannot make a single <a href="2d//programming/queries.html">query</a> to access both 2D and 3D
cameras. You should create separate <a href="2d//programming/systems.html">systems</a>, or at least two
separate queries, to handle each kind of camera. This makes sense, as you will
likely need different logic for 2D vs. 3D anyway.</p>
<p>投影决定了世界的坐标系统如何映射到视窗(通常是屏幕或窗口).
2d游戏总是使用正交投影.Camera2dBundle中自动包含了OrthographicProjection,
如果要在过程中访问正交投影的值,直接在query中访问<code>OrthographicProjection</code>即可.</p>
<p>3d中的处理有些差异.具体说如果我们写一个lib,需要处理好2d/3d的不同,
主要是没法通过单个query查到2d/3d相机中的正交投影,
要么是分成不同的system,要么是使用两个单独的query.
这是有道理的,因为无论如何您可能需要不同的 2D 与 3D 逻辑.</p>
<h3 id="caveat-nearfar-values"><a class="header" href="#caveat-nearfar-values">Caveat: near/far values</a></h3>
<p>The projection contains the <code>near</code> and <code>far</code> values, which indicate the minimum
and maximum Z coordinate (depth) that can be rendered, relative to the position
(<a href="2d//fundamentals/transforms.html">transform</a>) of the camera.</p>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a> sets them appropriately for 2D:
<code>-1000.0</code> to <code>1000.0</code>, allowing entities to be displayed on both positive and
negative Z coordinates. However, if you create the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> yourself, to change any
other settings, you need to set these values yourself. The default value of the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> struct is designed for
3D and has a <code>near</code> value of <code>0.0</code>, which means you might not be able to see
your 2D entities.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera2dBundle {
        projection: OrthographicProjection {
            // don't forget to set `near` and `far`
            near: -1000.0,
            far: 1000.0,
            // ... any other settings you want to change ...
            ..default()
        },
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p>A more foolproof way to go about this is to use a temporary variable, to let the
bundle do its thing, and then mutate whatever you want. This way, you don't have
to worry about the exact values or getting anything wrong:</p>
<pre><code class="language-rust no_run noplayground">let mut camera_bundle = Camera2dBundle::default();
// change the settings we want to change:
camera_bundle.projection.scale = 2.0;
camera_bundle.transform.rotate_z(30f32.to_radians());
// ...

commands.spawn((
    camera_bundle,
    MyCameraMarker,
));</code></pre>
<p>远近.正价投影不会应为远近有大小之分.投影的near/far值仅仅表示z轴的值,
表示离相机的距离.Camera2dBundle将这两个值设置为-1000.0和1000.0,
在这个范围内的实体都可以参与渲染.
(之前说的渲染过滤超过1000个单位就不显示了,这个阈值来至这里.)</p>
<p>如果是自己创建正交投影组件,就需要注意这些值的设置,
正交投影是为3d相机而设计的,这个结构体的near字段默认值是0,
也就是说如果在2d相机中,如果不设置near,就不会看到任何实体.</p>
<p>如果怕丢, 就将正交投影组件的值放在一个临时变量中,所有的2d相机都使用这个,
这样就不用担心在相机内部设置时少了设置.</p>
<h3 id="scaling-mode"><a class="header" href="#scaling-mode">Scaling Mode</a></h3>
<p>You can set the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> according to how you want to
handle window size / resolution.</p>
<p>The default for Bevy 2D cameras is to have 1 screen pixel correspond to 1 world
unit, thus allowing you to think of everything in "pixels". When the window is
resized, that causes more or less content to be seen.</p>
<p>If you want to keep this window resizing behavior, but change the mapping of screen
pixels to world units, use <code>ScalingMode::WindowSize(x)</code> with a value other than <code>1.0</code>.
The value represents the number of screen pixels for one world unit.</p>
<p>If, instead, you want to always fit the same amount of content
on-screen, regardless of resolution, you should use something like
<code>ScalingMode::FixedVertical</code> or <code>ScalingMode::AutoMax</code>. Then, you can directly
specify how many units you want to display on-screen, and your content will
be upscaled/downscaled as appropriate to fit the window size.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ScalingMode;

let mut my_2d_camera_bundle = Camera2dBundle::default();
// For this example, let's make the screen/window height correspond to
// 1600.0 world units. The width will depend on the aspect ratio.
my_2d_camera_bundle.projection.scaling_mode = ScalingMode::FixedVertical(1600.0);
my_2d_camera_bundle.transform = Transform::from_xyz(100.0, 200.0, 0.0);

commands.spawn((
    my_2d_camera_bundle,
    MyCameraMarker,
));</code></pre>
<p>根据对窗口大小/分辨率的处理,可以设置<code>ScalingMode</code>缩放模式.
2d相机默认1屏幕像素对应1个世界单位,这样窗口大小的改变会直接影响看到世界的大小.</p>
<p>如果想在改变窗口大小的同时还是能看到同样的世界,
<code>ScalingMode::WindowSize(x)</code>中的x就不能设置为1.0.
<code>ScalingMode::FixedVertical</code>或<code>ScalingMode::AutoMax</code>能保持原窗口看到的世界.
也可以直接指定要看到的世界的尺寸,或者将内容进行缩放到时和窗口大小.</p>
<hr />
<p>正交投影下的缩放模式.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ScalingMode {
    // Fixed 手动直接投影大小,忽略窗口resize,图像拉伸,参数为世界单位.
    Fixed {
        width: f32,
        height: f32,
    },
    // 指定视窗大小,参数是一个世界单位等于多少像素.
    WindowSize(f32),
    // 保持宽高比,要满足最小限制,单位是世界单位.
    AutoMin {
        min_width: f32,
        min_height: f32,
    },
    // 和AutoMin类似,要满足最大限制.
    AutoMax {
        max_width: f32,
        max_height: f32,
    },
    // 保持宽高比,宽度调整,高度不变,参数是投影所需的高度,世界单位.
    FixedVertical(f32),
    // 高度调整.
    FixedHorizontal(f32),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="zooming"><a class="header" href="#zooming">Zooming</a></h3>
<p>To "zoom" in 2D, you can change the orthographic projection's <code>scale</code>. This
allows you to just scale everything by some factor, regardless of the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> behavior.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_scale(
    mut query_camera: Query&lt;&amp;mut OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let mut projection = query_camera.single_mut();
    // zoom in
    projection.scale /= 1.25;
    // zoom out
    projection.scale *= 1.25;
}</code></pre>
<p>Alternatively, you can reconfigure the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a>. This
way you can be confident about how exactly coordinates/units map to the
screen. This also helps avoid scaling artifacts with 2D assets, especially
pixel art.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_scalingmode(
    mut query_camera: Query&lt;&amp;mut OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    use bevy::render::camera::ScalingMode;

    let mut projection = query_camera.single_mut();
    // 4 screen pixels to world/game pixel
    projection.scaling_mode = ScalingMode::WindowSize(4.0);
    // 6 screen pixels to world/game pixel
    projection.scaling_mode = ScalingMode::WindowSize(6.0);
}</code></pre>
<p>Consider having a list of predefined "zoom levels" / scale values, so that you
can make sure your game always looks good.</p>
<p>If you are making a pixel-art game, you want to make sure the default texture
filtering mode is set to Nearest (and not Linear), if you want your pixels
to appear crisp instead of blurry:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(
            DefaultPlugins
                .set(ImagePlugin::default_nearest())
        )
        // ...
        .run();
}</code></pre>
<p>However, when <em>downscaling</em>, Linear (the default) filtering is preferred
for higher quality. So, for games with high-res assets, you want to leave
it unchanged.</p>
<p>聚焦,通过正交投影的scale来改变,在2d相机中,可以将所有事物按同样的缩放因子进行缩放.
zoom和ScalingMode互不影响.两者都对缩放有影响,选择其中一种即可.</p>
<p>使用zoom可以有效防止2d资产在缩放过程产生残影.</p>
<p>在游戏中设置一个预定义的缩放表,游戏看起来会更好.</p>
<p>如果您正在制作像素艺术游戏,并且希望像素显得清晰而不是模糊,
则需要确保将默认纹理过滤模式设置为<code>最近</code>(而不是<code>线性</code>).
但是,在缩小尺寸时,首选线性(默认)过滤以获得更高的质量.
因此,对于具有高分辨率资源的游戏,您希望保持其不变.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="2d//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="sprites-and-atlases"><a class="header" href="#sprites-and-atlases">Sprites and Atlases</a></h1>
<p>Page coming soon…</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<p>精灵和地图集.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-3d"><a class="header" href="#bevy-3d">Bevy 3D</a></h1>
<p>This chapter covers topics relevant to making 3D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="3d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="3d-camera-setup"><a class="header" href="#3d-camera-setup">3D Camera Setup</a></h1>
<p><a href="3d//graphics/camera.html">Cameras</a> in Bevy are mandatory to see anything: they configure the
rendering.</p>
<p>This page will teach you about the specifics of 3D cameras. If you want to learn about
general non-3D specific functionality, see the <a href="3d//graphics/camera.html">general page on cameras</a>.</p>
<h2 id="creating-a-3d-camera"><a class="header" href="#creating-a-3d-camera">Creating a 3D Camera</a></h2>
<p>Bevy provides a <a href="3d//programming/bundle.html">bundle</a> that you can use to <a href="3d//programming/commands.html">spawn</a> a
camera <a href="3d//programming/ec.html#entities">entity</a>. It has reasonable defaults to set up everything
correctly.</p>
<p>You might want to set the <a href="3d//fundamentals/transforms.html">transform</a>, to position the camera.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyCameraMarker;

fn setup_camera(mut commands: Commands) {
    commands.spawn((
        Camera3dBundle {
            transform: Transform::from_xyz(10.0, 12.0, 16.0)
                .looking_at(Vec3::ZERO, Vec3::Y),
            ..default()
        },
        MyCameraMarker,
    ));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup_camera)
        .run();
}</code></pre>
<p>The "looking at" function is an easy way to orient a 3D camera. The second
parameter (which we provide as <code>Y</code>) is the "up" direction. If you want the camera
to be tilted sideways, you can use something else there. If you want to make a
top-down camera, looking straight down, you need to use something other than <code>Y</code>.</p>
<p>构造3d相机和2d相机类似,推荐使用Camera3dBundle来构造实体.
<code>looking_at()</code>的第二个参数是角度.</p>
<h2 id="projection-2"><a class="header" href="#projection-2">Projection</a></h2>
<p>The <a href="3d//graphics/camera.html#projection">projection</a> is what determines how coordinates map to the
<a href="3d//graphics/camera.html#viewport">viewport</a> (commonly, the screen/window).</p>
<p>3D cameras can use either a Perspective or an Orthographic projection.
Perspective is the default, and most common, choice.</p>
<p>When you spawn a 3D camera using Bevy's <a href="3d//programming/bundle.html">bundle</a>
(<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera3dBundle</code></a>), it adds the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.Projection.html"><code>Projection</code></a> <a href="3d//programming/ec.html#components">component</a> to your
<a href="3d//programming/ec.html#entities">entity</a>, which is an <code>enum</code>, allowing either projection kind to be
used.</p>
<p>When you are working with 3D cameras and you want to access the projection, you
should <a href="3d//programming/queries.html">query</a> for the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>Projection</code></a>
<a href="3d//programming/ec.html#components">component</a> type. You can then match on the enum, to handle each
case appropriately.</p>
<pre><code class="language-rust no_run noplayground">fn debug_projection(
    query_camera: Query&lt;&amp;Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let projection = query_camera.single();
    match projection {
        Projection::Perspective(persp) =&gt; {
            // we have a perspective projection
        }
        Projection::Orthographic(ortho) =&gt; {
            // we have an orthographic projection
        }
    }
}</code></pre>
<p>Note that this is different from <a href="3d//2d/camera.html#projection">2D</a>. If you are
making a library or some other code that should be able to handle both 2D and
3D, you cannot make a single <a href="3d//programming/queries.html">query</a> to access both 2D and 3D
cameras. You should create separate <a href="3d//programming/systems.html">systems</a>, or at least two
separate queries, to handle each kind of camera. This makes sense, as you will
likely need different logic for 2D vs. 3D anyway.</p>
<p>投影决定了从窗口看到的东西,默认是透视投影,3d游戏大部分场合下都使用这个.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component, Debug, Clone, Reflect)]
#[reflect(Component, Default)]
pub enum Projection {
    Perspective(PerspectiveProjection),
    Orthographic(OrthographicProjection),
}

// 默认是透视投影.
impl Default for Projection {
    fn default() -&gt; Self {
        Projection::Perspective(Default::default())
    }
}

impl Default for Camera3dBundle {
    fn default() -&gt; Self {
        Self {
            camera_render_graph: CameraRenderGraph::new(Core3d),
            camera: Default::default(),
            projection: Default::default(),  // Camera3dBundle 的默认投影
            visible_entities: Default::default(),
            frustum: Default::default(),
            transform: Default::default(),
            global_transform: Default::default(),
            camera_3d: Default::default(),
            tonemapping: Default::default(),
            color_grading: Default::default(),
            exposure: Default::default(),
            main_texture_usages: Default::default(),
            deband_dither: DebandDither::Enabled,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果要在system中访问投影,query中查Projection即可.
和2d类似,如果同时存在2d相机和3d相机,一个查询是无法查到两个相机的,
需要2个query.</p>
<h3 id="perspective-projections"><a class="header" href="#perspective-projections">Perspective Projections</a></h3>
<p>Perspective creates a realistic sense of 3D space. Things appear smaller the
further away they are from the camera. This is how things appear to the human
eye, and to real-life cameras.</p>
<p>The most important variable here is the FOV (Field-of-View). The FOV determines
the strength of the perspective effect. The FOV is the angle covered by the
height of the screen/image.</p>
<p>A larger FOV is like a wide-angle camera lens. It makes everything appear more
distant, stretched, "zoomed out". You can see more on-screen.</p>
<p>A smaller FOV is like a telephoto camera lens. It makes everything appear closer
and flatter, "zoomed in". You can see less on-screen.</p>
<p>For reference, a good neutral value is 45° (narrower, Bevy default) or 60°
(wider). 90° is very wide. 30° is very narrow.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle {
        projection: PerspectiveProjection {
            // We must specify the FOV in radians.
            // Rust can convert degrees to radians for us.
            fov: 60.0_f32.to_radians(),
            ..default()
        }.into(),
        transform: Transform::from_xyz(10.0, 12.0, 16.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p><img src="3d/../img/camera-3d-fov.png" alt="Side-by-side comparison of different FOV values." /></p>
<p>In the above image, we are halving/doubling the FOV and doubling/halving
how far away the camera is positioned, to compensate. Note how you can see
pretty much the same 3D content, but the higher FOV looks more stretched
and has a stronger 3D perspective effect.</p>
<p>Internally, Bevy's perspective projection uses an <a href="https://developer.nvidia.com/content/depth-precision-visualized">infinite reversed
Z</a> configuration. This allows for good numeric
precision for both nearby and far away objects, avoiding visual artifacts.</p>
<p>透视投影,在3d游戏中更加逼真:远小近大.(和人眼看到的类似).</p>
<p>透视投影中重要的概念是FOV(视野,包含水平视野HFOV/垂直视野VFOV,常用VFOV),
FOV 是摄像机视锥体的一个角度,表示在摄像机镜头前方能够看到的最大视野范围.
FOV定义了相机能看到的空间范围.</p>
<p>bevy中的FOV就是指垂直视野.</p>
<p>FOV越大就越像广角镜头,这让一切显得更加遥远/拉长/缩小,这样可以看到更多东西.<br />
FOV越小就越像长焦镜头,这样一起显得更加近/平坦/方法,看到的东西也越少.</p>
<p>bevy默认是45度(良好),60度属于较宽,90度很宽,30度非常窄.</p>
<p>上图一个是45度+单位距离,一个是90度(45度的2倍)+半个单位距离,后者的3d效果更加明显.</p>
<p>在内部,Bevy 的透视投影使用(无限反向Z配置)(这是一个显卡技术).
这使得附近和远处的物体都具有良好的数值精度,避免了视觉伪影.</p>
<h4 id="zooming-1"><a class="header" href="#zooming-1">Zooming</a></h4>
<p>To "zoom", change the perspective projection's FOV.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_perspective(
    mut query_camera: Query&lt;&amp;mut Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    // assume perspective. do nothing if orthographic.
    let Projection::Perspective(persp) = query_camera.single_mut().into_inner() else {
        return;
    };
    // zoom in
    persp.fov /= 1.25;
    // zoom out
    persp.fov *= 1.25;
}</code></pre>
<p>If the camera does not move, decreasing the FOV makes everything appear closer
and increasing it makes everything appear more distant:</p>
<p><img src="3d/../img/camera-3d-fov-zoom.png" alt="Side-by-side comparison of a &quot;zoomed in&quot; (small FOV) and a &quot;zoomed out&quot; (large FOV) 3D scene" /></p>
<p>Contrast this with moving the camera itself (using the
<a href="3d//fundamentals/transforms.html">transform</a>) closer or further away, while keeping the FOV the
same:</p>
<p><img src="3d/../img/camera-3d-position.png" alt="Side-by-side comparison of a camera positioned nearer to vs. further away from a 3D scene" /></p>
<p>In some applications (such as 3D editors), moving the camera might be preferable,
instead of changing the FOV.</p>
<p>聚焦,就是改变透视投影的FOV值.
如果相机不移动,则减小 FOV 会使一切看起来更近,而增加 FOV 会使一切看起来更远.
bevy的透视聚焦和真实相机的焦距是一个效果.</p>
<p>真实相机聚焦是因为现实距离限制,但在软件中,距离不再是限制,有时移动比聚焦的效果会更好.</p>
<h3 id="orthographic-projections"><a class="header" href="#orthographic-projections">Orthographic Projections</a></h3>
<p>An Orthographic projection makes everything always look the same size,
regardless of the distance from the camera. It can feel like if 3D was squashed
down into 2D.</p>
<p>Orthographic is useful for applications such as CAD and engineering, where you
want to accurately represent the dimensions of an object. Some games (notably
simulation games) might use orthographic as an artistic choice.</p>
<p>Orthographic can feel confusing and unintuitive to some people, because it does
not create any sense of 3D space. You cannot tell how far away anything is. It
creates a perfectly "flat" look. When displayed from a top-down diagonal angle,
this artistic style is sometimes referred to as "isometric".</p>
<p>You should set the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> according to how you want
to handle window size / resolution.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ScalingMode;

commands.spawn((
    Camera3dBundle {
        projection: OrthographicProjection {
            // For this example, let's make the screen/window height
            // correspond to 16.0 world units.
            scaling_mode: ScalingMode::FixedVertical(16.0),
            ..default()
        }.into(),
        // the distance doesn't really matter for orthographic,
        // it should look the same (though it might affect
        // shadows and clipping / culling)
        transform: Transform::from_xyz(10.0, 12.0, 16.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p><img src="3d/../img/camera-3d-orthographic.png" alt="Visualization of a 3D scene with orthographic projection" /></p>
<h4 id="zooming-2"><a class="header" href="#zooming-2">Zooming</a></h4>
<p>To "zoom", change the orthographic projection's scale. The scale determines
how much of the scene is visible.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_orthographic(
    mut query_camera: Query&lt;&amp;mut Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    // assume orthographic. do nothing if perspective.
    let Projection::Orthographic(ortho) = query_camera.single_mut().into_inner() else {
        return;
    };
    // zoom in
    ortho.scale /= 1.25;
    // zoom out
    ortho.scale *= 1.25;
}</code></pre>
<p><img src="3d/../img/camera-3d-orthographic-zoom.png" alt="Side-by-side comparison of different orthographic projection scale in 3D" /></p>
<p>正交投影下,不管距离如何,东西看起来都是一样大.可以准备表示对象尺寸.
非常适合CAD领域(精确测量/工程图纸/零件设计等).</p>
<p>正交投影对于某些人来说可能令人困惑且不直观,因为它不会产生任何 3D 空间感.
您无法分辨任何事物的距离.它会产生完美的平面外观.
当从上到下的对角线角度显示时,这种艺术风格有时被称为等距.</p>
<p>和在2d相机时一样,需要制定缩放模式ScalingMode,或通过scale进行缩放.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="3d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="3d-models-and-scenes-gltf"><a class="header" href="#3d-models-and-scenes-gltf">3D Models and Scenes (GLTF)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/load_gltf.rs"><code>load_gltf</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/update_gltf_scene.rs"><code>update_gltf_scene</code></a>.</p>
<hr />
<p>Bevy uses the GLTF 2.0 file format for 3D assets.</p>
<p>(other formats may be unofficially available via 3rd-party plugins)</p>
<p>bevy使用gltf2.0文件格式来表示3d资产.</p>
<h2 id="quick-start-spawning-3d-models-into-your-world"><a class="header" href="#quick-start-spawning-3d-models-into-your-world">Quick-Start: Spawning 3D Models into your World</a></h2>
<p>The simplest use case is to just load a "3D model" and spawn it into the game world.</p>
<p>"3D models" can often be complex, consisting of multiple parts. Think of a
house: the windows, roof, doors, etc., are separate pieces, that are likely
made of multiple meshes, materials, and textures. Bevy would technically
need multiple ECS Entities to represent and render the whole thing.</p>
<p>This is why your GLTF "model" is represented by Bevy as a
[Scene][cb::scene]. This way, you can easily spawn it, and Bevy will create
all the relevant <a href="3d//fundamentals/hierarchy.html">child entities</a> and configure them correctly.</p>
<pre><code class="language-rust no_run noplayground">fn spawn_gltf(mut commands: Commands, ass: Res&lt;AssetServer&gt;) {
    // note that we have to include the `Scene0` label
    let my_gltf = ass.load("my.glb#Scene0");

    // to position our 3d model, simply use the Transform
    // in the SceneBundle
    commands.spawn(SceneBundle {
        scene: my_gltf,
        transform: Transform::from_xyz(2.0, 0.0, -5.0),
        ..Default::default()
    });
}</code></pre>
<p>You could also use GLTF files to load an entire map/level. It works the same way.</p>
<p>The above example assumes that you have a simple GLTF file containing only
one "default scene". GLTF is a very flexible file format. A single file can
contain many "models" or more complex "scenes". To get a better understanding
of GLTF and possible workflows, read the rest of this page. :)</p>
<p>3d游戏有个常见的操作就是加载3d模型.
一个3d模型可以包含很多东西,一个桌子有桌面和桌柱,
bevy表示桌子是需要多个ECS实体才能渲染一个桌子.</p>
<p>通常一个3d模型就称为一个scene,bevy可以基于scene构造出所有依赖的实体.
可以通过一个gltf文件加载一系列实体.</p>
<h2 id="introduction-to-gltf"><a class="header" href="#introduction-to-gltf">Introduction to GLTF</a></h2>
<p>GLTF is a modern open standard for exchanging 3D assets between different
3D software applications, like game engines and 3D modeling software.</p>
<p>The GLTF file format has two variants: human-readable ascii/text (<code>*.gltf</code>)
and binary (<code>*.glb</code>). The binary format is more compact and preferable
for packaging the assets with your game. The text format may be useful for
development, as it can be easier to manually inspect using a text editor.</p>
<p>A GLTF file can contain many objects (sub-assets): meshes, materials,
textures, scenes, animation clips. When loading a GLTF file, Bevy will load
all of the assets contained inside. They will be mapped to the <a href="3d//builtins.html#assets">appropriate
Bevy-internal asset types</a>.</p>
<p>GLTF是现代的一个交换3d资产的标准,让不同软件的3d资产可以进行交互,
eg:3d建模软件blender可以输出3d资产,游戏引擎可以加载这些内容.</p>
<p>gltf有两种格式:人类阅读友好的(<em>.gltf),和二进制(</em>.glb).</p>
<p>一个gltf文件可以有很多子资产:网格/材质/纹理/scene/动画.</p>
<h2 id="the-gltf-sub-assets"><a class="header" href="#the-gltf-sub-assets">The GLTF sub-assets</a></h2>
<p>GLTF terminology can be confusing, as it sometimes uses the same words to
refer to different things, compared to Bevy. This section will try explain
the various GLTF terms.</p>
<p>To understand everything, it helps to mentally consider how these concepts are
represented in different places: in your 3D modeling software (like Blender),
in the GLTF file itself, and in Bevy.</p>
<p>GLTF <strong>Scenes</strong> are what you spawn into your game world. This is typically
what you see on the screen in your 3D modeling software. Scenes combine
all of the data needed for the game engine to create all the needed
entities to represent what you want. Conceptually, think of a scene as one
"unit". Depending on your use case, this could be one "3d model",
or even a whole map or game level. In Bevy, these are represented as Bevy
Scenes with all the child ECS entities.</p>
<p>GLTF Scenes are composed of GLTF <strong>Nodes</strong>. These describe the "objects"
in the scene, typically GLTF Meshes, but can also be other things like
Cameras and Lights. Each GLTF Node has a transform for positioning it in
the scene. GLTF Nodes do not have a core Bevy equivalent; Bevy just uses
this data to create the ECS Entities inside of a Scene. Bevy has a special
<a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> asset type, if you need access to this data.</p>
<p>GLTF <strong>Meshes</strong> represent one conceptual "3D object". These correspond
to the "objects" in your 3D modeling software. GLTF Meshes may be complex
and composed of multiple smaller pieces, called GLTF Primitives, each of
which may use a different Material. GLTF Meshes do not have a core Bevy
equivalent, but there is a special <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a> asset type,
which describes the primitives.</p>
<p>GLTF <strong>Primitives</strong> are individual "units of 3D geometry", for the purposes of
rendering. They contain the actual geometry / vertex data, and reference the
Material to be used when drawing. In Bevy, each GLTF Primitive is represented
as a Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> asset, and must be spawned as a separate ECS
Entity to be rendered.</p>
<p>GLTF <strong>Materials</strong> describe the shading parameters for the surfaces of
your 3D models. They have full support for Physically-Based Rendering
(PBR). They also reference the textures to use. In Bevy, they are represented
as <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a> assets, as used by the Bevy
PBR 3D renderer.</p>
<p>GLTF <strong>Textures</strong> (images) can be embedded inside the GLTF file, or stored
externally in separate image files alongside it. For example, you can have
your textures as separate PNG/JPEG/KTX2 files for ease of development, or
package them all inside the GLTF file for ease of distribution. In Bevy,
GLTF textures are loaded as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets.</p>
<p>GLTF <strong>Samplers</strong> describe the settings for how the GPU should use a
given Texture. Bevy does not keep these separate; this data is stored
inside the Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset (the <code>sampler</code> field of type
<a href="https://docs.rs/bevy/0.9.1/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a>).</p>
<p>GLTF <strong>Animations</strong> describe animations that interpolate various values,
such as transforms or mesh skeletons, over time. In Bevy, these are loaded
as <a href="https://docs.rs/bevy/0.9.1/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a> assets.</p>
<p>gltf资产是有标准名称的,这个是统一的.但bevy并没有完全按gltf标准来.</p>
<p>GLTF场景是您在游戏世界中生成的内容.
这通常是您在3D建模软件的屏幕上看到的内容.
场景结合了游戏引擎所需的所有数据,以创建所有必要的实体来表示您想要的内容.
从概念上讲,将场景视为一个“单元”.
根据您的用例,这可能是一个“3D模型”,甚至是整个地图或游戏级别.
在Bevy中,这些表示为包含所有子ECS实体的Bevy场景.</p>
<p>GLTF场景由GLTF节点组成.这些节点描述了场景中的“对象”,通常是GLTF网格,
但也可以是其他东西,如相机和灯光.每个GLTF节点都有一个变换来将其定位在场景中.
GLTF节点没有核心Bevy等效项；Bevy仅使用此数据在场景内创建ECS实体.
如果您需要访问此数据,Bevy有一个特殊的GltfNode资源类型.</p>
<p>GLTF网格代表一个概念上的“3D对象”.它们对应于3D建模软件中的“对象”.
GLTF网格可能很复杂,由多个较小的部分组成,称为GLTF基元,
每个基元可能使用不同的材质.GLTF网格没有核心Bevy等效项,
但有一个特殊的GltfMesh资源类型,用于描述基元.</p>
<p>GLTF基元是单独的“3D几何单元”,用于渲染.
它们包含实际的几何/顶点数据,并引用绘制时要使用的材质.
在Bevy中,每个GLTFPrimitive都表示为BevyMesh资源,
并且必须生成为单独的ECS实体才能进行渲染.</p>
<p>GLTF材质描述3D模型表面的着色参数.它们完全支持基于物理的渲染(PBR).
它们还引用要使用的纹理.在Bevy中,它们表示为StandardMaterial资源,
由BevyPBR3D渲染器使用.</p>
<p>GLTF纹理(图像)可以嵌入GLTF文件中,也可以存储在外部单独的图像文件中.
例如,您可以将纹理作为单独的PNG/JPEG/KTX2文件以方便开发,
或者将它们全部打包到GLTF文件中以方便分发.
在Bevy中,GLTF纹理作为Bevy图像资源加载.</p>
<p>GLTF采样器描述了GPU应如何使用给定纹理的设置.Bevy不会将这些分开保存；
这些数据存储在Bevy图像资产(SamplerDescriptor类型的采样器字段)中.</p>
<p>GLTF动画描述了随时间插入各种值(例如变换或网格骨架)的动画.
在Bevy中,这些被加载为AnimationClip资产.</p>
<h2 id="gltf-usage-patterns"><a class="header" href="#gltf-usage-patterns">GLTF Usage Patterns</a></h2>
<p>A single GLTF file can contain any number of sub-assets of any of the above
types, referring to each other however they like.</p>
<p>Because GLTF is so flexible, it is up to you how to structure your assets.</p>
<p>A single GLTF file might be used:</p>
<ul>
<li>To represent a single "3D model", containing a single
GLTF Scene with the model, so you can spawn it into your game.</li>
<li>To represent a whole level, as a GLTF Scene, possibly also including
the camera. This lets you load and spawn a whole level/map at once.</li>
<li>To represent sections of a level/map, such as a rooms, as separate GLTF Scenes.
They can share meshes and textures if needed.</li>
<li>To contain a set of many different "3D models", each as a separate GLTF Scene.
This lets you load and manage the whole collection at once and spawn them individually as needed.</li>
<li>… others?</li>
</ul>
<p>单个 GLTF 文件可以包含任意数量的上述任何类型的子资源, 并以任意方式相互引用.</p>
<p>gltf可以用在以下场景:</p>
<ul>
<li>表示单个3D 模型</li>
<li>将整个关卡表示为 GLTF 场景,可能还包括相机.这让您可以一次加载和生成整个关卡/地图.</li>
<li>将关卡/地图的各个部分(例如房间)表示为单独的 GLTF 场景.如果需要,它们可以共享网格和纹理.</li>
<li>包含一组许多不同的3D 模型,每个模型都是一个单独的 GLTF 场景.这让您可以一次加载和管理整个集合,并根据需要单独生成它们.</li>
<li>…其他？</li>
</ul>
<h2 id="tools-for-creating-gltf-assets"><a class="header" href="#tools-for-creating-gltf-assets">Tools for Creating GLTF Assets</a></h2>
<p>If you are using a recent version of Blender (2.8+) for 3D modeling, GLTF
is supported out of the box. Just export and choose GLTF as the format.</p>
<p>For other tools, you can try these exporter plugins:</p>
<ul>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Blender_to_glTF">Old Blender (2.79)</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/3DSMax_to_glTF">3DSMax</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Maya_to_glTF">Autodesk Maya</a>
<ul>
<li>(or this <a href="https://kashika.co.jp/product/gltfexporter/">alternative</a>)</li>
</ul>
</li>
</ul>
<p>Be sure to check your export settings to make sure the GLTF file contains
everything you expect.</p>
<p>If you need Tangents for normal maps, it is recommended that you include them
in your GLTF files. This avoids Bevy having to autogenerate them at runtime.
Many 3D editors do not enable this option by default.</p>
<p>创建gltf资产的工具,推荐使用开源的blender.</p>
<p>如果您需要法线贴图的切线,建议您将它们包含在 GLTF 文件中.
这避免了 Bevy 必须在运行时自动生成它们.许多 3D 编辑器默认不启用此选项.</p>
<h3 id="textures"><a class="header" href="#textures">Textures</a></h3>
<p>For your Textures / image data, the GLTF format specification officially
limits the supported formats to just PNG, JPEG, or Basis. However, Bevy does
not enforce such "artificial limitations". You can use any <a href="3d//builtins.html#file-formats">image format
supported by Bevy</a>.</p>
<p>Your 3D editor will likely export your GLTF with PNG textures. This will
"just work" and is nice for simple use cases.</p>
<p>However, mipmaps and compressed textures are very important to get good GPU
performance, memory (VRAM) usage, and visual quality. You will only get these
benefits if you use a format like KTX2 or DDS, that supports these features.</p>
<p>We recommend that you use KTX2, which natively supports all GPU texture
functionality + additional <code>zstd</code> compression on top, to reduce file size.
If you do this, don't forget to enable the <code>ktx2</code> and <code>zstd</code> <a href="3d//setup/bevy-config.html">cargo
features</a> for Bevy.</p>
<p>You can use the <a href="https://github.com/superdump/klafsa"><code>klafsa</code></a> tool to convert all the textures
used in your GLTF files from PNG/JPEG into KTX2, with mipmaps and GPU texture
compression of your choice.</p>
<pre><code>TODO: show an example workflow for converting textures into the "optimal" format
</code></pre>
<p>对于您的纹理/图像数据,GLTF格式规范正式将支持的格式限制为PNG、JPEG或Basis.
但是,Bevy不会强制执行这种“人为限制”.您可以使用Bevy支持的任何图像格式.</p>
<p>您的3D编辑器可能会使用PNG纹理导出您的GLTF.这将“正常工作”,并且非常适合简单的用例.</p>
<p>但是,mipmap和压缩纹理对于获得良好的GPU性能、内存(VRAM)使用率和视觉质量非常重要.
只有使用支持这些功能的KTX2或DDS等格式,您才能获得这些好处.</p>
<p>我们建议您使用KTX2,它原生支持所有GPU纹理功能+顶部的额外zstd压缩,以减小文件大小.
如果您这样做,请不要忘记为Bevy启用ktx2和zstd货物功能.</p>
<p>您可以使用klafsa工具将GLTF文件中使用的所有纹理从PNG/JPEG转换为KTX2,
并选择mipmap和GPU纹理压缩.</p>
<h2 id="using-gltf-sub-assets-in-bevy"><a class="header" href="#using-gltf-sub-assets-in-bevy">Using GLTF Sub-Assets in Bevy</a></h2>
<p>The various sub-assets contained in a GLTF file can be addressed in two ways:</p>
<ul>
<li>by index (integer id, in the order they appear in the file)</li>
<li>by name (text string, the names you set in your 3D modeling software
when creating the asset, which can be exported into the GLTF)</li>
</ul>
<p>To get handles to the respective assets in Bevy, you can use the
<a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="3d/gltf.html#gltf-master-asset">"master asset"</a>, or alternatively,
<a href="3d/gltf.html#assetpath-with-labels">AssetPath with Labels</a>.</p>
<p>在bevy中访问这些资产有两种方式:索引或名称.</p>
<h3 id="gltf-master-asset"><a class="header" href="#gltf-master-asset"><code>Gltf</code> master asset</a></h3>
<p>If you have a complex GLTF file, this is likely the most flexible and useful
way of navigating its contents and using the different things inside.</p>
<p>You have to wait for the GLTF file to load, and then use the <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> asset.</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::Gltf;

/// Helper resource for tracking our asset
#[derive(Resource)]
struct MyAssetPack(Handle&lt;Gltf&gt;);

fn load_gltf(mut commands: Commands, ass: Res&lt;AssetServer&gt;) {
    let gltf = ass.load("my_asset_pack.glb");
    commands.insert_resource(MyAssetPack(gltf));
}

fn spawn_gltf_objects(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
) {
    // if the GLTF has loaded, we can navigate its contents
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // spawn the first scene in the file
        commands.spawn(SceneBundle {
            scene: gltf.scenes[0].clone(),
            ..Default::default()
        });

        // spawn the scene named "YellowCar"
        commands.spawn(SceneBundle {
            scene: gltf.named_scenes["YellowCar"].clone(),
            transform: Transform::from_xyz(1.0, 2.0, 3.0),
            ..Default::default()
        });

        // PERF: the `.clone()`s are just for asset handles, don't worry :)
    }
}</code></pre>
<p>For a more convoluted example, say we want to directly create a 3D PBR
entity, for whatever reason. (This is not recommended; you should probably
just use scenes)</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::GltfMesh;

fn gltf_manual_entity(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
    assets_gltfmesh: Res&lt;Assets&lt;GltfMesh&gt;&gt;,
) {
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // Get the GLTF Mesh named "CarWheel"
        // (unwrap safety: we know the GLTF has loaded already)
        let carwheel = assets_gltfmesh.get(&amp;gltf.named_meshes["CarWheel"]).unwrap();

        // Spawn a PBR entity with the mesh and material of the first GLTF Primitive
        commands.spawn(PbrBundle {
            mesh: carwheel.primitives[0].mesh.clone(),
            // (unwrap: material is optional, we assume this primitive has one)
            material: carwheel.primitives[0].material.clone().unwrap(),
            ..Default::default()
        });
    }
}</code></pre>
<h3 id="assetpath-with-labels"><a class="header" href="#assetpath-with-labels">AssetPath with Labels</a></h3>
<p>This is another way to access specific sub-assets. It is less reliable,
but may be easier to use in some cases.</p>
<p>Use the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a> to convert a path string into a
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Handle.html"><code>Handle</code></a>.</p>
<p>The advantage is that you can get handles to your sub-assets immediately,
even if your GLTF file hasn't loaded yet.</p>
<p>The disadvantage is that it is more error-prone. If you specify a sub-asset
that doesn't actually exist in the file, or mis-type the label, or use the
wrong label, it will just silently not work. Also, currently only using a
numerial index is supported. You cannot address sub-assets by name.</p>
<pre><code class="language-rust no_run noplayground">fn use_gltf_things(mut commands: Commands, ass: Res&lt;AssetServer&gt;) {
    // spawn the first scene in the file
    let scene0 = ass.load("my_asset_pack.glb#Scene0");
    commands.spawn(SceneBundle {
        scene: scene0,
        ..Default::default()
    });

    // spawn the second scene
    let scene1 = ass.load("my_asset_pack.glb#Scene1");
    commands.spawn(SceneBundle {
        scene: scene1,
        transform: Transform::from_xyz(1.0, 2.0, 3.0),
        ..Default::default()
    });
}</code></pre>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Mesh{}/Primitive{}/MorphTargets</code>: Morph target animation data for a GLTF Primitive</li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<p>GLTF (Graphics Library Transmission Format)资源中使用的标签主要涉及以下几方面:
描述3D模型、场景结构、材质、纹理等元素的元数据。
这些标签帮助组织和定义了GLTF文件中的不同组件，
使得它们能够在不同的平台和应用程序间有效传输和渲染。
以下是一些关键的GLTF资源标签及其用途概述：</p>
<ul>
<li>asset: 包含了GLTF文件的基本元数据，如版本号、版权信息、生成工具等。</li>
<li>scene: 定义场景的基本构成，一个GLTF文件可以包含多个场景，每个场景可以引用不同的节点集合。</li>
<li>scenes: 场景列表，每个场景定义了场景的根节点，以及初始默认场景。</li>
<li>nodes: 节点列表，定义了3D空间中的对象（如模型、灯光、相机等）及其变换（位置、旋转、缩放）。</li>
<li>meshes: 网格列表，描述了3D对象的几何形状，包括顶点、索引和顶点属性（如法线、UV坐标）。</li>
<li>materials: 材质列表，定义了如何渲染网格表面，包括颜色、纹理、光照模型等属性。</li>
<li>textures: 纹理列表，存储图像数据，用于材质贴图、环境映射等。</li>
<li>images: 图像数据列表，可以是图片文件的引用或直接嵌入的图像数据。</li>
<li>samplers: 定义了如何采样纹理，如过滤和环绕方式。</li>
<li>accessors: 数据访问器，描述如何从缓冲区视图中读取和解释数组数据（如顶点坐标、颜色数据等）。</li>
<li>bufferViews: 缓冲区视图，指定缓冲区中数据的偏移量和长度，以及数据的字节排列方式。</li>
<li>buffers: 缓冲区，存储大量的原始二进制数据，如顶点坐标、索引等。</li>
<li>cameras: 相机定义，描述了如何从3D场景渲染到2D图像，包括透视相机和正交相机。</li>
<li>animations: 动画列表，定义了场景中节点或材质随时间变化的动画序列。</li>
<li>skins: 皮肤信息，用于绑定网格顶点到骨骼，实现蒙皮动画。</li>
<li>extensions: 扩展，允许在GLTF规范基础上添加额外的功能或特定平台的支持。</li>
<li>extras: 附加数据，用于存储不被GLTF规范直接定义的信息，通常供特定应用程序或工具使用。</li>
</ul>
<p>bevy中使用到了: scene/node/mesh/mesh原语/变形动画数据/纹理/材质/默认材质/动画/皮肤.</p>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>
asset types are only useful to help you navigate the contents of
your GLTF file. They are not core Bevy renderer types, and not used
by Bevy in any other way. The Bevy renderer expects Entities with
<a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>; for that you need the
<a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>.</p>
<h2 id="bevy-limitations"><a class="header" href="#bevy-limitations">Bevy Limitations</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this yet. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<p>bevy只支持gltf的部分功能,并不是所有的gltf文件都能加载进bevy.
在部分场景下,还得不到任何错误的诊断信息:</p>
<ul>
<li>gltf文件中,纹理经过了base64编码,这种文件无法加载</li>
<li>mip贴图之在ktx2/dds纹理文件中支持</li>
</ul>
<p>这个列表并不全,还有些错误未包含进来.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="input-handling-1"><a class="header" href="#input-handling-1">Input Handling</a></h1>
<p>Bevy supports the following inputs:</p>
<ul>
<li><a href="/input/keyboard.html">Keyboard</a> (detect when keys are pressed or released, or for text input)</li>
<li><a href="/input/mouse.html">Mouse</a>:
<ul>
<li><a href="/input/mouse.html#mouse-motion">Motion</a> (moving the mouse, not tied to OS cursor)</li>
<li><a href="/input/mouse.html#mouse-cursor-position">Cursor</a> (absolute pointer position)</li>
<li><a href="/input/mouse.html#mouse-buttons">Buttons</a></li>
<li><a href="/input/mouse.html#mouse-scrolling--wheel">Scrolling</a> (mouse wheel or touchpad gesture)</li>
<li><a href="/input/mouse.html#touchpad-gestures">Touchpad Gestures</a> (only macOS/iOS supported)</li>
</ul>
</li>
<li><a href="/input/touch.html">Touchscreen</a> (with multi-touch)</li>
<li><a href="/input/gamepad.html">Gamepad (Controller, Joystick)</a> (via the <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> library)</li>
<li><a href="/input/dnd.html">Drag-and-Drop</a> (only for files)</li>
<li><a href="/input/ime.html">IME</a> (for advanced text input, to support multilingual users)</li>
</ul>
<p>The following notable input devices are <em><strong>not</strong></em> supported:</p>
<ul>
<li>Accelerometers and gyroscopes for device tilt</li>
<li>Other sensors, like temperature sensors</li>
<li>Tracking individual fingers on a multi-touch trackpad, like on a touchscreen</li>
<li>Microphones and other audio input devices</li>
<li>MIDI (musical instruments), but there is an unofficial plugin: <a href="https://github.com/BlackPhlox/bevy_midi"><code>bevy_midi</code></a>.</li>
</ul>
<p>bevy支持以下输入:</p>
<ul>
<li>键盘按键的按下和释放,文本输入</li>
<li>鼠标移动,光标位置,鼠标按键,鼠标滚轮</li>
<li>多指触摸,触摸板手势(仅限与mac系列),触摸滚动</li>
<li>手柄</li>
<li>文件拖拽</li>
<li>IME 高级文本输入</li>
</ul>
<p>bevy还不支持以下设备:</p>
<ul>
<li>加速计和陀螺仪</li>
<li>传感器(eg:温度计)</li>
<li>多点触控板跟踪手指</li>
<li>麦克风和其他音频输入设备</li>
<li>乐器MIDI, (有个非官方的bevy_midi)</li>
</ul>
<hr />
<p>For most input types (where it makes sense), Bevy provides two ways of
dealing with them:</p>
<ul>
<li>by checking the current state via <a href="/programming/res.html">resources</a> (<a href="/builtins.html#input-handling-resources">input resources</a>),</li>
<li>or via <a href="/programming/events.html">events</a> (<a href="/builtins.html#input-events">input events</a>).</li>
</ul>
<p>Some inputs are only provided as events.</p>
<p>Checking state is done using <a href="/programming/res.html">resources</a> such as <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a> (for
binary inputs like keys or buttons), <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.Axis.html"><code>Axis</code></a> (for analog inputs), <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>
(for fingers on a touchscreen), etc. This way of handling input is very
convenient for implementing game logic. In these scenarios, you typically
only care about the specific inputs mapped to actions in your game. You can
check specific buttons/keys to see when they get pressed/released, or what
their current state is.</p>
<p><a href="/programming/events.html">Events</a> (<a href="/builtins.html#input-events">input events</a>) are a lower-level,
more all-encompassing approach. Use them if you want to get all activity
from that class of input device, rather than only checking for specific inputs.</p>
<p>对于大多数输入,bevy提供了两种处理方式:资源和事件.
部分输入只有事件.</p>
<p>检查资源的状态(ButtonInput的按键;Axis的遥感方向;Touches的触摸)等.
这种处理输入的方式对实现游戏逻辑来说非常方便.</p>
<p>事件输入是一个低级别的处理方式,处理也更加全面.
如果想从该类输入设备获取所有活动,而不是仅检查特定输入,请使用它们.</p>
<h2 id="input-mapping"><a class="header" href="#input-mapping">Input Mapping</a></h2>
<p>Bevy does not yet offer a built-in way to do input mapping (configure key
bindings, etc). You need to come up with your own way of translating the
inputs into logical actions in your game/app.</p>
<p>There are some community-made plugins that may help with that: <a href="https://bevyengine.org/assets/#input">see the
input-section on bevy-assets</a>. My personal recommendation:
<a href="https://github.com/leafwing-studios/leafwing-input-manager">Input Manager plugin by Leafwing Studios</a>. It is opinionated
and unlikely to suit all games, but if it works for you, it is very high quality.</p>
<p>It may be a good idea to build your own abstractions specific to your
game. For example, if you need to handle player movement, you might want to
have a system for reading inputs and converting them to your own internal
"movement intent/action events", and then another system acting on those
custom events, to actually move the player. Make sure to use <a href="/programming/system-order.html">explicit
system ordering</a> to avoid lag / frame delays.</p>
<p>bevy没有内置输入映射(eg:绑定组合键),这个应该由游戏逻辑来自定义.
社区有些插件可以实现这些功能,本书作者推荐使用<a href="https://github.com/leafwing-studios/leafwing-input-manager">这个插件</a>,
这个插件在某些场景下非常有用(潜在意思是,没有银弹,没有万灵丹).</p>
<p>在游戏中维护一个抽象层非常有必要.
如果需要处理角色移动,需要在system中读取输入,并转换成自己内部的事件,
其他system就能基于内部事件继续搭积木完善游戏逻辑.</p>
<h2 id="run-conditions-1"><a class="header" href="#run-conditions-1">Run Conditions</a></h2>
<p>Bevy also provides <a href="/programming/run-criteria.html">run conditions</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/common_conditions/index.html">see all of them
here</a>) that you can attach to your systems, if
you want a specific system to only run when a specific key or button is pressed.</p>
<p>This way, you can do input handling as part of the
<a href="/programming/intro-code.html">scheduling/configuration</a> of your <a href="/programming/systems.html">systems</a>, and
avoid running unnecessary code on the CPU.</p>
<p>Using these in real games is not recommended, because you have to hard-code the
keys, which makes it impossible to make user-configurable keybindings.</p>
<p>To support configurable keybindings, you can implement your own run conditions
that check your keybindings from your user preferences.</p>
<p>If you are using the <a href="https://github.com/leafwing-studios/leafwing-input-manager">LWIM plugin</a>, it also provides support for
<a href="https://docs.rs/leafwing-input-manager/latest/leafwing_input_manager/common_conditions/index.html">a similar run-condition-based workflow</a>.</p>
<p>bevy为system提供了运行条件,可以利用这个机制让system只在某些键被按下时运行.</p>
<p>可以通过"调度/配置"(后面章节中提到)来避免非必要的代码占用cpu资源.</p>
<p>这种方式是将硬编码key写在代码中了,用户无法重新绑定,所以不推荐在真实游戏中使用.</p>
<p>插件(LWIM,就是上面推荐的input管理插件)同样提供了一个小型的基于运行条件的工作流.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard Input</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/keyboard_input.rs"><code>keyboard_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/keyboard_input_events.rs"><code>keyboard_input_events</code></a>.</p>
<hr />
<p>This page shows how to handle keyboard keys being pressed and released.</p>
<p>Note: Command Key on Mac corresponds to the Super/Windows Key on PC.</p>
<p>Similar to <a href="input//input/mouse.html#mouse-buttons">mouse buttons</a>, keyboard input is available
as a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a> <a href="input//programming/res.html">resource</a>, <a href="input//programming/events.html">events</a>, and <a href="input//programming/run-criteria.html">run
conditions</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/common_conditions/index.html">see list</a>). Use
whichever pattern feels most appropriate to your use case.</p>
<p>和鼠标按键一样,键盘按键也可作为ButtonInput资源/事件/运行条件, 选择一种合适的即可.</p>
<h2 id="checking-key-state"><a class="header" href="#checking-key-state">Checking Key State</a></h2>
<p>Most commonly for games, you might be interested in specific known keys and
detecting when they are pressed or released. You can check specific keys
using the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput&lt;KeyCode&gt;</code></a> <a href="input//programming/res.html">resource</a>.</p>
<ul>
<li>Use <code>.pressed(…)</code>/<code>.released(…)</code> to check if a key is being held down
<ul>
<li>These return <code>true</code> every frame, for as long as the key is in the respective state.</li>
</ul>
</li>
<li>Use <code>.just_pressed(…)</code>/<code>.just_released(…)</code> to detect the actual press/release
<ul>
<li>These return <code>true</code> only on the frame update when the press/release happened.</li>
</ul>
</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn keyboard_input(
    keys: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Space) {
        // Space was pressed
    }
    if keys.just_released(KeyCode::ControlLeft) {
        // Left Ctrl was released
    }
    if keys.pressed(KeyCode::KeyW) {
        // W is being held down
    }
    // we can check multiple at once with `.any_*`
    if keys.any_pressed([KeyCode::ShiftLeft, KeyCode::ShiftRight]) {
        // Either the left or right shift are being held down
    }
    if keys.any_just_pressed([KeyCode::Delete, KeyCode::Backspace]) {
        // Either delete or backspace was just pressed
    }
}</code></pre>
<p>To iterate over any keys that are currently held, or that have been pressed/released:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_iter(
    keys: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    for key in keys.get_pressed() {
        println!("{:?} is currently held down", key);
    }
    for key in keys.get_just_pressed() {
        println!("{:?} was pressed", key);
    }
    for key in keys.get_just_released() {
        println!("{:?} was released", key);
    }
}</code></pre>
<p>大多数游戏都会选择检查资源,直接查资源保存的按键状态.<br />
<code>.pressed()/.released()</code>,检查某个键是否已经被按下或释放.只要状态对,每帧都返回true.<br />
<code>.just_pressed()/.just_released()</code>,只要状态对,只在当前帧返回true.</p>
<h2 id="run-conditions-2"><a class="header" href="#run-conditions-2">Run Conditions</a></h2>
<p>Another workflow is to add <a href="input//programming/run-criteria.html">run conditions</a> to your systems,
so that they only run when the appropriate inputs happen.</p>
<p>It is highly recommended you write your own <a href="input//programming/run-criteria.html">run conditions</a>,
so that you can check for whatever you want, support configurable bindings, etc…</p>
<p>For prototyping, Bevy offers some <a href="input//input.html#run-conditions">built-in run conditions</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::common_conditions::*;

app.add_systems(Update, (
    handle_jump
        .run_if(input_just_pressed(KeyCode::Space)),
    handle_shooting
        .run_if(input_pressed(KeyCode::Enter)),
));</code></pre>
<p>条件运行,仅在某些事发生时才执行system.</p>
<p>强烈推荐自己编写自己的运行条件,这样可以追求更大的灵活性,也支持配置按键绑定等.</p>
<p>上面的例子是bevy内置的运行条件.</p>
<h2 id="keyboard-events"><a class="header" href="#keyboard-events">Keyboard Events</a></h2>
<p>To get all keyboard activity, you can use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_events(
    mut evr_kbd: EventReader&lt;KeyboardInput&gt;,
) {
    for ev in evr_kbd.read() {
        match ev.state {
            ButtonState::Pressed =&gt; {
                println!("Key press: {:?} ({:?})", ev.key_code, ev.logical_key);
            }
            ButtonState::Released =&gt; {
                println!("Key release: {:?} ({:?})", ev.key_code, ev.logical_key);
            }
        }
    }
}</code></pre>
<p>捕获所有键盘事件,使用事件.</p>
<h3 id="physical-keycode-vs-logical-key"><a class="header" href="#physical-keycode-vs-logical-key">Physical <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a> vs. Logical <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a></a></h3>
<p>When a key is pressed, the <a href="input//programming/events.html">event</a> contains two important pieces of information:</p>
<ul>
<li>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a>, which always represents a specific key on the keyboard,
regardless of the OS layout or language settings.</li>
<li>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a>, which contains the logical meaning of the key as interpreted by the OS.</li>
</ul>
<p>When you want to implement gameplay mechanics, you want to use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a>.
This will give you reliable keybindings that always work, including for multilingual
users with multiple keyboard layouts configured in their OS.</p>
<p>When you want to implement text/character input, you want to use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a>.
This can give you Unicode characters that you can append to your text string and
will allow your users to type just like they do in other applications.</p>
<p>If you'd like to handle special function keys or media keys on keyboards that
have them, that can also be done via the logical <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a>.</p>
<p>当一个键按下时,事件会包含两部分信息:</p>
<ul>
<li>KeyCode,键盘上哪个键被按下了,和OS为不同语言的布局无关</li>
<li>Key,OS对按键的解释</li>
</ul>
<p>当实现游戏逻辑时,需要使用Keycode,这样你可以始终提供可靠的绑定.<br />
当实现文本/字符输入时,使用Key,这可以为您提供Unicode字符,您可以将其附加到文本字符串中,
并允许您的用户像在其他应用程序中一样进行键入。</p>
<p>如果您想处理具有特殊功能键或媒体键的键盘,也可以通过逻辑键来完成.</p>
<h2 id="text-input"><a class="header" href="#text-input">Text Input</a></h2>
<p>Here is a simple example of how to implement text input into a string (here
stored as a <a href="input//programming/local.html">local</a>).</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::ButtonState;
use bevy::input::keyboard::{Key, KeyboardInput};

fn text_input(
    mut evr_kbd: EventReader&lt;KeyboardInput&gt;,
    mut string: Local&lt;String&gt;,
) {
    for ev in evr_kbd.read() {
        // We don't care about key releases, only key presses
        if ev.state == ButtonState::Released {
            continue;
        }
        match &amp;ev.logical_key {
            // Handle pressing Enter to finish the input
            Key::Enter =&gt; {
                println!("Text input: {}", &amp;*string);
                string.clear();
            }
            // Handle pressing Backspace to delete last char
            Key::Backspace =&gt; {
                string.pop();
            }
            // Handle key presses that produce text characters
            Key::Character(input) =&gt; {
                // Ignore any input that contains control (special) characters
                if input.chars().any(|c| c.is_control()) {
                    continue;
                }
                string.push_str(&amp;input);
            }
            _ =&gt; {}
        }
    }
}</code></pre>
<p>Note how we implement special handling for keys like <code>Backspace</code> and <code>Enter</code>.
You can easily add special handling for other keys that make sense in your
application, like arrow keys or the <code>Escape</code> key.</p>
<p>Keys that produce useful characters for our text come in as small Unicode
strings. It is possible that there might be more than one <code>char</code> per keypress
in some languages.</p>
<p>Note: To support text input for international users who use languages
with complex scripts (such as East Asian languages), or users who use
assistive methods like handwriting recognition, you also need to support
<a href="input//input/ime.html">IME input</a>, in addition to keyboard input.</p>
<p>文本输入,上面的例子中对回退和enter键做了特殊处理,常见的特殊处理还有Esc/方向键.</p>
<p>注意:为了支持使用复杂脚本的语言(CJK)的国际用户或使用手写识别等辅助方法的用户的文本输入,
除了键盘输入之外,您还需要支持 IME 输入.</p>
<h2 id="keyboard-focus"><a class="header" href="#keyboard-focus">Keyboard Focus</a></h2>
<p>If you are doing advanced things like caching state to detect multi-key
sequences or combinations of keys, you might end up in an inconsistent
state if the Bevy OS window loses focus in the middle of keyboard input,
such as with Alt-Tab or similar OS window switching mechanisms.</p>
<p>If you are doing such things and you think your algorithm might be getting
stuck, Bevy offers a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/struct.KeyboardFocusLost.html"><code>KeyboardFocusLost</code></a> <a href="input//programming/events.html">event</a> to let you
know when you should reset your state.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::keyboard::KeyboardFocusLost;

fn detect_special_sequence(
    mut evr_focus_lost: EventReader&lt;KeyboardFocusLost&gt;,
    mut remembered_keys: Local&lt;Vec&lt;KeyCode&gt;&gt;,
) {
    // Imagine we need to remeber a sequence of keypresses
    // for some special gameplay reason.
    // TODO: implement that; store state in `remembered_keys`

    // But it might go wrong if the user Alt-Tabs, we need to reset
    if !evr_focus_lost.is_empty() {
        remembered_keys.clear();
        evr_focus_lost.clear();
    }
}</code></pre>
<p>如果您正在执行高级操作,例如缓存状态以检测多键序列或键组合,
如果 Bevy OS 窗口在键盘输入过程中失去焦点(例如使用 Alt-Tab 或类似的 OS 窗口切换机制),
您可能会陷入不一致的状态.</p>
<p><code>KeyboardFocusLost</code>事件会上清除一些按键缓存.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/mouse_input.rs"><code>mouse_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/mouse_input_events.rs"><code>mouse_input_events</code></a>.</p>
<hr />
<h2 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h2>
<p>Similar to <a href="input//input/keyboard.html">keyboard input</a>, mouse buttons are available as a
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a> <a href="input//programming/res.html">resource</a>, <a href="input//programming/events.html">events</a>, and <a href="input//programming/run-criteria.html">run
conditions</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/common_conditions/index.html">see list</a>). Use whichever
pattern feels most appropriate to your use case.</p>
<h3 id="checking-button-state"><a class="header" href="#checking-button-state">Checking Button State</a></h3>
<p>You can check the state of specific mouse buttons using the
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/enum.MouseButton.html"><code>ButtonInput&lt;MouseButton&gt;</code></a> <a href="input//programming/res.html">resource</a>:</p>
<ul>
<li>Use <code>.pressed(…)</code>/<code>.released(…)</code> to check if a button is being held down
<ul>
<li>These return <code>true</code> every frame, for as long as the button is in the respective state.</li>
</ul>
</li>
<li>Use <code>.just_pressed(…)</code>/<code>.just_released(…)</code> to detect the actual press/release
<ul>
<li>These return <code>true</code> only on the frame update when the press/release happened.</li>
</ul>
</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn mouse_button_input(
    buttons: Res&lt;ButtonInput&lt;MouseButton&gt;&gt;,
) {
    if buttons.just_pressed(MouseButton::Left) {
        // Left button was pressed
    }
    if buttons.just_released(MouseButton::Left) {
        // Left Button was released
    }
    if buttons.pressed(MouseButton::Right) {
        // Right Button is being held down
    }
    // we can check multiple at once with `.any_*`
    if buttons.any_just_pressed([MouseButton::Left, MouseButton::Middle]) {
        // Either the left or the middle (wheel) button was just pressed
    }
}</code></pre>
<p>You can also iterate over any buttons that have been pressed or released:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_iter(
    buttons: Res&lt;ButtonInput&lt;MouseButton&gt;&gt;,
) {
    for button in buttons.get_pressed() {
        println!("{:?} is currently held down", button);
    }
    for button in buttons.get_just_pressed() {
        println!("{:?} was pressed", button);
    }
    for button in buttons.get_just_released() {
        println!("{:?} was released", button);
    }
}</code></pre>
<p>通过ButtonInput<MourseButton>资源获取鼠标按键状态.</p>
<h3 id="run-conditions-3"><a class="header" href="#run-conditions-3">Run Conditions</a></h3>
<p>Another workflow is to add <a href="input//programming/run-criteria.html">run conditions</a> to your systems,
so that they only run when the appropriate inputs happen.</p>
<p>It is highly recommended you write your own <a href="input//programming/run-criteria.html">run conditions</a>,
so that you can check for whatever you want, support configurable bindings, etc…</p>
<p>For prototyping, Bevy offers some <a href="input//input.html#run-conditions">built-in run conditions</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::common_conditions::*;

app.add_systems(Update, (
    handle_middleclick
        .run_if(input_just_pressed(MouseButton::Middle)),
    handle_drag
        .run_if(input_pressed(MouseButton::Left)),
));</code></pre>
<p>运行条件,上面的例子中演示了鼠标中键按下和左键拖拽.</p>
<h3 id="mouse-button-events"><a class="header" href="#mouse-button-events">Mouse Button Events</a></h3>
<p>Alternatively, you can use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a> <a href="input//programming/events.html">events</a> to get
all activity:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseButtonInput;

fn mouse_button_events(
    mut mousebtn_evr: EventReader&lt;MouseButtonInput&gt;,
) {
    use bevy::input::ButtonState;

    for ev in mousebtn_evr.read() {
        match ev.state {
            ButtonState::Pressed =&gt; {
                println!("Mouse button press: {:?}", ev.button);
            }
            ButtonState::Released =&gt; {
                println!("Mouse button release: {:?}", ev.button);
            }
        }
    }
}</code></pre>
<p>鼠标事件.</p>
<h2 id="mouse-scrolling--wheel"><a class="header" href="#mouse-scrolling--wheel">Mouse Scrolling / Wheel</a></h2>
<p>To detect scrolling input, use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseWheel;

fn scroll_events(
    mut evr_scroll: EventReader&lt;MouseWheel&gt;,
) {
    use bevy::input::mouse::MouseScrollUnit;
    for ev in evr_scroll.read() {
        match ev.unit {
            MouseScrollUnit::Line =&gt; {
                println!("Scroll (line units): vertical: {}, horizontal: {}", ev.y, ev.x);
            }
            MouseScrollUnit::Pixel =&gt; {
                println!("Scroll (pixel units): vertical: {}, horizontal: {}", ev.y, ev.x);
            }
        }
    }
}</code></pre>
<p>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a> enum is important: it tells you the type of scroll
input. <code>Line</code> is for hardware with fixed steps, like the wheel on desktop
mice. <code>Pixel</code> is for hardware with smooth (fine-grained) scrolling, like
laptop touchpads.</p>
<p>You should probably handle each of these differently (with different
sensitivity settings), to provide a good experience on both types of hardware.</p>
<p><strong>Note:</strong> the <code>Line</code> unit is not guaranteed to have whole number values/steps!
At least <a href="input//platforms/macos.html">macOS</a> does non-linear scaling / acceleration of
scrolling at the OS level, meaning your app will get weird values for the number
of lines, even when using a regular PC mouse with a fixed-stepping scroll wheel.</p>
<p>鼠标滚轮事件.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MouseScrollUnit {
    Line, // 按行滚动, 适合鼠标硬件
    Pixel, // 按像素滚动, 适合笔记本触摸板
}
<span class="boring">}</span></code></pre></pre>
<p>mac系统对于Line滚动时,滚动的行数不是线性变化的,需要注意这个平台可能出现问题.</p>
<h2 id="mouse-motion"><a class="header" href="#mouse-motion">Mouse Motion</a></h2>
<p>Use this if you don't care about the exact position of the mouse cursor,
but rather you just want to see how much the mouse moved from frame to
frame. This is useful for things like controlling a 3D camera.</p>
<p>Use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a> <a href="input//programming/events.html">events</a>. Whenever the mouse is moved, you
will get an event with the delta.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseMotion;

fn mouse_motion(
    mut evr_motion: EventReader&lt;MouseMotion&gt;,
) {
    for ev in evr_motion.read() {
        println!("Mouse moved: X: {} px, Y: {} px", ev.delta.x, ev.delta.y);
    }
}</code></pre>
<p>You might want to <a href="input//window/mouse-grab.html">grab/lock the mouse inside the game
window</a>.</p>
<p>不关心鼠标具体移动了多少,而关心帧间移动的差值,这种需求在3d相机中还是有很多的.
使用<code>MouseMotion</code>事件来实现.</p>
<h2 id="mouse-cursor-position"><a class="header" href="#mouse-cursor-position">Mouse Cursor Position</a></h2>
<p>Use this if you want to accurately track the position of the pointer /
cursor. This is useful for things like clicking and hovering over objects
in your game or UI.</p>
<p>You can get the current coordinates of the mouse pointer, from the respective
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.Window.html"><code>Window</code></a> (if the mouse is currently inside that window):</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::PrimaryWindow;

fn cursor_position(
    q_windows: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    // Games typically only have one window (the primary window)
    if let Some(position) = q_windows.single().cursor_position() {
        println!("Cursor is inside the primary window, at {:?}", position);
    } else {
        println!("Cursor is not in the game window.");
    }
}</code></pre>
<p>To detect when the pointer is moved, use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a> <a href="input//programming/events.html">events</a>
to get the updated coordinates:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_events(
    mut evr_cursor: EventReader&lt;CursorMoved&gt;,
) {
    for ev in evr_cursor.read() {
        println!(
            "New cursor position: X: {}, Y: {}, in Window ID: {:?}",
            ev.position.x, ev.position.y, ev.window
        );
    }
}</code></pre>
<p>Note that you can only get the position of the mouse inside a window;
you cannot get the global position of the mouse in the whole OS Desktop /
on the screen as a whole.</p>
<p>The coordinates you get are in "window space". They represent window
pixels, and the origin is the <strong>top left</strong> corner of the window.</p>
<p>They do not relate to your camera or in-game coordinates in any way. <a href="input//cookbook/cursor2world.html">See
this cookbook example</a> for converting these window
cursor coordinates into world-space coordinates.</p>
<p>To track when the mouse cursor enters and leaves your window(s), use
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a> and <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>如果您想准确跟踪指针/光标的位置,请使用此选项.
这对于在游戏或 UI 中单击或悬停在对象上等操作非常有用.</p>
<p><code>cursor_position()</code>可以从当前窗口获取光标当前坐标.
<code>EventReader&lt;CursorMoved&gt;</code>获取光标移动事件.</p>
<p>光标在窗口中就能获取到坐标,出了窗口就获取不到了.
能获取到的坐标都是基于窗口的,窗口的原点在坐上角.
这个坐标和相机/游戏中的坐标不是同一套,两者的坐标转换可以翻一下前面的"坐标"一节.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="gamepad-controller-joystick"><a class="header" href="#gamepad-controller-joystick">Gamepad (Controller, Joystick)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/gamepad_input.rs"><code>gamepad_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/gamepad_input_events.rs"><code>gamepad_input_events</code></a>.</p>
<hr />
<p>Bevy has support for gamepad input hardware, using <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a>:
console controllers, joysticks, etc. Many different kinds of hardware should
work, but if your device is not supported, you should file an issue with the
<a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> project.</p>
<p>bevy利用gilrs库来实现手柄的输入.</p>
<h2 id="gamepad-ids"><a class="header" href="#gamepad-ids">Gamepad IDs</a></h2>
<p>Bevy assigns a unique ID (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.Gamepad.html"><code>Gamepad</code></a>) to each connected gamepad. For local
multiplayer, this lets you associate each device with a specific player and
distinguish which one your inputs are coming from.</p>
<p>You can use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a> <a href="input//programming/res.html">resource</a> to list the IDs of all the
currently connected gamepad devices, or to check the status of a specific one.</p>
<pre><code class="language-rust no_run noplayground">fn list_gamepads(gamepads: Res&lt;Gamepads&gt;) {
    println!("Currently connected gamepads:");
    for gamepad in gamepads.iter() {
        println!(
            "ID: {:?}; Name: {}",
            gamepad,
            gamepads.name(gamepad).unwrap_or("unknown")
        );
    }
}</code></pre>
<p>bevy给每个连接的手柄都分配了唯一id,这个id是用于区分输入源的.</p>
<p>上面的例子是通过Gamepads资源显示所有已连接的手柄.</p>
<h3 id="handling-connections--disconnections"><a class="header" href="#handling-connections--disconnections">Handling Connections / Disconnections</a></h3>
<p>To detect when gamepads are connected or disconnected, you can use
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/enum.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>Example showing how to remember the first connected gamepad ID:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::gamepad::{GamepadConnection, GamepadEvent};

/// Simple resource to store the ID of the first connected gamepad.
/// We can use it to know which gamepad to use for player input.
#[derive(Resource)]
struct MyGamepad(Gamepad);

fn gamepad_connections(
    mut commands: Commands,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut evr_gamepad: EventReader&lt;GamepadEvent&gt;,
) {
    for ev in evr_gamepad.read() {
        // we only care about connection events
        let GamepadEvent::Connection(ev_conn) = ev else {
            continue;
        };
        match &amp;ev_conn.connection {
            GamepadConnection::Connected(info) =&gt; {
                debug!(
                    "New gamepad connected: {:?}, name: {}",
                    ev_conn.gamepad, info.name,
                );
                // if we don't have any gamepad yet, use this one
                if my_gamepad.is_none() {
                    commands.insert_resource(MyGamepad(ev_conn.gamepad));
                }
            }
            GamepadConnection::Disconnected =&gt; {
                debug!("Lost connection with gamepad: {:?}", ev_conn.gamepad);
                // if it's the one we previously used for the player, remove it:
                if let Some(MyGamepad(old_id)) = my_gamepad.as_deref() {
                    if *old_id == ev_conn.gamepad {
                        commands.remove_resource::&lt;MyGamepad&gt;();
                    }
                }
            }
        }
    }
}</code></pre>
<p>使用<code>GamepadEvent</code>事件来检测手柄的连接状态.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum GamepadEvent {
    Connection(GamepadConnectionEvent),
    Button(GamepadButtonChangedEvent),
    Axis(GamepadAxisChangedEvent),
}
<span class="boring">}</span></code></pre></pre>
<p>上面维护手柄连接状态的例子,用资源保存了一个手柄信息,并未支持多手柄.</p>
<h2 id="handling-gamepad-inputs"><a class="header" href="#handling-gamepad-inputs">Handling Gamepad Inputs</a></h2>
<p>The <code>Axis&lt;GamepadAxis&gt;</code> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.Axis.html"><code>Axis</code></a>, <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadAxis.html"><code>GamepadAxis</code></a>) <a href="input//programming/res.html">resource</a>
keeps track of the current value of the different axes: X/Y for each thumb
stick, and the Z axes (the analog triggers).</p>
<p>Buttons can be handled with the <code>ButtonInput&lt;GamepadButton&gt;</code>
(<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a>, <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>) <a href="input//programming/res.html">resource</a>, similar to <a href="input//input/mouse.html#mouse-buttons">mouse
buttons</a> or <a href="input//input/keyboard.html">keyboard keys</a>.</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input(
    axes: Res&lt;Axis&lt;GamepadAxis&gt;&gt;, // 手柄输入可以通过事件或资源获取,这里是通过资源
    buttons: Res&lt;ButtonInput&lt;GamepadButton&gt;&gt;,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
) {
    // 手柄输入的处理流程是标准的: 先处理连接,再处理输入,两者独立处理.
    let Some(&amp;MyGamepad(gamepad)) = my_gamepad.as_deref() else {
        // no gamepad is connected
        // 这里可以只处理感兴趣的手柄,在多手柄连接的场景非常必要.
        // ns主界面,红蓝手柄都能控制,就是没有处理过滤.
        return;
    };

    // The joysticks are represented using a separate axis for X and Y
    let axis_lx = GamepadAxis {
        gamepad,
        axis_type: GamepadAxisType::LeftStickX,
    };
    let axis_ly = GamepadAxis {
        gamepad,
        axis_type: GamepadAxisType::LeftStickY,
    };

    // pub struct Axis&lt;T&gt;, T为输入设备类型,struct存储的是位置信息.
    // Axis.get()获取有限制范围,使用get_unclamped()获取无限制范围.

    if let (Some(x), Some(y)) = (axes.get(axis_lx), axes.get(axis_ly)) {
        // combine X and Y into one vector
        let left_stick = Vec2::new(x, y);

        // Example: check if the stick is pushed up
        if left_stick.length() &gt; 0.9 &amp;&amp; left_stick.y &gt; 0.5 {
            // do something
            // 自定义遥感逻辑.
        }
    }

    // In a real game, the buttons would be configurable, but here we hardcode them
    // 遥感按钮,和普通按钮的处理方式一致.
    let jump_button = GamepadButton {
        gamepad,
        button_type: GamepadButtonType::South,
    };
    let heal_button = GamepadButton {
        gamepad,
        button_type: GamepadButtonType::East,
    };

    if buttons.just_pressed(jump_button) {
        // button just pressed: make the player jump
    }

    if buttons.pressed(heal_button) {
        // button being held down: heal the player
    }
}</code></pre>
<p>Notice that the names of buttons in the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a> <code>enum</code> are
vendor-neutral (like <code>South</code> and <code>East</code> instead of X/O or A/B).</p>
<p>Some game controllers have additional buttons and axes beyond what is available
on a standard controller, for example:</p>
<ul>
<li>HOTAS (stick for flight sim)</li>
<li>steering wheel + pedals (for car driving games)</li>
</ul>
<p>These are represented by the <code>Other(u8)</code> variant in <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadAxis.html"><code>GamepadAxis</code></a>.
The <code>u8</code> value is hardware-specific, so if you want to support such devices,
your game needs to have a way for your users to configure their input bindings.</p>
<p>手柄输入的第一类就是遥感.
通过<code>Axis</code>和<code>GamepadAxis</code>可获取遥感的方向和模拟的Z轴.
遥感按钮是通过<code>ButtonInput&lt;GamepadButton&gt;</code>获取的.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Resource)]
pub struct Axis&lt;T&gt; {
    /// The position data of the input devices.
    axis_data: HashMap&lt;T, f32&gt;,
}

// 如何从资源中获取输入,下面分析一下.起点就是system的资源参数`Res&lt;Axis&lt;GamepadAxis&gt;&gt;`.
// Axis用hashmap来维护输入的值,key为输入类型,value为输入的值;获取值就使用get().
// 从使用的流程上讲,只需要构造一个GamepadAxis来能获取到对应手柄对应的输入事件的值了.

// GamepadAxis设计的如此暴力(简单有效)
pub struct GamepadAxis {
    pub gamepad: Gamepad, // 哪个手柄的
    pub axis_type: GamepadAxisType, // 哪个类型的输入
}

// 左右手柄的xyz是在这儿区分的.
pub enum GamepadAxisType {
    LeftStickX,
    LeftStickY,
    LeftZ,
    RightStickX,
    RightStickY,
    RightZ,
    Other(u8),
}

// 遥感按钮.
// GamepadButtonType枚举, 在bevy中重新取了名字,按键的数量和w3c的标准手柄按钮是能对上的.
pub struct GamepadButton {
    pub gamepad: Gamepad,
    pub button_type: GamepadButtonType,
}
<span class="boring">}</span></code></pre></pre>
<p>bevy中的手柄按钮是贴近某些手柄厂商的,不是贴近w3c标准的.
部分设备还支持非标输入,eg:开车游戏中的方向盘和踏板,飞行游戏中的飞行棒,
这些都用<code>Other(u8)</code>来处理.游戏需要提供一种方法让用户来绑定按键.</p>
<h3 id="events-1"><a class="header" href="#events-1">Events</a></h3>
<p>Alternatively, if you want to detect all activity as it comes in, you
can also handle gamepad inputs using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/enum.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input_events(mut evr_gamepad: EventReader&lt;GamepadEvent&gt;) {
    for ev in evr_gamepad.read() {
        match ev {
            GamepadEvent::Axis(ev_axis) =&gt; {
                println!(
                    "Axis {:?} on gamepad {:?} is now at {:?}",
                    ev_axis.axis_type, ev_axis.gamepad, ev_axis.value
                );
            }
            GamepadEvent::Button(ev_button) =&gt; {
                // The "value" of a button is typically `0.0` or `1.0`, but it
                // is a `f32` because some gamepads may have buttons that are
                // pressure-sensitive or otherwise analog somehow.
                println!(
                    "Button {:?} on gamepad {:?} is now at {:?}",
                    ev_button.button_type, ev_button.gamepad, ev_button.value
                );
            }
            _ =&gt; {
                // we don't care about other events here (connect/disconnect)
            }
        }
    }
}</code></pre>
<p>如果要捕获手柄的所有事件,用<code>GamepadEvent</code>.</p>
<h2 id="gamepad-settings"><a class="header" href="#gamepad-settings">Gamepad Settings</a></h2>
<p>You can use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a> <a href="input//programming/res.html">resource</a> to configure dead-zones
and other parameters of the various axes and buttons. You can set the global
defaults, as well as individually per-axis/button.</p>
<p>Here is an example showing how to configure gamepads with custom settings
(not necessarily <em>good</em> settings, please don't copy these blindly):</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::gamepad::{AxisSettings, ButtonSettings, GamepadSettings};

fn configure_gamepads(my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;, mut settings: ResMut&lt;GamepadSettings&gt;) {
    let Some(&amp;MyGamepad(gamepad)) = my_gamepad.as_deref() else {
        // no gamepad is connected
        return;
    };

    // add a larger default dead-zone to all axes (ignore small inputs, round to zero)
    settings.default_axis_settings.set_deadzone_lowerbound(-0.1);
    settings.default_axis_settings.set_deadzone_upperbound(0.1);

    // make the right stick "binary", squash higher values to 1.0 and lower values to 0.0
    let mut right_stick_settings = AxisSettings::default();
    right_stick_settings.set_deadzone_lowerbound(-0.5);
    right_stick_settings.set_deadzone_upperbound(0.5);
    right_stick_settings.set_livezone_lowerbound(-0.5);
    right_stick_settings.set_livezone_upperbound(0.5);
    // the raw value should change by at least this much,
    // for Bevy to register an input event:
    right_stick_settings.set_threshold(0.01);

    // make the triggers work in big/coarse steps, to get fewer events
    // reduces noise and precision
    let mut trigger_settings = AxisSettings::default();
    trigger_settings.set_threshold(0.25);

    // set these settings for the gamepad we use for our player
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::RightStickX,
        },
        right_stick_settings.clone(),
    );
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::RightStickY,
        },
        right_stick_settings.clone(),
    );
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::LeftZ,
        },
        trigger_settings.clone(),
    );
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::RightZ,
        },
        trigger_settings.clone(),
    );

    // for buttons (or axes treated as buttons):
    let mut button_settings = ButtonSettings::default();
    // require them to be pressed almost all the way, to count
    button_settings.set_press_threshold(0.9);
    // require them to be released almost all the way, to count
    button_settings.set_release_threshold(0.1);

    settings.default_button_settings = button_settings;
}</code></pre>
<p>To tie the examples together: if you have the <a href="input//programming/systems.html">system</a> from the
<a href="input/gamepad.html#handling-connections--disconnections">connect/disconnect example</a> earlier
above on this page, to update our <code>MyGamepad</code> resource, we can configure
the system from the above example with a <a href="input//programming/run-criteria.html">run condition</a>, so that
the gamepad settings are updated whenever a new gamepad is connected and
selected to be used:</p>
<pre><code class="language-rust no_run noplayground">    app.add_systems(
        Update,
        configure_gamepads.run_if(resource_exists_and_changed::&lt;MyGamepad&gt;),
    );</code></pre>
<p>每个遥感都可以设置<code>死区</code>,也可以全局配置.</p>
<h2 id="gamepad-rumble"><a class="header" href="#gamepad-rumble">Gamepad Rumble</a></h2>
<p>To cause rumble/vibration, use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/enum.GamepadRumbleRequest.html"><code>GamepadRumbleRequest</code></a> event. Every
event you send will add a "rumble" with a given intensity that lasts for
a given duration of time. As you send multiple events, each requested rumble
will be tracked independently, and the actual hardware vibration intensity
will be the sum of all the rumbles currently in progress.</p>
<p>You can also send a <code>Stop</code> event to immediately cancel any ongoing rumbling.</p>
<p>The intensity of each rumble is represented as two values: the "strong"
motor and the "weak" motor. These might produce different-feeling vibrations
on different hardware.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::gamepad::{GamepadRumbleIntensity, GamepadRumbleRequest};

fn gamepad_rumble(
    mut evw_rumble: EventWriter&lt;GamepadRumbleRequest&gt;,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
) {
    let Some(&amp;MyGamepad(gamepad)) = my_gamepad.as_deref() else {
        // no gamepad is connected
        return;
    };

    // add a short 100ms rumble at max intensity
    evw_rumble.send(GamepadRumbleRequest::Add {
        gamepad,
        duration: Duration::from_millis(100),
        intensity: GamepadRumbleIntensity::MAX,
    });

    // also rumble for a little longer (500 ms)
    // with the weak motor at half intensity
    // and the strong motor at quarter intensity
    evw_rumble.send(GamepadRumbleRequest::Add {
        gamepad,
        duration: Duration::from_millis(500),
        intensity: GamepadRumbleIntensity {
            strong_motor: 0.25,
            weak_motor: 0.5,
        },
    });
}</code></pre>
<p>手柄振动.<code>GamepadRumbleRequest</code>事件.
您发送的每个事件都会添加具有给定强度并持续给定时间的震动.
当您发送多个事件时,每个请求的震动都会被单独跟踪,
实际的硬件振动强度将是当前正在进行的所有震动的总和.</p>
<p><code>Stop</code>事件会立马终止振动.
振动有时长,有强弱.</p>
<p>强弱能设置为渐进的.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="touchscreen"><a class="header" href="#touchscreen">Touchscreen</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/touch_input.rs"><code>touch_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/touch_input_events.rs"><code>touch_input_events</code></a>.</p>
<hr />
<p>Multi-touch touchscreens are supported. You can track multiple fingers on
the screen, with position and pressure/force information. Bevy does not
offer gesture recognition.</p>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/input/touch/struct.Touches.html"><code>Touches</code></a> <a href="input//programming/res.html">resource</a> allows you to track any
fingers currently on the screen:</p>
<pre><code class="language-rust no_run noplayground">fn touches(
    touches: Res&lt;Touches&gt;,
) {
    // There is a lot more information available, see the API docs.
    // This example only shows some very basic things.

    for finger in touches.iter() {
        if touches.just_pressed(finger.id()) {
            println!("A new touch with ID {} just began.", finger.id());
        }
        println!(
            "Finger {} is at position ({},{}), started from ({},{}).",
            finger.id(),
            finger.position().x,
            finger.position().y,
            finger.start_position().x,
            finger.start_position().y,
        );
    }
}</code></pre>
<p>Alternatively, you can use <a href="https://docs.rs/bevy/0.9.1/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn touch_events(
    mut touch_evr: EventReader&lt;TouchInput&gt;,
) {
    use bevy::input::touch::TouchPhase;
    for ev in touch_evr.iter() {
        // in real apps you probably want to store and track touch ids somewhere
        match ev.phase {
            TouchPhase::Started =&gt; {
                println!("Touch {} started at: {:?}", ev.id, ev.position);
            }
            TouchPhase::Moved =&gt; {
                println!("Touch {} moved to: {:?}", ev.id, ev.position);
            }
            TouchPhase::Ended =&gt; {
                println!("Touch {} ended at: {:?}", ev.id, ev.position);
            }
            TouchPhase::Cancelled =&gt; {
                println!("Touch {} cancelled at: {:?}", ev.id, ev.position);
            }
        }
    }
}</code></pre>
<p>触摸支持<code>多指</code>,在屏幕上可跟踪多指的按下和压力信息,bevy原生没有提供手势识别,
如果有需要,游戏中需要自己实现.</p>
<p><code>Touches</code>资源可以跟踪手指信息;<code>TouchInput</code>事件也能达到同样的效果.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="gestures"><a class="header" href="#gestures">Gestures</a></h1>
<p>Multi-finger gestures on a Touchpad or Touchscreen are a very common
way to implement various operations, like panning, zooming, and rotating.</p>
<p>触摸屏上的多指手势识别可进行平移/缩放/旋转等常见操作,
而手势识别的实现还是有套路的.</p>
<h2 id="platform-gesture-events"><a class="header" href="#platform-gesture-events">Platform Gesture Events</a></h2>
<p>Bevy offers <a href="input//programming/events.html">events</a> that allow you to handle gestures as they
are detected / implemented by the OS.</p>
<p>Currently, only macOS and iOS are supported. Other platforms may be supported
in the future.</p>
<p>The supported gestures are:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.RotationGesture.html"><code>RotationGesture</code></a>: rotating with two fingers</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.PinchGesture.html"><code>PinchGesture</code></a>: pinch-to-zoom with two fingers</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.PanGesture.html"><code>PanGesture</code></a>: panning gesture</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.DoubleTapGesture.html"><code>DoubleTapGesture</code></a>: double-tap gesture</li>
</ul>
<pre><code class="language-rust no_run noplayground">use bevy::input::gestures::{
    DoubleTapGesture, PanGesture, PinchGesture, RotationGesture
};

// these only work on macOS and iOS
fn builtin_gestures(
    mut evr_gesture_pinch: EventReader&lt;PinchGesture&gt;,
    mut evr_gesture_rotate: EventReader&lt;RotationGesture&gt;,
    mut evr_gesture_pan: EventReader&lt;PanGesture&gt;,
    mut evr_gesture_doubletap: EventReader&lt;PanGesture&gt;,
) {
    for ev_pinch in evr_gesture_pinch.read() {
        // Positive numbers are zooming in
        // Negative numbers are zooming out
        println!("Two-finger zoom by {}", ev_pinch.0);
    }
    for ev_rotate in evr_gesture_rotate.read() {
        // Positive numbers are anticlockwise
        // Negative numbers are clockwise
        println!("Two-finger rotate by {}", ev_rotate.0);
    }
    for ev_pan in evr_gesture_pan.read() {
        // Each event is a Vec2 giving you the X/Y pan amount
        println!("Two-finger pan by X: {}, Y: {}", ev_pan.0.x, ev_pan.0.y);
    }
    for ev_doubletap in evr_gesture_doubletap.read() {
        // This one has no data
        println!("Double-Tap gesture!");
    }
}</code></pre>
<p>依赖平台的手势识别事件,mac系列是支持的.</p>
<h2 id="custom-touchpad-gestures"><a class="header" href="#custom-touchpad-gestures">Custom Touchpad Gestures</a></h2>
<p>It is not currently possible to implement your own gestures on a touchpad,
because there is no API to detect the individual fingers that are touching
the touchpad.</p>
<p>pad上的自定义手势识别还不支持,因为没有api来跟踪单个手指.</p>
<h2 id="custom-touchscreen-gestures"><a class="header" href="#custom-touchscreen-gestures">Custom Touchscreen Gestures</a></h2>
<p>You can (and probably should) implement your own touchscreen gestures. Bevy
offers multi-touch detection, tracking each finger that is currently on the
screen. Implementing your own gestures is be a good way to make touchscreen
input behave appropriately to your application.</p>
<p><a href="input//input/touch.html">See here for more info on touchscreen input in Bevy.</a></p>
<p>触摸屏上的手势识别可以尝试一下.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="drag-and-drop-files"><a class="header" href="#drag-and-drop-files">Drag-and-Drop (Files)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/app/drag_and_drop.rs"><code>drag_and_drop</code></a>.</p>
<hr />
<p>Bevy supports the Drag-and-Drop gesture common on most desktop operating
systems, but only for files, not arbitrary data / objects.</p>
<p>If you drag a file (say, from the file manager app) into a Bevy app, Bevy
will produce a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a> <a href="input//programming/events.html">event</a>, containing the path
of the file that was dropped in.</p>
<pre><code class="language-rust no_run noplayground">fn file_drop(
    mut evr_dnd: EventReader&lt;FileDragAndDrop&gt;,
) {
    for ev in evr_dnd.read() {
        if let FileDragAndDrop::DroppedFile { id, path_buf } = ev {
            println!("Dropped file with path: {:?}, in window id: {:?}", path_buf, id);
        }
    }
}</code></pre>
<p>拖拽,在桌面平台,且只支持文件.通过<code>FileDragAndDrop</code>事件捕获.</p>
<h2 id="detecting-the-position-of-the-drop"><a class="header" href="#detecting-the-position-of-the-drop">Detecting the Position of the Drop</a></h2>
<p>You may want to do different things depending on where the cursor was when the
drop gesture ended. For example, add the file to some collection, if it was
dropped over a specific UI element/panel.</p>
<p>Unfortunately, this is currently somewhat tricky to implement, due to <a href="https://github.com/rust-windowing/winit/issues/1550"><code>winit</code>
bug #1550</a>. Bevy does not get <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a> <a href="input//programming/events.html">events</a>
while the drag gesture is ongoing, and therefore does not respond to the
mouse cursor. Bevy completely loses track of the cursor position.</p>
<p>Checking the cursor position from the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.Window.html"><code>Window</code></a> will also not work.</p>
<p>Systems that use cursor events to respond to cursor movements will not work
during a drag gesture. This includes Bevy UI's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ui/enum.Interaction.html"><code>Interaction</code></a> detection,
which is the usual way of detecting when a UI element is hovered over.</p>
<p>您可能想要根据放下手势结束时光标所在的位置执行不同的操作.
例如,如果将文件拖放到特定的 UI 元素/面板上,则将文件添加到某个集合.
因为winit功能缺失,这个功能还未实现.</p>
<h3 id="workaround"><a class="header" href="#workaround">Workaround</a></h3>
<p>The only way to workaround this issue is to store the file path somewhere
temporarily after receiving the drop event. Then, wait until the next
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a> event, and then process the file.</p>
<p>Note that this might not even be on the next frame update. The next cursor
update will happen whenever the user moves the cursor. If the user does not
immediately move the mouse after dropping the file and leaves the cursor in the
same place for a while, there will be no events and your app will have no way of
knowing the cursor position.</p>
<p>解决此问题的唯一方法是在收到放置事件后将文件路径临时存储在某处.
然后,等待下一个 CursorMoved 事件,然后处理该文件.
请注意,这甚至可能不是在下一帧更新时.
只要用户移动光标,就会发生下一次光标更新.
如果用户在放下文件后没有立即移动鼠标,而是将光标停留在同一位置一段时间,
则不会发生任何事件,您的应用也无法知道光标的位置.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="ime-input"><a class="header" href="#ime-input">IME Input</a></h1>
<p>Bevy has support for IMEs (Input Method Editors), which is how people perform
text input in languages with more complex scripts, like East Asian languages, and
how non-keyboard text input methods (such as handwriting recognition) work. It
requires some special handling from you, however.</p>
<p>If you'd like all international users to be able to input text in their
language, the way they usually do in other GUI apps on their OS, you should
support IMEs. If you want good accessibility for disabled users or users
who prefer alternative text input methods like handwriting recognition, you
should support IMEs. This should be in addition to supporting <a href="input//input/keyboard.html#text-input">text input via
the keyboard</a>, which is how most users will input text.</p>
<p>复杂的输入需要使用IME支持,其中就包括汉字输入.
支持IME就可以支持不同语言的玩家.</p>
<h2 id="how-imes-work"><a class="header" href="#how-imes-work">How IMEs Work</a></h2>
<p>IMEs work by using a special "buffer", which shows the current in-progress
text suggestions and allows users to preview and compose the next part of
their text before confirming it. The text suggestions are provided by the OS,
but your app needs to display them for the user.</p>
<p>For example, imagine you have a text input box in your UI. You show the text
that the user has already inputted, with a cursor at the end.</p>
<p>If IME is enabled, you will get <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Preedit</code></a> <a href="input//programming/events.html">events</a>
for "pending" text.  You should show that "unconfirmed" text in the text
input box, but with different formatting to be visually distinct.</p>
<p>When the user confirms their desired input, you will get an
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Commit</code></a> <a href="input//programming/events.html">event</a> with the final text. You should
then discard any previous "uncofirmed" text and append the new text to your
actual text input string.</p>
<p>IME的工作原理是利用一个特殊的缓冲,通过这个缓冲可以得到候选字,
也可以将后来输入的和前面的合并形成新的候选字,用户在确认之前还可以预览.
生成候选字是其他OS提供的,但app需要显示用户输入.</p>
<p>在整个用户输入的过程中,app需要显示用户已确认的文本,并在最后显示光标.</p>
<p>如果启用了IME,通过<code>Ime::Preedit</code>事件得到阻塞的文本.
通过<code>Ime::Commit</code>事件得到用户确认的文本,加上之前确认的文本就是所有输入的文本.</p>
<h2 id="how-to-support-imes-in-your-bevy-app"><a class="header" href="#how-to-support-imes-in-your-bevy-app">How to support IMEs in your Bevy app</a></h2>
<p>First, you need to inform the OS when your application is expecting text input.
You don't want the IME to accidentally activate during gameplay, etc.</p>
<p>Whenever you want the user to input text, you enable "IME mode" on the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.Window.html"><code>Window</code></a>.
When you are done, disable it.</p>
<p>If the user is not using an IME, nothing happens when you enable "IME mode". You
will still get <a href="input//input/keyboard.html">keyboard</a> <a href="input//programming/events.html">events</a> as usual and you
can <a href="input//input/keyboard.html#text-input">accept text input that way</a>.</p>
<p>If the user has an IME, you will get an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Enabled</code></a> event. At that point,
your application will no longer receive any <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>You can then handle <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Preedit</code></a> <a href="input//programming/events.html">events</a> for pending/unconfirmed
text, and <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Commit</code></a> for final/confirmed text.</p>
<pre><code class="language-rust no_run noplayground">// for this simple example, we will just enable/disable IME mode on mouse click
fn ime_toggle(
    mousebtn: Res&lt;ButtonInput&lt;MouseButton&gt;&gt;,
    mut q_window: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    // 这里非常人性化的显示了鼠标左键单击就开始输入(可以换成enter输入,enter结束输入)
    if mousebtn.just_pressed(MouseButton::Left) {
        let mut window = q_window.single_mut();

        // toggle "IME mode"
        window.ime_enabled = !window.ime_enabled;

        // We need to tell the OS the on-screen coordinates where the text will
        // be displayed; for this simple example, let's just use the mouse cursor.
        // In a real app, this might be the position of a UI text field, etc.
        window.ime_position = window.cursor_position().unwrap();
    }
}

fn ime_input(mut evr_ime: EventReader&lt;Ime&gt;) {
    for ev in evr_ime.read() {
        match ev {
            Ime::Commit { value, .. } =&gt; {
                println!("IME confirmed text: {}", value);
            }
            Ime::Preedit { value, cursor, .. } =&gt; {
                println!("IME buffer: {:?}, cursor: {:?}", value, cursor);
            }
            Ime::Enabled { .. } =&gt; {
                println!("IME mode enabled!");
            }
            Ime::Disabled { .. } =&gt; {
                println!("IME mode disabled!");
            }
        }
    }
}</code></pre>
<p>For the sake of brevity, this example just prints the events to the console.</p>
<p>In a real app, you will want to display the "pre-edit" text on-screen, and use
different formatting to show the cursor. On "commit", you can append the
provided text to the actual string where you normally accept text input.</p>
<p>要在app中启用ime,按如下顺序操作:</p>
<ul>
<li>系统安装需要的输入法</li>
<li>在窗口启用IME功能</li>
</ul>
<p>当app的IME开始生效时(接收Ime::Enabled事件后),就不会在接收到的KeyboardInput事件了.
此时需要将pre-edit的文本显示在屏幕上,将已确认的文本显示在正确的位置,并在最后显示光标,
在<code>Commit</code>之后意味着输入结束,接着走后续逻辑.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="window-management"><a class="header" href="#window-management">Window Management</a></h1>
<p>This chapter covers topics related to working with the application's OS window.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="window-properties"><a class="header" href="#window-properties">Window Properties</a></h1>
<p>Page coming soon…</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<p>See the <a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/window/window_settings.rs"><code>window_settings</code></a> example.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="changing-the-background-color"><a class="header" href="#changing-the-background-color">Changing the Background Color</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/window/clear_color.rs"><code>clear_color</code></a>.</p>
<hr />
<p>Use the <a href="https://docs.rs/bevy/0.13.0/bevy/render/camera/struct.ClearColor.html"><code>ClearColor</code></a> <a href="window//programming/res.html">resource</a> to choose the default background
color. This color will be used as the default for all <a href="window//graphics/camera.html">cameras</a>,
unless overriden.</p>
<p>Note that the window will be black if no cameras exist. You must spawn at
least one camera.</p>
<pre><code class="language-rust no_run noplayground">fn setup(
    mut commands: Commands,
) {
    // this camera will use the default color
    commands.spawn(Camera2dBundle::default());
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // set the global default clear color
        .insert_resource(ClearColor(Color::rgb(0.9, 0.3, 0.6)))
        .add_systems(Startup, setup)
        .run();
}</code></pre>
<p>To override the default and use a different color for a specific camera, you can
set it using the <a href="https://docs.rs/bevy/0.13.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a> <a href="window//programming/ec.html#components">component</a>.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ClearColorConfig;

// configure the background color (if any), for a specific camera (3D)
commands.spawn(Camera3dBundle {
    camera: Camera {
        // clear the whole viewport with the given color
        clear_color: ClearColorConfig::Custom(Color::rgb(0.8, 0.4, 0.2)),
        ..Default::default()
    },
    ..Default::default()
});

// configure the background color (if any), for a specific camera (2D)
commands.spawn(Camera2dBundle {
    camera: Camera {
        // disable clearing completely (pixels stay as they are)
        // (preserves output from previous frame or camera/pass)
        clear_color: ClearColorConfig::None,
        ..Default::default()
    },
    ..Default::default()
});</code></pre>
<p>All of these locations (the components on specific cameras, the global default
resource) can be mutated at runtime, and bevy will use your new color. Changing
the default color using the resource will apply the new color to all existing
cameras that do not specify a custom color, not just newly-spawned cameras.</p>
<p><code>ClearColor</code>资源可用于设置相机默认背景色,默认对所有相机都生效.
如果没有相机,窗口默认是黑色的.</p>
<p>更改这个资源,会影响到所有相机,已有实体和即将新建的实体.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="grabbing-the-mouse"><a class="header" href="#grabbing-the-mouse">Grabbing the Mouse</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/input/mouse_grab.rs"><code>mouse_grab</code></a>.</p>
<hr />
<p>For some genres of games, you want to the mouse to be restricted to the window,
to prevent it from leaving the window during gameplay.</p>
<p>There are two variations on this behavior (<a href="https://docs.rs/bevy/0.13.0/bevy/window/enum.CursorGrabMode.html"><code>CursorGrabMode</code></a>):</p>
<ul>
<li><code>Confined</code> allows the cursor to be moved, but only within the bounds of the window.</li>
<li><code>Locked</code> fixes the cursor in place and does not allow it to move.
<ul>
<li>Relative <a href="window//input/mouse.html#mouse-motion">mouse motion</a> <a href="window//programming/events.html">events</a> still work.</li>
</ul>
</li>
</ul>
<p>To grab the cursor:</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::{CursorGrabMode, PrimaryWindow};

fn cursor_grab(
    mut q_windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    let mut primary_window = q_windows.single_mut();

    // if you want to use the cursor, but not let it leave the window,
    // use `Confined` mode:
    primary_window.cursor.grab_mode = CursorGrabMode::Confined;

    // for a game that doesn't use the cursor (like a shooter):
    // use `Locked` mode to keep the cursor in one place
    primary_window.cursor.grab_mode = CursorGrabMode::Locked;

    // also hide the cursor
    primary_window.cursor.visible = false;
}</code></pre>
<p>To release the cursor:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_ungrab(
    mut q_windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    let mut primary_window = q_windows.single_mut();

    primary_window.cursor.grab_mode = CursorGrabMode::None;
    primary_window.cursor.visible = true;
}</code></pre>
<p>You should grab the cursor during active gameplay and release it when
the player pauses the game / exits to menu / etc.</p>
<p>For relative mouse movement, you should use <a href="window//input/mouse.html#mouse-motion">mouse motion</a>
instead of <a href="window//input/mouse.html#mouse-cursor-position">cursor input</a> to implement your gameplay.</p>
<p>鼠标捕获,部分场景下需要光标不能离开窗口,具体场景有两种:</p>
<ul>
<li><code>Confined</code>: 光标移不出窗口</li>
<li><code>Locked</code>: 固定在一个区域,适合射击游戏,这样光标被固定在某个位置</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CursorGrabMode {
    None,
    Confined, // macOS不支持这个
    Locked, // windows不支持这个
}
<span class="boring">}</span></code></pre></pre>
<p>ios/android不支持光标.</p>
<p>从上面例子看,捕获鼠标和ime输入一样,都是可以在system中启用/关闭的.
在游戏暂停或退出时,可以释放鼠标.</p>
<h2 id="platform-differences"><a class="header" href="#platform-differences">Platform Differences</a></h2>
<p>macOS does not natively support <code>Confined</code> mode. Bevy will fallback to <code>Locked</code>.
If you want to support macOS and you want to use <a href="window//input/mouse.html#mouse-cursor-position">cursor input</a>,
you might want to implement a "virtual cursor" instead.</p>
<p>Windows does not natively support <code>Locked</code> mode. Bevy will fallback to <code>Confined</code>.
You could emulate the locked behavior by re-centering the cursor every frame:</p>
<pre><code class="language-rust no_run noplayground">#[cfg(target_os = "windows")]
fn cursor_recenter(
    mut q_windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    let mut primary_window = q_windows.single_mut();
    let center = Vec2::new(
        primary_window.width() / 2.0,
        primary_window.height() / 2.0,
    );
    primary_window.set_cursor_position(Some(center));
}</code></pre>
<pre><code class="language-rust no_run noplayground">#[cfg(target_os = "windows")]
app.add_systems(Update, cursor_recenter);</code></pre>
<p>平台差异.在macOS中没有<code>Confined</code>,要实现类似效果只能实现一个虚拟光标;
windows没有<code>Locked</code>模式,只能在每帧中重新将光标放在中心来实现.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="setting-the-window-icon"><a class="header" href="#setting-the-window-icon">Setting the Window Icon</a></h1>
<p>You might want to set a custom Window Icon. On Windows and Linux, this is
the icon image shown in the window title bar (if any) and task bar (if any).</p>
<p>Unfortunately, Bevy does not yet provide an easy and ergonomic built-in way
to do this. However, it can be done via the <code>winit</code> APIs.</p>
<p>The way shown here is quite hacky. To save on code complexity, instead of
using Bevy's asset system to load the image in the background, we bypass
the assets system and directly load the file using the <code>image</code> library.</p>
<p>There is some WIP on adding a proper API for this to Bevy; see PRs
<a href="https://github.com/bevyengine/bevy/issues/1163">#1163</a>, <a href="https://github.com/bevyengine/bevy/pull/2268">#2268</a>, <a href="https://github.com/bevyengine/bevy/issues/5488">#5488</a>,
<a href="https://github.com/bevyengine/bevy/issues/8130">#8130</a>, and <a href="https://github.com/bevyengine/bevy/issues/1031">Issue #1031</a>.</p>
<p>This example shows how to set the icon for the primary/main window, from
a Bevy startup system.</p>
<pre><code class="language-rust no_run noplayground">use bevy::winit::WinitWindows;
use winit::window::Icon;

fn set_window_icon(
    // we have to use `NonSend` here
    windows: NonSend&lt;WinitWindows&gt;,
) {
    // here we use the `image` crate to load our icon data from a png file
    // this is not a very bevy-native solution, but it will do
    let (icon_rgba, icon_width, icon_height) = {
        let image = image::open("my_icon.png")
            .expect("Failed to open icon path")
            .into_rgba8();
        let (width, height) = image.dimensions();
        let rgba = image.into_raw();
        (rgba, width, height)
    };
    let icon = Icon::from_rgba(icon_rgba, icon_width, icon_height).unwrap();

    // do it for all windows
    for window in windows.windows.values() {
        window.set_window_icon(Some(icon.clone()));
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, set_window_icon)
        .run();
}</code></pre>
<p>Note: that <a href="https://docs.rs/bevy/0.13.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> is a <a href="window//programming/non-send.html">non-send resource</a>.</p>
<p>Note: you need to add <code>winit</code> and <code>image</code> to your project's dependencies,
and they must be the same versions as used by Bevy. As of Bevy 0.13, that
should be <code>winit = "0.29"</code> and <code>image = "0.24"</code>. If you don't know which
version to use, you can use <code>cargo tree</code> or check <code>Cargo.lock</code> to see which
is the correct version.</p>
<p>窗口设置的图标会显示在标题栏和任务栏.
在bevy中只能通过winit API来实现.</p>
<p>为了简化复杂度,不是通过资产来加载图片,而是直接使用image库来加载.</p>
<p>在使用过程中有几点需要注意:</p>
<ul>
<li><code>WinitWindows</code>资源要指定为NonSend(只在主线程上运行)</li>
<li>需要依赖<code>winit</code>和<code>image</code>,且版本还要和bevy最新版保持一致</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-asset-management"><a class="header" href="#bevy-asset-management">Bevy Asset Management</a></h1>
<p>Assets are the data that the game engine is working with: all of your images,
3D models, sounds, scenes, game-specific things like item descriptions,
and more!</p>
<p>Bevy has a flexible system for loading and managing your game assets
asynchronously (in the background, without causing lag spikes in your game).</p>
<p>In your code, you refer to individual assets using <a href="/assets/handles.html">handles</a>.</p>
<p>Asset data can be <a href="/assets/assetserver.html">loaded from files</a> and also <a href="/assets/data.html">accessed from
code</a>. <a href="/assets/hot-reload.html">Hot-reloading</a> is supported to
help you during development, by reloading asset files if they change while the
game is running.</p>
<p>If you want to write some code to do something when assets finish loading, get
modified, or are unloaded, you can use <a href="/assets/assetevent.html">asset events</a>.</p>
<p>游戏引擎会用到的东西,如所有的图片,3d模型,声音,场景,游戏特定数据(物品描述)等等,
这些都是资产.</p>
<p>bevy加载管理资产非常灵活,支持异步.
bevy使用<code>handles</code>来引用不同的资源,术语是<code>句柄</code>,一个轻量级的ID.</p>
<p>资产是从文件中加载,在代码中访问,开发阶段还支持<code>热加载</code>,
游戏运行过程中,如果资产发生了变化,还可以进行<code>reload</code>.</p>
<p>通过资产事件,在资产加载完毕后可进行修改和卸载.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="handles"><a class="header" href="#handles">Handles</a></h1>
<p>Handles are lightweight IDs that refer to a specific asset. You need them
to use your assets, for example to <a href="assets//programming/commands.html">spawn entities</a> like
<a href="assets//2d/sprites.html">2D sprites</a> or <a href="assets//3d/gltf.html">3D models</a>, or to <a href="assets//assets/data.html">access the data
of the assets</a>.</p>
<p>Handles have the Rust type <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Handle.html"><code>Handle&lt;T&gt;</code></a>, where <code>T</code> is the
<a href="assets//builtins.html#assets">asset type</a>.</p>
<p>You can store handles in your <a href="assets//programming/ec.html#components">entity components</a> or
<a href="assets//programming/res.html">resources</a>.</p>
<p>Handles can refer to not-yet-loaded assets, meaning you can just spawn your
entities anyway, using the handles, and the assets will just "pop in" when
they become ready.</p>
<p>资产的句柄是一个轻量级ID,这个ID会指向真正的资产数据,
在实体构造中会使用到句柄(eg:2d精灵/3d模型).</p>
<p><code>Handle&lt;T&gt;</code>是句柄,T为资产类型.
组件/资源都可以存储句柄.</p>
<p>有了句柄后,实体构造时就可以使用句柄,实际的资产可以在后面加载.</p>
<h2 id="obtaining-handles"><a class="header" href="#obtaining-handles">Obtaining Handles</a></h2>
<p>If you are <a href="assets//assets/assetserver.html">loading an asset from a file</a>, the
<code>asset_server.load(…)</code> call will give you the handle. The loading of the
data happens in the background, meaning that the handle will initially refer
to an unavailable asset, and the actual data will become available later.</p>
<p>If you are <a href="assets//assets/data.html">creating your own asset data from code</a>,
the <code>assets.add(…)</code> call will give you the handle.</p>
<p>如何获取句柄:<code>asset_server.load(…)</code>从文件加载资产时会得到句柄,
实际的加载过程是异步的.</p>
<p>还有一种方式是从代码中创建资产,<code>assets.add()</code>.</p>
<h2 id="reference-counting-strong-and-weak-handles"><a class="header" href="#reference-counting-strong-and-weak-handles">Reference Counting; Strong and Weak Handles</a></h2>
<p>Bevy keeps track of how many handles to a given asset exist at any time. Bevy
will automatically unload unused assets, after the last handle is dropped.</p>
<p>For this reason, creating additional handles to the same asset requires you
to call <code>handle.clone()</code>. This makes the operation explicit, to ensure you are
aware of all the places in your code where you create additional handles. The
<code>.clone()</code> operation is cheap, so don't worry about performance (in most cases).</p>
<p>There are two kinds of handles: "strong" and "weak". Strong assets are
counted, weak handles are not. By default, handles are strong. If you want
to create a weak handle, use <code>.clone_weak()</code> (instead of <code>.clone()</code>) on an
existing handle. Bevy can unload the asset after all strong handles are gone,
even if you are still holding some weak handles.</p>
<p>句柄可以clone,所以就有了引用计数器,当所有的引用都释放后,bevy会自动卸载不使用的资产,
<code>clone</code>克隆的是强句柄,<code>clone_weak</code>克隆的是弱句柄,差别在与弱句柄没有引用计数器,
也不关心资产是否是已加载的.</p>
<h2 id="untyped-handles"><a class="header" href="#untyped-handles">Untyped Handles</a></h2>
<p>Bevy also has a <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.HandleUntyped.html"><code>HandleUntyped</code></a> type. Use this type
of handle if you need to be able to refer to any asset, regardless of the
asset type.</p>
<p>This allows you to store a collection (such as <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> or <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>HashMap</code></a>)
containing assets of mixed types.</p>
<p>You can create an untyped handle using <code>.clone_untyped()</code> on an existing
handle.</p>
<p>Just like regular handles, untyped handles can be strong or weak.</p>
<p>You need to do this to <a href="assets//assets/data.html">access the asset data</a>.</p>
<p>You can convert an untyped handle into a typed handle with <code>.typed::&lt;T&gt;()</code>,
specifying the type to use. You need to do this to <a href="assets//assets/data.html">access the asset
data</a>.</p>
<p>如果要引用任意类型的资产,可以使用无类型句柄<code>HandleUntyped</code>,
<code>clone_untyped</code>就能创建无类型句柄,<code>type::&lt;T&gt;</code>转换成有类型的.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="load-assets-from-files-with-assetserver"><a class="header" href="#load-assets-from-files-with-assetserver">Load Assets from Files with AssetServer</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/asset/asset_loading.rs"><code>asset_loading</code></a>.</p>
<hr />
<p>To load assets from files, use the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>
<a href="assets//programming/res.html">resource</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct UiFont(Handle&lt;Font&gt;);

fn load_ui_font(mut commands: Commands, server: Res&lt;AssetServer&gt;) {
    let handle: Handle&lt;Font&gt; = server.load("font.ttf");

    // we can store the handle in a resource:
    //  - to prevent the asset from being unloaded
    //  - if we want to use it to access the asset later
    commands.insert_resource(UiFont(handle));
}</code></pre>
<p>This queues the asset loading to happen in the background, and return a
<a href="assets//assets/handles.html">handle</a>. The asset will take some time to become available. You
cannot access the actual data immediately in the same <a href="assets//programming/systems.html">system</a>,
but you can use the handle.</p>
<p>You can spawn entities like your 2D sprites, 3D models, and UI, using the
handle, even before the asset has loaded. They will just "pop in" later,
when the asset becomes ready.</p>
<p>Note that it is OK to call <code>asset_server.load(…)</code> as many times as you want,
even if the asset is currently loading, or already loaded. It will just
provide you with the same handle. Every time you call it, it will just check
the status of the asset, begin loading it if needed, and give you a handle.</p>
<p>Bevy supports loading <a href="assets//builtins.html#file-formats">a variety of asset file formats</a>,
and can be extended to support more. The asset loader implementation to use
is selected based on the file extension.</p>
<p>从文件加载资产使用<code>AssetServer</code>资源,这样可以将资产存到资源中.
文件,图片都可以这么玩.</p>
<p>加载资产的队列,是在后台执行的,对同一个资产多次调用<code>asset_server.load()</code>,
会得到同一个句柄.</p>
<h2 id="untyped-loading"><a class="header" href="#untyped-loading">Untyped Loading</a></h2>
<p>If you want an <a href="assets//assets/handles.html#untyped-handles">untyped handle</a>, you can use
<code>asset_server.load_untyped(…)</code> instead.</p>
<p>Untyped loading is possible, because Bevy always detects the file type from
the file extension anyway.</p>
<h3 id="loading-folders"><a class="header" href="#loading-folders">Loading Folders</a></h3>
<p>You can also load an entire folder of assets, regardless of how many
files are inside, using <code>asset_server.load_folder(…)</code>. This gives you a
<code>Vec&lt;HandleUntyped&gt;</code> with all the <a href="assets//assets/handles.html#untyped-handles">untyped handles</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct ExtraAssets(Vec&lt;HandleUntyped&gt;);

fn load_extra_assets(mut commands: Commands, server: Res&lt;AssetServer&gt;) {
    if let Ok(handles) = server.load_folder("extra") {
        commands.insert_resource(ExtraAssets(handles));
    }
}</code></pre>
<p>Loading folders is not supported by all I/O backends. Notably, it does not
work on WASM/Web.</p>
<p><code>load_folder</code>加载整个文件夹,得到的是一个<code>Vec&lt;HandleUntyped&gt;</code>,wasm/web不支持这种.</p>
<h2 id="assetpath-and-labels"><a class="header" href="#assetpath-and-labels">AssetPath and Labels</a></h2>
<p>The asset path you use to identify an asset from the filesystem is actually
a special <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetPath.html"><code>AssetPath</code></a>, which consists of the file path +
a label. Labels are used in situations where multiple assets are contained
in the same file. An example of this are <a href="assets//3d/gltf.html">GLTF files</a>, which can
contain meshes, scenes, textures, materials, etc.</p>
<p>Asset paths can be created from a string, with the label (if any) attached
after a <code>#</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">fn load_gltf_things(mut commands: Commands, server: Res&lt;AssetServer&gt;) {
    // get a specific mesh
    let my_mesh: Handle&lt;Mesh&gt; = server.load("my_scene.gltf#Mesh0/Primitive0");

    // spawn a whole scene
    let my_scene: Handle&lt;Scene&gt; = server.load("my_scene.gltf#Scene0");
    commands.spawn(SceneBundle {
        scene: my_scene,
        ..Default::default()
    });
}</code></pre>
<p>See the <a href="assets//3d/gltf.html">GLTF page</a> for more info about working with 3D models.</p>
<p>资产路径用于标记文件系统中的资产文件的具体路径,
<code>资产路径 = 文件路径 + 标签</code>,如果一个文件中包含多个资产,标签就是用来进行区分的.
包含3d模型的gltf文件,一个文件就包含多种资产.标签是可选的.</p>
<p>"my_scene.gltf#Mesh0/Primitive0", 用<code>#</code>分割文件路径和标签.</p>
<h2 id="where-are-assets-loaded-from"><a class="header" href="#where-are-assets-loaded-from">Where are assets loaded from?</a></h2>
<p>The asset server internally relies on an implementation of the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/trait.AssetIo.html"><code>AssetIo</code></a> Rust trait, which is Bevy's way of providing
"backends" for fetching data from different types of storage.</p>
<p>Bevy provides its own default built-in I/O backends for each <a href="assets//platforms.html">supported
platform</a>.</p>
<p>On desktop platforms, it treats asset paths as relative to a folder called
<code>assets</code>, that must be placed at one of the following locations:</p>
<ul>
<li>Alongside the game's executable file, for distribution</li>
<li>In your Cargo project folder, when running your game using <code>cargo</code> during development
<ul>
<li>This is identified by the <code>CARGO_MANIFEST_DIR</code> environment variable</li>
</ul>
</li>
</ul>
<p>On the web, it fetches assets using HTTP URLs pointing within an <code>assets</code>
folder located alongside the game's <code>.wasm</code> file.</p>
<p>There are <a href="assets//setup/unofficial-plugins.html">unofficial plugins</a> available that provide alternative
I/O backend implementations, such as for loading assets from inside archive
files (<code>.zip</code>), embedded inside the game executable, using a network protocol,
… many other possibilities.</p>
<p>本文中描述的asset server资源类型是实现了<code>AssetIo</code>的.(这点在0.14版本中已经调整了).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="access-the-asset-data"><a class="header" href="#access-the-asset-data">Access the Asset Data</a></h1>
<p>To access the actual asset data from systems, use the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> <a href="assets//programming/res.html">resource</a>.</p>
<p>You can identify your desired asset using the <a href="assets//assets/handles.html">handle</a>.</p>
<p><a href="assets//assets/handles.html#untyped-handles">untyped handles</a> need to be "upgraded" into typed handles.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct SpriteSheets {
    map_tiles: Handle&lt;TextureAtlas&gt;,
}

fn use_sprites(
    handles: Res&lt;SpriteSheets&gt;,
    atlases: Res&lt;Assets&lt;TextureAtlas&gt;&gt;,
    images: Res&lt;Assets&lt;Image&gt;&gt;,
) {
    // Could be `None` if the asset isn't loaded yet
    if let Some(atlas) = atlases.get(&amp;handles.map_tiles) {
        // do something with the texture atlas
    }
}</code></pre>
<p>在system中访问实际的资产数据,使用<code>Assets&lt;T&gt;</code>资源,配合句柄就能锚定具体的资产.
使用无类型句柄时,需要先升级到具体某个类型的句柄.</p>
<p>使用Option来处理资产没有加载完毕的问题.</p>
<h2 id="creating-assets-from-code"><a class="header" href="#creating-assets-from-code">Creating Assets from Code</a></h2>
<p>You can also add assets to <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> manually.</p>
<p>Sometimes you need to create assets from code, rather than <a href="assets//assets/assetserver.html">loading them
from files</a>. Some common examples of such use-cases are:</p>
<ul>
<li>creating texture atlases</li>
<li>creating 3D or 2D materials</li>
<li>procedurally-generating assets like images or 3D meshes</li>
</ul>
<p>To do this, first create the data for the asset (an instance of the
<a href="assets//builtins.html#assets">asset type</a>), and then add it <code>.add(…)</code> it to the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> resource, for it to be stored and tracked by
Bevy. You will get a <a href="assets//assets/handles.html">handle</a> to use to refer to it, just like
any other asset.</p>
<pre><code class="language-rust no_run noplayground">fn add_material(mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;) {
    let new_mat = StandardMaterial {
        base_color: Color::rgba(0.25, 0.50, 0.75, 1.0),
        unlit: true,
        ..Default::default()
    };

    let handle = materials.add(new_mat);

    // do something with the handle
}</code></pre>
<p>代码中创建资产.常用场景有:</p>
<ul>
<li>创建纹理</li>
<li>创建2d/3d材质</li>
<li>生成图片或3d网格</li>
</ul>
<p>生成一个资产实例,并调用 <code>Assets&lt;T&gt;.add()</code>,之后bevy就能跟踪次资产了.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="react-to-changes-with-asset-events"><a class="header" href="#react-to-changes-with-asset-events">React to Changes with Asset Events</a></h1>
<p>If you need to perform specific actions when an asset is created,
modified, or removed, you can make a <a href="assets//programming/systems.html">system</a> that reacts to
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> <a href="assets//programming/events.html">events</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct MyMapImage {
    handle: Handle&lt;Image&gt;,
}

fn fixup_images(
    mut ev_asset: EventReader&lt;AssetEvent&lt;Image&gt;&gt;,
    mut assets: ResMut&lt;Assets&lt;Image&gt;&gt;,
    map_img: Res&lt;MyMapImage&gt;,
) {
    for ev in ev_asset.iter() {
        match ev {
            AssetEvent::Created { handle } =&gt; {
                // a texture was just loaded or changed!

                // WARNING: this mutable access will cause another
                // AssetEvent (Modified) to be emitted!
                let texture = assets.get_mut(handle).unwrap();
                // ^ unwrap is OK, because we know it is loaded now

                if *handle == map_img.handle {
                    // it is our special map image!
                } else {
                    // it is some other image
                }
            }
            AssetEvent::Modified { handle } =&gt; {
                // an image was modified
            }
            AssetEvent::Removed { handle } =&gt; {
                // an image was unloaded
            }
        }
    }
}</code></pre>
<p><strong>Note:</strong> If you are handling <code>Modified</code> events and doing a mutable access to
the data, the <code>.get_mut</code> will trigger another <code>Modified</code> event for the same
asset. If you are not careful, this could result in an infinite loop! (from
events caused by your own system)</p>
<p>还可以使用事件来监听资产的创建/修改/删除.<code>AssetEvent&lt;T&gt;</code>.</p>
<p>如果在修改事件的处理中做了一个修改操作,会触发一个新的修改事件,
此处需要特别注意:别整出个无限循环来.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="track-loading-progress"><a class="header" href="#track-loading-progress">Track Loading Progress</a></h1>
<p>There are good community plugins that can help with this. Otherwise, this page
shows you how to do it yourself.</p>
<hr />
<p>If you want to check the status of various <a href="assets//assets/assetserver.html">asset files</a>,
you can poll it from the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>. It will tell you
whether the asset(s) are loaded, still loading, not loaded, or encountered
an error.</p>
<p>To check an individual asset, you can use <code>asset_server.get_load_state(…)</code> with
a handle or path to refer to the asset.</p>
<p>To check a group of many assets, you can add them to a single collection
(such as a <code>Vec&lt;HandleUntyped&gt;</code>; <a href="assets//assets/handles.html#untyped-handles">untyped handles</a> are very
useful for this) and use <code>asset_server.get_group_load_state(…)</code>.</p>
<hr />
<p>Here is a more complete code example:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct AssetsLoading(Vec&lt;HandleUntyped&gt;);

// 在构造时将句柄全部收集起来.
fn setup(server: Res&lt;AssetServer&gt;, mut loading: ResMut&lt;AssetsLoading&gt;) {
    // we can have different asset types
    let font: Handle&lt;Font&gt; = server.load("my_font.ttf");
    let menu_bg: Handle&lt;Image&gt; = server.load("menu.png");
    let scene: Handle&lt;Scene&gt; = server.load("level01.gltf#Scene0");

    // add them all to our collection for tracking
    loading.0.push(font.clone_untyped());
    loading.0.push(menu_bg.clone_untyped());
    loading.0.push(scene.clone_untyped());
}

fn check_assets_ready(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
    loading: Res&lt;AssetsLoading&gt;,
) {
    use bevy::asset::LoadState;

    // 监控一组资产的状态变更.
    match server.get_group_load_state(loading.0.iter().map(|h| h.id)) {
        LoadState::Failed =&gt; {
            // one of our assets had an error
        }
        LoadState::Loaded =&gt; {
            // all assets are now ready

            // this might be a good place to transition into your in-game state

            // remove the resource to drop the tracking handles
            commands.remove_resource::&lt;AssetsLoading&gt;();
            // (note: if you don't have any other handles to the assets
            // elsewhere, they will get unloaded after this)
        }
        _ =&gt; {
            // NotLoaded/Loading: not fully ready yet
        }
    }
}</code></pre>
<p>本章介绍的自己实现资产加载进度,社区已经有了很多插件实现了这一功能.</p>
<p>如果想检查多个资产文件的加载进度,从asset server拉取,
状态大概有:已加载;加载中;未加载;出现错误.</p>
<p>如果想检查单个资产文件的加载进度,使用<code>get_load_state()</code>,入参是句柄或资产路径.</p>
<p>如果想要检查一组资产的状态(很多文件),将所有句柄放在<code>Vec&lt;HandleUntyped&gt;</code>中,
然后传给<code>get_group_load_state()</code>. 无类型句柄在此处也起了很大的作用.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="hot-reloading-assets"><a class="header" href="#hot-reloading-assets">Hot-Reloading Assets</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/asset/hot_asset_reloading.rs"><code>hot_asset_reloading</code></a>.</p>
<hr />
<p>At runtime, if you modify the file of an <a href="assets//assets.html">asset</a>
that is <a href="assets//assets/assetserver.html">loaded</a> into the game (via the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>), Bevy can detect that and reload the
asset automatically. This is very useful for quick iteration. You can edit
your assets while the game is running and see the changes instantly in-game.</p>
<p>Not all <a href="assets//builtins.html#file-formats">file formats</a> and use cases are supported
equally well. Typical asset types like textures / images should work without
issues, but complex GLTF or scene files, or assets involving custom logic,
might not.</p>
<p>If you need to run custom logic as part of your hot-reloading
workflow, you could implement it in a <a href="assets//programming/systems.html">system</a>, using
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> (<a href="assets//assets/assetevent.html">learn more</a>).</p>
<p>Hot reloading is opt-in and has to be enabled in order to work:</p>
<pre><code class="language-rust no_run noplayground">    fn main() {
        App::new()
            .add_plugins(DefaultPlugins.set(AssetPlugin {
                watch_for_changes: true,
                ..Default::default()
            }))
            .run();
    }</code></pre>
<p>Note that this requires the <code>filesystem_watcher</code> <a href="assets//setup/bevy-config.html">Bevy cargo
feature</a>. It is enabled by default, but if you have disabled
default features to customize Bevy, be sure to include it if you need it.</p>
<p>运行时修改了资产,bevy会检测到并自动进行reload,前提时开启资源变更监听.</p>
<p>对于纹理/图片来说,reload并没有什么问题,但其他格式可能会出现异常,
复杂的gltf/场景文件/自定义逻辑涉及的资源.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AssetPlugin {
    pub file_path: String,
    pub processed_file_path: String,
    pub watch_for_changes_override: Option&lt;bool&gt;, // 0.14该为此字段了
    pub mode: AssetMode,
}

impl Default for AssetPlugin {
    fn default() -&gt; Self {
        Self {
            mode: AssetMode::Unprocessed,
            file_path: Self::DEFAULT_UNPROCESSED_FILE_PATH.to_string(),
            processed_file_path: Self::DEFAULT_PROCESSED_FILE_PATH.to_string(),
            watch_for_changes_override: None, // 默认没有开启监听,需要注册插件时指定.
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>现在是v0.14,对应的变更监听功能涉及两个:<br />
embedded_watcher 内存资产变更监听;file_watcher 文件资产变更监听.</p>
<hr />
<h2 id="shaders"><a class="header" href="#shaders">Shaders</a></h2>
<p>Bevy also supports hot-reloading for shaders. You can edit your custom shader
code and see the changes immediately.</p>
<p>This works for any shader loaded from a file path, such as shaders specified
in your Materials definitions, or shaders <a href="assets//assets/assetserver.html">loaded</a> via the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>.</p>
<p>Shader code that does not come from asset files, such as if you include it
as a static string in your source code, cannot be hot-reloaded (for obvious
reasons).</p>
<p>着色器也支持热加载,不管是通过材质定义的着色器还是asset server定义的着色器都一样.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="processing-assets"><a class="header" href="#processing-assets">Processing Assets</a></h1>
<p>TODO / WIP</p>
<p>Coming soon...</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="audio"><a class="header" href="#audio">Audio</a></h1>
<p>Bevy offers a (somewhat barebones, but still useful) ECS-based Audio framework.
This chapter will teach you how to use it.</p>
<p>You can <a href="/audio/basic.html">play sound effects and music</a> from your game, with
volume control. There is a rudimentary <a href="/audio/spatial.html">"spatial audio"</a>
implementation, which can pan sounds left/right in stereo, based on the
<a href="/fundamentals/transforms.html">transforms</a> of <a href="/programming/intro-data.html#entities--components">entities</a>. You can also implement your
own <a href="/audio/custom.html">custom sources of audio data</a>, if you want to synthesize
sound from code, stream data from somewhere, or any other custom use case.</p>
<p>There are also 3rd-party alternatives to Bevy's audio support:</p>
<ul>
<li><a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a>: uses <a href="https://github.com/tesselode/kira"><code>kira</code></a>; provides a richer set of features and playback controls</li>
<li><a href="https://github.com/harudagondi/bevy_oddio"><code>bevy_oddio</code></a>: uses <a href="https://github.com/Ralith/oddio"><code>oddio</code></a>; seems to offer more advanced 3D spatial sound</li>
<li><a href="https://github.com/harudagondi/bevy_fundsp"><code>bevy_fundsp</code></a>: uses <a href="https://github.com/SamiPerttu/fundsp"><code>fundsp</code></a>; for advanced sound synthesis and effects</li>
</ul>
<p>(Bevy's official audio is based on the <a href="https://github.com/RustAudio/rodio"><code>rodio</code></a> library.)</p>
<p>As you can see, the Rust audio ecosystem is quite fragmented. There are
many backend libraries, all offering a different mix of features, none of
them particularly exhaustive. All of them are somewhat immature. You have
to pick your poison.</p>
<p>Audio is an area sorely in need of improvement. If you are an enthusiastic
audio developer, consider joining <a href="https://discord.gg/bevy">Discord</a> and helping
with development!</p>
<p>bevy提供了一个基于ecs的音频框架(基于rodio),虽然还缺乏很多东西,但核心功能还是有的.</p>
<p>基于这个框架,可以播放音效/音乐,音量调节,初级的空间音频,双声道.
甚至可以实现自定义的音频数据源,以及音频数据合并.</p>
<p>下面是几个优秀的第三方代替:</p>
<ul>
<li><code>bevy_kira_audio</code>基于kira,提供丰富的功能和回放控制</li>
<li><code>bevy_oddio</code>基于oddio,提供高级的3d空间音频</li>
<li><code>bevy_fundsp</code>基于fundsp,提供高级的合并和音效</li>
</ul>
<p>bevy的音频生态很割裂,每种方案都是文档匮乏,部分场合更是智障,按需选择.
这块继续进步.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="playing-sounds"><a class="header" href="#playing-sounds">Playing Sounds</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/audio.rs"><code>audio</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/audio_control.rs"><code>audio_control</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="spatial-audio"><a class="header" href="#spatial-audio">Spatial Audio</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/spatial_audio_2d.rs"><code>spatial_audio_2d</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/spatial_audio_3d.rs"><code>spatial_audio_3d</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="custom-audio-streams"><a class="header" href="#custom-audio-streams">Custom Audio Streams</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/decodable.rs"><code>decodable</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-ui-framework"><a class="header" href="#bevy-ui-framework">Bevy UI Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-programming-framework"><a class="header" href="#bevy-programming-framework">Bevy Programming Framework</a></h1>
<p>This chapter presents the features of the Bevy core programming framework. This
covers the ECS (Entity Component System), App and Scheduling.</p>
<p>All the knowledge of this chapter is useful even if you want to use Bevy as
something other than a game engine. For example: using just the ECS for a
scientific simulation.</p>
<p>Hence, this chapter does not cover the game-engine parts of Bevy. Those
features are covered in other chapters of the book. You can start with
<a href="/fundamentals.html">Game Engine Fundamentals</a> chapter.</p>
<p>For additional of programming patterns and idioms, see the <a href="/patterns.html">Programming
Patterns</a> chapter.</p>
<p>If you are also interested in GPU programming, see the <a href="/gpu.html">Bevy GPU
Framework</a> chapter.</p>
<p>这部分是bevy核心框架,并不仅仅能用来做游戏引擎,ECS也可以单独拿出来用的,
涉及对象较多的科学模拟大多使用ECS.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="ecs-programming-introduction"><a class="header" href="#ecs-programming-introduction">ECS Programming Introduction</a></h1>
<p>This page will try to teach you the general ECS mindset/paradigm.</p>
<hr />
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<p>Also check out the complete game examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>ECS is a programming paradigm that separates data and behavior. Bevy will store
all of <a href="programming//programming/intro-data.html">your data</a> and manage all of <a href="programming//programming/intro-code.html">your individual pieces
of functionality</a> for you. The code will run when
appropriate. Your code can get access to whatever data it needs to do its thing.</p>
<p>This makes it easy to write game logic (<a href="programming//programming/systems.html">Systems</a>) in a way that
is flexible and reusable. For example, you can implement:</p>
<ul>
<li>health and damage that works the same way for anything in the game,
regardless of whether that's the player, an NPC, or a monster, or a vehicle</li>
<li>gravity and collisions for anything that should have physics</li>
<li>an animation or sound effect for all buttons in your UI</li>
</ul>
<p>Of course, when you need specialized behavior only for specific entities (say,
player movement, which only applies to the player), that is naturally easy to
express, too.</p>
<p>If you are familiar with database programming, you will feel right at home. ECS
is conceptually very similar to a lightweight in-memory database.</p>
<p><a href="programming//programming/intro-data.html">Read more about how to represent your data.</a></p>
<p><a href="programming//programming/intro-code.html">Read more about how to represent your functionality.</a></p>
<p>bevy最核心的是ECS,ECS是一种将数据和逻辑完全分离的编程范式.
有很多称号,其中反oo和数据驱动开发用的比较多.</p>
<p>ECS的优势是逻辑解耦,小颗粒的组合提高了重用的可能.一定规模的项目比其他范式要简单很多.</p>
<ul>
<li>生命值和伤害的工作方式,在一个游戏内对所有对象都是一样的.玩家/npc/boss/车辆等</li>
<li>物理中的引力和碰撞对所有物品,包括玩家,都是一样的</li>
<li>界面中按钮的音效和动画,这些运行原理都是一样的</li>
</ul>
<p>只要是一样的,就可以单独成system.如果一个实体有多个逻辑,组合即可.</p>
<p>总之,ECS类似于内存中存储的轻量级数据库.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="intro-your-data"><a class="header" href="#intro-your-data">Intro: Your Data</a></h1>
<p>This page is an overview, to give you an idea of the big picture of how Bevy
works. Click on the various links to be taken to dedicated pages where you can
learn more about each concept.</p>
<p>这里只是简介,详细内容还需要点击链接进一步查看.</p>
<hr />
<p>As mentioned in <a href="programming//programming/ecs-intro.html">the ECS Intro</a>, Bevy stores all your data for
you and allows you easy and flexible access to whatever you need, wherever you
need it.</p>
<p>The ECS's data structure is called the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>. That is what
stores and manages all of the data. For advanced scenarios, is possible to
have <a href="programming//programming/sub-apps.html">multiple worlds</a>, and then each one will behave as
its own separate ECS instance. However, normally, you just work with the
main World that Bevy sets up for your <a href="programming//programming/app-builder.html">App</a>.</p>
<p>You can represent your data in two different ways:
<a href="programming/intro-data.html#entities--components">Entities/Components</a>, and <a href="programming/intro-data.html#resources">Resources</a>.</p>
<p>ECS的数据全部存在一个叫world的实例中,world管理和维护了所有的数据,
对于部分高级场景,可能会存在多个world,每个world都是自己独立的ECS实例,
通常app只有一个world,关心主world即可.</p>
<p>数据只能依附于组件或资源出现.资源就是一个中特殊的组件<code>单例组件</code>,
一个游戏中50%以上都是<code>单例组件</code>,这种特殊的组件在bevy中有个新名词:资源.</p>
<h2 id="entities--components"><a class="header" href="#entities--components">Entities / Components</a></h2>
<p>Conceptually, you can think of it by analogy with tables, like in a database or
spreadsheet. Your different data types (<a href="programming//programming/ec.html#components">Components</a>) are like
the "columns" of a table, and there can be arbitrarily many "rows"
(<a href="programming//programming/ec.html#entities">Entities</a>) containing values / instances of various components.
The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID is like the row number. It's an integer index
that lets you find specific component values.</p>
<p>Component types that are empty <code>struct</code>s (contain no data) are called <a href="programming//programming/ec.html#marker-components">marker
components</a>. They are useful as "tags" to identify
specific entities, or enable certain behaviors. For example, you could use them
to identify the player entity, to mark enemies that are currently chasing the
player, to select entities to be despawned at the end of the level, etc.</p>
<p>Here is an illustration to help you visualize the logical structure. The
checkmarks show what component types are present on each entity. Empty cells
mean that the component is not present. In this example, we have a player,
a camera, and several enemies.</p>
<div class="table-wrapper"><table><thead><tr><th><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> (ID)</th><th><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/transform/components/struct.Transform.html"><code>Transform</code></a></th><th><code>Player</code></th><th><code>Enemy</code></th><th><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/render/camera/struct.Camera.html"><code>Camera</code></a></th><th><code>Health</code></th><th>...</th></tr></thead><tbody>
<tr><td>...</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>107</td><td>✓ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td>✓</td><td></td><td></td><td>✓ <code>50.0</code></td><td></td></tr>
<tr><td>108</td><td>✓ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>✓</td><td></td><td>✓ <code>25.0</code></td><td></td></tr>
<tr><td>109</td><td>✓ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td></td><td>✓ <code>&lt;camera data&gt;</code></td><td></td><td></td></tr>
<tr><td>110</td><td>✓ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>✓</td><td></td><td>✓ <code>10.0</code></td><td></td></tr>
<tr><td>111</td><td>✓ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>✓</td><td></td><td>✓ <code>25.0</code></td><td></td></tr>
<tr><td>...</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Representing things this way gives you flexibility. For example, you could
create a <code>Health</code> component for your game. You could then have many entities
representing different things in your game, such as the player, NPCs, or
monsters, all of which can have a <code>Health</code> value (as well as other relevant
components).</p>
<p>The typical and obvious pattern is to use entities to represent "objects in the
game/scene", such as the camera, the player, enemies, lights, props, UI
elements, and other things. However, you are not limited to that. The ECS is a
general-purpose data structure. You can create entities and components to store
any data. For example, you could create an entity to store a bunch of settings
or configuration parameters, or other abstract things.</p>
<p>Data stored using Entities and Components is accessed using
<a href="programming//programming/queries.html">queries</a>. For example, if you want to implement a new game
mechanic, write a <a href="programming//programming/systems.html">system</a> (just a Rust function that takes
special parameters), specify what component types you want to access, and do
your thing. You can either iterate through all entities that match your query,
or access the data of a specific one (using the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID).</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Xp(u32);

#[derive(Component)]
struct Health {
    current: u32,
    max: u32,
}

fn level_up(
    // We want to access the Xp and Health data:
    mut query: Query&lt;(&amp;mut Xp, &amp;mut Health)&gt;,
) {
    // process all relevant entities
    for (mut xp, mut health) in query.iter_mut() {
        if xp.0 &gt; 1000 {
            xp.0 -= 1000;
            health.max += 25;
            health.current = health.max;
        }
    }
}</code></pre>
<p>Bevy can automatically keep track of what data your <a href="programming//programming/systems.html">systems</a> have
access to and <a href="programming//programming/system-order.html">run them in parallel</a> on multiple CPU
cores. This way, you get multithreading with no extra effort from you!</p>
<p>What if you want to create or remove entities and components, not just access
existing data? That requires special consideration. Bevy cannot change the
memory layout while other systems might be running. These operations can be
buffered/deferred using <a href="programming//programming/commands.html">Commands</a>. Bevy will apply them later
when it is safe to do so. You can also get <a href="programming//programming/world.html">direct World access</a>
using <a href="programming//programming/exclusive.html">exclusive systems</a>, if you want to perform such
operations immediately.</p>
<p><a href="programming//programming/bundle.html">Bundles</a> serve as "templates" for common sets of components, to
help you when you spawn new entities, so you don't accidentally forget anything.</p>
<pre><code class="language-rust no_run noplayground">/// Marker for the player
#[derive(Component)]
struct Player;

/// Bundle to make it easy to spawn the player entity
/// with all the correct components:
#[derive(Bundle)]
struct PlayerBundle {
    // 非常经典的自己定义Bundle
    marker: Player,
    health: Health,
    xp: Xp,
    // including all the components from another bundle
    sprite: SpriteBundle,
}

fn spawn_player(
    // needed for safely creating/removing data in the ECS World
    // (anything done via Commands will be applied later)
    mut commands: Commands,
    // needed for loading assets
    asset_server: Res&lt;AssetServer&gt;,
) {
    // create a new entity with whatever components we want
    commands.spawn(PlayerBundle {
        marker: Player,
        health: Health {
            current: 100,
            max: 125,
        },
        xp: Xp(0),
        sprite: SpriteBundle {
            texture: asset_server.load("player.png"),
            transform: Transform::from_xyz(25.0, 50.0, 0.0),
            // use the default values for all other components in the bundle
            ..Default::default()
        },
    });

    // Call .id() if you want to store the Entity ID of your new entity
    let my_entity = commands.spawn((/* ... */)).id();
}</code></pre>
<p>这里没有太多高深的理论,只是形象化描述了实体和组件的关系,
如果想要了解为啥ECS性能高,为啥要这样设计数据结构的,可以查看ECS的几种实现.</p>
<p>抛开设计只看表现形式,实体/组件就像一个表格(或数据库的表),
不同的列是不同类型的数据(组件),可以有任意多行,每一行就是一个实体,
实体的ID就是行号(这是一个形象化的比喻,很多ECS的Entity设计就是一个唯一整形,
自增主键ID正好满足这个条件).</p>
<p>如果组件类型是空结构体(没有具体的值),那么这种组件称为<code>标记组件</code>.
标记特殊实体,启用特定的system,这非常有用.</p>
<p>上图中在一个表中表示了不同类型的实体(具体bevy实现是不是这样,需要分析源码再说).</p>
<p>一般是用实体来表示游戏/场景中出现的对象,eg:相机/敌人/光线/界面,但可以表示更多,
使用ECS并没有什么限制.</p>
<p>数据存储在实体/组件中,访问方式是query,在增量开发中,新增一个游戏机制,
在实现system时只需要通过query将符合条件的实体找出来,并应用新机制即可,
这点可以让多人并行协作,是一个很大的突破.
出了通过query-遍历实体,还可以直接通过实体ID来访问数据.</p>
<p>bevy通过调度机制+system的顺序机制,尽量保证每个cpu核上都跑着system,
这样的好处是开发者友好,开发者不必再自己维护多线程了.</p>
<p>system运行时,bevy不能修改内存布局,如果要增删实体或组件,该怎么办?
通过Commands进行延时处理,这样就可以保证安全了.
当然如果要立马生效,也可以直接通过world直接访问数据和独占system来实现.</p>
<p>bevy提供了很多Bundle来辅助构造实体.</p>
<h3 id="comparison-with-object-oriented-programming"><a class="header" href="#comparison-with-object-oriented-programming">Comparison with Object-Oriented Programming</a></h3>
<p>Object-Oriented programming teaches you to think of everything as "objects",
where each object is an instance of a "class". The class specifies the data
and functionality for all objects of that type, in one place. Every object
of that class has the same data (with different values) and the same
associated functionality.</p>
<p>This is the opposite of the ECS mentality. In ECS, any <a href="programming//programming/ec.html#entities">entity</a> can
have any data (any combination of <a href="programming//programming/ec.html#components">components</a>). The purpose of
entities is to identify that data. Your <a href="programming//programming/systems.html">systems</a> are loose pieces
of functionality that can operate on any data. They can easily find what they
are looking for, and implement the desired behavior.</p>
<p>If you are an object-oriented programmer, you might be tempted to define a big
monolithic <code>struct Player</code> containing all the fields / properties of the player.
In Bevy, this is considered bad practice, because doing it that way can make it
more difficult to work with your data and limit performance. Instead, you should
make things granular, when different pieces of data may be accessed independently.</p>
<p>For example, represent the player in your game as an entity, composed of
separate component types (separate <code>struct</code>s) for things like the health, XP, or
whatever is relevant to your game. You can also attach standard Bevy components
like <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> (<a href="programming//fundamentals/transforms.html">transforms explained</a>) to it.</p>
<p>Then, each piece of functionality (each <a href="programming//programming/systems.html">system</a>) can just
<a href="programming//programming/queries.html">query</a> for the data it needs. Common functionality (like a
health/damage system) can be applied to any entity with the matching components,
regardless of whether that's the player or something else in the game.</p>
<p>If you have functionality that should only be applied to the player entity,
you can use a <a href="programming//programming/ec.html#marker-components">marker component</a> (like <code>struct Player;</code>)
to narrow down your query (using a <a href="programming//programming/queries.html#query-filters">query filter</a> like
<code>With&lt;Player&gt;</code>).</p>
<p>However, if some data always makes sense to be accessed together, then you
should put it in a single <code>struct</code>. For example, Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>.
With these types, the fields are not likely to be useful independently.</p>
<p>oo和反oo虽然是两种思想,但最终的目的都是一个:解决问题,达成目标,降低开发和维护成本.
oo是继承体系,ecs是组合思想.</p>
<p>oo是对象拥有数据,并拥有某些行为; ecs是数据和行为分离,每个system都是一个小的功能点,
组合不同的system同样可以实现逻辑,因为system都是碎片化的小功能点,她只关注自己的需求,
如果是oo的行为,会看到很多当前逻辑不需要的数据,整体的实现看要看整个继承体系
(这点在前几个版本不是问题), 但在后期维护的成本看,这会是个大问题.</p>
<p>ecs推荐小颗粒度的组件,这样方便复用.其实编成范式一直在演变,
oo如日中天时出现了ecs,并且<code>组合优于继承</code>基本深入人心了,
这是从无数个完整的项目生命周期得到的教训.</p>
<p>如果只想对某几个实体进行处理,便捷的方法是增加一个空的结构体组件充当标记组件,
同样走query机制.</p>
<p>如果某些数据一起访问时是有意义的,可以考虑放在同一个struct中.</p>
<h3 id="additional-internal-details"><a class="header" href="#additional-internal-details">Additional Internal Details</a></h3>
<p>The set / combination of components that a given entity has is called the
entity's Archetype. Bevy keeps track of that internally, to organize the
data in RAM. Entities of the same Archetype have their data stored together
in contiguous arrays, which allows the CPU to access and cache it efficiently.</p>
<p>If you add/remove component types on existing entities, you are changing
the Archetype, which may require Bevy to move previously-existing data to
a different location.</p>
<p><a href="programming//patterns/component-storage.html">Learn more about Bevy's component storage.</a></p>
<p>Bevy will reuse Entity IDs. The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> type is actually
two integers: the ID and a "generation". After you despawn some entities,
their IDs can be reused for newly-spawned entities, but Bevy will increase
the generation value.</p>
<p>在bevy中,实体拥有的组件列表成为原型,bevy内部会跟踪所有原型,
在内存中组织这些数据.(这是因为ECS为了迎合CPU的io特性,转换设计的,
只有要访问的数据是连续存放的,那么cpu在io时一次就可以读到未来几次需要的数据,
减少cpu的io次数,就是性能巨大提升的关键),同一个原型的实体时连续存放的,
方便cpu的缓存可以快速命中.</p>
<p>实体可以被销毁,但实体的id时可以复用的,一个实体内部由两个id表示:
一个是实体ID,一个是复用次数(也可以成为版本,代数,都是一个意思).
这里面还隐藏了一个关键技术:实体id复用机制.go语言有个arche也是ecs库,
实体的实现和bevy是一样的,底层有个链表来跟踪所有可复用的实体id,
不知道bevy是不是同样的实现.</p>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>If there is only one global instance (singleton) of something, and it is
standalone (not associated with other data), create a <a href="programming//programming/res.html">Resource</a>.</p>
<p>For example, you could create a resource to store your game's graphics
settings, or an interface to a non-Bevy library.</p>
<p>This is a simple way of storing data, when you know you don't need the
flexibility of Entities/Components.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct GameSettings {
    current_level: u32,
    difficulty: u32,
    max_time_seconds: u32,
}

fn setup_game(mut commands: Commands) {
    // Add the GameSettings resource to the ECS
    // (if one already exists, it will be overwritten)
    commands.insert_resource(GameSettings {
        current_level: 1,
        difficulty: 100,
        max_time_seconds: 60,
    });
}

fn spawn_extra_enemies(
    mut commands: Commands,
    // we can easily access our resource from any system
    game_settings: Res&lt;GameSettings&gt;,
) {
    if game_settings.difficulty &gt; 50 {
        commands.spawn((
            // ...
        ));
    }
}
</code></pre>
<p>单例组件:资源.一个游戏,大部分都是资源,少部分灵活的才是组件.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="intro-your-code"><a class="header" href="#intro-your-code">Intro: Your Code</a></h1>
<p>This page is an overview, to give you an idea of the big picture of how Bevy
works. Click on the various links to be taken to dedicated pages where you can
learn more about each concept.</p>
<p>这里只是概述,细节需要点击链接进一步查看.</p>
<hr />
<p>As mentioned in <a href="programming//programming/ecs-intro.html">the ECS Intro</a>, Bevy manages all of your
functionality/behaviors for you, running them when appropriate and giving them
access to whatever parts of <a href="programming//programming/intro-data.html">your data</a> they need.</p>
<p>Individual pieces of functionality are called <a href="programming//programming/systems.html">systems</a>. Each system
is a Rust function (<code>fn</code>) you write, which accepts <a href="programming//builtins.html#systemparams">special parameter
types</a> to indicate what <a href="programming//programming/intro-data.html">data</a> it needs to
access. Think of the function signature as a "specification" for what to fetch
from the ECS <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>Here is what a <a href="programming//programming/systems.html">system</a> might look like. Note how, just by looking
at the function parameters, we know <em>exactly</em> what <a href="programming//programming/intro-data.html">data</a>
can be accessed.</p>
<pre><code class="language-rust no_run noplayground">fn enemy_detect_player(
    // access data from resources
    mut ai_settings: ResMut&lt;EnemyAiSettings&gt;,
    gamemode: Res&lt;GameModeData&gt;,
    // access data from entities/components
    query_player: Query&lt;&amp;Transform, With&lt;Player&gt;&gt;,
    query_enemies: Query&lt;&amp;mut Transform, (With&lt;Enemy&gt;, Without&lt;Player&gt;)&gt;,
    // in case we want to spawn/despawn entities, etc.
    mut commands: Commands,
) {
    // ... implement your behavior here ...
}</code></pre>
<p>(learn more about: <a href="programming//programming/systems.html">systems</a>, <a href="programming//programming/queries.html">queries</a>, <a href="programming//programming/commands.html">commands</a>, <a href="programming//programming/res.html">resources</a>, <a href="programming//programming/ec.html#entities">entities</a>, <a href="programming//programming/ec.html#components">components</a>)</p>
<p>ECS是数据和逻辑分离的,这些逻辑成为system,在bevy中system用函数表示,
函数参数指定了要访问哪些数据.而数据是存在资源/实体的组件中,
system的另一种参数是Commands,这是对world数据的修改(实体/组件的增删),
bevy会将Commands放在每帧的后面执行(默认是PostUpdate),
同时还提供了after/befor来执行system执行顺序.</p>
<h2 id="parallel-systems"><a class="header" href="#parallel-systems">Parallel Systems</a></h2>
<p>Based on the <a href="programming//builtins.html#systemparams">parameter</a> types of the <a href="programming//programming/systems.html">systems</a>
you write, Bevy knows what data each system can access and whether it conflicts
with any other systems. Systems that do not conflict (don't access any of the
same data mutably) will automatically be <a href="programming//programming/system-order.html">run in parallel</a>
on different CPU threads. This way, you get multithreading, utilizing modern
multi-core CPU hardware effectively, with no extra effort from you!</p>
<p>For best parallelism, it is recommended that you keep your functionality and
<a href="programming//programming/intro-data.html">your data</a> granular. Split up your systems, so each
one has a narrowly-scoped purpose and access to only the data it needs. This
gives Bevy more opportunities for parallelism. Putting too much functionality
in one system, or too much data in a single <a href="programming//programming/ec.html#components">component</a> or
<a href="programming//programming/res.html">resource</a> <code>struct</code>, limits parallelism.</p>
<p>Bevy's parallelism is non-deterministic by default. Your systems might run in a
different and unpredictable order relative to one another, unless you add
<a href="programming//programming/system-order.html">ordering</a> dependencies to constrain it.</p>
<p>并行执行system是bevy的核心设计之一,也是高性能的保证.</p>
<p>bevy通过system参数就知道哪些system有竞争,不竞争的system会放在不同的cpu核中执行,
在利用现代多核CPU硬件的基础上,开发者还不用关心这些多线程的组织逻辑(bevy帮忙做了).</p>
<p>要减少竞争,最好的办法是控制数据的颗粒度,拆分system让其符合单一原则,
只有这样才能更好配合bevy进行并行执行.
一个system承载太多功能,或一个组件/资源承载太多数据,都会大大影响并行.</p>
<p>system之间要保证正交性(不管何时由哪个cpu执行,结果都是一样的),
如果两个system确实有顺序依赖,可以用system的顺序规则来指定先后.</p>
<h2 id="exclusive-systems"><a class="header" href="#exclusive-systems">Exclusive Systems</a></h2>
<p><a href="programming//programming/exclusive.html">Exclusive</a> systems provide you with a way to get <a href="programming//programming/world.html">full direct
access</a> to the ECS <a href="programming//programming/world.html"><code>World</code></a>. They cannot run in parallel
with other systems, because they can access anything and do anything. Sometimes,
you might need this additonal power.</p>
<pre><code class="language-rust no_run noplayground">fn save_game(
    // get full access to the World, so we can access all data and do anything
    world: &amp;mut World,
) {
    // ... save game data to disk, or something ...
}</code></pre>
<p>独占system是直接修改world数据的,极少情况下会用到,类似于核武器.
这类system并不能并行执行.</p>
<h2 id="schedules-1"><a class="header" href="#schedules-1">Schedules</a></h2>
<p>Bevy stores systems inside of <a href="programming//programming/schedules.html">schedules</a>
(<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/schedule/struct.Schedule.html"><code>Schedule</code></a>). The schedule contains the systems and all
relevant metadata to organize them, telling Bevy when and how to run them. Bevy
<a href="programming//programming/app-builder.html">Apps</a> typically contain many schedules. Each one is a collection of
systems to be invoked in different scenarios (every frame update, <a href="programming//fundamentals/fixed-timestep.html">fixed
timestep</a> update, at app startup, on <a href="programming//programming/states.html">state</a>
transitions, etc.).</p>
<p>The metadata stored in schedules allows you to control how systems run:</p>
<ul>
<li>Add <a href="programming//programming/run-criteria.html">run conditions</a> to control if systems should run during an
invocation of the schedule. You can disable systems if you only need them
to run sometimes.</li>
<li>Add <a href="programming//programming/system-order.html">ordering</a> constraints, if one system depends on
another system completing before it.</li>
</ul>
<p>Within schedules, systems can be grouped into <a href="programming//programming/system-sets.html">sets</a>. Sets
allow multiple systems to share common configuration/metadata. Systems
inherit configuration from all sets they belong to. Sets can also inherit
configuration from other sets.</p>
<p>Here is an illustration to help you visualize the logical structure of a
schedule. Let's look at how a hypothetical "Update" (run every frame) schedule of a
game might be organized.</p>
<p>List of <a href="programming//programming/systems.html">systems</a>:</p>
<div class="table-wrapper"><table><thead><tr><th><a href="programming//programming/systems.html">System</a> name</th><th><a href="programming//programming/system-sets.html">Sets</a> it belongs to</th><th><a href="programming//programming/run-criteria.html">Run conditions</a></th><th><a href="programming//programming/system-order.html">Ordering constraints</a></th></tr></thead><tbody>
<tr><td><code>footstep_sound</code></td><td><code>AudioSet</code> <code>GameplaySet</code></td><td></td><td><code>after(player_movement)</code> <code>after(enemy_movement)</code></td></tr>
<tr><td><code>player_movement</code></td><td><code>GameplaySet</code></td><td><code>player_alive</code> <code>not(cutscene)</code></td><td><code>after(InputSet)</code></td></tr>
<tr><td><code>camera_movement</code></td><td><code>GameplaySet</code></td><td></td><td><code>after(InputSet)</code></td></tr>
<tr><td><code>enemy_movement</code></td><td><code>EnemyAiSet</code></td><td></td><td></td></tr>
<tr><td><code>enemy_spawn</code></td><td><code>EnemyAiSet</code></td><td></td><td></td></tr>
<tr><td><code>enemy_despawn</code></td><td><code>EnemyAiSet</code></td><td></td><td><code>before(enemy_spawn)</code></td></tr>
<tr><td><code>mouse_input</code></td><td><code>InputSet</code></td><td><code>mouse_enabled</code></td><td></td></tr>
<tr><td><code>controller_input</code></td><td><code>InputSet</code></td><td><code>gamepad_enabled</code></td><td></td></tr>
<tr><td><code>background_music</code></td><td><code>AudioSet</code></td><td></td><td></td></tr>
<tr><td><code>ui_button_animate</code></td><td></td><td></td><td></td></tr>
<tr><td><code>menu_logo_animate</code></td><td><code>MainMenuSet</code></td><td></td><td></td></tr>
<tr><td><code>menu_button_sound</code></td><td><code>MainMenuSet</code> <code>AudioSet</code></td><td></td><td></td></tr>
<tr><td>...</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>List of <a href="programming//programming/system-sets.html">sets</a>:</p>
<div class="table-wrapper"><table><thead><tr><th><a href="programming//programming/system-sets.html">Set</a> name</th><th>Parent Sets</th><th><a href="programming//programming/run-criteria.html">Run conditions</a></th><th><a href="programming//programming/system-order.html">Ordering constraints</a></th></tr></thead><tbody>
<tr><td><code>MainMenuSet</code></td><td></td><td><code>in_state(MainMenu)</code></td><td></td></tr>
<tr><td><code>GameplaySet</code></td><td></td><td><code>in_state(InGame)</code></td><td></td></tr>
<tr><td><code>InputSet</code></td><td><code>GameplaySet</code></td><td></td><td></td></tr>
<tr><td><code>EnemyAiSet</code></td><td><code>GameplaySet</code></td><td><code>not(cutscene)</code></td><td><code>after(player_movement)</code></td></tr>
<tr><td><code>AudioSet</code></td><td></td><td><code>not(audio_muted)</code></td><td></td></tr>
</tbody></table>
</div>
<p>Note that it doesn't matter in what order systems are listed in the schedule.
Their <a href="programming//programming/system-order.html">order</a> of execution is determined by the metadata. Bevy
will respect those constraints, but otherwise run systems in parallel as much as
it can, depending on what CPU threads are available.</p>
<p>Also note how our hypothetical game is implemented using many individually-small
systems. For example, instead of playing audio inside of the <code>player_movement</code>
system, we made a separate <code>play_footstep_sounds</code> system. These two pieces of
functionality probably need to access different <a href="programming//programming/intro-data.html">data</a>, so
putting them in separate systems allows Bevy more opportunities for parallelism.
By being separate systems, they can also have different configuration. The
<code>play_footstep_sounds</code> system can be added to an <code>AudioSet</code>
<a href="programming//programming/system-sets.html">set</a>, from which it inherits a <code>not(audio_muted)</code> <a href="programming//programming/run-criteria.html">run
condition</a>.</p>
<p>Similarly, we put mouse and controller input in separate systems. The <code>InputSet</code>
set allows systems like <code>player_movement</code> to share an ordering dependency
on all of them at once.</p>
<p>You can see how Bevy's scheduling APIs give you a lot of flexibility to organize
all the functionality in your game. What will you do with all this power? ;)</p>
<hr />
<p>Here is how <a href="programming//programming/schedules.html">schedule</a> that was illustrated above could be
created in code:</p>
<pre><code class="language-rust no_run noplayground">// Set configuration is per-schedule. Here we do it for `Update`
app.configure_sets(Update, (
    MainMenuSet
        .run_if(in_state(MainMenu)),
    GameplaySet
        .run_if(in_state(InGame)),
    InputSet
        .in_set(GameplaySet),
    EnemyAiSet
        .in_set(GameplaySet)
        .run_if(not(cutscene))
        .after(player_movement),
    AudioSet
        .run_if(not(audio_muted)),
));
app.add_systems(Update, (
    (
        ui_button_animate,
        menu_logo_animate.in_set(MainMenuSet),
    ),
    (
        enemy_movement,
        enemy_spawn,
        enemy_despawn.before(enemy_spawn),
    ).in_set(EnemyAiSet),
    (
        mouse_input.run_if(mouse_enabled),
        controller_input.run_if(gamepad_enabled),
    ).in_set(InputSet),
    (
        footstep_sound.in_set(GameplaySet),
        menu_button_sound.in_set(MainMenuSet),
        background_music,
    ).in_set(AudioSet),
    (
        player_movement
            .run_if(player_alive)
            .run_if(not(cutscene)),
        camera_movement,
    ).in_set(GameplaySet).after(InputSet),
));</code></pre>
<p>(learn more about: <a href="programming//programming/schedules.html">schedules</a>, <a href="programming//programming/system-sets.html">system sets</a>, <a href="programming//programming/states.html">states</a>, <a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-order.html">system ordering</a>)</p>
<p>bevy的调度系统是保证并行执行的关键,也是保证system灵活的基石.
bevy将system列表存在一个容器,叫<code>调度</code>,bevy知道调度何时执行.</p>
<p>system的运行条件和顺序执行信息都存在调度中,这些信息被成为system的元数据</p>
<ul>
<li>运行条件,控制了调度中的system要不要执行</li>
<li>顺序约束,控制了调度中关联system的执行顺序</li>
</ul>
<p>bevy对调度的设计并不仅仅如表面看到的这么简单,设计的足够灵活,未来扩展就容易很大.
调度中的部分system列表可以继续放在一个容器集合中,也叫<code>调度</code>,算是之前调度的子调度,
默认是共享父调度的配置和元数据,在bevy的设计中也可以从其他调度中继承,这是后话,
目前bevy中对引擎的实现是: bevy管理了几个内置调度,每个调度都有多个子调度,
对于我们自己游戏的system,bevy提供了顺序约束,在此基础上,bevy总是尽量做到并行.</p>
<p>system足够小(功能内聚),bevy就能找到更大的并行机会.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="the-app"><a class="header" href="#the-app">The App</a></h1>
<p>Relevant official examples: All of them ;)</p>
<p>In particular, check out the complete game examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>To enter the Bevy runtime, you need to configure an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a>. The app is how you
define the structure of all the things that make up your project:
<a href="programming//programming/plugins.html">plugins</a>, <a href="programming//programming/systems.html">systems</a> (and their configuration/metadata:
<a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-order.html">ordering</a>, <a href="programming//programming/system-sets.html">sets</a>),
<a href="programming//programming/events.html">event</a> types, <a href="programming//programming/states.html">states</a>, <a href="programming//programming/schedules.html">schedules</a>…</p>
<p>You typically create your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> in your project's <code>main</code> function.  However,
you don't have to add everything from there. If you want to add things to your
app from multiple places (like other Rust files or crates), use
<a href="programming//programming/plugins.html">plugins</a>. As your project grows, you will need to do that to keep
everything organized.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // Bevy itself:
        .add_plugins(DefaultPlugins)

        // Plugins from our game/project:
        .add_plugins(ui::MyUiPlugin)

        // events:
        .add_event::&lt;LevelUpEvent&gt;()

        // systems to run once at startup:
        .add_systems(Startup, spawn_things)

        // systems to run each frame:
        .add_systems(Update, (
            camera_follow_player,
            debug_levelups,
            debug_stats_change,
        ))
        // ...

        // launch the app!
        .run();
}</code></pre>
<p>Note: use tuples with <code>add_systems</code>/<code>add_plugins</code>/<code>configure_sets</code> to add
multiple things at once.</p>
<p><a href="programming//programming/ec.html#components">Component</a> types do not need to be registered.</p>
<p>Schedules cannot (yet) be modified at runtime; all <a href="programming//programming/systems.html">systems</a> you
want to run must be added/configured in the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> ahead of time. You can
control individual systems using <a href="programming//programming/run-criteria.html">run conditions</a>. You can also
dynamically enable/disable entire schedules using the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a>
<a href="programming//programming/res.html">resource</a>.</p>
<p>app是组织项目的起点,通过app可以配置<code>插件</code>/<code>system(包括其运行条件/顺序/集合)</code>/
<code>事件</code>/<code>状态</code>/<code>调度</code>等等.</p>
<p>利用app可以按需添加功能,当项目增长时需要考虑如何组织代码,<code>插件</code>是最好的选择.</p>
<p>app的几个<code>add_函数</code>都是支持元组类型的,也就是说一次可以添加多个对象.
app不需要注册组件类型.</p>
<p>调度在运行期间不能修改,所以需要通过app明确配置完.
单个system是可以配置运行条件的;
利用<code>MainScheduleOrder</code>资源可以动态开启/关闭某个调度(这个是个高级用法,很少用到).</p>
<h2 id="builtin-bevy-functionality"><a class="header" href="#builtin-bevy-functionality">Builtin Bevy Functionality</a></h2>
<p>The Bevy game engine's own functionality is represented as a <a href="programming//programming/plugins.html#plugin-groups">plugin group</a>.
Every typical Bevy app must first add it, using either:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> if you are making a full game/app.</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> for something like a headless server.</li>
</ul>
<p>bevy游戏引擎自己的逻辑使用<code>插件组</code>来表示,bevy提供了两个默认的功能组:</p>
<ul>
<li>DefaultPlugins,默认插件列表</li>
<li>MinimalPlugins,最小插件列表</li>
</ul>
<h2 id="setting-up-data"><a class="header" href="#setting-up-data">Setting up data</a></h2>
<p>Normally, you can set up <a href="programming//programming/intro-data.html">your data</a> from
<a href="programming//programming/systems.html">systems</a>. Use <a href="programming//programming/commands.html">Commands</a> from regular systems, or
use <a href="programming//programming/exclusive.html">exclusive systems</a> to get <a href="programming//programming/world.html">full World access</a>.</p>
<p>Add your setup systems to the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Startup.html"><code>Startup</code></a> <a href="programming//programming/schedules.html">schedule</a> for
things you want to initialize at launch, or use <a href="programming//programming/states.html">state</a> enter/exit
systems to do things when transitioning between menus, game modes, levels, etc.</p>
<p>However, you can also initialize data directly from the app builder. This
is common for <a href="programming//programming/res.html">resources</a>, if they need to be present at all
times. You can also get <a href="programming//programming/world.html">direct World access</a>.</p>
<pre><code class="language-rust no_run noplayground">// Create (or overwrite) resource with specific value
app.insert_resource(StartingLevel(3));

// Ensure resource exists; if not, create it
// (using `Default` or `FromWorld`)
app.init_resource::&lt;MyFancyResource&gt;();

// We can also access/manipulate the World directly
// (in this example, to spawn an entity, but you can do anything)
app.world_mut().spawn(SomeBundle::default());</code></pre>
<p>构造实体有以下几种方式:</p>
<ul>
<li>在普通system中利用Commands实现</li>
<li>使用独占system来访问world的所有数据</li>
<li>在Startup调度中使用构造system来实现</li>
<li>在翻译菜单/游戏模型/等级时利用state在system开头或退出时实现</li>
<li>在app中直接使用world来构造</li>
</ul>
<p>通常利用app来直接初始化数据(资源,在剩下的游戏时间中都能被访问).</p>
<h2 id="quitting-the-app"><a class="header" href="#quitting-the-app">Quitting the App</a></h2>
<p>To cleanly shut down bevy, send an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/enum.AppExit.html"><code>AppExit</code></a> <a href="programming//programming/events.html">event</a> from any
<a href="programming//programming/systems.html">system</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::AppExit;

fn exit_system(mut exit: EventWriter&lt;AppExit&gt;) {
    exit.send(AppExit::Success);
}</code></pre>
<p>You can specify the exit code to return to the OS. If Bevy receives
multiple <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/enum.AppExit.html"><code>AppExit</code></a> events, success will only be returned if all
of them report success. If some report an error, the last event will
determine the actual exit code of the process.</p>
<p>退出bevy使用,在任意system中发出<code>AppExit</code>事件即可,
同时可以带上返回码.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/startup_system.rs"><code>startup_system</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/system_param.rs"><code>system_param</code></a>.</p>
<hr />
<p>Systems are pieces of functionality to be run by Bevy. They are typically
implemented using regular Rust functions. This is how you implement all
your game logic.</p>
<p>These functions can only take <a href="programming//builtins.html#systemparams">special parameter types</a>,
to specify what <a href="programming//programming/intro-data.html">data</a> you need access to. If you use
unsupported parameter types in your function, <a href="programming//pitfalls/into-system.html">you will get confusing compiler
errors!</a></p>
<p>Some of the possibilities are:</p>
<ul>
<li>accessing <a href="programming//programming/res.html">resources</a> using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a></li>
<li>accessing <a href="programming//programming/ec.html#components">components of entities</a> using <a href="programming//programming/queries.html">queries</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Query.html"><code>Query</code></a>)</li>
<li>creating/destroying entities, components, and resources using <a href="programming//programming/commands.html">Commands</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>)</li>
<li>sending/receiving <a href="programming//programming/events.html">events</a> using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader</code></a></li>
</ul>
<p><a href="programming//builtins.html#systemparams">See here for a full list!</a></p>
<pre><code class="language-rust no_run noplayground">fn debug_start(
    // access resource
    start: Res&lt;StartingLevel&gt;
) {
    eprintln!("Starting on level {:?}", *start);
}</code></pre>
<p>System parameters can be grouped into tuples (which can be nested). This is
useful for organization.</p>
<pre><code class="language-rust no_run noplayground">fn complex_system(
    (a, mut b): (
        Res&lt;ResourceA&gt;,
        ResMut&lt;ResourceB&gt;,
    ),
    (q0, q1, q2): (
        Query&lt;(/* … */)&gt;,
        Query&lt;(/* … */)&gt;,
        Query&lt;(/* … */)&gt;,
    ),
) {
    // …
}</code></pre>
<p>独占system的参数(此类system在执行时会独占world):</p>
<ul>
<li><code>&amp;mut world</code>: 直接访问world的方式,独占的</li>
<li><code>Local&lt;T&gt;</code>: system自己的数据,local不保存在world中,而是在system中,在system后续运行中也存在</li>
<li><code>&amp;mut SystemState&lt;P&gt;</code> <code>SystemState</code>: 模拟普通system,可以简单从world访问数据,P就是system参数</li>
<li><code>&amp;mut QueryState&lt;Q, F= ()&gt;</code> <code>QueryState</code>: 从world执行查询,类似普通system的Query</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<p>函数最多有16个参数,如果需要更多,就使用元组来突破限制.
元组同样最多只能有16个参数,但没有嵌套限制.</p>
<p>There is also a different kind of system: <a href="programming//programming/exclusive.html">exclusive systems</a>.
They have <a href="programming//programming/world.html">full direct access to the ECS World</a>, so you can access
any data you want and do anything, but cannot run in parallel. For most use
cases, you should use regular parallel systems.</p>
<pre><code class="language-rust no_run noplayground">fn reload_game(world: &amp;mut World) {
    // ... access whatever we want from the World
}</code></pre>
<p>system是bevy的功能片段,通常是rust函数实现,游戏的逻辑都在这里.</p>
<p>system的入参是有限制的(0),打破限制会导致编译报错(4.3).
常用的入参类型有:资源/query/Commands/事件收发器.</p>
<p>为了方便组织,可以将同类型的入参使用元组组织.</p>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>In order for your systems to actually be run by Bevy, you need to configure
them via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // run these only once at launch
        .add_systems(Startup, (setup_camera, debug_start))
        // run these every frame update
        .add_systems(Update, (move_player, enemies_ai))
        // ...
        .run();
}</code></pre>
<p>Be careful: writing a new system <code>fn</code> and forgetting to add it to your app is a
common mistake! If you run your project and your new code doesn't seem to be
running, make sure you added the system!</p>
<p>The above is enough for simple projects.</p>
<p>Systems are contained in <a href="programming//programming/schedules.html">schedules</a>. <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Update.html"><code>Update</code></a> is the schedule
where you typically add any systems you want to run every frame. <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Startup.html"><code>Startup</code></a> is
where you typically add systems that should run only once on app startup. There
are also <a href="programming//builtins.html#schedules">other possibilities</a>.</p>
<p>As your project grows more complex, you might want to make use of some of the
powerful tools that Bevy offers for managing when/how your systems run, such as:
<a href="programming//programming/system-order.html">explicit ordering</a>, <a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-sets.html">system
sets</a>, <a href="programming//programming/states.html">states</a>.</p>
<p>在app中可以利用调度器配置system的执行顺序,如果system函数没有添加到app中,
此是编译器不会报错,但运行没有效果,这可能要会花很多时间排查.</p>
<p>Startup是app启动时执行一次,Update是每帧都会执行,具体详情可以查看<code>调度器</code>章节.</p>
<p>当system数量非常多时,可用到下列工具:<code>显示顺序指定</code>,<code>运行条件</code>,<code>system集合</code>,<code>状态</code>.</p>
<h3 id="one-shot-systems"><a class="header" href="#one-shot-systems">One-Shot Systems</a></h3>
<p>Sometimes you don't want Bevy to run your system for you. In that case,
don't add it to a schedule.</p>
<p>If you are a writing a system that you want to call yourself whenever
you want (such as on a button press), you can do that using <a href="programming//programming/one-shot-systems.html">one-shot
systems</a>.</p>
<p><code>单击</code>system,不是注册到app由调度机制来触发执行,而是按需执行,
eg:按钮点击执行一个system.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="resources-2"><a class="header" href="#resources-2">Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Resources allow you to store a single global instance of some data type,
independently of <a href="programming//programming/intro-data.html#entities--components">entities</a>.</p>
<p>Use them for <a href="programming//programming/intro-data.html">data</a> that is truly global for your app, such
as configuration / settings. Resources make it easy for you to access such data
from anywhere.</p>
<p>To create a new resource type, simply define a Rust <code>struct</code> or <code>enum</code>, and
derive the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/trait.Resource.html"><code>Resource</code></a> trait, similar to
<a href="programming//programming/ec.html#components">components</a> and <a href="programming//programming/events.html">events</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct GoalsReached {
    main_goal: bool,
    bonus: u32,
}</code></pre>
<p>Types must be unique; there can only be at most one instance of a given type. If
you might need multiple, consider using <a href="programming//programming/intro-data.html#entities--components">entities and components</a> instead.</p>
<p>Bevy <a href="programming//builtins.html#resources">uses resources for many things</a>. You can use these builtin
resources to access various features of the engine. They work just like your own
custom types.</p>
<p>资源是可以存储某类型数据的全局单例,独立于实体.
对于app来说,资源是全局的,(配置和设置就是资源),在任何地方访问资源都非常方便.</p>
<p>创建资源很简单,struct/enum添加<code>Resource</code>自动实现即可(组件/事件都是如此声明的).</p>
<p>资源类型要唯一(这个是肯定的),只能有一个实例(单例,这个也是正常的).
如果有多个实例,使用ECS即可.</p>
<p>资源可以用来做很多事,bevy提供了不少内置资源,通过这些内置资源可以访问很多bevy功能.</p>
<h2 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing Resources</a></h2>
<p>To access the value of a resource from <a href="programming//programming/systems.html">systems</a>, use
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(
    // these will panic if the resources don't exist
    mut goals: ResMut&lt;GoalsReached&gt;,
    other: Res&lt;MyOtherResource&gt;,
    // use Option if a resource might not exist
    mut fancy: Option&lt;ResMut&lt;MyFancyResource&gt;&gt;,
) {
    if let Some(fancy) = &amp;mut fancy {
        // TODO: do things with `fancy`
    }
    // TODO: do things with `goals` and `other`
}</code></pre>
<p>在system中访问资源,只需要使用<code>Res&lt;T&gt;</code>或<code>ResMut&lt;T&gt;</code>.</p>
<h2 id="managing-resources"><a class="header" href="#managing-resources">Managing Resources</a></h2>
<p>If you need to create/remove resources at runtime, you can do so using
<a href="programming//programming/commands.html">commands</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>):</p>
<pre><code class="language-rust no_run noplayground">fn my_setup(mut commands: Commands /* ... */) {
    // add (or overwrite if existing) a resource, with the given value
    // 对于同一类型调用insert_resource(),会覆盖资源的值.
    commands.insert_resource(GoalsReached {
        main_goal: false,
        bonus: 100,
    });
    // ensure resource exists (create it with its default value if necessary)
    // 如果资源已存在,直接返回;如果资源不存在,使用`FromWorld`特型初始化值.
    // 任何资源,只要实现了Default特型,就自动实现了FromWorld特型.
    // 所以使用init_resource()的类型,一般要实现Default特型.
    commands.init_resource::&lt;MyFancyResource&gt;();
    // remove a resource (if it exists)
    // 如果资源不存在,直接返回.
    commands.remove_resource::&lt;MyOtherResource&gt;();
}</code></pre>
<p>Alternatively, using <a href="programming//programming/world.html">direct World access</a> from an <a href="programming//programming/exclusive.html">exclusive
system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn my_setup2(world: &amp;mut World) {
    // The same methods as with Commands are also available here,
    // but we can also do fancier things:

    // Check if resource exists
    if !world.contains_resource::&lt;MyFancyResource&gt;() {
        // Get access to a resource, inserting a custom value if unavailable
        let _bonus = world
            .get_resource_or_insert_with(|| GoalsReached {
                main_goal: false,
                bonus: 100,
            })
            .bonus;
    }
}</code></pre>
<p>Resources can also be set up from the <a href="programming//programming/app-builder.html">app builder</a>. Do this for
resources that are meant to always exist from the start.</p>
<pre><code class="language-rust no_run noplayground">    App::new()
        .add_plugins(DefaultPlugins)
        .insert_resource(StartingLevel(3))
        .init_resource::&lt;MyFancyResource&gt;()
        // ...</code></pre>
<p>运行过程中增删资源使用Commands进行操作;
也可以在独占system中直接对world进行操作;
对于一开始就要存在的资源,在app builder中也可以直接通过app增加资源.</p>
<h2 id="resource-initialization"><a class="header" href="#resource-initialization">Resource Initialization</a></h2>
<p>If you want to be able to use <code>.init_resource</code> to create your resource,
here is how you can provide the default value.</p>
<p>Implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> for simple resources:</p>
<pre><code class="language-rust no_run noplayground">// simple derive, to set all fields to their defaults
#[derive(Resource, Default)]
struct GameProgress {
    game_completed: bool,
    secrets_unlocked: u32,
}

#[derive(Resource)]
struct StartingLevel(usize);

// custom implementation for unusual values
impl Default for StartingLevel {
    fn default() -&gt; Self {
        StartingLevel(1)
    }
}

// on enums, you can specify the default variant
#[derive(Resource, Default)]
enum GameMode {
    Tutorial,
    #[default] // 这个default标识如果GameMode::default()时,默认会返回SinglePlayer::default()
    Singleplayer,
    Multiplayer,
}</code></pre>
<p>For resources that need complex initialization, implement <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct MyFancyResource {/* stuff */}

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS World from here.

        // For example, you can access (and mutate!) other things:
        {
            let mut x = world.resource_mut::&lt;MyOtherResource&gt;();
            x.do_mut_stuff();
        }

        // You can load assets:
        let font: Handle&lt;Font&gt; = world.resource::&lt;AssetServer&gt;().load("myfont.ttf");

        MyFancyResource { /* stuff */ }
    }
}</code></pre>
<p>Beware: it can be easy to get yourself into a mess of unmaintainable code
if you overuse <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> to do complex things.</p>
<p>使用init_resource()时,对于特别复杂的初始化,可以直接使用<code>FroWorld</code>.
这种灵活性的代价是<code>过渡使用FromWorld很有可能写出无法维护的代码</code>.</p>
<h2 id="usage-advice"><a class="header" href="#usage-advice">Usage Advice</a></h2>
<p>The choice of when to use <a href="programming//programming/intro-data.html#entities--components">entities/components</a> vs. resources is
typically about how you want to access the <a href="programming//programming/intro-data.html">data</a>: globally
from anywhere (resources), or using ECS patterns (entities/components).</p>
<p>Even if there is only one of a certain thing in your game (such as the
player in a single-player game), it can be a good fit to use an entity
instead of resources, because entities are composed of multiple components,
some of which can be common with other entities. This can make your game
logic more flexible. For example, you could have a "health/damage system"
that works with both the player and enemies.</p>
<p>选择使用ECS还是资源取决于访问方式,从任何地方访问全局变量,使用资源,其他使用ECS.</p>
<p>并不是只有一个实例就应该设计为资源,如果很多实体都要用到某个数据,设计为组件.
这样的考虑会更加灵活.</p>
<h3 id="settings"><a class="header" href="#settings">Settings</a></h3>
<p>One common usage of resources is for storing settings and configuration.</p>
<p>However, if it is something that cannot be changed at runtime and only used when
initializing a <a href="programming//programming/plugins.html">plugin</a>, consider putting that inside the plugin's
<code>struct</code>, instead of a resource.</p>
<p>资源的另一个常见使用场景是存储设置/配置.</p>
<p>游戏启动时初始化,运行期间不改变,最好设计为插件,而不是资源.</p>
<h3 id="caches"><a class="header" href="#caches">Caches</a></h3>
<p>Resources are also useful if you want to store some data in a way that is easier
or more efficient for you to access. For example, keeping a collection of <a href="programming//assets/handles.html">asset
handles</a>, or using a custom datastructure for representing a game
map more efficiently than using entities and components, etc.</p>
<p><a href="programming//programming/intro-data.html#entities--components">Entities and Components</a>, as flexible as they are, are not necessarily
the best fit for all use cases. If you want to represent your data some other
way, feel free to do so. Simply create a resource and put it there.</p>
<p>只要是想存储的简单点,或是访问的简单点,都可以使用资源来实现.
eg: asset资源的处理handle;游戏地图(这个用资源实现比ECS简单多了).</p>
<p>ECS非常灵活,但并不是在各个非方面都领先其他方案.</p>
<h3 id="interfacing-with-external-libraries"><a class="header" href="#interfacing-with-external-libraries">Interfacing with external libraries</a></h3>
<p>If you want to integrate some external non-Bevy software into a Bevy app,
it can be very convenient to create a resource to hold onto its state/data.</p>
<p>For example, if you wanted to use an external physics or audio engine, you
could put all its data in a resource, and write some systems to call its
functions. That can give you an easy way to interface with it from Bevy code.</p>
<p>If the external code is not thread-safe (<code>!Send</code> in Rust parlance), which is
common for non-Rust (e.g C++ and OS-level) libraries, you should use a
<a href="programming//programming/non-send.html">Non-Send</a> Bevy resource instead. This will make sure any Bevy
system that touches it will run on the main thread.</p>
<p>bevy程序使用外部软件时,资源适合存储状态和数据.eg:使用外部的物理引擎或音频引擎.</p>
<p>如果外部库不是线程安全的,可以用!Send来指明:只在主线程中运行.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p><a href="programming//programming/intro-data.html">See here for more explanation on how storing data in the ECS works.</a></p>
<p>Conceptually, an entity represents a set of values for different components.
Each component is a Rust type (<code>struct</code> or <code>enum</code>) and an entity can be used to
store a value of that type.</p>
<p>Technically, an entity is just a simple integer ID (imagine the "row number" in
a table/spreadsheet) that can be used to find related data values (in different
"columns" of that table).</p>
<p>In Bevy, <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> is this value. It consists of two integers:
the ID and the "generation" (allowing IDs to be reused, after you despawn old
entities).</p>
<p>You can create ("spawn") new entities and destroy ("despawn") entities using
<a href="programming//programming/commands.html"><code>Commands</code></a> or <a href="programming//programming/world.html">exclusive <code>World</code> access</a>.</p>
<pre><code class="language-rust no_run noplayground">fn setup(mut commands: Commands) {
    // create a new entity
    commands.spawn((
        // Initialize all your components and bundles here
        Enemy,
        Health {
            hp: 100.0,
            extra: 25.0,
        },
        AiMode::Passive,
        // ...
    ));

    // If you want to get the Entity ID, just call `.id()` after spawn
    let my_entity = commands.spawn((/* ... */)).id();

    // destroy an entity, removing all data associated with it
    commands.entity(my_entity).despawn();
}</code></pre>
<p>Many of your entities might need to have the same common components. You can use
<a href="programming//programming/bundle.html">Bundles</a> to make it easier to spawn your entities.</p>
<p>实体,就是组件集合,组件的rust类型是struct/enum.</p>
<p>在ECS设计中,实体通常是一个简单的整数ID,通过这个id可以找到实际的实体数据.
bevy也是这么设计的.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug)]
#[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
#[cfg_attr(feature = "bevy_reflect", reflect_value(Hash, PartialEq))]
#[cfg_attr(
    all(feature = "bevy_reflect", feature = "serialize"),
    reflect_value(Serialize, Deserialize)
)]
#[repr(C, align(8))]
pub struct Entity {
    #[cfg(target_endian = "little")]
    index: u32, // 对外暴露的ID.
    generation: NonZeroU32, // 版本,代数,重用一次自增一次.
    #[cfg(target_endian = "big")]
    index: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>很多实体可能需要相同的组件,bevy提供了多个模板Bundle,用于简化实体的构造.</p>
<h1 id="components-1"><a class="header" href="#components-1">Components</a></h1>
<p>Components are the data associated with entities.</p>
<p>To create a new component type, simply define a Rust <code>struct</code> or <code>enum</code>, and
derive the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Health {
    hp: f32,
    extra: f32,
}

#[derive(Component)]
enum AiMode {
    Passive,
    ChasingPlayer,
}</code></pre>
<p>Types must be unique – an entity can only have one component per Rust type.</p>
<p>实体不能包含多个同一类型的组件,因为实体是按类型区别组件的,重复会导致panic.</p>
<h2 id="newtype-components"><a class="header" href="#newtype-components">Newtype Components</a></h2>
<p>Use wrapper (newtype) structs to make unique components out of simpler types:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct PlayerXp(u32);

#[derive(Component)]
struct PlayerName(String);</code></pre>
<p>新类型组件,就是了防止两个组件的类型一致而添加了一层封装.</p>
<h2 id="marker-components"><a class="header" href="#marker-components">Marker Components</a></h2>
<p>You can use empty structs to help you identify specific entities. These are
known as "marker components". Useful with <a href="programming//programming/queries.html#query-filters">query filters</a>.</p>
<pre><code class="language-rust no_run noplayground">/// Add this to all menu ui entities to help identify them
#[derive(Component)]
struct MainMenuUI;

/// Marker for hostile game units
#[derive(Component)]
struct Enemy;

/// This will be used to identify the main player entity
#[derive(Component)]
struct Player;

/// Tag all creatures that are currently friendly towards the player
#[derive(Component)]
struct Friendly;</code></pre>
<p>标记组件,空结构体,这个用处太多了.eg:友军和敌军大部分组件都是类似的,
利用标记组件来做区分.</p>
<h2 id="accessing-components"><a class="header" href="#accessing-components">Accessing Components</a></h2>
<p>Components can be accessed from <a href="programming//programming/systems.html">systems</a>, using <a href="programming//programming/queries.html">queries</a>.</p>
<p>You can think of the query as the "specification" for the data you want
to access. It gives you access to specific component values from entities
that match the query's signature.</p>
<pre><code class="language-rust no_run noplayground">fn level_up_player(
    // get the relevant data. some components read-only, some mutable
    mut query_player: Query&lt;(&amp;PlayerName, &amp;mut PlayerXp, &amp;mut Health), With&lt;Player&gt;&gt;,
) {
    // `single` assumes only one entity exists that matches the query
    let (name, mut xp, mut health) = query_player.single_mut();
    if xp.0 &gt; 1000 {
        xp.0 = 0;
        health.hp = 100.0;
        health.extra += 25.0;
        info!("Player {} leveled up!", name.0);
    }
}

fn die(
    // `Entity` can be used to get the ID of things that match the query
    query_health: Query&lt;(Entity, &amp;Health)&gt;,
    // we also need Commands, so we can despawn entities if we have to
    mut commands: Commands,
) {
    // we can have many such entities (enemies, player, whatever)
    // so we loop to check all of them
    for (entity_id, health) in query_health.iter() {
        if health.hp &lt;= 0.0 {
            commands.entity(entity_id).despawn();
        }
    }
}</code></pre>
<p>访问组件一般都是通过query来匹配实体,遍历实体列表,再访问组件.</p>
<h2 id="addingremoving-components"><a class="header" href="#addingremoving-components">Adding/removing Components</a></h2>
<p>You can add/remove components on existing entities, using <a href="programming//programming/commands.html"><code>Commands</code></a> or
<a href="programming//programming/world.html">exclusive <code>World</code> access</a>.</p>
<pre><code class="language-rust no_run noplayground">fn make_enemies_friendly(
    query_enemy: Query&lt;Entity, With&lt;Enemy&gt;&gt;,
    mut commands: Commands,
) {
    for entity_id in query_enemy.iter() {
        commands.entity(entity_id)
            .remove::&lt;Enemy&gt;()
            .insert(Friendly);
    }
}</code></pre>
<p>增删实体的组件有两种方式:</p>
<ul>
<li>Commands</li>
<li>独占system访问world</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="bundles-1"><a class="header" href="#bundles-1">Bundles</a></h1>
<p>You can think of Bundles like "templates" for creating entities.
They make it easy to create <a href="programming//programming/ec.html#entities">entities</a> with a common set of
<a href="programming//programming/ec.html#components">components</a> types.</p>
<p>By creating a bundle type, instead of adding your components one by one, you
can make sure that you will never accidentally forget some important component
on your entities. The Rust compiler will give an error if you do not set all
the fields of a struct, thus helping you make sure your code is correct.</p>
<p>Bevy provides many <a href="programming//builtins.html#bundles">built-in bundle types</a> that you can use
to spawn common kinds of entities.</p>
<p>bundle可翻译为一捆一包,将多个组件划分为一包,再参与实体的构造,
简单点说就是构造实体打造出的特殊类型,为什么要bundle,自然是为了api的统一.</p>
<p>bundle还有个好处,将部分组件划分为一包,这样在构造实体时就不会意外少了某个组件,
ecs架构中少一个组件,运行结果将大大不同.rust编译器会检查bundle的每个字段,
这也是变相保证了代码的正确性(这有点硬扯了).</p>
<p>bevy提供了多种内置的bundle,方便生成不同类型的实体.</p>
<h2 id="creating-bundles"><a class="header" href="#creating-bundles">Creating Bundles</a></h2>
<p>To create your own bundle, derive <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/bundle/trait.Bundle.html"><code>Bundle</code></a> on a <code>struct</code>:</p>
<pre><code class="language-rust no_run noplayground">// 给自定义类型添加Bundle的derive之后,自定类型就实现了Bundle特型.
// Bundle特性的功能在于实体可以增删组件,实现方式是用Bundle表示一组实体的组件.
// Bundle中的组件不能重复,否则会panic.
//
// Bundle主要功能还是向实体中新增Bundle,
// 如果某个实体已经有了新增的组件,那么实体中原始组件的值会被覆盖.
// (这意味着一个实体可以包含多个Bundle,多个Bundle可以包含相同的组件,
// 但单个Bundle中不能包含重复的组件).
//
// Bundle仅仅是组件的组合,不关心组件的行为,组件的行为由system考虑.
// 所以在设计上`Query`的对象是组件,而不是Bundle.
//
// 少部分场景下实体可以删除Bundle,此时会删除所有Bundle中的组件,
// 如果删除后实体并无其他组件时,实体会被删除.
#[derive(Bundle)]
struct PlayerBundle {
    xp: PlayerXp,
    name: PlayerName,
    health: Health,
    marker: Player,

    // We can nest/include another bundle.
    // Add the components for a standard Bevy Sprite:
    sprite: SpriteBundle,
}</code></pre>
<p>When you have nested bundles, everything gets flattened.
You end up with an entity that has all the included component
types. If a type appears more than once, that's an error.</p>
<p>不管bundle嵌套多少,最终都是扁平化处理,实体会拥有所有的组件类型,如果重复会出错.</p>
<h3 id="using-bundles"><a class="header" href="#using-bundles">Using Bundles</a></h3>
<p>You can then use your bundle when you spawn your entities:</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn(PlayerBundle {
        xp: PlayerXp(0),
        name: PlayerName("Player 1".into()),
        health: Health {
            hp: 100.0,
            extra: 0.0,
        },
        marker: Player,
        sprite: SpriteBundle {
            // TODO
            ..Default::default()
        },
    });</code></pre>
<p>If you want to have default values (similar to Bevy's bundles):</p>
<pre><code class="language-rust no_run noplayground">impl Default for PlayerBundle {
    fn default() -&gt; Self {
        Self {
            xp: PlayerXp(0),
            name: PlayerName("Player".into()),
            health: Health {
                hp: 100.0,
                extra: 0.0,
            },
            marker: Player,
            sprite: Default::default(),
        }
    }
}</code></pre>
<p>Now you can do this:</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn(PlayerBundle {
        name: PlayerName("Player 1".into()),
        ..Default::default()
    });</code></pre>
<p>具体实现Bundle特型的类型,在Commands.spawn()中可以传入具体的实例,
具体类型还可以实现Default来简化写法.</p>
<h3 id="bundles-for-removal"><a class="header" href="#bundles-for-removal">Bundles for Removal</a></h3>
<p>Bundles can also be useful to represent a set of components that you
want to be able to easily remove from an entity.</p>
<pre><code class="language-rust no_run noplayground">/// Contains all components to remove when
/// resetting the player between rooms/levels.
#[derive(Bundle)]
struct PlayerResetCleanupBundle {
    status_effect: StatusEffect,
    pending_action: PlayerPendingAction,
    modifier: CurrentModifier,
    low_hp_marker: LowHpMarker,
}</code></pre>
<pre><code class="language-rust no_run noplayground">    commands
        .entity(e_player)
        .remove::&lt;PlayerResetCleanupBundle&gt;();</code></pre>
<p>The component types included in the bundle will be removed from the
entity, if any of them exist on the entity.</p>
<p>实体删除Bundle的套路是:
<code>commands.entity(实体id).remove::&lt;具体的Bundle类型&gt;();</code></p>
<h2 id="loose-components-as-bundles"><a class="header" href="#loose-components-as-bundles">Loose components as bundles</a></h2>
<p>Technically, Bevy also considers arbitrary tuples of components as bundles:</p>
<pre><code>(ComponentA, ComponentB, ComponentC)
</code></pre>
<p>This allows you to easily spawn an entity using a loose bunch of components (or
bundles), or add more arbitrary components when you spawn entities. However,
this way you don't have the compile-time correctness advantages that a
well-defined <code>struct</code> gives you.</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn((
        SpriteBundle {
            // ...
            ..default()
        },
        Health {
            hp: 50.0,
            extra: 0.0,
        },
        Enemy,
        // ...
    ));</code></pre>
<p>You should strongly consider creating proper <code>struct</code>s, especially if you are
likely to spawn many similar entities. It will make your code easier to maintain.</p>
<p>bevy设计的Bundle是一个非常灵活的类型,无限嵌套让Bundle的表现力非常强大,
也复用rust编译器的正确性检查功能.仅凭这一点,
最好还是使用结构体将松散的组件列表维护起来, 特别是要构造很多相似的实体时,代码更容易维护.</p>
<p>所以说尽量使用Bundle来组织组件.</p>
<h2 id="querying"><a class="header" href="#querying">Querying</a></h2>
<p>Note that you cannot <a href="programming//programming/queries.html">query</a> for a whole bundle. Bundles are just a
convenience when creating the entities. Query for the individual component types
that your <a href="programming//programming/systems.html">system</a> needs to access.</p>
<p>This is <em>wrong</em>:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(query: Query&lt;&amp;SpriteBundle&gt;) {
  // ...
}</code></pre>
<p>Instead, do this:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(query: Query&lt;(&amp;Transform, &amp;Handle&lt;Image&gt;)&gt;) {
  // ...
}</code></pre>
<p>(or whatever specific components you need in that system)</p>
<p>ECS查询时使用组件,因为Bundle设计的使用场景是构造实体,不是这儿的查询.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Queries let you access <a href="programming//programming/ecs-intro.html">components of entities</a>.</p>
<p>Use the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> <a href="programming//programming/systems.html">system parameter</a>, where you can specify the data
you want to access, and optionally additional <a href="programming//programming/queries.html#query-filters">filters</a>.</p>
<p>Think of the types you put in your <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> as a "specification" for selecting
what entities you want to access. Queries will match only those entities in the
ECS World that fit your specification. You are then able to access the relevant
data from any such entities.</p>
<p>The first type parameter for a query is the data you want to access. Use <code>&amp;</code> for
shared/readonly access and <code>&amp;mut</code> for exclusive/mutable access. Use <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> if
the component is not required (you want to find entities with or without that
component. If you want multiple components, put them in a tuple.</p>
<p>通过query可以访问实体的组件.</p>
<pre><code class="language-rsut">pub struct Query&lt;'world, 'state, D, F = ()&gt;
where
    D: QueryData, // 特型,用于从world中查找数据.
    F: QueryFilter, // 特型,用于过滤查询的结果.
{ /* private fields */ }
</code></pre>
<p>Query是一个泛型结构体,有两个参数.前一个参数只能是引用类型(不然所有权没了),
且如果不确定某个组件有没有,使用Option,如果实体包含此组件,就返回;否则返回空.
如果要访问多个组件,使用元组.</p>
<h3 id="iterating"><a class="header" href="#iterating">Iterating</a></h3>
<p>The most common operation is to simply iterate to access the component values of
every entity that matches the query:</p>
<pre><code class="language-rust no_run noplayground">fn check_zero_health(
    // access entities that have `Health` and `Transform` components
    // get read-only access to `Health` and mutable access to `Transform`
    // optional component: get access to `Player` if it exists
    mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
    // get all matching entities
    for (health, mut transform, player) in query.iter_mut() {
        eprintln!("Entity at {} has {} HP.", transform.translation, health.hp);

        // center if hp is zero
        if health.hp &lt;= 0.0 {
            transform.translation = Vec3::ZERO;
        }

        if let Some(player) = player {
            // the current entity is the player!
            // do something special!
        }
    }
}</code></pre>
<p>If you want to know the entity IDs of the entities you are accessing, you can
put the special <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> type in your query. This is useful if you need
to later perform specific operations on those entities.</p>
<pre><code class="language-rust no_run noplayground">// add `Entity` to `Query` to get Entity IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
    for (e, /* ... */) in q.iter() {
        // `e` is the Entity ID of the entity we are accessing
    }
}</code></pre>
<p>上面显示了query组件最常见的遍历方式.
也可以query实体,得到的是实体ID,如上面的例子.</p>
<h3 id="accessing-specific-entities"><a class="header" href="#accessing-specific-entities">Accessing Specific Entities</a></h3>
<p>To access the <a href="programming//programming/ec.html#components">components</a> from one specific <a href="programming//programming/ec.html#entities">entity</a>
only, you need to know the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID:</p>
<pre><code class="language-rust no_run noplayground">if let Ok((health, mut transform)) = query.get_mut(entity) {
    // do something with the components
} else {
    // the entity does not have the components from the query
}</code></pre>
<p>If you want to access the data from several entities all at once, you can use
<code>many</code>/<code>many_mut</code> (panic on error) or <code>get_many</code>/<code>get_many_mut</code> (return
<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>).  These methods ensure that all the requested entities exist and
match the query, and will produce an error otherwise.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct UiHudIndicators {
    // say we have 3 special UI elements
    entities_ui: [Entity; 3],
    entities_text: [Entity; 3],
}

fn update_ui_hud_indicators(
    indicators: Res&lt;UiHudIndicators&gt;,
    query_text: Query&lt;&amp;Text&gt;,
    query_ui: Query&lt;(&amp;Style, &amp;BackgroundColor)&gt;,
) {
    // we can get everything as an array
    if let Ok(my_texts) = query_text.get_many(indicators.entities_text) {
        // the entities exist and match the query
        // TODO: something with `my_texts[0]`, `my_texts[1]`, `my_texts[2]`
    } else {
        // query unsuccessful
    };

    // we can use "destructuring syntax"
    // if we want to unpack everything into separate variables
    let [(style0, color0), (style1, color1), (style2, color2)] =
        query_ui.many(indicators.entities_ui);

    // TODO: something with all these variables
}</code></pre>
<p>访问特定的实体,提前保存好实体id即可.
如果要同时访问多个实体,可以使用many/many_mut或get_many/get_many_mut.</p>
<h3 id="unique-entities"><a class="header" href="#unique-entities">Unique Entities</a></h3>
<p>If you know that only one matching entity is supposed to exist (the query is
expected to only ever match a single entity), you can use <code>single</code>/<code>single_mut</code>
(panic on error) or <code>get_single</code>/<code>get_single_mut</code> (return <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>). These
methods ensure that there exists exactly one candidate entity that can match
your query, and will produce an error otherwise.</p>
<p>You do not need to know the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID.</p>
<pre><code class="language-rust no_run noplayground">fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
    let (player, mut transform) = q.single_mut();

    // do something with the player and its transform
}</code></pre>
<p>唯一实体,eg:我们操纵的角色只有一个,此时可用single/single_mut或get_single/get_many_mut.
此时不需要实体ID.</p>
<h3 id="combinations"><a class="header" href="#combinations">Combinations</a></h3>
<p>If you want to iterate over all possible combinations of N entities, Bevy
provides a method for that too. Be careful: with a lot of entities, this
can easily become very slow!</p>
<pre><code class="language-rust no_run noplayground">fn print_potential_friends(
    q_player_names: Query&lt;&amp;PlayerName&gt;,
) {
    // this will iterate over every possible pair of two entities
    // (that have the PlayerName component)

    for [player1, player2] in q_player_names.iter_combinations() {
        println!("Maybe {} could be friends with {}?", player1.0, player2.0);
    }
}

fn apply_gravity_to_planets(
    mut query: Query&lt;&amp;mut Transform, With&lt;Planet&gt;&gt;,
) {
    // this will iterate over every possible pair of two planets

    // For mutability, we need a different syntax
    let mut combinations = query.iter_combinations_mut();
    while let Some([planet1, planet2]) = combinations.fetch_next() {
        // TODO: calculate the gravity force between the planets
    }
}</code></pre>
<p>将query结果进行组合,使其变为数组.当实体数量大时,性能会很差.
这个的意义在与补充标准<code>query-for</code>的遍历方式.</p>
<h2 id="bundles-2"><a class="header" href="#bundles-2">Bundles</a></h2>
<p>Queries work with individual components. If you created an entity using a
<a href="programming//programming/bundle.html">bundle</a>, you need to query for the specific components from
that bundle that you care about.</p>
<p>A common beginner mistake is to query for the bundle type!</p>
<p>bundle只在构造时有用,不能用在query处.</p>
<h2 id="query-filters"><a class="header" href="#query-filters">Query Filters</a></h2>
<p>Add query filters to narrow down the entities you get from the query.</p>
<p>This is done using the second (optional) generic type parameter of the
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> type.</p>
<p>Note the syntax of the query: first you specify the data you want to access
(using a tuple to access multiple things), and then you add any additional
filters (can also be a tuple, to add multiple).</p>
<p>Use <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.With.html"><code>With</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Without.html"><code>Without</code></a> to only get entities that have specific components.</p>
<pre><code class="language-rust no_run noplayground">fn debug_player_hp(
    // access the health (and optionally the PlayerName, if present), only for friendly players
    query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
    // get all matching entities
    for (health, name) in query.iter() {
        if let Some(name) = name {
            eprintln!("Player {} has {} HP.", name.0, health.hp);
        } else {
            eprintln!("Unknown player has {} HP.", health.hp);
        }
    }
}</code></pre>
<p>This is useful if you don't actually care about the data stored inside these
components, but you want to make sure that your query only looks for entities
that have (or not have) them. If you want the data, then put the component in
the first part of the query (as shown previously), instead of using a filter.</p>
<p>Multiple filters can be combined:</p>
<ul>
<li>in a tuple to apply all of them (AND logic)</li>
<li>using the <code>Or&lt;(…)&gt;</code> wrapper to detect any of them (OR logic).
<ul>
<li>(note the tuple inside)</li>
</ul>
</li>
</ul>
<p>query的第二个泛型参数是过滤,可省略,也可以是元组组成.
多个过滤可以进行组合:</p>
<ul>
<li>用元组,里面是<code>逻辑与</code>关系</li>
<li>用<code>Or&lt;..&gt;</code>, <code>逻辑或</code>关系</li>
</ul>
<h2 id="query-transmutation"><a class="header" href="#query-transmutation">Query Transmutation</a></h2>
<p>If you want one function with a <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> parameter to call another function
with a different (but compatible) <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> parameter, you can create the
needed <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> from the one you have using something called <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.QueryLens.html"><code>QueryLens</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn debug_positions(
    query: Query&lt;&amp;Transform&gt;,
) {
    for transform in query.iter() {
        eprintln!("{:?}", transform.translation);
    }
}

fn move_player(
    mut query_player: Query&lt;&amp;mut Transform, With&lt;Player&gt;&gt;,
) {
    // TODO: mutate the transform to move the player

    // say we want to call our debug_positions function

    // first, convert into a query for `&amp;Transform`
    let mut lens = query_player.transmute_lens::&lt;&amp;Transform&gt;();
    debug_positions(lens.query());
}

fn move_enemies(
    mut query_enemies: Query&lt;&amp;mut Transform, With&lt;Enemy&gt;&gt;,
) {
    // TODO: mutate the transform to move our enemies

    let mut lens = query_enemies.transmute_lens::&lt;&amp;Transform&gt;();
    debug_positions(lens.query());
}</code></pre>
<p>Note: when we call <code>debug_positions</code> from each function, it will access
different entities! Even though the <code>Query&lt;&amp;Transform&gt;</code> parameter type does not
have any additional <a href="programming//programming/queries.html#query-filters">filters</a>, it was created by transmuting
via <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.QueryLens.html"><code>QueryLens</code></a>, and therefore it can only access the entities and components
of the original <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> that it was derived from. If we were to add
<code>debug_positions</code> to Bevy as a regular system, it would access the transforms of
all entities.</p>
<p>Also note: this has some performance overhead; the transmute operation is not
free. Bevy normally caches some query metadata across multiple runs of a
system. When you create the new query, it has to make a copy of it.</p>
<p>部分场景下,system会调用另一个函数,另一个函数的参数也是一个query,
只不过这个query参数是调用方system 入参query的兼容部分(只是包含部分组件),
如上面的例子所示,可以使用一个叫<code>QueryLen</code>的技术来实现转换.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn transmute_lens&lt;NewD&gt;(&amp;mut self) -&gt; QueryLens&lt;'_, NewD&gt;
where
    NewD: QueryData,
<span class="boring">}</span></code></pre></pre>
<p>这是对QueryData的处理,将要查询的组件缩小了范围.组件范围缩小了,
意味着将system函数拆分为小函数的过程中,部分小函数只关心自己需要的那部分数据,
好处是小函数也容易复用.</p>
<p>这么做也是有代价的,性能是一个,内存也是一个.
因为bevy通常会缓存查询的元数据,方便多次调用system时能提高性能,
但新建一个query时,需要拷贝.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> to spawn/despawn entities, add/remove components on existing
entities, manage resources, from your <a href="programming//programming/systems.html">systems</a>.</p>
<p>Commands可以增删实体;从实体中增删组件;管理资源.</p>
<pre><code class="language-rust no_run noplayground">// 这个Commands的例子将主要使用的场景都罗列出来了.
fn spawn_things(mut commands: Commands) {
    // manage resources
    commands.insert_resource(MyResource::new());
    commands.remove_resource::&lt;MyResource&gt;();
    // 增删资源,同类型的资源都只有一份.(如果要增加多份就使用组件,资源都是单例组件).

    // create a new entity using `spawn`,
    // providing the data for the components it should have
    // (typically using a Bundle)
    commands.spawn(PlayerBundle {
        name: PlayerName("Henry".into()),
        xp: PlayerXp(1000),
        health: Health {
            hp: 100.0,
            extra: 20.0,
        },
        _p: Player,
        sprite: Default::default(),
    });
    // 构造一个实体,单组件.

    // you can use a tuple if you need additional components or bundles
    // (tuples of component and bundle types are considered bundles)
    // (note the extra parentheses)
    let my_entity_id = commands
        .spawn((
            // add some components
            ComponentA,
            ComponentB::default(),
            // add some bundles
            MyBundle::default(),
            TransformBundle::default(),
        ))
        .id(); // get the Entity (id) by calling `.id()` at the end

    // 构造一个实体,多组件.
    // Bundle是特征,从单元元组到14个元素的元组,都实现了Bundle.
    //
    // Commands::spawn()是构造实体,返回的是system::EntityCommands,
    // EntityCommands是一个命令列表,这些命令会修改实体. id()会返回实体(一个轻量级的标识:数值类型).

    // add/remove components of an existing entity
    commands
        .entity(my_entity_id)
        .insert(ComponentC::default())
        .remove::&lt;ComponentA&gt;()
        .remove::&lt;(ComponentB, MyBundle)&gt;();
    // 对实体进行组件增删操作.
    // Commands.entity()会根据Entity查到对应的EntityCommands,
    // EntityCommands的insert/remove就是对具体实体进行组件变更操作.

    // remove everything except the given components / bundles
    commands
        .entity(my_entity_id)
        .retain::&lt;(TransformBundle, ComponentC)&gt;();
    // 只保留指定的组件,其他全部删除.
}

// 改变敌对关系,增加敌人组件,删除友善组件.
fn make_all_players_hostile(
    mut commands: Commands,
    // we need the Entity id, to perform commands on specific entities
    query: Query&lt;Entity, With&lt;Player&gt;&gt;,
) {
    for entity in query.iter() {
        commands
            .entity(entity)
            // add an `Enemy` component to the entity
            .insert(Enemy)
            // remove the `Friendly` component
            .remove::&lt;Friendly&gt;();
    }
}

// 删除所有实体的敌人组件.
fn despawn_all_enemies(mut commands: Commands, query: Query&lt;Entity, With&lt;Enemy&gt;&gt;) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}</code></pre>
<h2 id="when-do-these-actions-get-applied"><a class="header" href="#when-do-these-actions-get-applied">When do these actions get applied?</a></h2>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> do not take effect immediately, because it wouldn't be safe to
modify the data layout in memory when other <a href="programming//programming/systems.html">systems</a> could be
running in parallel. When you do anything using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, it gets queued to
be applied later when it is safe to do so.</p>
<p>Within the same <a href="programming//programming/schedules.html">schedule</a>, you can add <code>.before()</code>/<code>.after()</code>
<a href="programming//programming/system-order.html">ordering constraints</a> to your systems, and Bevy will
automatically make sure that Commands get applied in-between if necessary, so
that the second system can see the changes made by the first system.</p>
<p>Commands并不会立马生效,因为systems也在并行修改内存数据,立马生效会导致不安全,
等待安全时,bevy会将命令集应用到world上.</p>
<p>在调度器组织system时,bevy提供了before/after机制,在部分调度执行之前/之后插入逻辑,
bevy会择机应用Commands,保证了安全,下一个system执行时,Commands已经应用了.</p>
<p>before/after外加调度器内置的顺序,提供了强大的灵活性.</p>
<pre><code class="language-rust no_run noplayground">    app.add_systems(Update, spawn_new_enemies_if_needed);

    // This system will see any newly-spawned enemies when it runs,
    // because Bevy will make sure to apply the first system's Commands
    // (thanks to the explicit `.after()` dependency)
    app.add_systems(Update, enemy_ai.after(spawn_new_enemies_if_needed));</code></pre>
<p>If you do not have explicit ordering dependencies, it is undefined when Commands
will be applied. It is possible that some systems will only see the changes on
the next frame update!</p>
<p>Otherwise, Commands are normally applied at the end of every
<a href="programming//programming/schedules.html">schedule</a>. <a href="programming//programming/systems.html">Systems</a> that live in different schedules
will see the changes. For example, Bevy's engine systems (that live in
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>) will see the entities you spawn in your systems (that live in
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Update.html"><code>Update</code></a>).</p>
<p>如果没有明确命令应用顺序,那么命令具体应用时间是不确定的,
可能在下帧才应用上.</p>
<h2 id="custom-commands"><a class="header" href="#custom-commands">Custom Commands</a></h2>
<p>Commands can also serve as a convenient way to do any custom manipulations
that require <a href="programming//programming/world.html">full access</a> to the ECS <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>. You can queue up
any custom code to run in a deferred fashion, the same way as the standard
commands work.</p>
<p>For a one-off thing, you can just pass a closure:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(mut commands: Commands) {
    let x = 420;

    commands.add(move |world: &amp;mut World| {
        // do whatever you want with `world` here

        // note: it's a closure, you can use variables from
        // the parent scope/function
        eprintln!("{}", x);
    });
}</code></pre>
<p>If you want something reusable, consider <a href="programming//programming/one-shot-systems.html">one-shot systems</a>.
They are a way to write regular Bevy systems and run them on-demand.</p>
<p>只要是访问ECS的world,使用Commands是非常便捷的方式.
可以将自定义逻辑以延时的方式运行,标准命令也是如此工作的.</p>
<p>对于一次性的事情,可以传递一个闭包.
对于想重用的事情,可以考虑<code>一击</code>system,这是常规的bevy systm,按需运行.</p>
<p>所谓<code>一击</code>system,就是想要时才调用,eg:按钮按下,触发一个特殊事件等等.</p>
<h3 id="extending-the-commands-api"><a class="header" href="#extending-the-commands-api">Extending the Commands API</a></h3>
<p>If you want something more integrated, that feels like as if it was
part of Bevy's Commands API, here is how to do it.</p>
<p>Create a custom type and implement the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.Command.html"><code>Command</code></a> trait:</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::world::Command;

struct MyCustomCommand {
    // you can have some parameters
    data: u32,
}

impl Command for MyCustomCommand {
    fn apply(self, world: &amp;mut World) {
        // do whatever you want with `world` and `self.data` here
    }
}

// use it like this
fn my_other_system(mut commands: Commands) {
    commands.add(MyCustomCommand {
        data: 920, // set your value
    });
}</code></pre>
<p>And if you want to make it extra nice to use, you can create
an extension trait to add extra methods to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>:</p>
<pre><code class="language-rust no_run noplayground">pub trait MyCustomCommandsExt {
    // define a method that we will be able to call on `commands`
    fn do_custom_thing(&amp;mut self, data: u32);
}

// implement our trait for Bevy's `Commands`
impl&lt;'w, 's&gt; MyCustomCommandsExt for Commands&lt;'w, 's&gt; {
    fn do_custom_thing(&amp;mut self, data: u32) {
        self.add(MyCustomCommand { data });
    }
}

fn my_fancy_system(mut commands: Commands) {
    // now we can call our custom method just like Bevy's `spawn`, etc.
    commands.do_custom_thing(42);
}</code></pre>
<p>Note: if you want to use your custom extension method from other Rust
files, you will have to import your trait, or it will not be available:</p>
<pre><code class="language-rust no_run noplayground">use crate::thing::MyCustomCommandsExt;</code></pre>
<p>扩展Commands API</p>
<p>如果有更多交互需求,可扩展Commands.</p>
<p>bevy::ecs::system下有两个类型: 特型Command和 实现了Command的结构体Commands.</p>
<p>Commands是命令列表,Command是具体命令.</p>
<p>按照扩展的约束:只要当前crate中包含特型或类型其中之一就可以进行扩展.</p>
<p>所以先定义一个类型<code>MyCustomCommand</code>,让其实现Command,这样自定义命令就可以正常使用了.
如果要为自定义命令添加自定义方法,就需要添加自定义特型<code>MyCustomCommandsExt</code>,
此处需要注意:让Commands实现自定义特型.</p>
<p>NOTE: 如果要在其他rust文件中也使用这个扩展,就需要导入自定义特型.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="events-2"><a class="header" href="#events-2">Events</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/event.rs"><code>event</code></a>.</p>
<hr />
<p>Send data between systems! Let your <a href="programming//programming/systems.html">systems</a> communicate with each other!</p>
<p>Like <a href="programming//programming/res.html">resources</a> or <a href="programming//programming/ec.html#components">components</a>, events are
simple Rust <code>struct</code>s or <code>enum</code>s. When creating a new event type, derive
the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/trait.Event.html"><code>Event</code></a> trait.</p>
<p>Then, any <a href="programming//programming/systems.html">system</a> can send (broadcast) values of that type,
and any system can receive those events.</p>
<ul>
<li>To send events, use an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>.</li>
<li>To receive events, use an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>.</li>
</ul>
<p>Every reader tracks the events it has read independently, so you can handle
the same events from multiple <a href="programming//programming/systems.html">systems</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Event)]
struct LevelUpEvent(Entity);

fn player_level_up(
    mut ev_levelup: EventWriter&lt;LevelUpEvent&gt;,
    query: Query&lt;(Entity, &amp;PlayerXp)&gt;,
) {
    for (entity, xp) in query.iter() {
        if xp.0 &gt; 1000 {
            ev_levelup.send(LevelUpEvent(entity));
        }
    }
}

fn debug_levelups(
    mut ev_levelup: EventReader&lt;LevelUpEvent&gt;,
) {
    for ev in ev_levelup.read() {
        eprintln!("Entity {:?} leveled up!", ev.0);
    }
}</code></pre>
<p>You need to register your custom event types via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">app.add_event::&lt;LevelUpEvent&gt;();</code></pre>
<p>Event用于system传递数据.derive中指定Event就可以声明事件了.</p>
<p>任何system都可以发送事件,任何sytem都可以接收事件.
<code>EventWriter&lt;T&gt;</code>发送事件,<code>EventReader&lt;T&gt;</code>接收事件.
每个reader都是单独消费事件的.</p>
<p>如上面的例子,事件收发都在system入参中明确了.</p>
<h2 id="usage-advice-1"><a class="header" href="#usage-advice-1">Usage Advice</a></h2>
<p>Events should be your go-to data flow tool. As events can be sent from any
<a href="programming//programming/systems.html">system</a> and received by multiple systems, they are <em>extremely</em>
versatile.</p>
<p>Events can be a very useful layer of abstraction. They allow you to decouple
things, so you can separate different functionality and more easily reason
about which <a href="programming//programming/systems.html">system</a> is responsible for what.</p>
<p>You can imagine how, even in the simple "player level up" example shown above,
using events would allow us to easily extend our hypothetical game with more
functionality. If we wanted to display a fancy level-up effect or animation,
update UI, or anything else, we can just add more systems that read the events
and do their respective things. If the <code>player_level_up</code> system had simply
checked the player XP and managed the player level directly, without going via
events, it would be unwieldy for future development of the game.</p>
<p>system之间交互的,推荐使用事件,在绝大部分场景下,事件都是优先选项.
和消息系统类似,bevy的事件系统具有强大的解耦能力.</p>
<p>只有解耦之后,才能在一个事件发生时才能触发更多逻辑,从工程化和协作的角度来看,这点是非常重要的.</p>
<h2 id="how-it-all-works"><a class="header" href="#how-it-all-works">How it all works</a></h2>
<p>When you register an event type, Bevy will create an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a>
<a href="programming//programming/res.html">resource</a>, which acts as the backing storage for the event queue. Bevy
also adds an "event maintenance" <a href="programming//programming/systems.html">system</a> to clear events periodically,
preventing them from accumulating and using up memory.</p>
<p>Bevy ensures that events are kept around for at least two frame update cycles,
or two <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> cycles, whichever is longer. After
that, they are silently dropped. This gives your systems enough opportunity
to handle them, assuming your systems are running all the time. Beware when
adding <a href="programming//programming/run-criteria.html">run conditions</a> to your systems, as you might miss some events
when your systems are not running!</p>
<p>If you don't like this, <a href="programming//patterns/manual-event-clear.html">you can have manual control over when events are
cleared</a> (at the risk of leaking / wasting memory if you
forget to clear them).</p>
<p>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a> system parameter is just syntax sugar for mutably
accessing the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a> <a href="programming//programming/res.html">resource</a> to add events to the queue. The
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a> is a little more complex: it accesses the events storage
immutably, but also stores an integer counter to keep track of how many events
you have read. This is why it also needs the <code>mut</code> keyword.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a> itself is internally implemented using simple <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a>s. Sending
events is equivalent to just pushing to a <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a>. It is very fast,
low overhead. Events are often the most performant way to implement things
in Bevy, better than using <a href="programming//programming/change-detection.html">change detection</a>.</p>
<p>当我们注册一个事件类型时,bevy会创建一个<code>Event&lt;T&gt;</code>资源,事件队列就存储在这个资源中.
bevy还添加了一个定期清理事件的<code>事件维护system</code>,防止内存泄漏.</p>
<p>bevy保证事件至少保留两帧,或两个Fixed周期(不按帧走的sytem,就是按Fixed time走的).
之后就默默被丢弃.如果system一直在运行,那么捕获事件的概率就很高了.
所以指定system的<code>运行条件</code>要非常注意,一不小心就会错过事件.
当然也可以手动清除事件,只是如果忘了清理就会造成内存泄漏.</p>
<p><code>EventWriter&lt;T&gt;</code>参数是一个mut的语法糖,用于将事件添加到事件队列;
<code>EventReader&lt;T&gt;</code>参数虽然不会修改事件队列,但会更新接收事件的数量,所以同样使用了mut.</p>
<p><code>Event&lt;T&gt;</code>内部使用<code>Vec</code>实现的,发送事件就是push,效率很高,比<code>变更检测</code>的效率还高.</p>
<h2 id="possible-pitfalls"><a class="header" href="#possible-pitfalls">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the
receiving system before the sending system. The receiving system will only
get a chance to receive the events the next time it runs. If you need to
ensure that events are handled on the same frame, you can use <a href="programming//programming/system-order.html">explicit
system ordering</a>.</p>
<p>If your systems have <a href="programming//programming/run-criteria.html">run conditions</a>, beware that they might miss
some events when they are not running! If your system does not check for events
at least once every other frame or <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a>, the
events will be lost.</p>
<p>If you want events to persist for longer than that, you can <a href="programming//patterns/manual-event-clear.html">implement a
custom cleanup/management strategy</a>. However, you can
only do this for your own event types. There is no solution for Bevy's
<a href="programming//builtins.html#events">built-in</a> types.</p>
<p>可能的失败.</p>
<p>注意部分场景下是有1帧的滞后的. eg:bevy先执行了接收system再执行发送system.
如果要确保在同帧中处理事件,那需要显示指定system的执行顺序.</p>
<p>使用条件运行的system,有可能会丢失事件.</p>
<p>如果想事件持久一些,可以自己实现事件清理策略,但这种方式只能用于自定事件,
bevy内置的事件无法修改清理策略.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/app/plugin.rs"><code>plugin</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/app/plugin_group.rs"><code>plugin_group</code></a>.</p>
<hr />
<p>As your project grows, it can be useful to make it more modular. You can
split it into "plugins".</p>
<p>Plugins are simply collections of things to be added to the <a href="programming//programming/app-builder.html">App
Builder</a>. Think of this as a way to add things to the app from
multiple places, like different Rust files/modules or crates.</p>
<p>The simplest way to create a plugin is by just writing a Rust function
that takes <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>&amp;mut App</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn my_plugin(app: &amp;mut App) {
    app.init_resource::&lt;MyCustomResource&gt;();
    app.add_systems(Update, (
        do_some_things,
        do_other_things,
    ));
}</code></pre>
<p>An alternative way is by creating a <code>struct</code> and implementing the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/trait.Plugin.html"><code>Plugin</code></a> trait:</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.init_resource::&lt;MyOtherResource&gt;();
        app.add_event::&lt;MyEvent&gt;();
        app.add_systems(Startup, plugin_init);
        app.add_systems(Update, my_system);
    }
}</code></pre>
<p>The benefit of using a <code>struct</code> is that you could extend it with configuration
parameters or generics if you want to make your plugin configurable.</p>
<p>Either way, you get <code>&amp;mut</code> access to the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a>, so you can add whatever
you want to it, just like you can do from your <code>fn main()</code>.</p>
<p>You can now add your plugins to your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> from elsewhere (most commonly
<code>fn main()</code>). Bevy will just call your plugin implementation above. In effect,
everything the plugin adds will be flattened into your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> alongside
everything that is already there.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins((
            my_plugin, // the `fn`-based plugin
            MyPlugin,  // the `struct`-based plugin
        ))
        .run();
}</code></pre>
<p>For internal organization in your own project, the main value of plugins
comes from not having to declare all your Rust types and functions as
<code>pub</code>, just so they can be accessible from <code>fn main</code> to be added to the
app builder. Plugins let you add things to your <a href="programming//programming/app-builder.html">app</a> from multiple
different places, like separate Rust files / modules.</p>
<p>You can decide how plugins fit into the architecture of your game.</p>
<p>Some suggestions:</p>
<ul>
<li>Create plugins for different <a href="programming//programming/states.html">states</a>.</li>
<li>Create plugins for various sub-systems, like physics or input handling.</li>
</ul>
<p>随着项目的增长,需要考虑模块化,此时需要用到<code>插件</code>,将部分逻辑拆分到插件中.
最简单的插件实现就是一个函数.其次是用结构体实现<code>Plugin</code>特性.</p>
<p>为了追求灵活性,struct实现的插件,可以接受一些配置参数.
之前很多篇幅中都有使用到这点,eg:设置背景色,默认插件列表中有大部分都是可配置插件.</p>
<p>虽然在任何地方都可以在app中添加插件,不过在main中处理这些是主流方案.
在组织项目时,插件的主要值的类型需要用pub声明.</p>
<p>下面是使用插件的建议:</p>
<ul>
<li>不同状态使用不同的插件</li>
<li>不同的子system使用不同插件,eg:输入/物理部分</li>
</ul>
<h2 id="plugin-groups"><a class="header" href="#plugin-groups">Plugin Groups</a></h2>
<p>Plugin groups register multiple plugins at once.  Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a>
and <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> are examples of this.</p>
<p>To create your own plugin group, implement the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/trait.PluginGroup.html"><code>PluginGroup</code></a> trait:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::PluginGroupBuilder;

struct MyPluginGroup;

impl PluginGroup for MyPluginGroup {
    fn build(self) -&gt; PluginGroupBuilder {
        PluginGroupBuilder::start::&lt;Self&gt;()
            .add(FooPlugin)
            .add(BarPlugin)
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MyPluginGroup)
        .run();
}</code></pre>
<p>When adding a plugin group to the <a href="programming//programming/app-builder.html">app</a>, you can disable some
plugins while keeping the rest.</p>
<p>For example, if you want to manually set up logging (with your own <code>tracing</code>
subscriber), you can disable Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>:</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins(
        DefaultPlugins.build()
            .disable::&lt;bevy::log::LogPlugin&gt;()
    )
    .run();</code></pre>
<p>Note that this simply disables the functionality, but it cannot actually
remove the code to avoid binary bloat. The disabled plugins still have to
be compiled into your program.</p>
<p>If you want to slim down your build, you should look at disabling Bevy's
default <a href="programming//setup/bevy-config.html">cargo features</a>, or depending on the various Bevy
sub-crates individually.</p>
<p>插件组,一次性注册多个插件.方便不同场景下使用,免得每新建一个项目就需要注册很多插件,
这是用户友好的表现,bevy内置了两个常用的插件组:DefaultPlugins/MinimalPlugins.</p>
<p>如果要实现自己的插件组,只需要实现PluginGroup特型即可.这应该是一个比较常用的功能.
在app处添加插件组时还能disable部分插件(这种方式只是屏蔽了特定的插件,
不能减少二进制大小).</p>
<p>如果实在要减少二进制大小,需要在cargo功能处做disable,或者将子包独立,从依赖出着手.</p>
<h2 id="plugin-configuration"><a class="header" href="#plugin-configuration">Plugin Configuration</a></h2>
<p>Plugins are also a convenient place to store settings/configuration that are
used during initialization/startup. For settings that can be changed at runtime,
it is recommended that you put them in <a href="programming//programming/res.html">resources</a> instead.</p>
<pre><code class="language-rust no_run noplayground">struct MyGameplayPlugin {
    /// Should we enable dev hacks?
    enable_dev_hacks: bool,
}

impl Plugin for MyGameplayPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // add our gameplay systems
        app.add_systems(Update, (
            health_system,
            movement_system,
        ));
        // ...

        // if "dev mode" is enabled, add some hacks
        if self.enable_dev_hacks {
            app.add_systems(Update, (
                player_invincibility,
                free_camera,
            ));
        }
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MyGameplayPlugin {
            // change to true for dev testing builds
            enable_dev_hacks: false,
        })
        .run();
}</code></pre>
<p>Plugins that are added using <a href="programming//programming/plugins.html#plugin-groups">Plugin Groups</a> can also be
configured. Many of Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> work this way.</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::WindowResolution;

App::new()
    .add_plugins(DefaultPlugins.set(
        // here we configure the main window
        WindowPlugin {
            primary_window: Some(Window {
                resolution: WindowResolution::new(800.0, 600.0),
                // ...
                ..Default::default()
            }),
            ..Default::default()
        }
    ))
    .run();</code></pre>
<p>插件在初始化或启动时可以配置(struct插件才行,这也是大部分插件的选择).
运行时也可以修改,不过推荐将配置放在资源中(这种场景应该非常少见).</p>
<p>ps:bevy还是有点理想主义的,各个包和机制都设计得非常灵活,但实际场景下,
绝大部分只使用到了其中几条,这点在bevy的很多地方都都体现了:eg:这儿+ecs.</p>
<h2 id="publishing-crates"><a class="header" href="#publishing-crates">Publishing Crates</a></h2>
<p>Plugins give you a nice way to publish Bevy-based libraries for other people
to easily include into their projects.</p>
<p>Bevy offers some official guidance for good practices when you develop plugins
you want to publish for other people to use. <a href="https://bevyengine.org/learn/book/plugin-development/">You can read it here.</a></p>
<p>Don't forget to submit an entry to <a href="https://bevyengine.org/assets">Bevy Assets</a> on the official
website, so that people can find your plugin more easily. You can do this
by making a PR in <a href="https://github.com/bevyengine/bevy-assets">the Github repo</a>.</p>
<p>If you are interested in supporting bleeding-edge Bevy (main), <a href="programming//setup/bevy-git.html#advice-for-plugin-authors">see here
for advice</a>.</p>
<p>插件作为模块化分割了逻辑,就能分享给他人.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="local-resources"><a class="header" href="#local-resources">Local Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Local resources allow you to have per-<a href="programming//programming/systems.html">system</a> data. This data
is not stored in the ECS World, but rather together with your system.
Nothing outside of your system can access it. The value will be kept across
subsequent runs of the system.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is a system parameter similar to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, which gives
you full mutable access to a single value of the given data type, that is
independent from entities and components.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a> refer to a single global instance of the type, shared
between all systems. On the other hand, every <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> parameter is a
separate instance, exclusively for that system.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyState {
    // ...
}

fn my_system1(mut local: Local&lt;MyState&gt;) {
    // you can do anything you want with the local here
}

fn my_system2(mut local: Local&lt;MyState&gt;) {
    // the local in this system is a different instance
}</code></pre>
<p>The type must implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> or <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a>. It is automatically
initialized. It is not possible to specify a custom initial value.</p>
<p>A system can have multiple <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local</code></a>s of the same type.</p>
<p>local资源,可以存储每帧的system数据,资源不属于ecs世界,而是跟着system走的.
这个数据只有system才能访问.</p>
<p><code>Local&lt;T&gt;</code>是一个system参数,类似于<code>ResMut&lt;T&gt;</code>,通过这个参数可以访问指定类型的数据,
听到这儿,感觉local resource和普通的资源没什么差别.
差别在于资源是所有system都可以访问的,local资源只能被特定的system访问.</p>
<p>local类型需要实现Default或FromWorld特性,初始化是自动的,不能指定自定义值.</p>
<p>一个system可以拥有多个local参数,而且这些local参数可以是同一个类型的.</p>
<h2 id="specify-an-initial-value"><a class="header" href="#specify-an-initial-value">Specify an initial value</a></h2>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is always automatically initialized using the default value for
the type. If that doesn't work for you, there is an alternative way to pass
data into a system.</p>
<p>If you need specific data, you can use a closure instead. Rust closures that
take system parameters are valid Bevy systems, just like standalone functions.
Using a closure allows you to "move data into the function".</p>
<p>This example shows how to initialize some data to configure a system, without
using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyConfig {
    magic: usize,
}

fn my_system(
    mut cmd: Commands,
    my_res: Res&lt;MyStuff&gt;,
    // note this isn't a valid system parameter
    config: &amp;MyConfig,
) {
    // TODO: do stuff
}

fn main() {
    let config = MyConfig {
        magic: 420,
    };

    App::new()
        .add_plugins(DefaultPlugins)

        // create a "move closure", so we can use the `config`
        // variable that we created above

        // Note: we specify the regular system parameters we need.
        // The closure needs to be a valid Bevy system.
        .add_systems(Update, move |cmd: Commands, res: Res&lt;MyStuff&gt;| {
            // call our function from inside the closure,
            // passing in the system params + our custom value
            my_system(cmd, res, &amp;config);
        })
        .run();
}</code></pre>
<p>Another way to accomplish the same thing is to "return" the system from
"constructor" helper function that creates it:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyConfig {
    magic: usize,
}

// create a "constructor" function, which can initialize
// our data and move it into a closure that Bevy can run as a system
fn my_system_constructor() -&gt; impl FnMut(Commands, Res&lt;MyStuff&gt;) {
    // create the `MyConfig`
    let config = MyConfig {
        magic: 420,
    };

    // this is the actual system that bevy will run
    move |mut commands, res| {
        // we can use `config` here, the value from above will be "moved in"
        // we can also use our system params: `commands`, `res`
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // note the parentheses `()`
        // we are calling the "constructor" we made above,
        // which will return the actual system that gets added to bevy
        .add_systems(Update, my_system_constructor())

        .run();
}</code></pre>
<p>local参数初始化是使用默认值,不能指定自定义值,但bevy还是提供了其他方法来实现.</p>
<p>不使用<code>Local&lt;T&gt;</code>,改为闭包.</p>
<p>利用闭包捕获局部变量,而闭包的是实现就是一个普通system的实现,但在函数内部,
可以使用捕获的局部变量,而局部变量的值是可以自定义的,变相达到了自定义初始化值.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="exclusive-systems-1"><a class="header" href="#exclusive-systems-1">Exclusive Systems</a></h1>
<p>Exclusive systems are <a href="programming//programming/systems.html">systems</a> that Bevy will not run in parallel
with any other system. They can have <a href="programming//programming/world.html">full unrestricted access</a>
to the whole ECS <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>, by taking a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;mut World</code></a> parameter.</p>
<p>Inside of an exclusive system, you have full control over all data stored
in the ECS. You can do whatever you want.</p>
<p>Some example situations where exclusive systems are useful:</p>
<ul>
<li>Dump various entities and components to a file, to implement things like
saving and loading of game save files, or scene export from an editor</li>
<li>Directly spawn/despawn <a href="programming//programming/intro-data.html#entities--components">entities</a>, or insert/remove <a href="programming//programming/res.html">resources</a>,
immediately with no delay (unlike when using <a href="programming//programming/commands.html">Commands</a>
from a regular system)</li>
<li>Run arbitrary <a href="programming//programming/systems.html">systems</a> and <a href="programming//programming/schedules.html">schedules</a> with your
own custom control flow logic</li>
<li>…</li>
</ul>
<p>See the <a href="programming//programming/world.html">direct World access page</a> to learn more about how to do
such things.</p>
<pre><code class="language-rust no_run noplayground">fn do_crazy_things(world: &amp;mut World) {
    // we can do anything with any data in the Bevy ECS here!
}</code></pre>
<p>You need to add exclusive systems to the <a href="programming//programming/app-builder.html">App</a>, just like
regular systems. All scheduling APIs (<a href="programming//programming/system-order.html">ordering</a>, <a href="programming//programming/run-criteria.html">run
conditions</a>, <a href="programming//programming/system-sets.html">sets</a>) are supported and work the same
as with regular systems.</p>
<pre><code class="language-rust no_run noplayground">    app.add_systems(
        Update,
        do_crazy_things
            .run_if(needs_crazy_things)
            .after(do_regular_things)
            .before(other_things),
    );</code></pre>
<p>独占system也是system,只不过不和其他system并行处理,正是因为这点,
独占system比普通system多了一个使用场景:无限制访问world.
而使用独占system主要是为了无限制访问world,不然使用普通system得了.</p>
<p>无限制访问world,意味着可以访问整个ECS,下面是独占system的几个常用使用场景:</p>
<ul>
<li>dump ECS到一个文件,游戏的保存和加载,从编辑器导出场景</li>
<li>直接增删实体,增删资源,这是立马生效的(Commands也能做到,只不过是延时的)</li>
<li>执行任意system/调度</li>
</ul>
<p>在app中添加独占system的方式和处理普通system的方式是一样的,
bevy内部会识别system参数,来标识独占system.
事情都是bevy做的,用户友好.</p>
<h2 id="exclusive-system-parameters"><a class="header" href="#exclusive-system-parameters">Exclusive System Parameters</a></h2>
<p>There are a few other things, besides <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;mut World</code></a>, that can be used as
parameters for exclusive systems:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;mut World</code></a>:
Full <a href="programming//programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="programming//programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>&amp;mut SystemState&lt;P&gt;</code></a>:
Emulates a regular system, allowing you to easily access data from the World.
<code>P</code> are the system parameters.</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/query/struct.QueryState.html"><code>&amp;mut QueryState&lt;Q, F = ()&gt;</code></a>:
Allows you to perform queries on the World, similar to a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Query.html"><code>Query</code></a> in regular systems.</li>
</ul>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> can be used to emulate a normal system.  You can put regular
system parameters inside. This allows you to access the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a> as you would
from a normal system, but you can confine it to a specific scope inside your
function body, making it more flexible.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/query/struct.QueryState.html"><code>QueryState</code></a> is the same thing, but for a single query.  It is a simpler
alternative to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> for when you just need to be able to query for
some data.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::system::SystemState;

fn spawn_particles_for_enemies(
    world: &amp;mut World,
    // behaves sort of like a query in a regular system
    q_enemies: &amp;mut QueryState&lt;&amp;Transform, With&lt;Enemy&gt;&gt;,
    // emulates a regular system with an arbitrary set of parameters
    params: &amp;mut SystemState&lt;(
        ResMut&lt;MyGameSettings&gt;,
        ResMut&lt;MyParticleTracker&gt;,
        Query&lt;&amp;mut Transform, With&lt;Player&gt;&gt;,
        EventReader&lt;MyDamageEvent&gt;,
        // yes, even Commands ;)
        Commands,
    )&gt;,
    // local resource, just like in a regular system
    mut has_run_once: Local&lt;bool&gt;,
) {
    // note: unlike with a regular Query, we need to provide the world as an argument.
    // The world will only be "locked" for the duration of this loop
    for transform in q_enemies.iter(world) { // 和普通system.query差别不大
         // TODO: do something with the transforms
    }

    // create a scope where we can access our things like a regular system
    {
        // 这个作用域限制了变量的范围,这样灵活性更高一点.
        let (mut settings, mut tracker, mut q_player, mut evr, commands) = params.get_mut(world);

        // TODO: do things with our resources, query, events, commands, ...
    }

    // because our SystemState includes Commands,
    // we must apply them when we are done
    params.apply(world);

    // we are now free to directly spawn entities
    // because the World is no longer used by anything
    // (the SystemState and the QueryState are no longer accessing it)

    world.spawn_batch(
        (0..10000) // efficiently spawn 10000 particles
            .map(|_| SpriteBundle {
                // ...
                ..Default::default()
            }),
    );

    // and, of course, we can use our Local
    *has_run_once = true;
}</code></pre>
<p>Note: if your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> includes <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, you must call <code>.apply()</code>
after you are done! That is when the deferred operations queued via
<a href="programming//programming/commands.html">commands</a> will be applied to the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>独占system的参数,出了<code>&amp;mut world</code>,还有以下几种:</p>
<ul>
<li><code>Local&lt;T&gt;</code></li>
<li><code>&amp;mut SystemState&lt;P&gt;</code>,模拟一个普通system,简化world的访问</li>
<li><code>&amp;mut QueryState&lt;Q, F= ()&gt;</code> QueryState: 从world执行查询,类似普通system的Query</li>
</ul>
<p>从下面的SystemState泛型类型的定义来看,具体参数是system参数,
SystemState本身也实现了SystemParam特性,也是一个system参数,
所以说SystemState是对普通system参数的一层封装.
因为SystemState能访问所有ECS数据,在使用时只需要限制在特定范围就能得到最大灵活性.</p>
<p>如果SystemState包含了Commands,需要调用apply来让其生效.
SystemState对应普通system的参数;QueryState对应普通system的query,搭配使用.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SystemState&lt;Param: SystemParam + 'static&gt; {
    meta: SystemMeta,
    param_state: Param::State,
    world_id: WorldId,
    archetype_generation: ArchetypeGeneration,
}

impl&lt;Param: SystemParam&gt; SystemState&lt;Param&gt; {...}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>Exclusive systems, by definition, limit parallelism and multi-threading, as
nothing else can access the same ECS World while they run. The whole schedule
needs to come to a stop, to accomodate the exclusive system. This can easily
introduce a performance bottleneck.</p>
<p>Generally speaking, you should avoid using exclusive systems, unless you need
to do something that is only possible with them.</p>
<p>On the other hand, if your alternative is to use <a href="programming//programming/commands.html">commands</a>,
and you need to process a huge number of entities, exclusive systems are faster.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> is effectively just a way to ask Bevy do to exclusive <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>
access for you, at a later time. Going through the commands queue is much
slower than just doing the exclusive access yourself.</p>
<p>Some examples for when exclusive systems can be faster:</p>
<ul>
<li>You want to spawn/despawn a ton of entities.
<ul>
<li>Example: Setup/cleanup for your whole game map.</li>
</ul>
</li>
<li>You want to do it every frame.
<ul>
<li>Example: Managing hordes of enemies.</li>
</ul>
</li>
</ul>
<p>Some examples for when normal systems with <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> can be faster:</p>
<ul>
<li>You need to check some stuff every frame, but only use <a href="programming//programming/commands.html">commands</a> sometimes.
<ul>
<li>Example: Despawn enemies when they reach 0 HP.</li>
<li>Example: Spawn/despawn entities when <a href="programming//fundamentals/time.html#timer">timers</a> finish.</li>
<li>Example: Add/remove some UI elements depending on what is happening in-game.</li>
</ul>
</li>
</ul>
<p>独占system,运行时不能并行执行,效率肯定有很大的影响,性能瓶颈一般出在这儿,
在游戏中要尽量避免使用独占system.</p>
<p>如果要对大量实体进行处理,使用Commands延时处理,此是性能不一定比独占system效率高,
矮个子里拔高个,两权相害取其轻.</p>
<p>Commands时延时执行,里面涉及队列,如果实体数量大了,性能就差了.</p>
<p>以下场景独占system会更快:</p>
<ul>
<li>实体的构造和销毁,游戏启动或结束清理时</li>
<li>每帧都执行的,eg:管理大量敌人</li>
</ul>
<p>以下场景是Commands更快:</p>
<ul>
<li>每帧都需要检查一些东西,Commands只是时不时用到</li>
</ul>
<p>eg: 敌人没hp了,就要销毁实体;定时器到了需要构造/销毁实体;依据游戏逻辑增删UI元素.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="direct-world-access"><a class="header" href="#direct-world-access">Direct World Access</a></h1>
<p>(This page is WIP)</p>
<hr />
<p>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.World.html"><code>World</code></a> is where Bevy ECS stores all data and associated metadata. It
keeps track of <a href="programming//programming/res.html">resources</a>, <a href="programming//programming/intro-data.html#entities--components">entities and components</a>.</p>
<p>Typically, the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.App.html"><code>App</code></a>'s runner will run all <a href="programming//programming/schedules.html">schedules</a> (which,
in turn, run their <a href="programming//programming/systems.html">systems</a>) on the main world. Regular
<a href="programming//programming/systems.html">systems</a> are limited in what data they can access from the world,
by their <a href="programming//builtins.html#systemparams">system parameter types</a>.  Operations that
manipulate the world itself are only done indirectly using
<a href="programming//programming/commands.html"><code>Commands</code></a>. This is how most typical Bevy user code behaves.</p>
<p>However, there are also ways you can get full direct access to the world, which
gives you full control and freedom to do anything with any data stored in the
Bevy ECS:</p>
<ul>
<li><a href="programming//programming/exclusive.html">Exclusive systems</a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impls</li>
<li>Via the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.App.html"><code>App</code></a> <a href="programming//programming/app-builder.html">builder</a></li>
<li>Manually created <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.World.html"><code>World</code></a>s for purposes like <a href="programming//patterns/system-tests.html">tests</a> or scenes</li>
<li><a href="programming//programming/commands.html#custom-commands">Custom Commands</a></li>
</ul>
<p>Direct world access lets you do things like:</p>
<ul>
<li>Freely spawn/despawn entities, insert/remove resources, etc., taking effect immediately
(no delay like when using <a href="programming//programming/commands.html"><code>Commands</code></a> from a regular <a href="programming//programming/systems.html">system</a>)</li>
<li>Access any component, entities, and resources you want</li>
<li>Manually run arbitrary systems or schedules</li>
</ul>
<p>This is especially useful if you want to do things that do not fit within
Bevy's typical execution model/flow of just running systems once every frame.</p>
<p>With direct world access, you can implement custom control flow, like
looping some systems multiple times, selecting different systems to run in
different circumstances, exporting/importing data from files like scenes or
game saves, …</p>
<p>bevy将ECS的数据存储在world中,包括:资源/实体/组件.</p>
<p>通常app的所有调度都跑在主world中,普通system通过system参数类型跑在指定world中,
大部分代码都是通过Commands间接维护world.</p>
<p>直接维护world的几种途径如下:</p>
<ul>
<li>独占system</li>
<li>FromWorld的实现</li>
<li>app</li>
<li>为特殊目的手动创建的world(eg:测试/场景)</li>
<li>自定义Commands</li>
</ul>
<p>直接访问world可以做以下几种事:</p>
<ul>
<li>自由的构造/销毁实体;自由的增删资源等,都是立马生效</li>
<li>访问任意组件/实体/资源</li>
<li>手动执行任意system/调度</li>
</ul>
<p>如果在每帧的执行调度上,bevy内置的调度机制不满足需求,那么直接访问world是一种选择.</p>
<p>直接访问world意味着可以实现自定义逻辑流,eg:循环system多次,
不同的环境选择不同的system,游戏或场景的导入/导出.</p>
<h2 id="working-with-the-world"><a class="header" href="#working-with-the-world">Working with the <code>World</code></a></h2>
<p>Here are some ways that you can make use of the direct world access APIs.</p>
<h3 id="systemstate"><a class="header" href="#systemstate"><code>SystemState</code></a></h3>
<p>The easiest way to do things is using a <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>.</p>
<p>This is a type that "imitates a system", behaving the same way as a
<a href="programming//programming/systems.html">system</a> with various parameters would. All the same behaviors like
<a href="programming//programming/queries.html">queries</a>, <a href="programming//programming/change-detection.html">change detection</a>, and even
<a href="programming//programming/commands.html"><code>Commands</code></a> are available. You can use any <a href="programming//builtins.html#systemparams">system
params</a>.</p>
<p>It also tracks any persistent state, used for things like <a href="programming//programming/change-detection.html">change
detection</a> or caching to improve performance. Therefore,
if you plan on reusing the same <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> multiple times, you should store
it somewhere, rather than creating a new one every time. Every time you call
<code>.get(world)</code>, it behaves like another "run" of a system.</p>
<p>If you are using <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, you can choose when you want to apply them to the
world. You need to manually call <code>.apply(world)</code> on the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>, to
apply them.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<p>访问world最常见的手法是<code>SystemState</code>,用法和普通的system类似,能实现的功能也类似.</p>
<p>可以跟踪持久化的状态,这点可用于<code>变更检测</code>或缓存(提高性能).
如果要多次重用同一SystemState,就应该考虑持久化,避免每次执行都生成一个新的.</p>
<h3 id="running-a-system"><a class="header" href="#running-a-system">Running a System</a></h3>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<h3 id="running-a-schedule"><a class="header" href="#running-a-schedule">Running a Schedule</a></h3>
<p>If you want to run many systems (a common use-case is
<a href="programming//patterns/system-tests.html">testing</a>), the easiest way is to construct an impromptu
<a href="programming//programming/schedules.html">schedule</a>. This way you reuse all the scheduling logic that Bevy
normally does when running systems. They will run with multithreading, etc.</p>
<p>This is also useful if you want custom control flow. For example, Bevy's
<a href="programming//programming/states.html">states</a> and <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> abstractions
are implemented just like this! There is an exclusive system that can contain
loops, if/else branching, etc. to implement fancy algorithms and run entire
schedules of systems as appropriate!</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<p>如果要运行多个system(eg:测试用例),最简单的方式是构造一个调度,其他地方能重用.</p>
<p>若要实现自定义控制流,调度也是非常有用的,bevy的固定时间戳就是这样实现的.</p>
<h3 id="navigating-by-metadata"><a class="header" href="#navigating-by-metadata">Navigating by Metadata</a></h3>
<p>The world contains a lot of metadata that allows navigating all the data
efficiently, such as information about all the stored components, entities,
archeypes.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<p>world包含了很多元数据,这个元数据之间有关联,可以方便做到导航,
eg:存储所有实体/组件/原型的信息.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="schedules-2"><a class="header" href="#schedules-2">Schedules</a></h1>
<p>See also: <a href="programming//programming/intro-code.html">ECS Intro: Your Code</a>, for a general overview
of Bevy's scheduling framework.</p>
<hr />
<p>All <a href="programming//programming/systems.html">systems</a> to be run by Bevy are contained and organized using
schedules. A schedule is a collection of systems, with metadata for how they
should run, and an associated executor algorithm to run the systems.</p>
<p>A Bevy app has many different schedules for different purposes, to run them
in different situations.</p>
<p>bevy运行的system是放在容器中的(调度schedule),也是由调度组织的.
调度还包含system的元数据(运行条件/顺序约束,system集合).</p>
<h2 id="scheduling-systems"><a class="header" href="#scheduling-systems">Scheduling Systems</a></h2>
<p>If you want a <a href="programming//programming/systems.html">system</a> to be run by Bevy, you need to add it to a
schedule via the <a href="programming//programming/app-builder.html">app builder</a>. Writing a new Rust function and
forgetting to add it / register it with Bevy is a common mistake.</p>
<p>Whenever you add a system, you specify what schedule to put it in:</p>
<pre><code class="language-rust no_run noplayground">// add something to the Update schedule (runs every frame)
app.add_systems(Update, camera_movement);

// add something to the Startup schedule (runs once at app startup)
app.add_systems(Startup, setup_camera);</code></pre>
<p>app添加system都是将system丢到某个调度中,如果忘了就会出现system无效果的现象.</p>
<h3 id="per-system-configuration"><a class="header" href="#per-system-configuration">Per-System Configuration</a></h3>
<p>You can add metadata to your systems, to affect how they will be run.</p>
<p>This can include:</p>
<ul>
<li><a href="programming//programming/run-criteria.html">Run Conditions</a> to control if a system should run</li>
<li><a href="programming//programming/system-order.html">Ordering Dependencies</a>, if a system should run before/after specific other systems in the same schedule</li>
<li><a href="programming//programming/system-sets.html">System Sets</a> to group systems together, so common configuration can be applied to all of them</li>
</ul>
<p>When the schedule runs, the executor algorithm will honor all of this
configuration when determining if a system is ready to run. A system is ready
when all of the following is true:</p>
<ul>
<li>No other currently-running system is accessing any of the same data mutably (as per the <a href="programming//builtins.html#systemparams">system parameters</a>)</li>
<li>All of the systems <a href="programming//programming/system-order.html">ordered</a> "before" have finished or have been skipped due to run conditions</li>
<li>The system's <a href="programming//programming/run-criteria.html">run conditions</a> all return true</li>
</ul>
<p>When a system becomes ready, it will be run on an available CPU thread. Systems
run in a non-deterministic order by default! A system might run at different
times every frame. If you care about its relationship to other systems, add
<a href="programming//programming/system-order.html">ordering dependencies</a>.</p>
<p>每个system都可以进行配置,包括(运行条件/顺序约束/system集合).
其中system集合是system组,一些通用配置都可以应用到组内每个system.</p>
<p>bevy执行一个system的前提条件:</p>
<ul>
<li>system覆盖的mut数据,没有依赖同样数据的system正在运行</li>
<li>before顺序的system都运行完了或因为运行条件跳过了</li>
<li>运行条件为true</li>
</ul>
<p>并行执行的system的之间的顺序不是确定的,每帧都可能不一样.</p>
<h3 id="dynamically-addingremoving-systems"><a class="header" href="#dynamically-addingremoving-systems">Dynamically Adding/Removing Systems</a></h3>
<p>Bevy's schedules do not (yet?) support adding and removing systems at runtime.
You need to configure everything ahead of time.</p>
<p>You should add all systems you might want to run, and then control them using
<a href="programming//programming/run-criteria.html">run conditions</a>. That is the mechanism for disabling them if they
shouldn't run.</p>
<p>system的动态增删,目前还不支持.</p>
<h2 id="bevys-app-structure"><a class="header" href="#bevys-app-structure">Bevy's App Structure</a></h2>
<p>Bevy has three primary/foundational schedules: <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a>.
There are also other schedules, which are managed and run within <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>.</p>
<p>In a normal Bevy app, the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>+<a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a>+<a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a> schedules are run repeatedly
in a loop. Together, they produce one frame of your game. Every time <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>
runs, it runs a sequence of other schedules. On its first run, it also first
runs a sequence of "startup" schedules.</p>
<p>Most Bevy users only have to deal with the sub-schedules of <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>.
<a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a> are only relevant to graphics developers who want to
develop new/custom rendering features for the engine. This page is only focused
on <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>. If you want to learn more about <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a>, <a href="programming//gpu/intro.html">see
this page about Bevy's rendering architecture</a>.</p>
<p>bevy的三个基础调度:Main/Extract/Render,分别是主调度/外部调度/渲染调度.
外部调度负责将world数据拷贝到渲染调度中.渲染调度和下帧的主调度并行执行.</p>
<p>大部分游戏只需要在Main调度中添加system逻辑即可.</p>
<h2 id="the-main-schedule"><a class="header" href="#the-main-schedule">The Main Schedule</a></h2>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> is where all the application logic runs. It is a sort of meta-schedule,
whose job is to run other schedules in a specific order. You should not add any
custom systems directly to <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>. You should add your systems to the various
schedules managed by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>.</p>
<p>Bevy provides the following schedules, to organize all the systems:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.First.html"><code>First</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.RunFixedMainLoop.html"><code>RunFixedMainLoop</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Last.html"><code>Last</code></a>
<ul>
<li>These schedules are run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> every time it runs</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreStartup.html"><code>PreStartup</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Startup.html"><code>Startup</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostStartup.html"><code>PostStartup</code></a>
<ul>
<li>These schedules are run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> once, the first time it runs</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a>
<ul>
<li>The <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> equivalent of the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> schedule.</li>
<li>Run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.RunFixedMainLoop.html"><code>RunFixedMainLoop</code></a> as many times as needed, to catch up to the fixed timestep interval.</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedFirst.html"><code>FixedFirst</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPreUpdate.html"><code>FixedPreUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPostUpdate.html"><code>FixedPostUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedLast.html"><code>FixedLast</code></a>
<ul>
<li>The <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> equivalents of the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> sub-schedules.</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter(…)</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit(…)</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition(…)</code></a>
<ul>
<li>These schedules are run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a> on <a href="programming//programming/states.html">state</a> changes</li>
</ul>
</li>
</ul>
<p>The intended places for most user systems (your game logic) are <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>,
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Startup.html"><code>Startup</code></a>, and the <a href="programming//programming/states.html">state</a> transition schedules.</p>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> is for your usual game logic that should run every frame. <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Startup.html"><code>Startup</code></a> is
useful to perform initialization tasks, before the first normal frame update
loop. <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> is if you want to use a <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<p>The other schedules are intended for engine-internal functionality. Splitting
them like that ensures that Bevy's internal engine systems will run correctly
with respect to your systems, without any configuration on your part.
Remember: Bevy's internals are implemented using ordinary systems
and ECS, just like your own stuff!</p>
<p>If you are developing plugins to be used by other people, you might be
interested in adding functionality to <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> (or the <code>Fixed</code>
equivalents), so it can run alongside other "engine systems". Also consider
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreStartup.html"><code>PreStartup</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostStartup.html"><code>PostStartup</code></a> if you have startup systems that should be
separated from your users' startup systems.</p>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.First.html"><code>First</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Last.html"><code>Last</code></a> exist only for special edge cases, if you really need to
ensure something runs before/after <em>everything</em> else, including all the normal
"engine-internal" code.</p>
<p>Main调度是入口,会管理其他调度,我们添加的system只能添加到其管理的调度中.
调度顺序和组织方式可以参看(0),都是一样的内容.</p>
<p>Startup做初始化,Update做每帧逻辑,FixedUpdate适合自定义间隔的逻辑.</p>
<p>其他调度是引擎内部的功能,bevy维护,我们不需要配置,
bevy在实现内部调度时,用的是ECS+system的顺序约束,我们自定义逻辑也是这个套路.</p>
<p>如果要开发插件,PreUpdate/PostUpdate就能用上了.</p>
<p>First/Last就是特殊场景下才使用,eg:在Update之前/之后要确保某个对象的状态.
引擎内部的代码就用到了这两个调度.</p>
<h2 id="configuring-schedules"><a class="header" href="#configuring-schedules">Configuring Schedules</a></h2>
<p>Bevy also offers some features that can be configured at the schedule level.</p>
<h3 id="single-threaded-schedules"><a class="header" href="#single-threaded-schedules">Single-Threaded Schedules</a></h3>
<p>If you consider multi-threading to not be working well for you, for whatever reason,
you can disable it per-schedule.</p>
<p>In a single-threaded schedule, systems will run one at a time, on the main
thread.  However, the same "readiness" algorithm is still applied and so
systems can run in an undefined order. You should still specify <a href="programming//programming/system-order.html">ordering
dependencies</a> where you need determinism.</p>
<pre><code class="language-rust no_run noplayground">// Make FixedUpdate run single-threaded
app.edit_schedule(FixedUpdate, |schedule| {
    schedule.set_executor_kind(ExecutorKind::SingleThreaded);

    // or alternatively: Simple will apply Commands after every system
    schedule.set_executor_kind(ExecutorKind::Simple);
});</code></pre>
<p>如果多线程不合适,可以考虑单线程,在主线程一次只运行一个system.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExecutorKind {
    SingleThreaded, // 适合wasm.
    Simple, // 和单线程类似,只不过会在每个system执行完后立马执行延时任务(eg:Commands).
    MultiThreaded, // 带线程池的.
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ambiguity-detection"><a class="header" href="#ambiguity-detection">Ambiguity Detection</a></h3>
<p>The Ambiguity Detector is an optional Bevy feature that can help you debug issues
related to non-determinism.</p>
<pre><code class="language-rust no_run noplayground">// Enable ambiguity warnings for the Update schedule
app.edit_schedule(Update, |schedule| {
    schedule.set_build_settings(ScheduleBuildSettings {
        ambiguity_detection: LogLevel::Warn,
        ..default()
    });
});</code></pre>
<p>It will print warnings for any combination of systems where at least one of
them accesses some piece of data (<a href="programming//programming/res.html">resource</a> or
<a href="programming//programming/ec.html#components">component</a>) mutably, but the others don't have explicit
<a href="programming//programming/system-order.html">ordering dependencies</a> on that system.</p>
<p>Such situations might indicate a bug, because you don't know if the systems that
read the data would run before or after the system that mutates the data.</p>
<p>It is up to you to decide if you care about this, on a case-by-case basis.</p>
<p>二义性检查,这是一个功能开关,开启后可对不确定的执行顺序进行二义性检查,
常用在debug模式.如果有数据竞争,这个就可以很好检测出来,添加顺序约束即可.
这个检查可能会误报,因为实际上的游戏逻辑可能会确保两个system不会产生竞争.</p>
<hr />
<p>为啥rust编译器要做的事需要bevy来做,因为bevy的system调度是自定义的,
rust编译器并不能很好的发挥作用.</p>
<h3 id="deferred-application"><a class="header" href="#deferred-application">Deferred Application</a></h3>
<p>Normally, Bevy will automatically manage where <a href="programming//programming/commands.html">Commands</a>
and other deferred operations get applied. If <a href="programming//programming/systems.html">systems</a> have
<a href="programming//programming/system-order.html">ordering dependencies</a> on one another, Bevy will make
sure to apply any pending deferred operations from the first system before
the second system runs.</p>
<p>If you would like to disable this automatic behavior and manually manage
the sync points, you can do that.</p>
<pre><code class="language-rust no_run noplayground">app.edit_schedule(Update, |schedule| {
    schedule.set_build_settings(ScheduleBuildSettings {
        auto_insert_apply_deferred: false,
        ..default()
    });
});</code></pre>
<p>Now, to manually create sync points, add special [<code>apply_deferred</code>] systems
where you like them:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(
    Update,
    apply_deferred
        .after(MyGameplaySet)
        .before(MyUiSet)
);
app.add_systems(Update, (
    (
        system_a,
        apply_deferred,
        system_b,
    ).chain(),
));</code></pre>
<p>bevy会自动管理如Commands之类的延时操作,如果两个system之间有顺序依赖,
第一个system执行完后会立马执行延时操作,再执行第二个system.</p>
<p>当然也可以禁止这种自动行为,改为手动管理同步机制.
<code>auto_insert_apply_deferred = false</code>,并且使用<code>apply_deferred</code>手动管理同步机制.</p>
<h2 id="main-schedule-configuration"><a class="header" href="#main-schedule-configuration">Main Schedule Configuration</a></h2>
<p>The order of schedules to be run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> every frame is configured in the
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> <a href="programming//programming/res.html">resource</a>. For advanced use cases, if Bevy's
predefined schedules don't work for your needs, you can change it.</p>
<p>Main调度的顺序也可以修改.需要用到这种场景的应该是非常少,
但bevy还是提供了各种扩展来丰富其灵活性,理想主义又抬头了.</p>
<h3 id="creating-a-new-custom-schedule"><a class="header" href="#creating-a-new-custom-schedule">Creating a New Custom Schedule</a></h3>
<p>As an example, let's say we want to add an additional schedule, that runs every
frame (like <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>), but runs before <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<p>First, we need to create a name/label for our new schedule, by creating a Rust
type (a <code>struct</code> or <code>enum</code>) and deriving <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/trait.ScheduleLabel.html"><code>ScheduleLabel</code></a> + an assortment of
required standard Rust traits.</p>
<pre><code class="language-rust no_run noplayground">#[derive(ScheduleLabel, Debug, Clone, PartialEq, Eq, Hash)]
struct PrepareUpdate;</code></pre>
<p>Now, we can init the schedule in the <a href="programming//programming/app-builder.html">app</a>, add it to
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> to make it run every frame where we like it, and add some
systems to it!</p>
<pre><code class="language-rust no_run noplayground">// Ensure the schedule has been created
// (this is technically optional; Bevy will auto-init
// the schedule the first time it is used)
app.init_schedule(PrepareUpdate);

// Add it to the MainScheduleOrder so it runs every frame
// as part of the Main schedule. We want our PrepareUpdate
// schedule to run after StateTransition.
app.world.resource_mut::&lt;MainScheduleOrder&gt;()
    .insert_after(StateTransition, PrepareUpdate);

// Now we can add some systems to our new schedule!
app.add_systems(PrepareUpdate, (
    my_weird_custom_stuff,
));</code></pre>
<p>bevy提供的默认调度顺序大部分场合是够用了,如果不够可以新建调度,
并插到某个调度的前后.</p>
<p>Main调度顺序是存在一个资源中的,<code>MainScheduleOrder</code>,
所有调度的顺序其实是放在Vec中的,插入一个新的并不难.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MainScheduleOrder {
    pub labels: Vec&lt;Interned&lt;dyn ScheduleLabel&gt;&gt;,
    pub startup_labels: Vec&lt;Interned&lt;dyn ScheduleLabel&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="system-order-of-execution"><a class="header" href="#system-order-of-execution">System Order of Execution</a></h1>
<p>Bevy's scheduling algorithm is designed to deliver maximum performance by
running as many <a href="programming//programming/systems.html">systems</a> as possible in parallel across the
available CPU threads.</p>
<p>This is possible when the systems do not conflict over the data they need
to access. However, when a system needs to have mutable (exclusive) access
to a piece of data, other systems that need to access the same data cannot
be run at the same time. Bevy determines all of this information from the
system's function signature (the types of the parameters it takes).</p>
<p>In such situations, the order is <em>nondeterministic</em> by default. Bevy takes
no regard for when each system will run, and the order could even change
every frame!</p>
<p>system的执行顺序</p>
<p>bevy的调度算法设计的目标是最高性能,做法是让每个CPU线程都运行一个system.
如果system访问的数据不存在冲突,那么调度算法就达到了目的.
如果一个system对某个数据是可变访问时(独占),那么其他依赖此数据的system就不能并行执行,
至于system要访问哪些数据,bevy可以从函数签名中了解信息.</p>
<p>默认情况下(未指定顺序),顺序是不确定的,bevy也不会主动干预,每帧system的执行顺序都可能不同.</p>
<p>即要提高性能,又要避免数据竞争导致的性能损失,最好的方式就是明确system的执行顺序.</p>
<h2 id="explicit-system-ordering"><a class="header" href="#explicit-system-ordering">Explicit System Ordering</a></h2>
<p>If a specific system must always run before or after some other systems,
you can add ordering constraints:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
let mut app = App::new();
app.add_systems(Update, (
    enemy_movement,
    input_handling,

    player_movement
        // `player_movement` must always run before `enemy_movement`
        .before(enemy_movement)
        // `player_movement` must always run after `input_handling`
        .after(input_handling),

    // order doesn't matter for some systems:
    particle_effects,
    npc_behaviors,

    // we can apply ordering to multiple systems at once:
    (
        spawn_monsters,
        spawn_zombies,
        spawn_spiders,
    ).before(enemy_movement),

    // to run a sequence of systems in order, use `.chain()`
    // (this is just syntax sugar to automatically add
    // before/after dependencies between the systems in the tuple)
    (
        spawn_particles,
        animate_particles,
        debug_particle_statistics,
    ).chain()
));</code></pre>
<p>When you have a lot of systems that you need to configure, it can start to
get unwieldy. Consider using <a href="programming//programming/system-sets.html">system sets</a> to organize and
manage your systems.</p>
<p>显示指定system之间的顺序.
有时有很多system要配置顺序,就可以使用system集合来组织和管理.</p>
<h2 id="does-it-even-matter"><a class="header" href="#does-it-even-matter">Does it even matter?</a></h2>
<p>In many cases, you don't need to worry about this.</p>
<p>However, sometimes you need to rely on specific systems to run in a particular
order. For example:</p>
<ul>
<li>Maybe the logic you wrote in one of your systems needs any modifications
done to that data by another system to always happen first?</li>
<li>One system needs to receive <a href="programming//programming/events.html">events</a> sent by another system.</li>
<li>You are using <a href="programming//programming/change-detection.html">change detection</a>.</li>
</ul>
<p>In such situations, systems running in the wrong order typically causes
their behavior to be delayed until the next frame. In rare cases, depending
on your game logic, it may even result in more serious logic bugs!</p>
<p>It is up to you to decide if this is important.</p>
<p>With many things in typical games, such as juicy visual effects, it probably
doesn't matter if they get delayed by a frame. It might not be worthwhile
to bother with it. If you don't care, leaving the order ambiguous may also
result in better performance.</p>
<p>On the other hand, for things like handling the player input controls,
this would result in annoying lag or worse, so you should probably fix it.</p>
<p>大部分场景下都不需要关心顺序,少部分场景下才需要顺序约束:</p>
<ul>
<li>一个system修改数据,另一个system使用,且有先后顺序</li>
<li>一个system接收的事件是另一个system发出的</li>
<li>变更检测</li>
</ul>
<p>上面这些都是实际的游戏逻辑决定的,出现异常就意味着bug.</p>
<p>大部分视觉特效都不关心一帧中的延时,并发执行甚至还能提升性能.</p>
<h2 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h2>
<p>If you have multiple systems mutually depending on each other, then it is
clearly impossible to resolve the situation completely like that.</p>
<p>You should try to redesign your game to avoid such situations, or just accept
the consequences. You can at least make it behave predictably, using explicit
ordering to specify the order you prefer.</p>
<p>循环依赖.需要重新涉及游戏逻辑,或直接不管.
不过游戏开发的底线是运行结果可预测.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="run-conditions-4"><a class="header" href="#run-conditions-4">Run Conditions</a></h1>
<p>Run Conditions (RC) are a mechanism for controlling if Bevy should run specific
<a href="programming//programming/systems.html">systems</a>, at runtime. This allows you to enable/disable systems
on-demand, so that they only run sometimes.</p>
<p>RCs are Rust functions that return a value of type <code>bool</code>. They can accept
any <a href="programming//builtins.html#systemparams">system parameters</a>, like a normal system, but
they must all be read-only (immutable).</p>
<pre><code class="language-rust no_run noplayground">fn run_if_player_alive(
    q_player: Query&lt;&amp;Health, With&lt;Player&gt;&gt;,
) -&gt; bool {
    let health = q_player.single();
    health.hp &gt; 0.0
}

fn run_if_connected(
    mode: Res&lt;MyMultiplayerMode&gt;,
    session: Res&lt;MyNetworkSession&gt;,
) -&gt; bool
{
    *mode != MyMultiplayerMode::Local &amp;&amp; session.is_connected()
}

fn run_if_enemies_present(
    q_enemies: Query&lt;(), With&lt;Enemy&gt;&gt;,
) -&gt; bool {
    !q_enemies.is_empty()
}</code></pre>
<p>RCs can be applied to individual <a href="programming//programming/systems.html">systems</a> or to entire <a href="programming//programming/system-sets.html">system
sets</a>.</p>
<pre><code class="language-rust no_run noplayground">app.configure_sets(Update,
    MyPlayerSet
        .run_if(run_if_player_alive)
);

app.add_systems(Update, (
    player_input,
    player_movement,
    player_alert_enemies
        .run_if(run_if_enemies_present)
).in_set(MyPlayerSet));

app.add_systems(Update,
    manage_multiplayer_server
        .run_if(run_if_connected)
);</code></pre>
<p>When applied to a single <a href="programming//programming/systems.html">system</a>, Bevy will evaluate the RC at
the last moment, right before the system would otherwise be ready to run. If
you add the same RC to multiple systems, Bevy will evaluate it separately
for each one.</p>
<p>When applied to a <a href="programming//programming/system-sets.html">set</a>, the run condition will only be
evaluated once, before Bevy runs any system from the set, and if it returns
false, the entire set will be skipped.</p>
<p>Any given system can be governed by any number of RCs. You can add multiple RCs
to one system, and it will also inherit the RCs of any <a href="programming//programming/system-sets.html">sets</a>
it belongs to. Bevy will evaluate all the RCs, and the system will only run
if all of them return <code>true</code>.</p>
<p>运行条件,是返回bool的一个函数,入参可以是system参数(只读).</p>
<p>运行条件应用对象可以是单个system,或system集合.</p>
<p>单system有运行条件时,运行条件在system之前执行.如果多个system都有同样的运行条件,
bevy会单独计算运行条件.</p>
<p>system集合有运行条件时,运行条件只会计算一次.</p>
<p>system可以有多个运行条件,还可以从任何system集合中继承运行条件.</p>
<h2 id="common-conditions"><a class="header" href="#common-conditions">Common Conditions</a></h2>
<p>Bevy provides some built-in RCs for some common scenarios, that you can just
apply to your systems:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/common_conditions/index.html">ECS common conditions</a>:
<ul>
<li>For checking <a href="programming//programming/states.html">states</a>, <a href="programming//programming/res.html">resource</a> values and <a href="programming//programming/change-detection.html">changes</a>, <a href="programming//programming/events.html">events</a>, if <a href="programming//programming/intro-data.html">entities</a> with specific <a href="programming//programming/ec.html#components">components</a> exist, etc...</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/input/common_conditions/index.html">Input common conditions</a>:
<ul>
<li>For <a href="programming//input.html">input handling</a>: running on key/button press/release.</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/time/common_conditions/index.html">Time common conditions</a>:
<ul>
<li>For controlling systems based on <a href="programming//fundamentals/time.html">time</a>: repeating on a timer, running after a delay, etc...</li>
</ul>
</li>
</ul>
<p>bevy内置了一些常用的条件:</p>
<ul>
<li>ECS常用条件,状态,资源值(的变化),事件,实体是否包含指定组件等等</li>
<li>输入常用条件,某键是否按下/释放</li>
<li>时间常用条件,基于定时器的控制,定时器/延时到达</li>
</ul>
<h2 id="known-pitfalls-1"><a class="header" href="#known-pitfalls-1">Known Pitfalls</a></h2>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run every frame
update, you can miss some events that are sent while the receiving systems
are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<p>已知陷阱.事件接收+条件运行可能会导致遗漏事件,应对方法是自定义事件消息清理策略.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="system-sets"><a class="header" href="#system-sets">System Sets</a></h1>
<p>System Sets allow you to easily apply common properties to multiple systems,
such as <a href="programming//programming/system-order.html">ordering</a> and <a href="programming//programming/run-criteria.html">run conditions</a>.</p>
<p>Anything you add to the set will automatically be applied to all systems
belonging to the set.</p>
<p>A system can belong to multiple different sets, and will inherit all the
properties from all of them. You can also add additional properties to
individual systems.</p>
<p>All of this combined gives you a lot of flexibility and control over how your systems run.</p>
<p>在顺序约束和条件运行中都涉及到system集合,这个集合是组织system的一种底层次方式.</p>
<p>任何新增到集合中的system都会自动应用集合的约束.</p>
<p>一个system可以属于多个set,继承所有set的约束.也可单独为system添加属性.</p>
<h2 id="anonymous-sets"><a class="header" href="#anonymous-sets">Anonymous Sets</a></h2>
<p>The simplest kind of system set is when you just <a href="programming//programming/app-builder.html">add</a> a tuple of
multiple <a href="programming//programming/systems.html">systems</a> using <code>.add_systems</code>.</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(
    Update,
    (
        system_a,
        system_b,
        system_c
    )
    .run_if(common_run_condition)
    .after(some_system)
);</code></pre>
<p>This syntax is useful when you just want to apply some common configuration to
multiple systems.</p>
<p>匿名集合,用元组.</p>
<h2 id="named-sets"><a class="header" href="#named-sets">Named Sets</a></h2>
<p>This is the more formal and powerful way to use system sets.</p>
<p>You can create a Rust type (<code>struct</code> or <code>enum</code>) to serve as a label/identifier,
so you can refer to the set from different places.</p>
<p>For a single set, create an empty <code>struct</code>. If you need to create multiple
related sets, create an <code>enum</code>. Every variant of the <code>enum</code> is a separate system
set.</p>
<p>You need to derive <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/trait.SystemSet.html"><code>SystemSet</code></a> + an assortment of required standard Rust traits:</p>
<pre><code class="language-rust no_run noplayground">#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
struct MyAudioSet;

#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
struct MyInputSet;

#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
enum MyInputKindSet {
    Touch,
    Mouse,
    Gamepad,
}

#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
enum MyGameplaySet {
    Player,
    Enemies,
}</code></pre>
<p>Now, you can apply the set to your systems using <code>.in_set()</code>:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(Update, (
    (
        play_music
            .run_if(music_enabled),
        play_ui_sounds,
    ).in_set(MyAudioSet),
    (
        player_movement,
        player_animation
            .after(player_movement),
        player_level_up,
        player_footsteps
            .in_set(MyAudioSet),
    ).in_set(MyGameplaySet::Player),
    (
        enemy_movement,
        enemy_ai
            .after(MyGameplaySet::Player),
        enemy_footsteps
            .in_set(MyAudioSet),
    ).in_set(MyGameplaySet::Enemies),
    (
        (
            mouse_cursor_tracking,
            mouse_clicks,
        ).in_set(MyInputKindSet::Mouse),
        (
            gamepad_cursor_tracking,
            gamepad_buttons,
        ).in_set(MyInputKindSet::Gamepad),
        (
            touch_gestures,
        ).in_set(MyInputKindSet::Touch),
    ).in_set(MyInputSet),
));</code></pre>
<p>You can add <a href="programming//programming/run-criteria.html">run conditions</a> and <a href="programming//programming/system-order.html">ordering
dependencies</a> on your set using <code>.configure_sets</code>:</p>
<pre><code class="language-rust no_run noplayground">app.configure_sets(Update, (
    MyAudioSet
        .run_if(audio_enabled),
    MyGameplaySet::Player
        .after(MyInputSet)
        .run_if(player_is_alive),
    MyGameplaySet::Enemies
        .run_if(enemies_present),
    MyInputKindSet::Touch
        .run_if(touchscreen_enabled),
    MyInputKindSet::Mouse
        .run_if(mouse_enabled),
    MyInputKindSet::Gamepad
        .run_if(gamepad_connected),
));</code></pre>
<p>The main use case of named system sets is for logical organization, so that you
can manage your systems and refer to the whole group.</p>
<p>Some examples:</p>
<ul>
<li>A set for all your audio-related systems, so you can disable them all if sound is muted.</li>
<li>A set for all your touchscreen input systems, so you can disable them all if there is no touchscreen.</li>
<li>A set for all your input handling systems, so you can order them to run before gameplay systems.</li>
<li>A set for all your gameplay systems, so that they only run during the in-game <a href="programming//programming/states.html">state</a>.</li>
</ul>
<p>具名集合.使用SystemSet特型指明,具体类型可以是struct/enum.
枚举的单个类型都是一个新的system集合.</p>
<p><code>in_set</code>将system集合的system提取出来,扁平化处理后添加到某个地方.
运行条件和顺序约束的应用和普通system没啥区别.</p>
<p>具名集合的主要用途是组织.下面都是使用例子:</p>
<ul>
<li>所有audio相关的system放一起,这样方便实现mute</li>
<li>触摸屏输入的sytem放一起,方便对触摸屏输入功能进行开关</li>
<li>所有的输入处理system放一起,这样可以让她们在游戏逻辑前面运行</li>
<li>所有游戏逻辑放在一起,这样可以确保只在某个游戏状态时运行</li>
</ul>
<h3 id="with-plugins"><a class="header" href="#with-plugins">With Plugins</a></h3>
<p>Named sets are also very useful together with <a href="programming//programming/plugins.html">plugins</a>. When you are writing
a plugin, you can expose (make <code>pub</code>) some system set types, to allow users of your
plugin to control how things in your plugin run, or how their things run in relation to
your plugin. This way, you don't have to expose any of your individual systems.</p>
<p>Some examples:</p>
<ul>
<li>You are making a physics plugin. Make a set for your whole plugin, so your users can
easily order their systems to run before/after physics. They can also easily control
whether your physics runs at all, by adding an extra run condition to your set.</li>
<li>You are using plugins for internal organization in your project. You have an UI plugin.
Create a system set for the systems that need to update UI state from gameplay state,
so that you can easily add ordering dependencies between UI and gameplay. Other plugins
/ places in your code now don't need to know about the internals of your UI plugin.</li>
</ul>
<p>具名集合和插件配合使用.对于某个插件包的提供者来说,
对外暴露system集合好过单独暴露多个sytem.</p>
<h2 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h2>
<p>WARNING! System set configuration is stored <em>per-<a href="programming//programming/schedules.html">schedule</a>!</em> Notice how
we had to specify <code>.configure_sets(Update, ...)</code>. It can be very easy to configure your
sets once and then just assume you can use them anywhere, but that is not true.</p>
<p>If you try to use them in a <a href="programming//programming/schedules.html">schedule</a> other than the one
where you configured them, your code will compile and run (Bevy silently
initializes the sets in each schedule), but will not work correctly, as they
will not have any of your configurations.</p>
<p>Some common scenarios where this can occur:</p>
<ul>
<li>You configure your set in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> and try to also use it in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, or vice versa.</li>
<li>You try to use your sets in the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit</code></a> schedules of various <a href="programming//programming/states.html">app states</a>.</li>
<li>You add a system to <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> or <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>.</li>
</ul>
<p>常见陷阱.</p>
<p>配置的system集合存储在调度中,这个集合可以用在多个调度中,
要注意:每个调度中的集合都需要配置,不然就是默认配置.</p>
<p>如果集合用在Update中,又用在FixedUpdate中,记住两个地方都需要配置.
如果OnEnter/OnExit调度中都用到某个集合,记住两个地方都需要配置.
一个system添加到PostUpdate/PreUpdate调度中,记住两个地方都需要配置.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="states"><a class="header" href="#states">States</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/state.rs"><code>state</code></a>.</p>
<hr />
<p>States allow you to structure the runtime "flow" of your app.</p>
<p>This is how you can implement things like:</p>
<ul>
<li>A menu screen or a loading screen</li>
<li>Pausing / unpausing the game</li>
<li>Different game modes</li>
<li>…</li>
</ul>
<p>In every state, you can have different <a href="programming//programming/systems.html">systems</a> running. You
can also add setup and cleanup systems to run when entering or exiting a state.</p>
<hr />
<p>To use states, first define an <code>enum</code> type. You need to derive
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/trait.States.html"><code>States</code></a> + an assortment of required standard Rust traits:</p>
<pre><code class="language-rust no_run noplayground">#[derive(States, Debug, Clone, PartialEq, Eq, Hash)]
enum MyAppState {
    LoadingScreen,
    MainMenu,
    InGame,
}

#[derive(States, Default, Debug, Clone, PartialEq, Eq, Hash)]
enum MyGameModeState {
    #[default]
    NotInGame,
    Singleplayer,
    Multiplayer,
}

#[derive(States, Default, Debug, Clone, PartialEq, Eq, Hash)]
enum MyPausedState {
    #[default]
    Paused,
    Running,
}</code></pre>
<p>Note: you can have multiple orthogonal states! Create multiple types
if you want to track multiple things independently!</p>
<p>You then need to register the state type(s) in the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">// Specify the initial value:
app.insert_state(MyAppState::LoadingScreen);

// Or use the default (if the type impls Default):
app.init_state::&lt;MyGameModeState&gt;();
app.init_state::&lt;MyPausedState&gt;();</code></pre>
<p>在Bevy游戏引擎中,States是一个关键概念,用于管理游戏的不同阶段或模式.
例如,一个游戏可能有主菜单/游戏进行中/暂停等不同状态.
Bevy中的状态管理系统允许开发者在这些不同状态之间进行切换,
并定义在每个状态下应执行哪些系统和逻辑.</p>
<p>每个状态都可以划分不同的system进行运行(这个很容易办到,
只需要在system入口判断是不是匹配的状态即可,不匹配就结束).</p>
<p>状态需要由enum定义,指定实现了States特型.</p>
<p>可以使用多个正交状态,可完成更加丰富的需求.
状态需要在app中注册.</p>
<h2 id="running-different-systems-for-different-states"><a class="header" href="#running-different-systems-for-different-states">Running Different Systems for Different States</a></h2>
<p>If you want some <a href="programming//programming/systems.html">systems</a> to only run in specific states,
Bevy offers an <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/common_conditions/fn.in_state.html"><code>in_state</code></a> <a href="programming//programming/run-criteria.html">run condition</a>. Add it
to your systems. You probably want to create <a href="programming//programming/system-sets.html">system sets</a>
to help you group many systems and control them at once.</p>
<pre><code class="language-rust no_run noplayground">// configure some system sets to help us manage our systems
// (note: it is per-schedule, so we also need it for FixedUpdate
// if we plan to use fixed timestep)
app.configure_sets(Update, (
    MyMainMenuSet
        .run_if(in_state(MyAppState::MainMenu)),
    MyGameplaySet
        // note: you can check for a combination of different states
        .run_if(in_state(MyAppState::InGame))
        .run_if(in_state(MyPausedState::Running)),
));
app.configure_sets(FixedUpdate, (
    // configure the same set here, so we can use it in both
    // FixedUpdate and Update
    MyGameplaySet
        .run_if(in_state(MyAppState::InGame))
        .run_if(in_state(MyPausedState::Running)),
    // configure a bunch of different sets only for FixedUpdate
    MySingleplayerSet
        // inherit configuration from MyGameplaySet and add extras
        .in_set(MyGameplaySet)
        .run_if(in_state(MyGameModeState::Singleplayer)),
    MyMultiplayerSet
        .in_set(MyGameplaySet)
        .run_if(in_state(MyGameModeState::Multiplayer)),
));

// now we can easily add our different systems
app.add_systems(Update, (
    update_loading_progress_bar
        .run_if(in_state(MyAppState::LoadingScreen)),
    (
        handle_main_menu_ui_input,
        play_main_menu_sounds,
    ).in_set(MyMainMenuSet),
    (
        camera_movement,
        play_game_music,
    ).in_set(MyGameplaySet),
));
app.add_systems(FixedUpdate, (
    (
        player_movement,
        enemy_ai,
    ).in_set(MySingleplayerSet),
    (
        player_net_sync,
        enemy_net_sync,
    ).in_set(MyMultiplayerSet),
));

// of course, if we need some global (state-independent)
// setup to run on app startup, we can still use Startup as usual
app.add_systems(Startup, (
    load_settings,
    setup_window_icon,
));</code></pre>
<p>Bevy also creates special <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit</code></a>,
and <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition</code></a> <a href="programming//programming/schedules.html">schedules</a> for each
possible value of your state type. Use them to perform setup and cleanup for
specific states. Any systems you add to them will run once every time the state
is changed to/from the respective values.</p>
<pre><code class="language-rust no_run noplayground">// do the respective setup and cleanup on state transitions
app.add_systems(OnEnter(MyAppState::LoadingScreen), (
    start_load_assets,
    spawn_progress_bar,
));
app.add_systems(OnExit(MyAppState::LoadingScreen), (
    despawn_loading_screen,
));
app.add_systems(OnEnter(MyAppState::MainMenu), (
    setup_main_menu_ui,
    setup_main_menu_camera,
));
app.add_systems(OnExit(MyAppState::MainMenu), (
    despawn_main_menu,
));
app.add_systems(OnEnter(MyAppState::InGame), (
    spawn_game_map,
    setup_game_camera,
    spawn_enemies,
));
app.add_systems(OnEnter(MyGameModeState::Singleplayer), (
    setup_singleplayer,
));
app.add_systems(OnEnter(MyGameModeState::Multiplayer), (
    setup_multiplayer,
));
// ...</code></pre>
<p>哪些system在哪些状态下运行,出了上面提到的简单方法,还可以使用运行条件实现.
bevy提供了一个<code>in_state</code>的运行条件.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn in_state&lt;S: States&gt;(state: S) -&gt; impl FnMut(Option&lt;Res&lt;State&lt;S&gt;&gt;&gt;) -&gt; bool + Clone {
    move |current_state: Option&lt;Res&lt;State&lt;S&gt;&gt;&gt;| match current_state {
        Some(current_state) =&gt; *current_state == state,
        None =&gt; false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>看上面的源码,实现原理和上面提到的简单方法是一样的,这里是运行条件实现的.</p>
<p>对比看上面的例子, system集合和状态结合,威力非常巨大.</p>
<p>OnEnter/OnExit/OnTransition, 是状态进入/退出/改变时的调度.
利用这几个调度可以跟踪状态的切换.</p>
<h3 id="with-plugins-1"><a class="header" href="#with-plugins-1">With Plugins</a></h3>
<p>This can also be useful with <a href="programming//programming/plugins.html">Plugins</a>. You can set up all the state
types for your project in one place, and then your different plugins can just add
their systems to the relevant states.</p>
<p>You can also make plugins that are configurable, so that it is possible to specify
what state they should add their systems to:</p>
<pre><code class="language-rust no_run noplayground">pub struct MyPlugin&lt;S: States&gt; {
    pub state: S,
}

impl&lt;S: States&gt; Plugin for MyPlugin&lt;S&gt; {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_systems(Update, (
            my_plugin_system1,
            my_plugin_system2,
            // ...
        ).run_if(in_state(self.state.clone())));
    }
}</code></pre>
<p>Now you can configure the plugin when adding it to the app:</p>
<pre><code class="language-rust no_run noplayground">app.add_plugins(MyPlugin {
    state: MyAppState::InGame,
});</code></pre>
<p>When you are just using <a href="programming//programming/plugins.html">plugins</a> to help with internal
organization of your project, and you know what systems should go into each
state, you probably don't need to bother with making the plugin configurable
as shown above. Just hardcode the states / add things to the correct states
directly.</p>
<p>插件也可以根据状态来分类,eg:插件中添加的system只绑定到某几个状态.
如果只用插件来组织项目,在插件中对状态进行硬编码会更加简单.
这里的硬编码是相对于上面的例子来说的(上面的例子是通过参数传递状态).</p>
<p>总的来说,组织项目的有:</p>
<ul>
<li>插件</li>
<li>调度</li>
<li>system 集合</li>
<li>状态</li>
</ul>
<h2 id="controlling-states"><a class="header" href="#controlling-states">Controlling States</a></h2>
<p>Inside of systems, you can check the current state using the
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.State.html"><code>State&lt;T&gt;</code></a> <a href="programming//programming/res.html">resource</a>:</p>
<pre><code class="language-rust no_run noplayground">fn debug_current_gamemode_state(state: Res&lt;State&lt;MyGameModeState&gt;&gt;) {
    eprintln!("Current state: {:?}", state.get());
}</code></pre>
<p>To change to another state, you can use the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.NextState.html"><code>NextState&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn toggle_pause_game(
    state: Res&lt;State&lt;MyPausedState&gt;&gt;,
    mut next_state: ResMut&lt;NextState&lt;MyPausedState&gt;&gt;,
) {
    match state.get() {
        MyPausedState::Paused =&gt; next_state.set(MyPausedState::Running),
        MyPausedState::Running =&gt; next_state.set(MyPausedState::Paused),
    }
}

// if you have multiple states that must be set correctly,
// don't forget to manage them all
fn new_game_multiplayer(
    mut next_app: ResMut&lt;NextState&lt;MyAppState&gt;&gt;,
    mut next_mode: ResMut&lt;NextState&lt;MyGameModeState&gt;&gt;,
) {
    next_app.set(MyAppState::InGame);
    next_mode.set(MyGameModeState::Multiplayer);
}</code></pre>
<p>This will queue up state transitions to be performed during the next frame
update cycle.</p>
<p>状态在运行逻辑中会变化,也就是说system中会改变状态.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait States: 'static + Send + Sync + Clone + PartialEq + Eq + Hash + Debug {
    const DEPENDENCY_DEPTH: usize = 1usize;
}

#[derive(Resource, Debug)]
#[cfg_attr(
    feature = "bevy_reflect",
    derive(bevy_reflect::Reflect),
    reflect(Resource)
)]
pub struct State&lt;S: States&gt;(pub(crate) S);
<span class="boring">}</span></code></pre></pre>
<p>对状态的控制:</p>
<ul>
<li><code>Res&lt;State&lt;MyGameModeState&gt;&gt;.get()</code>获取状态</li>
<li><code>ResMut&lt;NextState&lt;MyPausedState&gt;&gt;.set()</code>设置状态</li>
</ul>
<p>对状态的变更,会放在队列中,在下帧的更新循环(StateTransition调度)中进行更新.</p>
<h2 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h2>
<p>Every frame update, a <a href="programming//programming/schedules.html">schedule</a> called
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a> runs. There, Bevy will check if
any new state is queued up in <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.NextState.html"><code>NextState&lt;T&gt;</code></a> and perform
the transition for you.</p>
<p>The transition involves several steps:</p>
<ul>
<li>A <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.StateTransitionEvent.html"><code>StateTransitionEvent</code></a> <a href="programming//programming/events.html">event</a> is sent.</li>
<li>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit(old_state)</code></a> <a href="programming//programming/schedules.html">schedule</a> is run.</li>
<li>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition { from: old_state, to: new_state }</code></a> <a href="programming//programming/schedules.html">schedule</a> is run.</li>
<li>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter(new_state)</code></a> <a href="programming//programming/schedules.html">schedule</a> is run.</li>
</ul>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.StateTransitionEvent.html"><code>StateTransitionEvent</code></a> is useful in any <a href="programming//programming/systems.html">systems</a> that run
regardless of state, but want to know if a transition has occurred. You can use
it to detect state transitions.</p>
<p>The <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a> <a href="programming//programming/schedules.html">schedule</a> runs after <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a> (which
contains Bevy engine internals), but before <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> (<a href="programming//fundamentals/fixed-timestep.html">fixed
timestep</a>) and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>, where your game's
<a href="programming//programming/systems.html">systems</a> usually live.</p>
<p>Therefore, state transitions happen before your game logic for the current frame.</p>
<p>If doing state transitions once per frame is not enough for you, you can add
additional transition points, by adding Bevy's <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/fn.apply_state_transition.html"><code>apply_state_transition</code></a>
<a href="programming//programming/systems.html">system</a> wherever you like.</p>
<pre><code class="language-rust no_run noplayground">// Example: also do state transitions for MyPausedState
// before MyGameplaySet on each fixed timestep run
app.add_systems(
    FixedUpdate,
    apply_state_transition::&lt;MyPausedState&gt;
        .before(MyGameplaySet)
);</code></pre>
<p>状态变更: 在当前帧的StateTransition中执行上帧<code>NextState&lt;T&gt;</code>的状态变更,具体为:</p>
<ul>
<li>发送StateTransitionEvent事件</li>
<li>OnExit(旧状态)调度运行</li>
<li>OnTransition(from:旧状态,to:新状态)调度执行</li>
<li>OnEnter(新状态)调度运行</li>
</ul>
<p>StateTransition调度在PreUpdate之后执行(PreUpdate是bevy内部引擎包含的),
在FixedMain和Update之前.因此状态变更是在当前帧逻辑之前发生的.</p>
<p>如果每帧发生一次状态变更还不够,可以使用<code>apply_state_transition</code> system
添加变更点.</p>
<h2 id="known-pitfalls-2"><a class="header" href="#known-pitfalls-2">Known Pitfalls</a></h2>
<h3 id="system-set-configuration-is-per-schedule"><a class="header" href="#system-set-configuration-is-per-schedule">System set configuration is per-schedule!</a></h3>
<p>This is the same general caveat that applies any time you configure <a href="programming//programming/system-sets.html">system sets</a>.</p>
<p>Note that <code>app.configure_sets()</code> is <em>per-<a href="programming//programming/schedules.html">schedule</a>!</em> If you configure some sets
in one <a href="programming//programming/schedules.html">schedule</a>, that configuration does not carry over to other schedules.</p>
<p>Because states are so schedule-heavy, you have to be especially careful. Don't assume
that just because you configured a set, you can use it anywhere.</p>
<p>For example, your sets from <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> will not work in
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit</code></a> for your various state transitions.</p>
<p>system集合要对每个调度都做配置,少了配置就会出问题.</p>
<h3 id="events-3"><a class="header" href="#events-3">Events</a></h3>
<p>This is the same general caveat that applies to any <a href="programming//programming/systems.html">systems</a> with
<a href="programming//programming/run-criteria.html">run conditions</a> that want to receive <a href="programming//programming/events.html">events</a>.</p>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run all the time, such
as during a pause state, you will miss any events that are sent while when
the receiving systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<p>接收事件+运行条件,会导致漏事件,解决方法是自定义事件清理策略,
手动维护相关事件的生命周期.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/component_change_detection.rs"><code>component_change_detection</code></a>.</p>
<hr />
<p>Bevy allows you to easily detect when data is changed. You can use this to
perform actions in response to changes.</p>
<p>One of the main use cases is optimization – avoiding unnecessary work by
only doing it if the relevant data has changed. Another use case is triggering
special actions to occur on changes, like configuring something or sending
the data somewhere.</p>
<p>bevy提供了变更检测,以下场景下会用上:</p>
<ul>
<li>优化,只做和变更数据相关的事,不做无意义的事</li>
<li>变更触发某个动作,eg:配置变更</li>
</ul>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<p>You can make a <a href="programming//programming/queries.html">query</a> that only yields entities if specific
<a href="programming//programming/ec.html#components">components</a> on them have been modified.</p>
<p>Use <a href="programming//programming/queries.html#query-filters">query filters</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Added.html"><code>Added&lt;T&gt;</code></a>: detect new component instances
<ul>
<li>if the component was added to an existing entity</li>
<li>if a new entity with the component was spawned</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Changed.html"><code>Changed&lt;T&gt;</code></a>: detect component instances that have been changed
<ul>
<li>triggers when the component is mutated</li>
<li>also triggers if the component is newly-added (as per <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Added.html"><code>Added</code></a>)</li>
</ul>
</li>
</ul>
<p>(If you want to react to removals, see <a href="programming//programming/change-detection.html#removal-detection">removal
detection</a>. It works differently.)</p>
<pre><code class="language-rust no_run noplayground">/// Print the stats of friendly players when they change
fn debug_stats_change(
    query: Query&lt;
        // components
        (&amp;Health, &amp;PlayerXp),
        // filters
        (Without&lt;Enemy&gt;, Or&lt;(Changed&lt;Health&gt;, Changed&lt;PlayerXp&gt;)&gt;), 
    &gt;,
) {
    for (health, xp) in query.iter() {
        eprintln!(
            "hp: {}+{}, xp: {}",
            health.hp, health.extra, xp.0
        );
    }
}

/// detect new enemies and print their health
fn debug_new_hostiles(
    query: Query&lt;(Entity, &amp;Health), Added&lt;Enemy&gt;&gt;,
) {
    for (entity, health) in query.iter() {
        eprintln!("Entity {:?} is now an enemy! HP: {}", entity, health.hp);
    }
}</code></pre>
<p>组件过滤,能将某些组件变更了的实体全部query出来.</p>
<ul>
<li><code>Added&lt;T&gt;</code> 检测新组件实例
<ul>
<li>已有实体新增组件</li>
<li>构造一个包含组件的实体</li>
</ul>
</li>
<li><code>Changed&lt;T&gt;</code> 检测组件实体是否有变更
<ul>
<li>组件被修改触发</li>
<li>组件新增触发(这条等价于Added<T>)</li>
</ul>
</li>
</ul>
<p>组件删除还有<code>删除检测</code>,和变更检测的实现方式有点不同.</p>
<h3 id="checking"><a class="header" href="#checking">Checking</a></h3>
<p>If you want to access all the entities, as normal, regardless of if they have
been modified, but you just want to know if a component has been changed,
you can use special [<code>Ref&lt;T&gt;</code>] query parameters instead of <code>&amp;</code> for immutable access.</p>
<p>For mutable access, the change detection methods are always available (because
Bevy queries actually return a special <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.Mut.html"><code>Mut&lt;T&gt;</code></a> type whenever you have <code>&amp;mut</code>
in the query).</p>
<pre><code class="language-rust no_run noplayground">/// Make sprites flash red on frames when the Health changes
fn debug_damage(
    mut query: Query&lt;(&amp;mut Sprite, Ref&lt;Health&gt;)&gt;,
) {
    for (mut sprite, health) in query.iter_mut() {
        // detect if the Health changed this frame
        if health.is_changed() {
            eprintln!("HP is: {}", health.hp);
            // we can also check if the sprite has been changed
            if !sprite.is_changed() {
                sprite.color = Color::RED;
            }
        }
    }
}</code></pre>
<p>bevy还提供了一种方法来判断某个组件是否有改变</p>
<ul>
<li>只查是否有改变,本次system执行不改变组件值. <code>Ref&lt;T&gt;.is_changed()</code></li>
<li>查是否有改变,并在本次system还支持变更组件值. <code>(&amp;mut T).is_changed()</code></li>
</ul>
<h2 id="resources-3"><a class="header" href="#resources-3">Resources</a></h2>
<p>For <a href="programming//programming/res.html">resources</a>, change detection is provided via methods on the
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a> system parameters.</p>
<pre><code class="language-rust no_run noplayground">fn check_res_changed(
    my_res: Res&lt;MyResource&gt;,
) {
    if my_res.is_changed() {
        // do something
    }
}

fn check_res_added(
    // use Option, not to panic if the resource doesn't exist yet
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists

        if my_res.is_added() {
            // it was just added
            // do something
        }
    }
}</code></pre>
<p>资源也支持增改检测.<code>Res&lt;T&gt;.is_changed()</code>, <code>Option&lt;Res&lt;T&gt;&gt;.is_added()</code>.</p>
<h2 id="what-gets-detected"><a class="header" href="#what-gets-detected">What gets detected?</a></h2>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Changed.html"><code>Changed</code></a> detection is triggered by <a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>. Simply accessing
<a href="programming//programming/ec.html#components">components</a> via a mutable <a href="programming//programming/queries.html">query</a>, or
<a href="programming//programming/res.html">resources</a> via <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>, without actually performing a <code>&amp;mut</code>
access, will <em>not</em> trigger it. This makes change detection quite accurate.</p>
<p>Note: if you call a Rust function that takes a <code>&amp;mut T</code> (mutable borrow),
that counts! It will trigger change detection even if the function does
not actually do any mutation. Be careful with helper functions!</p>
<p>Also, when you mutate a component, Bevy does not check if the new value
is actually different from the old value. It will always trigger the change
detection. If you want to avoid that, simply check it yourself:</p>
<pre><code class="language-rust no_run noplayground">fn update_player_xp(
    mut query: Query&lt;&amp;mut PlayerXp&gt;,
) {
    for mut xp in query.iter_mut() {
        let new_xp = maybe_lvl_up(&amp;xp);

        // avoid triggering change detection if the value is the same
        if new_xp != *xp {
            *xp = new_xp;
        }
    }
}</code></pre>
<p>Change detection works on a per-<a href="programming//programming/systems.html">system</a> granularity, and is
reliable. A system will detect changes only if it has not seen them before
(the changes happened since the last time it ran).</p>
<p>Unlike <a href="programming//programming/events.html">events</a>, you do <em>not</em> have to worry about missing changes
If your system only runs sometimes (such as when using <a href="programming//programming/states.html">states</a>
or <a href="programming//programming/run-criteria.html">run conditions</a>).</p>
<p><code>变更检测</code>是由<code>DerefMut</code>触发的.</p>
<p>简单的获取可变组件/资源并不执行&amp;mut 访问,是不会触发变更检测的.</p>
<p>如果是rust函数有个<code>&amp;mut T</code>参数,这会触发可变检测(估计bevy对system函数有特殊处理),
所以要警惕辅助函数.</p>
<p>如果修改组件了,bevy不会检查前后两次的值是否相等,而是直接触发<code>变更检测</code>,
这个避免的方式是在修改组件之前,先做前后值比较,如果相等就不修改了.</p>
<p>变更检测以每个系统为粒度进行工作,并且是可靠的.
仅当系统以前未见过更改(自上次运行以来发生的更改)时,系统才会检测到更改.</p>
<p>这个变更检测不像事件,变更检测是可靠的;事件叠加状态和运行条件,可能会漏掉.</p>
<h2 id="possible-pitfalls-1"><a class="header" href="#possible-pitfalls-1">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the detecting
system before the changing system. The detecting system will see the change
the next time it runs, typically on the next frame update.</p>
<p>If you need to ensure that changes are handled immediately / during the same
frame, you can use <a href="programming//programming/system-order.html">explicit system ordering</a>.</p>
<p>变更检测的逻辑是放在system中的,所以检测和实际的变更是可能存在不确定顺序的,
如果先检测再变更,只能再下帧才会收集到变更信息.</p>
<p>如果想要顺序必须正确,就使用system的顺序约束来保证.</p>
<hr />
<h1 id="removal-detection"><a class="header" href="#removal-detection">Removal Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/removal_detection.rs"><code>removal_detection</code></a>.</p>
<hr />
<p>Removal detection is special. This is because, unlike with <a href="programming//programming/change-detection.html">change
detection</a>, the data does not exist in the ECS anymore
(obviously), so Bevy cannot keep tracking metadata for it.</p>
<p>Nevertheless, being able to respond to removals is important for some
applications, so Bevy offers a limited form of it.</p>
<p>删除检测,删除意味着ECS都删除了,就没法跟踪了(其实是元数据被删掉了).
bevy还是提供了一种带限制的方式.</p>
<h2 id="components-3"><a class="header" href="#components-3">Components</a></h2>
<p>You can check for <a href="programming//programming/ec.html#components">components</a> that have been removed during the
current frame. The data is cleared at the end of every frame update. You must
make sure your detecting <a href="programming//programming/systems.html">system</a> <a href="programming//programming/system-order.html">is ordered after</a>
(or is in another <a href="programming//programming/schedules.html">schedule</a> that runs after) the system that
does the removing.</p>
<p>Note: removal detection also includes despawned entities!</p>
<p>Use the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/removal_detection/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a> special system parameter type. Internally, it
is implemented using <a href="programming//programming/events.html">events</a> and behaves like an <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader</code></a>,
but it gives you the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> IDs of entities whose component <code>T</code> was removed.</p>
<pre><code class="language-rust no_run noplayground">fn detect_removals(
    mut removals: RemovedComponents&lt;EnemyIsTrackingPlayer&gt;,
    // ... (maybe Commands or a Query ?) ...
) {
    for entity in removals.read() {
        // do something with the entity
        eprintln!("Entity {:?} had the component removed.", entity);
    }
}</code></pre>
<p>(To do things with these entities, you can just use the <code>Entity</code> IDs with
<a href="programming//programming/commands.html"><code>Commands::entity()</code></a> or <a href="programming//programming/queries.html"><code>Query::get()</code></a>.)</p>
<p>删除组件,其元数据的删除是在每帧更新的最后执行的,那么删除检测就需要在删除system之后就行.</p>
<p>实体删除组件;删除实体都会触发<code>删除变更</code>.</p>
<p><code>RemovedComponents&lt;T&gt;</code>是删除组件事件接收器,和<code>EventReader</code>很像, 会提供实体ID.</p>
<h2 id="resources-4"><a class="header" href="#resources-4">Resources</a></h2>
<p>Bevy does not provide any API for detecting when <a href="programming//programming/res.html">resources</a> are removed.</p>
<p>You can work around this using <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> and a separate <a href="programming//programming/local.html"><code>Local</code></a>
system parameter, effectively implementing your own detection.</p>
<pre><code class="language-rust no_run noplayground">fn detect_removed_res(
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
    mut my_res_existed: Local&lt;bool&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists!

        // remember that!
        *my_res_existed = true;

        // (... you can do something with the resource here if you want ...)
    } else if *my_res_existed {
        // the resource does not exist, but we remember it existed!
        // (it was removed)

        // forget about it!
        *my_res_existed = false;

        // ... do something now that it is gone ...
    }
}</code></pre>
<p>Note that, since this detection is local to your system, it does not have
to happen during the same frame update.</p>
<p>bevy没有提供资源删除检测的api.但可以通过Option来跟踪资源,通过Local来记录资源是否存在.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="one-shot-systems-1"><a class="header" href="#one-shot-systems-1">One-Shot Systems</a></h1>
<p>One-Shot Systems are <a href="programming//programming/systems.html">systems</a> that you intend to call yourself,
whenever you want. For example: on a button press, upon triggering a special
item or ability in your game, etc…</p>
<pre><code class="language-rust no_run noplayground">fn item_handler_health(
    mut q_player: Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
) {
    let mut health = q_player.single_mut();
    health.hp += 25.0;
}

fn item_handler_magic_potion(
    mut evw_magic: EventWriter&lt;MyMagicEvent&gt;,
    mut commands: Commands,
) {
    evw_magic.send(MyMagicEvent::Sparkles);
    commands.spawn(MySparklesBundle::default());
}</code></pre>
<p>单击system,ui操作,游戏中的补蓝等.</p>
<h2 id="registration"><a class="header" href="#registration">Registration</a></h2>
<p>You should not add these systems to a <a href="programming//programming/schedules.html">schedule</a>.</p>
<p>Instead, you can register them into the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>, to get a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemId.html"><code>SystemId</code></a>.
You can then store that <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemId.html"><code>SystemId</code></a> somewhere and use it to run the
system later.</p>
<p>The most convenient way is probably to use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> and put your
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemId.html"><code>SystemId</code></a>s in a <a href="programming//programming/res.html">resource</a>:</p>
<pre><code class="language-rust no_run noplayground">/// For this simple example, we will just organize our systems
/// using string keys in a hash map.
#[derive(Resource)]
struct MyItemSystems(HashMap&lt;String, SystemId&gt;);

impl FromWorld for MyItemSystems {
    fn from_world(world: &amp;mut World) -&gt; Self {
        let mut my_item_systems = MyItemSystems(HashMap::new());

        my_item_systems.0.insert(
            "health".into(),
            world.register_system(item_handler_health)
        );
        my_item_systems.0.insert(
            "magic".into(),
            world.register_system(item_handler_magic_potion)
        );

        my_item_systems
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyItemSystems&gt;();</code></pre>
<p>Alternative: register from an <a href="programming//programming/exclusive.html">exclusive system</a>:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">fn register_item_handler_systems(world: &amp;mut World) {
    let mut my_item_systems = MyItemSystems(HashMap::new());

    my_item_systems.0.insert(
        "health".into(),
        world.register_system(item_handler_health)
    );
    my_item_systems.0.insert(
        "magic".into(),
        world.register_system(item_handler_magic_potion)
    );

    world.insert_resource(my_item_systems);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, register_item_handler_systems);</code></pre>
</details>
<p>Or from the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">fn my_plugin(app: &amp;mut App) {
    let mut my_item_systems = MyItemSystems(HashMap::new());

    my_item_systems.0.insert(
        "health".into(),
        app.register_system(item_handler_health)
    );
    my_item_systems.0.insert(
        "magic".into(),
        app.register_system(item_handler_magic_potion)
    );

    app.insert_resource(my_item_systems);
}</code></pre>
</details>
<p>单击system不属于调度,而是属于world.使用<code>register_system</code>来注册system.
(add_system是ecs添加system).</p>
<p>这里有个概念,world中的单击system是有systemID的,类似于实体id一样,是个引用.
register_system注册后会返回systemID,后续调用需要这个ID.</p>
<p>这个ID可以保存起来,是的,推荐使用资源将ID保存起来,为了方便区分,还可以使用hash存储起来.</p>
<p>如上图所示,定一个资源来存储hash.实现FromWorld特型(自动填充资源).
或者直接操纵world来添加资源,或者通过app来添加资源.
(推荐使用FromWorld特型).</p>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<p>The easiest way is using <a href="programming//programming/commands.html">Commands</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>):</p>
<pre><code class="language-rust no_run noplayground">fn trigger_health_item(
    mut commands: Commands,
    systems: Res&lt;MyItemSystems&gt;,
) {
    // TODO: do some logic to implement picking up the health item

    let id = systems.0["health"];
    commands.run_system(id);
}</code></pre>
<p>This queues up the system to be run later, whenever Bevy decides to
apply the <a href="programming//programming/commands.html">Commands</a>.</p>
<p>If you want to run a one-shot system immediately, like a normal function
call, you need <a href="programming//programming/world.html">direct <code>World</code> access</a>. Do it from an <a href="programming//programming/exclusive.html">exclusive
system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn trigger_magic_item(world: &amp;mut World) {
    // TODO: do some logic to implement picking up the magic item

    let id = world.resource::&lt;MyItemSystems&gt;().0["magic"];
    world.run_system(id).expect("Error Running Oneshot System");

    // Since we are in an exclusive system, we can expect
    // the magic potion to now be in effect!
}</code></pre>
<p>Either way, the one-shot system's <a href="programming//programming/commands.html">Commands</a>
are automatically applied immediately when it runs.</p>
<p>运行,通过<code>Commands.run_system(systemID)</code>实现.这样是延时执行的.
如果要立马生效,用独占system来直接访问world.</p>
<h3 id="without-registration"><a class="header" href="#without-registration">Without Registration</a></h3>
<p>It is possible to also run one-shot systems without <a href="programming/one-shot-systems.html#registration">registering</a>
them beforehand:</p>
<pre><code class="language-rust no_run noplayground">world.run_system_once(my_oneshot_system_fn);</code></pre>
<p>If you do this, Bevy is unable to store any data related to the system:</p>
<ul>
<li><a href="programming//programming/local.html">Locals</a> will not retain their value from a previous run.</li>
<li><a href="programming//programming/queries.html">Queries</a> will not be able to cache their lookups, leading to slower performance.</li>
<li>etc…</li>
</ul>
<p>It is therefore recommended to register your one-shot systems, unless
you really only intend to run them once.</p>
<p>bevy还允许不注册直接运行单击system.<code>world.run_system_once(my_oneshot_system_fn);</code>
只是这样bevy就不能缓存system相关数据了:</p>
<ul>
<li>Local</li>
<li>Query</li>
</ul>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<p>To run a one-shot system, exclusive <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a> access is required. The
system can have arbitrary parameters, and Bevy cannot validate its data
access against other systems, like it does when the system is part of a
<a href="programming//programming/schedules.html">schedule</a>. So, no multi-threading allowed.</p>
<p>In practice, this isn't usually a problem, because the use cases for
one-shot systems are things that happen rarely.</p>
<p>But maybe don't overuse them! If something happens regularly, consider
doing it from a normal system that is part of a <a href="programming//programming/schedules.html">schedule</a>,
and controlling it with <a href="programming//programming/run-criteria.html">run conditions</a> instead.</p>
<p>如果使用独占system来运行单击system,此时会独占world,性能就是一个大问题.</p>
<p>这个机制存在的理由是:实际场景下必须使用独占system来运行单击system的场景非常少.</p>
<p>只要不过渡使用即可.如果单击system发生的非常频繁,需考虑转换成普通system.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="internal-parallelism"><a class="header" href="#internal-parallelism">Internal Parallelism</a></h1>
<p>Internal parallelism is multithreading <em>within</em> a <a href="programming//programming/systems.html">system</a>.</p>
<p>The usual multithreading in Bevy is to run each <a href="programming//programming/systems.html">system</a> in
parallel when possible (when there is no conflicting data access with other
systems). This is called "external parallelism".</p>
<p>However, sometimes, you need to write a <a href="programming//programming/systems.html">system</a> that
has to process a huge number of <a href="programming//programming/intro-data.html">entities</a> or
<a href="programming//programming/events.html">events</a>. In that case, simple <a href="programming//programming/queries.html">query</a> or
<a href="programming//programming/events.html">event</a> iteration would not scale to make good use of the CPU.</p>
<p>Bevy offers a solution: parallel iteration. Bevy will automatically split
all the entities/events into appropriately-sized batches, and iterate
each batch on a separate CPU thread for you, calling a function/closure
you provide.</p>
<p>If there are only a few entities/events, Bevy will automatically fall back
to single-threaded iteration, and it will behave the same way as if you
had just iterated normally. With a few entities/events, that is faster than
multi-threading.</p>
<p>Even through parallel iteration should automatically make a good decision
regardless of the number of entities/events, it is more awkward to use and
not always suitable, as you have to do everything from inside a closure
and there are other limitations.</p>
<p>Also, if your <a href="programming//programming/systems.html">system</a> is unlikely to ever encounter huge
numbers of entities/events, don't bother with it and just iterate your
<a href="programming//programming/queries.html">queries</a> and <a href="programming//programming/events.html">events</a> normally.</p>
<p>内部并行是指system内部的多线程.<br />
外部并行是指bevy启用多线程让system并行执行.</p>
<p>某些时候,在一个system内可能要遍历大量实体或事件,
此时简单的query或事件迭代就无法有效利用CPU了.</p>
<p>bevy提出了内部并行的方案:bevy自动将实体列表/事件列表拆分成合适大小,
每块使用一个CPU线程来运行.如果块数很少,bevy会自动合并到一个线程中跑.</p>
<p>即使开启了内部并行,但bevy内部的自动机制也不一定合适,因为闭包内部还有其他限制.</p>
<p><strong>如果项目不是遇到巨量实体/事件,使用正常的query循环/事件迭代就够用了.</strong></p>
<h2 id="parallel-query-iteration"><a class="header" href="#parallel-query-iteration">Parallel Query Iteration</a></h2>
<p><a href="programming//programming/queries.html">Queries</a> support parallel iteration to let you process many
entities across multiple CPU threads.</p>
<pre><code class="language-rust no_run noplayground">fn my_particle_physics(
    mut q_particles: Query&lt;(&amp;mut Transform, &amp;MyParticleState), With&lt;MyParticle&gt;&gt;,
) {
    q_particles.par_iter_mut().for_each(|(mut transform, my_state)| {
        my_state.move_particle(&amp;mut transform);
    });
}</code></pre>
<p>One limitation of parallel iteration is that safe Rust does not allow you to
share <code>&amp;mut</code> access across CPU threads. Therefore, it is not possible to mutate
any data outside of the current entity's own <a href="programming//programming/ec.html#components">components</a>.</p>
<p>If you need to mutate shared data, you could use something like <a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code>Mutex</code></a>,
but beware of the added overhead. It could easily drown out any benefits
you get from parallel iteration.</p>
<h2 id="parallel-commands"><a class="header" href="#parallel-commands">Parallel Commands</a></h2>
<p>If you need to use <a href="programming//programming/commands.html">commands</a>, there is the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ParallelCommands.html"><code>ParallelCommands</code></a>
system parameter. It allows you to get access to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> from within
the parallel iteration closure.</p>
<pre><code class="language-rust no_run noplayground">fn my_particle_timers(
    time: Res&lt;Time&gt;,
    mut q_particles: Query&lt;(Entity, &amp;mut MyParticleState), With&lt;MyParticle&gt;&gt;,
    par_commands: ParallelCommands,
) {
    q_particles.par_iter_mut().for_each(|(e_particle, mut my_state)| {
        my_state.timer.tick(time.delta());

        if my_state.timer.finished() {
            par_commands.command_scope(|mut commands| {
                commands.entity(e_particle).despawn();
            })
        }
    });
}</code></pre>
<p>However, generally speaking, <a href="programming//programming/commands.html">commands</a> are an inefficient way to
do things in Bevy, and they do not scale well to huge numbers of entities. If
you need to spawn/despawn or insert/remove <a href="programming//programming/ec.html#components">components</a>
on huge numbers of entities, you should probably do it from an <a href="programming//programming/exclusive.html">exclusive
system</a>, instead of using <a href="programming//programming/commands.html">commands</a>.</p>
<p>In the above example, we update <a href="programming//fundamentals/time.html#timer">timers</a> stored across many
entities, and use <a href="programming//programming/commands.html">commands</a> to despawn any entities whose
time has elapsed. It is a good use of <a href="programming//programming/commands.html">commands</a>, because the
timers need to be ticked for all entities, but only a few entities are likely
to need despawning at once.</p>
<h2 id="parallel-event-iteration"><a class="header" href="#parallel-event-iteration">Parallel Event Iteration</a></h2>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a> offers parallel iteration for <a href="programming//programming/events.html">events</a>,
allowing you to process a huge number of events across multiple CPU threads.</p>
<pre><code class="language-rust no_run noplayground">fn handle_many_events(
    mut evr: EventReader&lt;MyEvent&gt;,
) {
    evr.par_read().for_each(|ev| {
        // TODO: do something with `ev`
    });
}</code></pre>
<p>However, one downside is that you cannot use it for events that need to be
handled in order. With parallel iteration, the order becomes undefined.</p>
<p>Though, if you use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventParIter.html"><code>.for_each_with_id</code></a>, your closure will
be given an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventId.html"><code>EventId</code></a>, which is a sequential index to indicate which event
you are currently processing. That can help you know where you are in the
event queue, even though you are still processing events in an undefined order.</p>
<p>Another downside is that typically you need to be able to mutate some data in
response to events, but, in safe Rust, it is not possible to share mutable
access to anything across CPU threads. Thus, parallel event handling is
impossible for most use cases.</p>
<p>If you were to use something like <a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code>Mutex</code></a> for shared access to data, the
synchronization overhead would probably kill performance, and you'd have
been better off with regular single-threaded event iteration.</p>
<h2 id="controlling-the-batch-size"><a class="header" href="#controlling-the-batch-size">Controlling the Batch Size</a></h2>
<p>The batch size and number of parallel tasks are chosen automatically using
smart algorithms, based on how many entities/events need to be processed,
and how Bevy ECS has stored/organized the entity/component data in memory.
However, it assumes that the amount of work/computation you do for each
entity is roughly the same.</p>
<p>If you find that you want to manually control the batch size, you can specify
a minimum and maximum using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/batching/struct.BatchingStrategy.html"><code>BatchingStrategy</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn par_iter_custom_batch_size(
    q: Query&lt;&amp;MyComponent&gt;,
) {
    q.par_iter().batching_strategy(
        BatchingStrategy::new()
            // whatever fine-tuned values you come up with ;)
            .min_batch_size(256)
            .max_batch_size(4096)
    ).for_each(|my_component| {
        // TODO: do some heavy work
    });

    q.par_iter().batching_strategy(
        // fixed batch size
        BatchingStrategy::fixed(1024)
    ).for_each(|my_component| {
        // TODO: do some heavy work
    });
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="system-piping"><a class="header" href="#system-piping">System Piping</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/system_piping.rs"><code>system_piping</code></a>.</p>
<hr />
<p>You can compose a single Bevy <a href="programming//programming/systems.html">system</a> from multiple Rust functions.</p>
<p>You can make functions that can take an input and produce an output, and be
connected together to run as a single larger system. This is called "system piping".</p>
<p>You can think of it as creating "modular" systems made up of multiple building
blocks. This way, you can reuse some common code/logic in multiple systems.</p>
<p>Note that system piping is <em>not</em> a way of communicating between systems.
If you want to pass data between systems, you should use <a href="programming//programming/events.html">Events</a>
instead.</p>
<p>Your functions will be combined and Bevy will treat them as if they were a
single big <a href="programming//programming/systems.html">system</a> with all the combined system parameters for
data access.</p>
<p>将多个rust函数组合成单个system,在这个system中,函数有input/output,
最终组合成一个管道,这就是system管道.</p>
<p>bevy中system之间通信的机制是事件.system管道的提出不是为了解决system之间的通信.</p>
<h2 id="example-handling-results"><a class="header" href="#example-handling-results">Example: Handling <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>s</a></h2>
<p>One useful application of system piping is to be able to return errors (allowing
the use of Rust's <code>?</code> operator) and then have a separate function for handling
them:</p>
<pre><code class="language-rust no_run noplayground">fn net_receive(mut netcode: ResMut&lt;MyNetProto&gt;) -&gt; std::io::Result&lt;()&gt; {
    netcode.send_updates(/* ... */)?;
    netcode.receive_updates(/* ... */)?;

    Ok(())
}

fn handle_io_errors(
    In(result): In&lt;std::io::Result&lt;()&gt;&gt;,
    // we can also have regular system parameters
    mut commands: Commands,
) {
    if let Err(e) = result {
        eprintln!("I/O error occurred: {}", e);
        // Maybe spawn some error UI or something?
        commands.spawn((/* ... */));
    }
}</code></pre>
<p>Such functions cannot be <a href="programming//programming/app-builder.html">added</a> individually as systems (Bevy
doesn't know what to do with the input/output). By "piping" them together,
we create a valid system that we can add:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(FixedUpdate, net_receive.pipe(handle_io_errors));</code></pre>
<p>system管道的典型应用场景是返回错误(利用rust的?操作符),然后使用一个单独函数来处理错误.
这个在某些场景非常有用.</p>
<h2 id="performance-warning"><a class="header" href="#performance-warning">Performance Warning</a></h2>
<p>Beware that Bevy treats the whole chain as if it was a single big system, with
all the combined system parameters and their respective data access
requirements. This implies that parallelism could be limited, affecting
performance.</p>
<p>If you create multiple "piped systems" that all contain a common function which
contains any mutable access, that prevents all of them from running in parallel!</p>
<p>因为system组合了很多函数,导致参数多了很多,每个参数都要计算,性能就很差.</p>
<p>如果多个system管道都包含了一个公共函数,而这个公共函数是mut访问数据,
那么这些system不能并行执行.性能就会更差.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="param-sets"><a class="header" href="#param-sets">Param Sets</a></h1>
<p>For safety reasons, a <a href="programming//programming/systems.html">system</a> cannot have multiple parameters
whose data access might have a chance of mutability conflicts over the
same data.</p>
<p>Some examples:</p>
<ul>
<li>Multiple incompatible <a href="programming//programming/queries.html">queries</a>.</li>
<li>Using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a> while also having other system parameters to access specific data.</li>
<li>…</li>
</ul>
<p>Consider this example <a href="programming//programming/systems.html">system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    mut q_player: Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
    mut q_enemy: Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
) {
    // ...
}</code></pre>
<p>The two <a href="programming//programming/queries.html">queries</a> are both trying to mutably access <code>Health</code>. They
have different <a href="programming//programming/queries.html#query-filters">filters</a>, but what if there are entities that
have both <code>Player</code> and <code>Enemy</code> components? If we know that shouldn't happen, we
can add <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/query/struct.Without.html"><code>Without</code></a> filters, but what if it is actually valid for our game?</p>
<p>Such code will compile (Rust cannot know about Bevy ECS semantics), but will
result in a runtime panic. When Bevy tries to run the system, it will panic with
a message about conflicting system parameters:</p>
<pre><code>thread 'main' panicked at bevy_ecs/src/system/system_param.rs:225:5:
error[B0001]: Query&lt;&amp;mut game::Health, bevy_ecs::query::filter::With&lt;game::Enemy&gt;&gt; in
system game::reset_health accesses component(s) game::Health in a way that conflicts
with a previous system parameter. Consider using `Without&lt;T&gt;` to create disjoint Queries
or merging conflicting Queries into a `ParamSet`.
</code></pre>
<p>Bevy provides a solution: wrap any incompatible parameters in a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    // access the health of enemies and the health of players
    // (note: some entities could be both!)
    mut set: ParamSet&lt;(
        Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
        Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
        // also access the whole world ... why not
        &amp;World,
    )&gt;,
) {
    // set health of enemies (use the 1st param in the set)
    for mut health in set.p0().iter_mut() {
        health.hp = 50.0;
    }

    // set health of players (use the 2nd param in the set))
    for mut health in set.p1().iter_mut() {
        health.hp = 100.0;
    }

    // read some data from the world (use the 3rd param in the set)
    let my_resource = set.p2().resource::&lt;MyResource&gt;();
}</code></pre>
<p>This ensures only one of the conflicting parameters can be used at the same time.
Bevy will now happily run our system.</p>
<p>The maximum number of parameters in a param set is 8.</p>
<p>system的多个入参不能对同一数据有竞争访问.<br />
多个不兼容的query;同时拥有&amp;world(独占世界)和其他数据的访问.</p>
<p>rust是不知道的bevy的ECS语义的,所以system入参竞争是无法通过编译器报告出来的,
运行时会导致panic.</p>
<p>bevy提供了一个方法: 使用ParamSet将不兼容的入参封装一下.
这样bevy会保证在同一时间只会有个一个竞争参数在使用.</p>
<p>ParamSet最大参数个数为8.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="non-send-resources"><a class="header" href="#non-send-resources">Non-Send Resources</a></h1>
<p>"Non-send" refers to data types that must only be accessed from the "main
thread" of the application. Such data is marked by Rust as <code>!Send</code> (lacking
the <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> trait).</p>
<p>Some (often system) libraries have interfaces that cannot be safely used from
other threads. A common example of this are various low-level OS interfaces
for things like windowing, graphics, or audio. If you are doing advanced
things like creating a Bevy plugin for interfacing with such things, you
may encounter the need for this.</p>
<p>Normally, Bevy works by running all your <a href="programming//programming/systems.html">systems</a> on a
thread-pool, making use of many CPU cores. However, you might need to ensure
that some code always runs on the "main thread", or access data that is not
safe to access in a multithreaded way.</p>
<p>Non-Send资源,意味只能从主线程访问指定类型的数据.rust会将这些数据标记为<code>!Send</code>.</p>
<p>很多底层OS接口都不能在多线程中安全切换,eg:窗口,图像,音频.</p>
<p>通常bevy运行system是利用线程池来运行,以提高多核CPU的利用率.</p>
<p>部分场景下,部分代码是需要一直跑在主线程中的,还有多线程访问数据是不安全的.</p>
<h2 id="non-send-systems-and-data-access"><a class="header" href="#non-send-systems-and-data-access">Non-Send Systems and Data Access</a></h2>
<p>To do this, you can use a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a> system parameter.
This behaves just like <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, letting you access an ECS
<a href="programming//programming/res.html">resource</a> (single global instance of some data), except that the
presence of such a parameter forces the Bevy scheduler to always run the
<a href="programming//programming/systems.html">system</a> on the main thread. This ensures that data never has to be
sent between threads or accessed from different threads.</p>
<p>One example of such a resource is <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> in Bevy.  This is the
low-level layer behind the <a href="programming//window/props.html">window entities</a> that you typically use
for window management. It gives you more direct access to OS window management
functionality.</p>
<pre><code class="language-rust no_run noplayground">fn setup_raw_window(
    q_primary: Query&lt;Entity, With&lt;PrimaryWindow&gt;&gt;,
    mut windows: NonSend&lt;WinitWindows&gt;
) {
    let raw_window = windows.get_window(q_primary.single());
    // do some special things using `winit` APIs
}</code></pre>
<pre><code class="language-rust no_run noplayground">// just add it as a normal system;
// Bevy will notice the NonSend parameter
// and ensure it runs on the main thread
app.add_systems(Startup, setup_raw_window);</code></pre>
<p>Non-Send system和数据访问.<code>NonSend&lt;T&gt;, NonSendMut&lt;T&gt;</code>这是访问资源的升级版,
添加的约束是system只在主函数中运行.</p>
<p>另一个常见的就是WinitWindows资源,是窗口实体背后窗口管理器的后端,
只能在主线程访问.</p>
<p>只需要指定NonSend,bevy在检查system参数时就会明白这个system是主线程跑的.</p>
<h2 id="custom-non-send-resources"><a class="header" href="#custom-non-send-resources">Custom Non-Send Resources</a></h2>
<p>Normally, to insert <a href="programming//programming/res.html">resources</a>, their types must be <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a>.</p>
<p>Bevy tracks non-Send resources separately, to ensure that they can only be
accessed using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>.</p>
<p>It is not possible to insert non-send resources using
<a href="programming//programming/commands.html"><code>Commands</code></a>, only using <a href="programming//programming/world.html">direct World access</a>. This
means that you have to initialize them in an <a href="programming//programming/exclusive.html">exclusive system</a>,
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impl, or from the <a href="programming//programming/app-builder.html">app builder</a>.</p>
<pre><code class="language-rust no_run noplayground">fn setup_platform_audio(world: &amp;mut World) {
    // assuming `OSAudioMagic` is some primitive that is not thread-safe
    let instance = OSAudioMagic::init();

    world.insert_non_send_resource(instance);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_platform_audio);</code></pre>
<p>Or, for simple things, if you don't need a full-blown system:</p>
<pre><code class="language-rust no_run noplayground">app.insert_non_send_resource(OSAudioMagic::init());</code></pre>
<p>If you just need to write a <a href="programming//programming/systems.html">system</a> that must run on
the main thread, but you don't actually have any data to store,
you can use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/core/struct.NonSendMarker.html"><code>NonSendMarker</code></a> as a dummy.</p>
<pre><code class="language-rust no_run noplayground">fn my_main_thread_system(
    marker: NonSend&lt;NonSendMarker&gt;,
    // ...
) {
    // TODO: do stuff ...
}</code></pre>
<p>自定义Non-Send资源.</p>
<p>一般添加的资源都是Send的(可在多线程访问的).</p>
<p>自定义的Non-Send资源只能通过world直接访问,Commands是无法添加这类资源的.</p>
<p>world直接访问意味着:独占system/FromWorld/app三种途径可以实现.
<code>world.insert_non_send_resource()</code>.</p>
<p>还有一种情况,system没有特别的入参,可使用<code>NonSend&lt;NonSendMarker&gt;</code>来告诉bevy,
system运行在主线程上.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-render-gpu-framework"><a class="header" href="#bevy-render-gpu-framework">Bevy Render (GPU) Framework</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>This chapter covers Bevy's rendering framework and how to work with the GPU.</p>
<p>Make sure you are well familiar with <a href="/programming.html">Bevy's Core Programming
Framework</a>. Everything here builds on top of it.</p>
<p>Here you will learn how to write custom rendering code. If you are simply
interested in using the existing graphical features provided by Bevy, check
out the chapters about <a href="/graphics.html">General Graphics Features</a>,
<a href="/2d.html">2D</a>, and <a href="/3d.html">3D</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="gpu//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="render-architecture-overview"><a class="header" href="#render-architecture-overview">Render Architecture Overview</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>The current Bevy render architecture premiered in Bevy 0.6. The <a href="https://bevyengine.org/news/bevy-0-6">news blog
post</a> is another place you can learn about it. :)</p>
<p>It was inspired by the Destiny Render Architecture (from the Destiny game).</p>
<h2 id="pipelined-rendering-1"><a class="header" href="#pipelined-rendering-1">Pipelined Rendering</a></h2>
<p>Bevy's renderer is architected in a way that operates independently from all
the normal app logic. It operates in its own separate <a href="gpu//programming/world.html">ECS World</a>
and has its own <a href="gpu//programming/app-builder.html">schedule</a>, with <a href="gpu//gpu/stages.html">stages</a> and
<a href="gpu//programming/systems.html">systems</a>.</p>
<p>The plan is that, in a future Bevy version, the renderer will run in parallel
with all the normal app logic, allowing for greater performance. This is
called "pipelined rendering": rendering the previous frame at the same time
as the app is processing the next frame update.</p>
<p>Every frame, the two parts are synchronized in a special <a href="gpu//programming/schedules.html">stage</a>
called "Extract". The Extract stage has access to both <a href="gpu//programming/world.html">ECS Worlds</a>,
allowing it to copy data from the main World into the render World.</p>
<p>From then on, the renderer only has access to the render World, and can only
use data that is stored there.</p>
<p>Every frame, all <a href="gpu//programming/intro-data.html#entities--components">entities</a> in the render World are erased, but
<a href="gpu//programming/res.html">resources</a> are kept. If you need to persist data from frame to
frame, store it in resources. Dynamic data that could change every frame
should be copied into the render world in the Extract stage, and typically
stored using entities and components.</p>
<p><img src="gpu/../img/pipelined-rendering.png" alt="Diagram of pipelined rendering timings in app-bound and render-bound cases" /></p>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<p>The renderer operates in multiple <a href="gpu//gpu/stages.html">render stages</a>. This
is how the work that needs to be performed on the CPU is managed.</p>
<p>The ordering of the workloads to be performed on the GPU is controlled
using the <a href="gpu//TODO.html">render graph</a>. The graph consists of
<a href="gpu//TODO.html">nodes</a>, each representing a workload for the GPU,
typically a <a href="gpu//TODO.html">render pass</a>. The nodes are connected using
<a href="gpu//TODO.html">edges</a>, representing their ordering/dependencies
with regard to one another.</p>
<h2 id="layers-of-abstraction"><a class="header" href="#layers-of-abstraction">Layers of Abstraction</a></h2>
<p>The Bevy rendering framework can accomodate you working at various different
levels of abstraction, depending on how much you want to integrate with the
Bevy ecosystem and built-in features, vs. have more direct control over the GPU.</p>
<p>For most things, you would be best served by the "high-level" or "mid-level" APIs.</p>
<h3 id="low-level"><a class="header" href="#low-level">Low-Level</a></h3>
<p>Bevy works directly with <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a>, a Rust-based cross-platform
graphics API. It is the abstraction layer over the GPU APIs of the underlying
<a href="gpu//platforms.html">platform</a>. This way, the same GPU code can work on all
supported platforms. The API design of <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> is based on
the WebGPU standard, but with extensions to support native platform features,
going beyond the limitations of the web platform.</p>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Backends (in order of priority)</th></tr></thead><tbody>
<tr><td>Linux</td><td>Vulkan, GLES3</td></tr>
<tr><td>Windows</td><td>DirectX 12, Vulkan, GLES3</td></tr>
<tr><td>macOS</td><td>Metal</td></tr>
<tr><td>iOS</td><td>Metal</td></tr>
<tr><td>Android</td><td>Vulkan, GLES3</td></tr>
<tr><td>Web</td><td>WebGPU, WebGL2</td></tr>
</tbody></table>
</div>
<p>On GLES3 and WebGL2, some renderer features are unsupported and performance is worse.</p>
<p>WebGPU is experimental and few browsers support it.</p>
<p><code>wgpu</code>是rust编写的图形库,实现了WebGPU规范,为web和原生应用提供了跨平台一致的api,
性能很高,相比WebGL,WebGPU更加底层,对于GPU是直接访问,性能和灵活性都高很多.
跨平台是wgpu的特点,目前安卓到linux/web/macOS/windows都是支持的.
是下一代图形处理技术.复杂图形渲染/三维实时可视化场景下是强项,
适用于游戏开发/数据可视化/科学计算.<code>可以说bevy能起飞,wgpu就是核心基石之一</code>.
wgpu跨平台,Vulkan(通用跨平台图像库,下一代的技术)/Metal(Apple)/D3D12(windows)/
OpenGL/WebGL2和WebGPU(wasm),所以可以跨平台.</p>
<p>从上面的表格上看各个平台都有了支持.未来不知道是否可以支持主机平台.</p>
<p><code>wgpu</code> forms the "lowest level" of Bevy rendering. If you really need the
most direct control over the GPU, you can pretty much use <code>wgpu</code> directly,
from within the Bevy render framework.</p>
<h3 id="mid-level"><a class="header" href="#mid-level">Mid-Level</a></h3>
<p>On top of <code>wgpu</code>, Bevy provides some abstractions that can help you, and
integrate better with the rest of Bevy.</p>
<p>The first is <a href="gpu//TODO.html">pipeline caching</a> and
<a href="gpu//TODO.html">specialization</a>. If you create your
<a href="gpu//TODO.html">render pipelines</a> via this interface, Bevy can manage
them efficiently for you, creating them when they are first used, and then
caching and reusing them, for optimal performance.</p>
<p>Caching and specialization are, analogously, also available for <a href="gpu//TODO.html">GPU Compute
pipelines</a>.</p>
<p>Similar to the <a href="gpu//TODO.html">pipeline cache</a>, there is a <a href="gpu//TODO.html">texture
cache</a>. This is what you use for rendering-internal
<a href="gpu//TODO.html">textures</a> (for example: shadow maps, reflection maps,
…), that do not originate from <a href="gpu//assets.html">assets</a>. It will manage and
reuse the GPU memory allocation, and free it when it becomes unused.</p>
<p>For using data from <a href="gpu//assets.html">assets</a>, Bevy provides the <a href="gpu//TODO.html">Render
Asset</a> abstraction to help with extracting the data from
different <a href="gpu//builtins.html#assets">asset types</a>.</p>
<p>Bevy can manage all the "objects to draw" using <a href="gpu//TODO.html">phases</a>,
which sort and draw <a href="gpu//TODO.html">phase items</a>. This way, Bevy
can sort each object to render, relative to everything else in the scene,
for optimal performance and correct transparency (if any).</p>
<p>Phase Items are defined using <a href="gpu//TODO.html">render commands</a>
and/or <a href="gpu//TODO.html">draw functions</a>. These are, conceputally,
the rendering equivalents of ECS <a href="gpu//programming/systems.html">systems</a> and <a href="gpu//programming/exclusive.html">exclusive
systems</a>, fetching data from the ECS World and generating
<a href="gpu//TODO.html">draw calls</a> for the GPU.</p>
<p>All of these things fit into the core architecture of the Bevy <a href="gpu//TODO.html">render
graph</a> and <a href="gpu//gpu/stages.html">render stages</a>. During
the Render stage, <a href="gpu//TODO.html">graph nodes</a> will execute <a href="gpu//TODO.html">render
passes</a> with the <a href="gpu//TODO.html">render phases</a>,
to draw everything as it was set up in the Prepare/Queue/PhaseSort stages.</p>
<p>The <code>bevy_core_pipeline</code> crate defines a set of <a href="gpu//TODO.html">standard
phase/item</a> and main pass types. If you can, you
should work with them, for best compatibility with the Bevy ecosystem.</p>
<h3 id="high-level"><a class="header" href="#high-level">High-Level</a></h3>
<p>On top of all the mid-level APIs, Bevy provides abstractions to make many
common kinds of workloads easier.</p>
<p>The most notable higher-level features are <a href="gpu//TODO.html">meshes</a> and
<a href="gpu//TODO.html">materials</a>.</p>
<p>Meshes are the source of per-vertex data (<a href="gpu//TODO.html">vertex
attributes</a>) to be fed into
your <a href="gpu//TODO.html">shaders</a>. The material specifies what
<a href="gpu//TODO.html">shaders</a> to use and any other data that needs to be
fed into it, like <a href="gpu//TODO.html">textures</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="gpu//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="render-stages"><a class="header" href="#render-stages">Render Stages</a></h1>
<p>Everything on the CPU side (the whole process of driving the GPU workloads)
is structured in a sequence of "render stages":</p>
<p>这里的渲染阶段都是指在CPU端发生的,用于驱动GPU工作任务.</p>
<h2 id="timings"><a class="header" href="#timings">Timings</a></h2>
<p>Note: Pipelined rendering is not yet actually enabled in Bevy 0.9. This section
explains the intended behavior, which will land in a future Bevy version. You
have to understand it, because any custom rendering code you write will have to
work with it in mind.</p>
<p><img src="gpu/../img/pipelined-rendering.png" alt="Diagram of pipelined rendering timings in app-bound and render-bound cases" /></p>
<p>Every frame, <a href="gpu/stages.html#extract">Extract</a> serves as the synchronization point.</p>
<p>When the Render Schedule completes, it will start again, but Extract will
wait for the App Schedule, if it has not completed yet. The App Schedule
will start again as soon as Extract has completed.</p>
<p>Therefore:</p>
<ul>
<li>in an App-bound scenario (if app takes longer than render):
<ul>
<li>The start of Extract is waiting for App to finish</li>
</ul>
</li>
<li>in a Render-bound scenario (if render takes longer than app):
<ul>
<li>The start of App is waiting for Extract to finish</li>
</ul>
</li>
</ul>
<p>If <a href="gpu//window/props.html#vsync">vsync</a> is enabled, the wait for the next refresh of the
screen will happen in the <a href="gpu/stages.html#prepare">Prepare</a> stage. This has the effect of
prolonging the Prepare stage in the Render schedule. Therefore, in practice,
your game will behave like the "Render-bound" scenario shown above.</p>
<p>The final render (the framebuffer with the pixels to show in the
<a href="gpu//window/props.html">window</a>) is <em>presented</em> to the OS/driver at the end of the
<a href="gpu/stages.html#render">Render</a> stage.</p>
<p>Bevy updates its <a href="gpu//fundamentals/time.html">timing information</a> (in <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a>)
at the start of the First stage in the main App schedule. The value to
use is measured at "presentation time", in the render world, and the
<a href="https://doc.rust-lang.org/stable/std/time/struct.Instant.html"><code>Instant</code></a> is sent over a channel, to be applied on the
next frame.</p>
<p>本篇写的是bevy v0.9时代,那时管道渲染还没有enable,后续版本会启用.
只要是写自定义渲染的,需要明白本文的全部.</p>
<p>同步点:在每帧中,不管是app world和render world哪个运行时间长,以长的为单位,
结束后都会执行<code>外部调度</code>,在外部调度阶段会将app数据同步到render中,这个点就是同步点.</p>
<p>同步点之前是游戏逻辑执行;之后是渲染.两个同步点间是app逻辑和上帧的渲染逻辑并行执行.</p>
<p>如果启用了垂直同步,则等待屏幕的下一次刷新将发生在准备阶段.
这会延长渲染计划中的准备阶段.实际看起来render时长(每帧运行花费时间)会被app时长要长.</p>
<p>最终的渲染是让OS/显卡驱动来呈现的.</p>
<p>参与到<code>渲染</code>的阶段很多,第一步就是计算render时长和app时长,
bevy会将每帧的时间信息放到<code>Time</code>资源中,这个动作是在app的Main调度中完成的.
在render world中,这个值用于计算每帧渲染时长,
这个信息放在Instant(对单调非递减时钟的测量)中, 通过通道发给bevy,应用在下一帧.</p>
<h2 id="adding-systems-to-render-stages"><a class="header" href="#adding-systems-to-render-stages">Adding Systems to Render Stages</a></h2>
<p>If you are implementing custom rendering functionality in Bevy, you will likely
need to add some of your own systems to at least some of the render stages:</p>
<ul>
<li>
<p>Anything that needs data from your main App World will need a system in
<a href="gpu/stages.html#extract">Extract</a> to copy that data. In practice, this is almost everything,
unless it is fully contained on the GPU, or only uses renderer-internal
generated data.</p>
</li>
<li>
<p>Most use cases will need to do some setup of GPU resources
in <a href="gpu/stages.html#prepare">Prepare</a> and/or <a href="gpu/stages.html#queue">Queue</a>.</p>
</li>
<li>
<p>In <a href="gpu/stages.html#cleanup">Cleanup</a>, all <a href="gpu//programming/intro-data.html#entities--components">entities</a> are cleared automatically.
If you have some custom data stored in <a href="gpu//programming/res.html">resources</a>, you can let it
stay for the next frame, or add a system to clear it, if you want.</p>
</li>
</ul>
<p>The way Bevy is set up, you shouldn't need to do anything in <a href="gpu/stages.html#render">Render</a>
or <a href="gpu/stages.html#phasesort">PhaseSort</a>. If your custom rendering is part of the Bevy
<a href="gpu//TODO.html">render graph</a>, it will just be handled automatically
when Bevy executes the render graph in the <a href="gpu/stages.html#render">Render</a> stage. If you
are implementing custom <a href="gpu//TODO.html">phase items</a>, the Main Pass
render graph node will render them together with everything else.</p>
<p>You can add your rendering systems to the respective stages, using the render
<a href="gpu//programming/app-builder.html#sub-apps">sub-app</a>:</p>
<pre><code>// TODO: code example
</code></pre>
<p>bevy默认的渲染已经将该有的system添加到了对应的调度中,
如果有自定义渲染的功能,需要将这些system添加到如下调度中:</p>
<ul>
<li>要从app传数据到render的,需要在外部调度中添加拷贝数据的system</li>
<li>部分场景还需要在渲染的Prepare准备阶段或渲染任务队列阶段构造GPU资源</li>
<li>在渲染清理阶段,所有实体会自动清理掉.如果有自定义数据存储在资源中,按需清除</li>
</ul>
<p>在实际的渲染Render阶段和排序PhaseSort阶段,不需要我们介入.</p>
<h2 id="extract"><a class="header" href="#extract">Extract</a></h2>
<p>Extract is a very important and special stage. It is the synchronization
point that links the two ECS Worlds. This is where the data required for
rendering is copied ("extracted") from the main App World into the Render
World, allowing for pipelined rendering.</p>
<p>During the Extract stage, nothing else can run in parallel, on either the
main App World or the Render World. Hence, Extract should be kept minimal
and complete its work as quickly as possible.</p>
<p>It is recommended that you avoid doing any computations in Extract, if
possible. Just copy data.</p>
<p>It is recommended that you only copy the data you actually need for rendering.
Create new <a href="gpu//programming/ec.html#components">component types</a> and <a href="gpu//programming/res.html">resources</a> just
for use within the render World, with only the data you need.</p>
<p>For example, Bevy's 2D sprites uses a <a href="https://docs.rs/bevy/0.9.1/bevy/sprite/struct.ExtractedSprite.html"><code>struct ExtractedSprite</code></a>, where it copies the relevant data
from the "user-facing" components of sprite and spritesheet entities in the
main World.</p>
<p>Bevy <strong>reserves Entity IDs</strong> in the render World, matching all the Entities
existing in the main World. In most cases, you do not need to <em>spawn</em>
new entities in the render World. You can just <a href="gpu//programming/commands.html">insert components with
Commands</a> on the same Entity IDs as from the main World.</p>
<pre><code>// TODO: code example
</code></pre>
<p>外部调度负责同步数据到render world.</p>
<h2 id="prepare"><a class="header" href="#prepare">Prepare</a></h2>
<p>Prepare is the stage to use if you need to set up any data on the
GPU. This is where you can create GPU <a href="gpu//TODO.html">buffers</a>,
<a href="gpu//TODO.html">textures</a>, and <a href="gpu//TODO.html">bind groups</a>.</p>
<p>// TODO: elaborate on different ways Bevy is using it internally</p>
<pre><code>// TODO: code example
</code></pre>
<p>准备阶段,可以构造GPU要使用的数据.</p>
<h2 id="queue"><a class="header" href="#queue">Queue</a></h2>
<p>Queue is the stage where you can set up the "rendering jobs" you will need to
execute.</p>
<p>Typically, this means creating <a href="gpu//TODO.html">phase items</a>
with the correct <a href="gpu//TODO.html">render pipeline</a> and <a href="gpu//TODO.html">draw
function</a>, for everything that you need to draw.</p>
<p>For other things, analogously, Queue is where you would set up the workloads
(like compute or draw calls) that the GPU would need to perform.</p>
<p>// TODO: elaborate on different ways Bevy is using it internally</p>
<pre><code>// TODO: code example
</code></pre>
<p>入队阶段,可以构造要执行的渲染任务.</p>
<h2 id="phasesort"><a class="header" href="#phasesort">PhaseSort</a></h2>
<p>This stage exists for Bevy to sort all of the <a href="gpu//TODO.html">phase
items</a> that were set up during the <a href="gpu/stages.html#queue">Queue</a>
stage, before rendering in the <a href="gpu/stages.html#render">Render</a> stage.</p>
<p>It is unlikely that you will need to add anything custom here. I'm not aware
of use cases. <a href="gpu//contact.html">Let me know</a> if you know of any.</p>
<p>排序阶段:对所有已解析的渲染任务(入队阶段添加的渲染任务)进行排序.</p>
<h2 id="render"><a class="header" href="#render">Render</a></h2>
<p>Render is the stage where Bevy executes the <a href="gpu//TODO.html">Render Graph</a>.</p>
<p>The built-in behavior is configured using Cameras. For each active Camera,
Bevy will execute its associated render graph, configured to output to its
associated render target.</p>
<p>If you are using any of the <a href="gpu//TODO.html">standard render phases</a>,
you don't need to do anything. Your custom <a href="gpu//TODO.html">phase items</a>
will be rendered automatically as part of the Main Pass built-in render graph
<a href="gpu//TODO.html">nodes</a>, alongside everything else.</p>
<p>If you are implementing a rendering feature that needs a separate step, you
can add it as a <a href="gpu//TODO.html">render graph node</a>, and it will be
rendered automatically.</p>
<p>The only time you might need to do something custom here is if you really
want to sidestep Bevy's frameworks and reach for low-level <code>wgpu</code> access.
You could place it in the Render stage.</p>
<p>实际渲染阶段,由bevy按渲染图执行.</p>
<p>这里会根据相机配置来进行渲染,每个相机都有自己的渲染图,
bevy会对每个渲染图进行操作,之后将结果输出到相机配置的渲染目标上.</p>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>Bevy has a built-in system in Cleanup that clears all <a href="gpu//programming/intro-data.html#entities--components">entities</a> in
the render World. Therefore, all data stored in components will be lost.
It is expected that fresh data will be obtained in the next frame's
<a href="gpu/stages.html#extract">Extract</a> stage.</p>
<p>To persist rendering data over multiple frames, you should store it in
<a href="gpu//programming/res.html">resources</a>. That way you have control over it.</p>
<p>If you need to clear some data from your resources sometimes, you could
add a custom system to the Cleanup stage to do it.</p>
<pre><code>// TODO: code example
</code></pre>
<p>清理阶段. 有自定数据存在资源中要清理的,在这个阶段清理.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="programming-patterns"><a class="header" href="#programming-patterns">Programming Patterns</a></h1>
<p>This chapter is about any non-obvious tricks, programming techniques,
patterns and idioms, that may be useful when programming with Bevy.</p>
<p>These topics are an extension of the topics covered in the <a href="/programming.html">Bevy Programming
Framework</a> chapter. See that chapter to learn the
foundational concepts.</p>
<p>Some of the things covered in this chapter might be controversial or only useful
to specific use cases. Don't take this chapter as teaching "general best
practice".</p>
<p>这里介绍的是一些bevy常用的花招/编程技术/泛式/习惯.
这不是适合每个场景的,都是针对特殊场景的一些优解,在其他场景可能就不行了.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="generic-systems"><a class="header" href="#generic-systems">Generic Systems</a></h1>
<p>Bevy <a href="patterns//programming/systems.html">systems</a> are just plain rust functions, which means they
can be generic. You can add the same system multiple times, parametrized to
work on different Rust types or values.</p>
<p>bevy的system是函数,可以进行泛化,这样可以多次添加system,支持具体类型有差异而已.</p>
<h2 id="generic-over-component-types"><a class="header" href="#generic-over-component-types">Generic over Component types</a></h2>
<p>You can use the generic type parameter to specify what
<a href="patterns//programming/ec.html#components">component</a> types (and hence what <a href="patterns//programming/ecs-intro.html">entities</a>)
your <a href="patterns//programming/systems.html">system</a> should operate on.</p>
<p>This can be useful when combined with Bevy <a href="patterns//programming/states.html">states</a>.
You can do the same thing to different sets of entities depending on state.</p>
<p>组件类型泛化,前提是system能支持泛化的组件.</p>
<p>结合state,可对不同state的实体做同样的事.</p>
<h3 id="example-cleanup"><a class="header" href="#example-cleanup">Example: Cleanup</a></h3>
<p>One straightforward use-case is for cleanup. We can make a generic cleanup
system that just despawns all entities that have a certain component
type. Then, trivially run it on exiting different states.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::component::Component;

fn cleanup_system&lt;T: Component&gt;(
    mut commands: Commands,
    q: Query&lt;Entity, With&lt;T&gt;&gt;,
) {
    for e in q.iter() {
        commands.entity(e).despawn_recursive();
    }
}</code></pre>
<p>Menu entities can be tagged with <code>cleanup::MenuExit</code>, entities from the game
map can be tagged with <code>cleanup::LevelUnload</code>.</p>
<p>We can add the generic cleanup system to our state transitions, to take care
of the respective entities:</p>
<pre><code class="language-rust no_run noplayground">/// Marker components to group entities for cleanup
mod cleanup {
    use bevy::prelude::*;
    #[derive(Component)]
    pub struct LevelUnload;
    #[derive(Component)]
    pub struct MenuClose;
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_state(AppState::MainMenu)
        // add the cleanup systems
        .add_system_set(SystemSet::on_exit(AppState::MainMenu)
            .with_system(cleanup_system::&lt;cleanup::MenuClose&gt;))
        .add_system_set(SystemSet::on_exit(AppState::InGame)
            .with_system(cleanup_system::&lt;cleanup::LevelUnload&gt;))
        .run();
}</code></pre>
<h2 id="using-traits"><a class="header" href="#using-traits">Using Traits</a></h2>
<p>You can use this in combination with Traits, for when you need some sort of
varying implementation/functionality for each type.</p>
<p>泛型system可以结合特型.</p>
<h3 id="example-bevys-camera-projections"><a class="header" href="#example-bevys-camera-projections">Example: Bevy's Camera Projections</a></h3>
<p>(this is a use-case within Bevy itself)</p>
<p>Bevy has a <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/trait.CameraProjection.html"><code>CameraProjection</code></a> trait. Different
projection types like <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>
and <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> implement that
trait, providing the correct logic for how to respond to resizing the window,
calculating the projection matrix, etc.</p>
<p>There is a generic system <code>fn camera_system::&lt;T: CameraProjection + Component&gt;</code>, which handles all the cameras with a given projection type. It
will call the trait methods when appropriate (like on window resize events).</p>
<p>The <a href="patterns//cookbook/custom-projection.html">Bevy Cookbook Custom Camera Projection
Example</a> shows this API in action.</p>
<p>相机投影是特型,正交/透视是两个实现,system的泛化参数可以指定为特型,
调度添加system时再决定具体类型,极大提高了灵活性.</p>
<h2 id="using-const-generics"><a class="header" href="#using-const-generics">Using Const Generics</a></h2>
<p>Now that Rust has support for Const Generics, functions can also be
parametrized by values, not just types.</p>
<pre><code class="language-rust no_run noplayground">fn process_layer&lt;const LAYER_ID: usize&gt;(
    // system params
) {
    // do something for this `LAYER_ID`
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(process_layer::&lt;1&gt;)
        .add_system(process_layer::&lt;2&gt;)
        .add_system(process_layer::&lt;3&gt;)
        .run();
}</code></pre>
<p>Note that these values are static / constant at compile-time. This can be
a severe limitation. In some cases, when you might suspect that you could
use const generics, you might realize that you actually want a runtime value.</p>
<p>If you need to "configure" your system by passing in some data, you could,
instead, use a <a href="patterns//programming/res.html">Resource</a> or <a href="patterns//programming/local.html">Local</a>.</p>
<p>Note: As of Rust 1.65, support for using <code>enum</code> values as const generics is
not yet stable. To use <code>enum</code>s, you need Rust Nightly, and to enable the
experimental/unstable feature (put this at the top of your <code>main.rs</code> or
<code>lib.rs</code>):</p>
<pre><code class="language-rust no_run noplayground">#![feature(adt_const_params)]</code></pre>
<p>常量泛化,使用const修饰,编译期会将常量和system绑定在一起.
和配置不同,常量泛化是代码中的硬编码,因为是常量所以运行期不能修改.</p>
<p>如果是配置,一样可以将数据传递给system,不同的场景可以使用不同的实现方案.
配置可以存放在资源或local中.</p>
<p>从rust v1.65开始就支持了enum,这也是个非常灵活的狠角色,
用enum作为常量泛化还不稳定,但现在bevy都是v0.14了,大多例子都是enum.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="component-storage-tablesparse-set"><a class="header" href="#component-storage-tablesparse-set">Component Storage (Table/Sparse-Set)</a></h1>
<p>Bevy ECS provides two different ways of storing data: tables and sparse sets.
The two storage kinds offer different performance characteristics.</p>
<p>The kind of storage to be used can be chosen per <a href="patterns//programming/ec.html#components">component</a>
type.  When you derive the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait, you can
specify it. The default, if unspecified, is table storage. You can have
components with a mixture of different storage kinds on the same entity.</p>
<p>The rest of this page is dedicated to explaining the performance trade-offs
and why you might want to choose one storage kind vs. the other.</p>
<pre><code class="language-rust no_run noplayground">/// Component for entities that can cast magic spells
#[derive(Component)] // Use the default table storage
struct Mana {
    mana: f32,
}

/// Component for enemies that currently "see" the player
/// Every frame, add/remove to entities based on visibility
/// (use sparse-set storage due to frequent add/remove)
#[derive(Component)]
#[component(storage = "SparseSet")]
struct CanSeePlayer;

/// Component for entities that are currently taking bleed damage
/// Add to entities to apply bleed effect, remove when done
/// (use sparse-set storage to not fragment tables,
/// as this is a "temporary effect")
#[derive(Component)]
#[component(storage = "SparseSet")]
struct Bleeding {
    damage_rate: f32,
}</code></pre>
<p>bevy的ecs支持两种不同的存储:表格和稀疏集.
每种组件类型都可以选择自己的存储类型.默认是表格.
同一个实体是可以同时使用不同存储的.</p>
<h2 id="table-storage"><a class="header" href="#table-storage">Table Storage</a></h2>
<p>Table storage is optimized for fast <a href="patterns//programming/queries.html">query</a> iteration. If the
way you usually use a specific component type is to iterate over its data
across many entities, this will offer the best performance.</p>
<p>However, adding/removing table components to existing entities is a relatively
slow operation. It requires copying the data of all table components for
the entity to a different location in memory.</p>
<p>It's OK if you have to do this sometimes, but if you are likely to add/remove
a component very frequently, you might want to switch that component type
to sparse-set storage.</p>
<p>You can see why table storage was chosen as Bevy's default. Most component
types are rarely added/removed in practice. You typically spawn entities with
all the components they should have, and then access the data via queries,
usually every frame. Sometimes you might add or remove a component to change
an entity's behavior, but probably not nearly as often, or every frame.</p>
<p>表格存储的特点是迭代查询非常快.这种模式下增删很慢,因为涉及到所有表格数据的移动.
频繁增删使用表格存储就是灾难.</p>
<p>默认就是表格存储,因为大多数场景下,动态增删是一个低频操作.</p>
<h2 id="sparse-set-storage"><a class="header" href="#sparse-set-storage">Sparse-Set Storage</a></h2>
<p>Sparse-Set storage is optimized for fast adding/removing of a component to
existing entities, at the cost of slower querying. It can be more efficient
for components that you would like to add/remove very frequently.</p>
<p>An example of this might be a <a href="patterns//programming/ec.html#marker-components">marker component</a>
indicating whether an enemy is currently aware of the player. You might
want to have such a component type, so that you can easily use a <a href="patterns//programming/queries.html#query-filters">query
filter</a> to find all the enemies that are currently
tracking the player. However, this is something that can change every frame,
as enemies or the player move around the game level. If you add/remove this
component every time the visibility status changed, that's a lot of additions
and removals.</p>
<p>You can see that situations like these are more niche and do not apply
to most typical component types. Treat sparse-set storage as a potential
optimization you could try in specific circumstances.</p>
<p>Even in situations like the example above, it might not be a performance win.
Everything depends on your application's unique usage patterns. You have to
measure and try.</p>
<p>稀疏集存储就是增删非常快,query慢.</p>
<p>如果组件就是临时性的,频繁增删,就使用这个.</p>
<p>使用存储来提高性能,还不如优化游戏逻辑来得快.</p>
<h2 id="table-fragmentation"><a class="header" href="#table-fragmentation">Table Fragmentation</a></h2>
<p>Furthermore, the actual memory layout of the "tables" depends on the set of
all table components that each of your entities has.</p>
<p>ECS queries perform best when many of the entities they match have the same
overall set of components.</p>
<p>Having a large number of entities, that all have the same component types, is
very efficient in terms of data access performance. Having diverse entities
with a varied mixture of different component types, means that their data
will be fragmented in memory and be less efficient to access.</p>
<p>Sparse-Set components do not affect the memory layout of tables. Hence,
components that are only used on a few entities or as a "temporary effect",
might also be good candidates for sparse-set storage. That way they don't
fragment the memory of the other (table) components. Systems that do not
care about these components will be completely unaffected by them existing.</p>
<p>如果大量实体都有某个组件,按这个组件查询,效率会非常高.</p>
<p>大量不连续的实体,性能就只能退化为普通的了.</p>
<h2 id="overall-advice"><a class="header" href="#overall-advice">Overall Advice</a></h2>
<p>While this page describes the general performance characteristics and gives
some guidelines, you often cannot know if something improves performance
without benchmarking.</p>
<p>When your game grows complex enough and you have something to benchmark,
you could try to apply sparse-set storage to situations where it might make
sense, as described above, and see how it affects your results.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="manual-event-clearing"><a class="header" href="#manual-event-clearing">Manual Event Clearing</a></h1>
<p>The <a href="patterns//programming/events.html">event</a> queue needs to be cleared periodically,
so that it does not grow indefinitely and waste unbounded memory.</p>
<p>Bevy's default cleanup strategy is to clear events every frame, but with double
buffering, so that events from the previous frame update stay available. This
means that you can handle the events only until the end of the next frame
after the one when they are sent.</p>
<p>This default works well for systems that run every frame and check for events
every time, which is the typical usage pattern.</p>
<p>However, if you have systems that do not read events every frame, they might
miss some events. Some common scenarios where this occurs are:</p>
<ul>
<li>systems with an early-return, that don't read events every time they run</li>
<li>when using <a href="patterns//fundamentals/fixed-timestep.html">fixed timestep</a></li>
<li>systems that only run in specific <a href="patterns//programming/states.html">states</a>,
such as if your game has a pause state</li>
<li>when using custom <a href="patterns//programming/run-criteria.html">run criteria</a> to control
your systems</li>
</ul>
<p>To be able to reliably manage events in such circumstances, you might want
to have manual control over how long the events are held in memory.</p>
<p>You can replace Bevy's default cleanup strategy with your own.</p>
<p>To do this, simply add your event type (wrapped as <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a>)
to the <a href="patterns//programming/app-builder.html">app builder</a> using <code>.init_resource</code>, instead of <code>.add_event</code>.</p>
<p>(<code>.add_event</code> is actually just a convenience method that initializes the
<a href="patterns//programming/res.html">resource</a> and adds Bevy's built-in system (<a href="patterns//patterns/generic-systems.html">generic</a>
over your event type) for the default cleanup strategy)</p>
<p>You must then clear the events at your discretion. If you don't do this often
enough, your events might pile up and waste memory.</p>
<p>手动清理事件,事件队列会定时清理,所以不用担心内存泄漏.</p>
<p>bevy是默认每帧都清理事件,单因为执行顺序,可能部分事件会跨两帧.
要处理事件就必须在下帧结束之前处理.</p>
<p>同理,处理事件最好每帧都执行,但很多场景下并不是每帧都执行检测.</p>
<ul>
<li>固定时间戳</li>
<li>system在检测逻辑之前提前返回了</li>
<li>system只在特定state运行</li>
<li>system有运行条件</li>
</ul>
<p>在上面的场景中,需要手动控制事件的清理.bevy提供了便捷的方法:
在app中用初始化资源代替添加事件,参数为资源(具体类型是事件),
bevy识别到后,知道遇到这个事件就丢到对应的资源中.</p>
<p>之后需要手动清理事件,不然就会出现内存泄漏.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We can create <a href="patterns//patterns/generic-systems.html">generic systems</a> for this. Implement
the custom cleanup strategy, and then add that <a href="patterns//programming/systems.html">system</a> to your
<a href="https://docs.rs/bevy/0.9.1/bevy/app/struct.App.html"><code>App</code></a> as many times as you need, for each <a href="patterns//programming/events.html">event</a> type
where you want to use your custom behavior.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::event::Events;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // add the `Events&lt;T&gt;` resource manually
        // these events will not have automatic cleanup
        .init_resource::&lt;Events&lt;MySpecialEvent&gt;&gt;() // 初始化资源,入参为事件
        // this is a regular event type with automatic cleanup
        .add_event::&lt;MyRegularEvent&gt;()
        // add the cleanup systems
        .add_system(my_event_manager::&lt;MySpecialEvent&gt;) // 事件处理
        .run();
}

/// Custom cleanup strategy for events
///
/// Generic to allow using for any custom event type
fn my_event_manager&lt;T: 'static + Send + Sync&gt;(mut events: ResMut&lt;Events&lt;T&gt;&gt;) {
    // TODO: implement your custom logic
    // for deciding when to clear the events

    // 下面是事件处理
    // clear all events like this:
    events.clear();

    // or with double-buffering
    // (this is what Bevy's default strategy does)
    events.update();

    // or drain them, if you want to iterate,
    // to access the values:
    for event in events.drain() {
        // TODO: do something with each event
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="writing-tests-for-systems"><a class="header" href="#writing-tests-for-systems">Writing Tests for Systems</a></h1>
<p>You might want to write and run automated tests for your <a href="patterns//programming/systems.html">systems</a>.</p>
<p>You can use the regular Rust testing features (<code>cargo test</code>) with Bevy.</p>
<p>To do this, you can create an empty ECS <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a> in your
tests, and then, using <a href="patterns//programming/world.html">direct World access</a>, insert whatever
<a href="patterns//programming/ec.html#entities">entities</a> and <a href="patterns//programming/res.html">resources</a> you need for testing. Create
a standalone <a href="patterns//programming/schedules.html">stage</a> with the <a href="patterns//programming/systems.html">systems</a> you want to
run, and manually run it on the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>Bevy's official repository has a fantastic <a href="https://github.com/bevyengine/bevy/blob/main/tests/how_to_test_systems.rs">example of how to do
this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="bevy-on-different-platforms"><a class="header" href="#bevy-on-different-platforms">Bevy on Different Platforms</a></h1>
<p>This chapter is a collection of platform-specific information, about using
Bevy with different operating systems or environments.</p>
<p>Feel free to suggest things to add.</p>
<p>本章介绍一些不同平台的信息.</p>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h2>
<p>Bevy aims to also make it easy to target different platforms, such as the
various desktop operating systems, web browsers (via WebAssembly), mobile
(Android and iOS), and game consoles. Your Bevy code can be the same for all
platforms, with differences only in the build process and environment setup.</p>
<p>However, that vision is not fully met yet. Currently, support for non-desktop
platforms is limited, and requires more complex configuration.</p>
<p>Bevy的目的是针对不同的平台,让其操作简单,
比如不同的台式操作系统/web浏览器(通过WebAssembly)/移动端(Android和iOS)/以及游戏控制台.</p>
<p>所有的平台上,你的Bevy代码可以是一样的,除了构建过程及环境启动时的差异.
然而, 目前版本还没有完全满足上面情况.现在对非台式机平台的支持时有限的,
并且还要求更复杂的配置.</p>
<h3 id="desktop"><a class="header" href="#desktop">Desktop</a></h3>
<p>Bevy trivially works out-of-the-box on the three major desktop operating
systems: Linux, macOS, Windows. No special configuration is required.</p>
<p>Bevy工作在三种主流的台式机操作系统: Linux, macOS, Windows. 不需要特别的配置.</p>
<p>See the following pages for specific tips/advice when developing for the
desktop platforms:</p>
<ul>
<li><a href="/platforms/linux.html">Linux</a></li>
<li><a href="/platforms/macos.html">macOS</a></li>
<li><a href="/platforms/windows.html">Windows</a></li>
</ul>
<p>All Bevy features are fully supported on each of the above.</p>
<p>You can also build Windows EXEs for your Windows users, if you are working
in <a href="/setup/cross/linux-windows.html">Linux</a> or <a href="/setup/cross/macos-windows.html">macOS</a>.</p>
<p>桌面系统, Bevy的全部特性均被支持.
如果你工作在linux或MacOS上,你也可以为Windows用户构建Windows EXEs.</p>
<h3 id="web"><a class="header" href="#web">Web</a></h3>
<p>Bevy works quite well on the <a href="/platforms/wasm.html">web (using WebAssembly)</a>,
but with some limitations.</p>
<p>Multithreading is not supported, so you will have limited performance and
possible audio glitches. Rendering is limited to the features of the WebGL2
API, meaning worse performance and limitations like only supporting a maximum
of 256 lights in 3D scenes. These limitations can be lifted by enabling the
new WebGPU support, but then you will have limited browser compatibility.</p>
<p>For inspiration, check out the entries in the Bevy Game Jams
(<a href="https://itch.io/jam/bevy-jam-3/entries">third</a>, <a href="https://itch.io/jam/bevy-jam-2/entries">second</a>, <a href="https://itch.io/jam/bevy-jam-1/entries">first</a>). Many
of them have web builds you can play in your browser.</p>
<p>Bevy在web平台使用WebAssembly运行得很好,但是也有一些限制.</p>
<p>不支持多线程,所以你只有限定的性能,和可能的audio glitches(
音频故障audio glitch通常指音频播放或录制过程中出现的短暂/不正常的声音干扰).</p>
<p>渲染受限于WebGL2 API的特性,这意味着更糟的性能和限制,比如在3D场景中,
最大只支持256 lights.启用新的WebGPU支持后,这些限制能被改善,
但这也意味着你将拥有有限的浏览器兼容性.</p>
<h3 id="mobile"><a class="header" href="#mobile">Mobile</a></h3>
<p>Apple iOS is well-supported and most features work well. There are developers
in the Bevy community that have successfully shipped Bevy-based apps to the
App Store.</p>
<p>Android support is not as good as iOS, but very usable (as of Bevy 0.12). If
you find bugs, broken features, or other issues, please report them.</p>
<p>Bevy has been known to have issues with emulator devices. It is recommended
you test your app on real hardware.</p>
<p>很好地支持Apple iOS,很多特性运行得不错.
Bevy社区有些开发者已经成功地将基于Bevy的apps发布到App Store上.</p>
<p>Android支持没有IOS那么好, 但也是可用的(如Bevy0.12)
据称, Bevy在模拟设备上有些问题. 建议你在真实硬件上测试你的app.</p>
<h3 id="game-consoles"><a class="header" href="#game-consoles">Game Consoles</a></h3>
<p>Unfortunately, due to NDA requirements, developing for consoles is inaccessible
to most community developers who work in the open, and Bevy support is still
mostly nonexistent.</p>
<p>At some point, there was someone in the community working on PlayStation
support. I do not know if they are still around, or anything about the
status of that work. If you are interested, join <a href="https://discord.gg/bevy">Discord</a>
and ask around. Maybe you can find each other and work together.</p>
<p>The Rust Programming Language aims to make Nintendo Switch a supported target,
but that work is in its early days and has not progressed enough to be useful
for Bevy yet. It should be possible to work on Nintendo Switch support in
the open, without NDAs, using emulators.</p>
<p>The Steam Deck, and other such "handheld PCs", are well supported. Such
devices run special versions of standard Desktop OSs (Linux, Windows) and are
designed to support PC games out of the box. To develop for these devices,
just make regular Linux/Windows builds of your game and ideally try them on
an actual device, so you can see how the handheld experience is like and make
sure your game feels good on such a device.</p>
<p>不幸的是,由于NDA需求(保密协议,Non-Disclosure Agreement),
对于很多开放社区的开发者而言,基于控制台的研发是不可获得的.</p>
<p>Rust编程语言致力于支持Nintendo Switch,但是工作进展仍然停留在早期阶段,
并没有太多的进展,使其可用于Bevy.</p>
<p>Steam Deck和其他的一些手柄PCs,被很好地支持.
这些设备运行在特定版本的桌面OSs内.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="linux-desktop"><a class="header" href="#linux-desktop">Linux Desktop</a></h1>
<p>If you have any additional Linux-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Desktop Linux is one of the best-supported platforms by Bevy.</p>
<p>There are some development dependencies you may need to setup, depending on your
distribution. <a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">See instructions in official Bevy repo.</a></p>
<p><a href="platforms//setup/cross/linux-windows.html">See here if you also want to build Windows EXEs from Linux</a>.</p>
<p>linux桌面是bevy支持最好的.不同的发行版本只需要安装一些必要的以来就可以愉快玩耍了.</p>
<h2 id="gpu-drivers-1"><a class="header" href="#gpu-drivers-1">GPU Drivers</a></h2>
<p>Bevy apps need support for the Vulkan graphics API to run best. There is a
fallback on OpenGL ES 3 for systems where Vulkan is unsupported, but it might not
work and will have limited features and performance.</p>
<p>You (and your users) must ensure that you have compatible hardware and drivers
installed. On most modern distributions and computers, this should be no problem.</p>
<p>If Bevy apps refuse to run and print an error to the console about not being
able to find a compatible GPU, the problem is most likely with the Vulkan
components of your graphics driver not being installed correctly. You may
need to install some extra packages or reinstall your graphics drivers. Check
with your Linux distribution for what to do.</p>
<p>To confirm that Vulkan is working, you can try to run this command (found in
a package called <code>vulkan-tools</code> on most distributions):</p>
<pre><code class="language-sh">vulkaninfo
</code></pre>
<p>bevy对vulkan图形api支持的最好.(vulkan是一个组织维护的标准,wgpu/等多个标准都是她维护的).
其次是OpenGl ES3, 这个是性能和功能上比vulkan差了一截.</p>
<p>一般只要安装好驱动,基本没啥大问题.
如果app运行报错说没有找到兼容的GPU,一般是vulkan驱动没有正确安装.
重新安装vulkan驱动.使用<code>vulkaninfo</code>命令来检查vulkan的运行状态.</p>
<h2 id="x11-and-wayland"><a class="header" href="#x11-and-wayland">X11 and Wayland</a></h2>
<p>As of the year 2023, the Linux desktop ecosystem is fragmented between
the legacy X11 stack and the modern Wayland stack. Many distributions are
switching to Wayland-based desktop environments by default.</p>
<p>Bevy supports both, but only X11 support is enabled by default. If you are
running a Wayland-based desktop, this means your Bevy app will run in the
XWayland compatibility layer.</p>
<p>To enable native Wayland support for Bevy, enable the <code>wayland</code> cargo feature:</p>
<pre><code class="language-toml">[dependencies]
bevy = { version = "0.12", features = ["wayland"] }
</code></pre>
<p>Now your app will be built with support for both X11 and Wayland.</p>
<p>If you want to remove X11 support for whatever reason, you will have to disable
the default features and re-enable everything you need, without the <code>x11</code>
feature. <a href="platforms//setup/bevy-config.html">See here to learn how to configure Bevy features.</a></p>
<p>If both are enabled, you can override which display protocol to use at runtime,
using an environment variable:</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=x11
</code></pre>
<p>(to run using X11/XWayland on a Wayland desktop)</p>
<p>or</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=wayland
</code></pre>
<p>(to require the use of Wayland)</p>
<p>x11和wayland是linux的桌面后端,x11几十年了,稳定; wayland是新标准,更加现代化和高效.
bevy默认是支持x11的,因为使用x11的多.</p>
<p>如果两个都启用了,那么使用环境变量来选择桌面后端,如上面的例子.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="macos-desktop"><a class="header" href="#macos-desktop">macOS Desktop</a></h1>
<p>If you have any additional macOS-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p><a href="platforms//setup/cross/macos-windows.html">See here if you also want to build Windows EXEs from macOS</a>.</p>
<h2 id="known-pitfalls-3"><a class="header" href="#known-pitfalls-3">Known Pitfalls</a></h2>
<h3 id="input-peculiarities"><a class="header" href="#input-peculiarities">Input Peculiarities</a></h3>
<p><a href="platforms//input/mouse.html#mouse-scrolling--wheel">Mouse wheel scrolling</a> behaves in a peculiar manner,
because macOS does "scroll acceleration" at the OS level. Other OSs, with
regular PC mice, provide <code>Line</code> scroll events with whole number values, where
1.0 corresponds to one step on the scroll wheel. macOS scales the value
depending on how fast the user is spinning the wheel. You do not get whole
numbers. They can range anywhere from tiny values &lt;0.1 (for the starting event,
before the scroll speed ramps up), up to values as big as &gt;10.0 (say, for a fast
flick of the wheel), per event.</p>
<p>macOS provides <a href="platforms//input/mouse.html#touchpad-gestures">special events for touchpad gestures</a>
for zooming and rotation, which you can handle in Bevy.</p>
<p>Some keyboard keys have a somewhat-unintuitive mapping:</p>
<ul>
<li>The Command (⌘) key is <code>KeyCode::{SuperLeft, SuperRight}</code>.</li>
<li>The Option (⌥) key is <code>KeyCode::{AltLeft, AltRight}</code>.</li>
</ul>
<p>Other key codes have their intuitive names.</p>
<h3 id="window-management-apps-compatability"><a class="header" href="#window-management-apps-compatability">Window Management Apps Compatability</a></h3>
<p>Bevy apps can encounter performance issues (such as lag when dragging the window
around the screen) when window management apps like "Magnet" are used. This is a
bug in <code>winit</code> (the OS window management library that Bevy uses). This issue can
be tracked <a href="https://github.com/rust-windowing/winit/issues/1737">here</a>.</p>
<p>Until that bug is fixed, advise closing the window management apps, if
encountering performance issues.</p>
<h2 id="creating-an-application-bundle"><a class="header" href="#creating-an-application-bundle">Creating an Application Bundle</a></h2>
<p>When you build your Bevy project normally, cargo/Rust will produce a bare
executable file, similar to other operating systems. However, this is not how
"normal" macOS apps look and behave. You probably want to create a proper
native-feeling Mac app for distribution to your users.</p>
<p>You need to do this, to have your app play nicely with the Mac desktop GUI, such
as to have a nice icon appear in the dock.</p>
<p>macOS applications are typically stored on the filesystem as "bundles" – special
directories/folders that end in <code>.app</code>, that the OS displays to the user as one
item. macOS expects to find a special hieararchy of subfolders and files inside.</p>
<p>A minimal app bundle might have the following files:</p>
<ul>
<li><code>MyGame.app/Contents/MacOS/MyGame</code>: the actual executable file</li>
<li><code>MyGame.app/Contents/MacOS/assets/</code>: your Bevy assets folder</li>
<li><code>MyGame.app/Contents/Info.plist</code>: metadata (see below)</li>
<li><code>MyGame.app/Contents/Resources/AppIcon.icns</code>: the app's icon</li>
</ul>
<p>Only the executable file is technically mandatory. If you have nothing else, the
app will run, as long as the executable file name matches the app bundle file
name. You should, however, follow the below instructions, if you want to make a
proper nice Mac app. :)</p>
<h3 id="executable-file"><a class="header" href="#executable-file">Executable File</a></h3>
<p>The executable file produced by the Rust compiler (in the <code>target</code> directory) is
a single-architecture binary for your current development machine. You could
just copy this file into the app bundle, but then you will not support all Mac
hardware natively.</p>
<p>If you want to support both machines with Intel CPUs and with Apple Silicon
(Arm) CPUs, you need to compile for both of them, and then combine them into a
single executable using Apple's <code>lipo</code> tool.</p>
<p>First, make sure you have Rust toolchain support for both architectures installed:</p>
<pre><code class="language-sh">rustup target add x86_64-apple-darwin
rustup target add aarch64-apple-darwin
</code></pre>
<p>Now, you can compile for both architectures:</p>
<pre><code class="language-sh">cargo build --release --target x86_64-apple-darwin
cargo build --release --target aarch64-apple-darwin
</code></pre>
<p>Now, you can combine the two executables into one, for your app bundle.</p>
<pre><code class="language-sh">lipo "target/x86_64-apple-darwin/release/my_game" \
     "target/aarch64-apple-darwin/release/my_game" \
     -create -output "MyGame.app/Contents/MacOS/MyGame"
</code></pre>
<p>Note: please ensure the Bevy <code>dynamic_linking</code> cargo feature is <em><strong>not</strong></em> enabled.</p>
<h3 id="game-assets"><a class="header" href="#game-assets">Game Assets</a></h3>
<p>Your Bevy <code>assets</code> folder needs to be placed alongside the executable file,
for Bevy to find it and be able to load your assets. Just copy it into
<code>Contents/MacOS</code> in your app bundle.</p>
<p>Note: This is not the standard conventional location as prescribed by Apple.
Typically, macOS apps store their data files in <code>Contents/Resources</code>. However,
Bevy will not find them there. Thankfully, Apple does not enforce this, so we
are free to do something unusual when we have to.</p>
<h3 id="infoplist"><a class="header" href="#infoplist"><code>Info.plist</code></a></h3>
<p>This file contains all the metadata that macOS wants.</p>
<p>If you do not create this file, or if it is missing some of the fields, macOS
will try to guess them, so your app can still run. Ideally, you want to create a
proper <code>Info.plist</code> file, to prevent issues.</p>
<p><a href="platforms//dl/Info.plist">Download an example file as a starting point.</a></p>
<p>You can edit this file using Apple XCode or a text editor. Check that all the
values make sense for your app. Pay special attention to these values:</p>
<ul>
<li><code>CFBundleName</code> (Bundle name)
<ul>
<li>Short user-visible name of your app</li>
</ul>
</li>
<li><code>CFBundleDisplayName</code> (Bundle display name)
<ul>
<li>Optional: You can set a longer user-visible name here, if you want</li>
</ul>
</li>
<li><code>CFBundleExecutable</code> (Executable file)
<ul>
<li>The name of the executable file</li>
</ul>
</li>
<li><code>CFIconFile</code> (Icon file)
<ul>
<li>The name of the icon file</li>
</ul>
</li>
<li><code>CFBundleIdentifier</code> (Bundle identifier)
<ul>
<li>Apple wants an ID for your app, in domain format, like: <code>com.mycompany.mygame</code></li>
</ul>
</li>
<li><code>CFBundleShortVersionString</code> (Bundle version string (short))
<ul>
<li>The version of your app, like <code>0.1.0</code>.</li>
</ul>
</li>
</ul>
<h3 id="app-icon"><a class="header" href="#app-icon">App Icon</a></h3>
<p>The icon file needs to be in a special Apple format.</p>
<p>Such a file can be created from a collection of PNGs of different standard sizes
(powers of two). If you want your app to look nice at all sizes, you can
hand-craft an image for each size, following <a href="https://developer.apple.com/design/human-interface-guidelines/app-icons">Apple Design
Guidelines</a>. If you don't care, you can just take one image
(ideally 1024x1024, the biggest size used by macOS) and scale it to different sizes.</p>
<p>Here is a script that does that:</p>
<pre><code class="language-sh">SOURCE_IMAGE="myicon1024.png"
mkdir -p AppIcon.iconset
sips -z 16 16     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_16x16.png
sips -z 32 32     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_16x16@2x.png
sips -z 32 32     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_32x32.png
sips -z 64 64     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_32x32@2x.png
sips -z 128 128   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_128x128.png
sips -z 256 256   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_128x128@2x.png
sips -z 256 256   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_256x256.png
sips -z 512 512   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_256x256@2x.png
sips -z 512 512   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_512x512.png
cp "${SOURCE_IMAGE}" AppIcon.iconset/icon_512x512@2x.png
iconutil -c icns AppIcon.iconset
## move it into the app bundle
mv AppIcon.icns MyGame.app/Contents/Resources
</code></pre>
<p>It works by creating a special <code>iconset</code> folder, with all the PNG files at different
sizes, created by resizing your source image. Then, it uses <code>iconutil</code> to produce
the final Apple ICNS file for your app bundle.</p>
<p>If you want hand-crafted icons for each size, you could use a similar process.
Create an <code>iconset</code> folder with your PNGs, and run <code>iconutil -c icns</code> on it.</p>
<p>Alternatively, Apple XCode has GUI tools for creating and editing app icons.</p>
<h3 id="putting-everything-together"><a class="header" href="#putting-everything-together">Putting Everything Together</a></h3>
<p>Here is a simple shell script to build a Mac app. It follows the recommendations
on this page. Adjust everything as necessary for your project.</p>
<pre><code class="language-sh"># set the name of the Mac App
APP_NAME="MyGame"
# set the name of your rust crate
RUST_CRATE_NAME="my_game"
# create the folder structure
mkdir -p "${APP_NAME}.app/Contents/MacOS"
mkdir -p "${APP_NAME}.app/Contents/Resources"
# copy Info.plist
cp Info.plist "${APP_NAME}.app/Contents/Info.plist"
# copy the icon (assuming you already have it in Apple ICNS format)
cp AppIcon.icns "${APP_NAME}.app/Contents/Resources/AppIcon.icns"
# copy your Bevy game assets
cp -a assets "${APP_NAME}.app/Contents/MacOS/"
# compile the executables for each architecture
cargo build --release --target x86_64-apple-darwin # build for Intel
cargo build --release --target aarch64-apple-darwin # build for Apple Silicon
# combine the executables into a single file and put it in the bundle
lipo "target/x86_64-apple-darwin/release/${RUST_CRATE_NAME}" \
     "target/aarch64-apple-darwin/release/${RUST_CRATE_NAME}" \
     -create -output "${APP_NAME}.app/Contents/MacOS/${APP_NAME}"
</code></pre>
<p>Note: please ensure the Bevy <code>dynamic_linking</code> cargo feature is <em><strong>not</strong></em> enabled.</p>
<h2 id="creating-a-dmg-file"><a class="header" href="#creating-a-dmg-file">Creating a DMG file</a></h2>
<p>It is common for Mac apps downloadable from the internet to be distributed as
DMG files – Apple's "disk image" format. Users can drag-and-drop the app bundle
inside into their <code>Applications</code> folder on their system.</p>
<h3 id="create-dmg"><a class="header" href="#create-dmg"><code>create-dmg</code></a></h3>
<p>If you want to create a fancy DMG file, you can install and use the
<a href="https://github.com/create-dmg/create-dmg"><code>create-dmg</code> tool</a>.</p>
<p>If you are using Homebrew, you can install it easily from there:</p>
<pre><code class="language-sh">brew install create-dmg
</code></pre>
<p>Then, you can use it as follows:</p>
<pre><code class="language-sh">create-dmg \
  --volname "My Bevy Game" \
  --volicon "AppIcon.icns" \
  --background "DMG-background.png" \
  --window-size 800 400 \
  --icon-size 128 \
  --icon "MyGame.app" 200 200 \
  --hide-extension "MyGame.app" \
  --app-drop-link 600 200 \
  "mybevygame_release_mac.dmg" \
  "build/mac/"
</code></pre>
<p>The options are:</p>
<ul>
<li><code>--volname</code>: the name of the device when the user opens the DMG file</li>
<li><code>--volicon</code>: the icon of the device when the user opens the DMG file</li>
<li><code>--background</code>: the background image for the Finder window</li>
<li><code>--window-size</code>: the size of the Finder window</li>
<li><code>--icon-size</code>: the default zoom level (how big the icons should look)</li>
<li><code>--icon</code>: specify the X/Y coordinates where to display a specific file</li>
<li><code>--hide-extension</code>: do not display the file extension for this file</li>
<li><code>--app-drop-link</code>: create a shortcut to Applications for easy drag-and-drop; place at given X/Y coordinates</li>
<li>the name of the DMG file to create</li>
<li>the name of the folder where you have the files to be added to the DMG (your app + anything else you want to add)</li>
</ul>
<h3 id="hdiutil"><a class="header" href="#hdiutil"><code>hdiutil</code></a></h3>
<p>If you don't want to install any special tools, you can create a very simple
DMG file using <code>hdiutil</code>, which comes with macOS:</p>
<pre><code class="language-sh">hdiutil create -fs HFS+ \
  -volname "My Bevy Game" \
  -srcfolder "MyGame.app" \
  "mybevygame_release_mac.dmg"
</code></pre>
<p>Specify the Volume Name (how it appears when opened), the name of your app
bundle, and the name of the output DMG file, respectively. You can use
<code>-srcfolder</code> multiple times, if you want to add more files and folders to the
DMG image.</p>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<p>If you want to create a DMG file using a GUI, you can use Apple's "Disk
Utility" app that comes preinstalled with macOS. Then, just use Finder to
set up everything inside how you like it.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="windows-desktop"><a class="header" href="#windows-desktop">Windows Desktop</a></h1>
<p>If you have any additional Windows-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Windows is one of the best-supported platforms by Bevy.</p>
<p>Both the MSVC and the GNU compiler toolchains should work.</p>
<p>You can also build Windows EXEs while working in <a href="platforms//setup/cross/linux-windows.html">Linux</a>
or <a href="platforms//setup/cross/macos-windows.html">macOS</a>.</p>
<p>If you want to work inside WSL2, see <a href="platforms//platforms/windows/wsl2.html">this guide</a>.</p>
<h2 id="distributing-your-app"><a class="header" href="#distributing-your-app">Distributing Your App</a></h2>
<p>The EXE built with <code>cargo build</code> can work standalone without any extra files or DLLs.</p>
<p>Your <code>assets</code> folder needs be distributed alongside it. Bevy will search for it in
the same directory as the EXE on the user's computer.</p>
<p>The easiest way to give your game to other people to play is to put them
together in a ZIP file. If you use some other method of installation,
install the <code>assets</code> folder and the EXE to the same path.</p>
<p>If built with the MSVC toolchain, your users may need the Microsoft C/C++
Runtime Redistributables installed.</p>
<h3 id="dxc-compiler-support"><a class="header" href="#dxc-compiler-support">DXC Compiler Support</a></h3>
<p>Bevy (technically <code>wgpu</code>) supports using the Microsoft DXC compiler for
improved shader compilation when using DirectX 12.</p>
<p>To do this, you need to <a href="https://github.com/microsoft/DirectXShaderCompiler/releases/latest">download it from Microsoft's
repo</a> and put <code>dxcompiler.dll</code> and <code>dxil.dll</code>
alongside your game's EXE.</p>
<p>Bevy should detect these DLL files automatically and use them.</p>
<h2 id="disabling-the-windows-console"><a class="header" href="#disabling-the-windows-console">Disabling the Windows Console</a></h2>
<p>By default, when you run a Bevy app (or any Rust program for that matter)
on Windows, a Console window also shows up. To disable this,
place this Rust attribute at the top of your <code>main.rs</code>:</p>
<pre><code class="language-rust no_run noplayground">#![windows_subsystem = "windows"]</code></pre>
<p>This tells Windows that your executable is a graphical application, not a
command-line program. Windows will know not display a console.</p>
<p>However, the console can be useful for development, to see log messages.
You can disable it only for release builds, and leave it enabled in debug
builds, like this:</p>
<pre><code class="language-rust no_run noplayground">#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]</code></pre>
<h2 id="creating-an-icon-for-your-app"><a class="header" href="#creating-an-icon-for-your-app">Creating an icon for your app</a></h2>
<p>There are two places where you might want to put your application icon:</p>
<ul>
<li>The EXE file (how it looks in the file explorer)</li>
<li>The window at runtime (how it looks in the taskbar and the window title bar)</li>
</ul>
<h3 id="setting-the-exe-icon"><a class="header" href="#setting-the-exe-icon">Setting the EXE icon</a></h3>
<p>(adapted from <a href="https://github.com/NiklasEi/bevy_game_template">here</a>)</p>
<p>The EXE icon can be set using a cargo build script.</p>
<p>Add a build dependency of <code>embed_resources</code> to your <code>Cargo.toml</code> allow embedding assets into your compiled executables</p>
<pre><code class="language-toml">[build-dependencies]
embed-resource = "1.6.3"
</code></pre>
<p>Create a <code>build.rs</code> file in your project folder:</p>
<pre><code class="language-rust no_run noplayground">extern crate embed_resource;

fn main() {
    let target = std::env::var("TARGET").unwrap();
    if target.contains("windows") {
        embed_resource::compile("icon.rc");
    }
}</code></pre>
<p>Create a <code>icon.rc</code> file in your project folder:</p>
<pre><code>app_icon ICON "icon.ico"
</code></pre>
<p>Create your icon as <code>icon.ico</code> in your project folder.</p>
<h3 id="setting-the-window-icon-1"><a class="header" href="#setting-the-window-icon-1">Setting the Window Icon</a></h3>
<p>See: <a href="platforms//window/icon.html">Setting the Window Icon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/windows//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h2 id="working-in-wsl2"><a class="header" href="#working-in-wsl2">Working in WSL2</a></h2>
<p>If you prefer to have a more Linux-centric development workflow, you might want
to work inside of WSL2 and build your project there. Another reason to do it is
compile times; they are often much faster in WSL2 than on the Windows host
system. Linux has faster I/O and filesystem than Windows, and that makes a big
difference to compile times.</p>
<h3 id="cross-compiling-to-run-windows-native"><a class="header" href="#cross-compiling-to-run-windows-native">Cross-compiling to run Windows Native</a></h3>
<p>The recommended way to run your Bevy app from WSL is to <a href="platforms/windows//setup/cross/linux-windows.html">cross-compile for
Windows</a>. The Windows EXE you build inside of WSL2 can
be run just fine from the Linux commandline, and it will seamlessly run on the
host system! This way, you don't need any GPU drivers or GUI support inside
your WSL2 Linux environment. Also, you will be running and testing the Windows
build of your game, so you can see how it will really perform on Windows.
It will run with full performance and use your host Windows GPU drivers.</p>
<p>Note that when you run Windows binaries from WSL2, they don't get the Linux
environment variables. <code>cargo run</code> does not just work, because your Bevy game
will look for its <code>assets</code> folder in the path where the EXE is (which would be
in the <code>target</code> build output folder). My simple solution is to just copy the
EXE into the project folder after building, and run it directly from there.
For non-Bevy Rust projects, this would be unnecessary.</p>
<p>The process can be automated with a little script, to use instead of <code>cargo run</code>:</p>
<pre><code class="language-sh">#!/bin/sh
cargo build --target x86_64-pc-windows-gnu &amp;&amp;
cp target/x86_64-pc-windows-gnu/debug/mygame.exe . &amp;&amp;
exec ./mygame.exe "$@"
</code></pre>
<p>This way you also don't have to type the cross-compilation target every time
(and you can also add any other options you want there).</p>
<p>Just save the script (you can call it something like <code>win.sh</code>) and run your
game as:</p>
<pre><code class="language-sh">./win.sh
</code></pre>
<h3 id="running-linux-builds-using-wslg"><a class="header" href="#running-linux-builds-using-wslg">Running Linux builds using WSLg</a></h3>
<p>This is an alternative way of running your Bevy game from WSL. It does not
require cross-compilation, but is likely to have other issues and limitations.</p>
<p>Newer installs of WSL2 should have support for WSLg: Microsoft's Linux GUI
support. It should allow you to simply compile your Bevy game in Linux and
run it. WSLg will do the dark magic needed to forward graphics and audio to
the Windows host.</p>
<p>Your game will run locked to 60 FPS, and there will be other performance
problems. WSLg is effectively RDP (Remote Desktop) under the hood. It's
like streaming video from the VM to the host. Some functionality might be
broken/unsupported.</p>
<p>Both Wayland and X11 should work. Wayland is recommended, so be sure to
enable the <code>"wayland"</code> <a href="platforms/windows//setup/bevy-config.html">cargo feature in Bevy</a>.</p>
<p>There are many dependencies (such as graphics drivers) needed for GUI support
in Linux, which are likely missing if you have never used any other GUI app
from your WSL environment. The easiest way to make sure you have everything installed,
is to just install some random Linux GUI app. For example:</p>
<pre><code class="language-sh">sudo apt install gucharmap # the GNOME Character Map app
</code></pre>
<p>It will pull in everything needed for a Linux GUI environment. Bevy should then
also be able to work.</p>
<p>This will be sufficient for OpenGL support. However, to use all features of
Bevy, you need Vulkan. For Vulkan in WSL, it is recommended that you use
a PPA (unofficial repository) to get an updated version of Mesa (graphics
drivers). Here is how to install everything:</p>
<pre><code class="language-sh">sudo add-apt-repository ppa:kisak/kisak-mesa
sudo apt update
sudo apt upgrade
sudo apt install vulkan-tools
</code></pre>
<p>(<code>dzn</code>, Microsoft's Vulkan driver for WSL2, is technically non-conformant,
so there may be bugs and other issues, but it seems to work fine)</p>
<p>Now, you can simply run your Bevy project in Linux in the usual way:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="browser-webassembly"><a class="header" href="#browser-webassembly">Browser (WebAssembly)</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>You can make web browser games using Bevy. This chapter will help you with
the things you need to know to do it. This page gives an overview of Bevy's
Web support.</p>
<p>Your Bevy app will be compiled for WebAssembly (WASM), which allows it to
be embedded in a web page and run inside the browser.</p>
<p>Performance will be limited, as WebAssembly is slower than native code and
does not currently support multithreading.</p>
<p>Not all 3rd-party plugins are compatible. If you need extra unofficial plugins,
you will have to check if they are compatible with WASM.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The same Bevy project, without any special code modifications, can be built
for either web or desktop/native.</p>
<p>However, you will need a "website" with some HTML and JavaScript to contain the
game, so that the browser can load, run, and display it.</p>
<p>For development and testing, this can just be a minimal shim.
It can be easily autogenerated.</p>
<p>To deploy, you will need a server to host your website for other people to
access. You could use GitHub's hosting service: <a href="platforms//platforms/wasm/gh-pages.html">GitHub Pages</a>.
You can also host your game on <a href="platforms//platforms/wasm/itch.html">itch.io</a>.</p>
<h2 id="additional-caveats"><a class="header" href="#additional-caveats">Additional Caveats</a></h2>
<p>When users want to play your game, their browser will need to download the
files. <a href="platforms//platforms/wasm/size-opt.html">Optimizing for size</a> is important, so that your game can
start faster and not waste data bandwidth.</p>
<p>Note: the <code>dynamic_linking</code> <a href="platforms//setup/bevy-config.html">feature flag</a> is not supported for
WASM builds. You cannot use it.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>First, add WASM support to your Rust installation. Using Rustup:</p>
<pre><code class="language-sh">rustup target install wasm32-unknown-unknown
</code></pre>
<h3 id="wasm-server-runner"><a class="header" href="#wasm-server-runner"><code>wasm-server-runner</code></a></h3>
<p>The easiest and most automatic way to get started is the
<a href="https://github.com/jakobhellermann/wasm-server-runner"><code>wasm-server-runner</code></a> tool.
It is great for testing during development.</p>
<p>Install it:</p>
<pre><code class="language-sh">cargo install wasm-server-runner
</code></pre>
<p>Set up <code>cargo</code> to use it, in <code>.cargo/config.toml</code> (in your project folder,
or globally in your user home folder):</p>
<pre><code class="language-toml">[target.wasm32-unknown-unknown]
runner = "wasm-server-runner"
</code></pre>
<p>Alternatively, you can also set the runner using an environment variable:</p>
<pre><code>export CARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER=wasm-server-runner
</code></pre>
<p>Now you can just run your game with:</p>
<pre><code class="language-sh">cargo run --target wasm32-unknown-unknown
</code></pre>
<p>It will automatically run a minimal local webserver and open your game in your browser.</p>
<h3 id="higher-level-tools"><a class="header" href="#higher-level-tools">Higher-level Tools</a></h3>
<p>Here are some higher-level alternatives. These are feature-rich tools that can
do more for you and automate much of your workflow, but are opinionated in how
they work.</p>
<ul>
<li><a href="https://trunkrs.dev">Trunk</a></li>
<li><a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a></li>
</ul>
<h3 id="custom-web-page"><a class="header" href="#custom-web-page">Custom Web Page</a></h3>
<p>If you are a web developer and you want to make your own website where you embed
your Bevy game, <a href="platforms//platforms/wasm/webpage.html">see here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="optimize-for-size"><a class="header" href="#optimize-for-size">Optimize for Size</a></h1>
<p>When serving a WASM binary, the smaller it is, the faster the browser can
download it. Faster downloads means faster page load times and less data
bandwidth use, and that means happier users and happier server hosts. ;)</p>
<p>This page gives some suggestions for how to make your WASM files smaller for
deployment / release builds. You probably don't need small WASM files during
development, and many of these techniques can get in the way of your workflow!
They come at the cost of longer compile times and less debuggability.</p>
<p>Depending on the nature of your application, your mileage may vary, and
performing measurements of binary size and execution speed is recommended.</p>
<p><a href="https://github.com/rustwasm/twiggy">Twiggy</a> is a code size profiler for WASM binaries, which
you can use to make measurements.</p>
<p>For additional information and more techniques, refer to the Code Size
chapter in the <a href="https://rustwasm.github.io/docs/book/reference/code-size.html">Rust WASM book</a>.</p>
<p>Do you know of more WASM size-optimization techniques? Post about them in the
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub Issue Tracker</a> so that they can be added to this page!</p>
<h2 id="compiling-for-size-instead-of-speed"><a class="header" href="#compiling-for-size-instead-of-speed">Compiling for size instead of speed</a></h2>
<p>You can change the optimization profile of the compiler, to tell it to
prioritize small output size, rather than performance.</p>
<p>(although in some rare cases, optimizing for size can actually improve speed)</p>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>These are two different profiles for size optimization. Usually, <code>z</code> produces
smaller files than <code>s</code>, but sometimes it can be the opposite. Measure to
confirm which one works better for you.</p>
<h2 id="link-time-optimization-lto"><a class="header" href="#link-time-optimization-lto">Link-Time Optimization (LTO)</a></h2>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<p>For some big improvements with moderate slowdown to compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = "thin"
</code></pre>
<p>For the biggest improvements at the cost of the slowest compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = true
codegen-units = 1
</code></pre>
<p>LTO tells the compiler to optimize all code together, considering all crates as
if they were one. It may be able to inline and prune functions much more
aggressively. This typically results in smaller size <em>and</em> better performance,
but do measure to confirm. Sometimes, the size can actually be larger.</p>
<h2 id="use-the-wasm-opt-tool"><a class="header" href="#use-the-wasm-opt-tool">Use the <code>wasm-opt</code> tool</a></h2>
<p>The <a href="https://github.com/WebAssembly/binaryen">binaryen</a> toolkit is a set of extra tools for working
with WASM. One of them is <code>wasm-opt</code>. It goes much further than what the
compiler can do, and can be used to further optimize for either speed or size:</p>
<pre><code class="language-shell"># Optimize for size (z profile).
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for size (s profile).
wasm-opt -Os -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O3 -o output.wasm input.wasm

# Optimize for both size and speed.
wasm-opt -O -ol 100 -s 100 -o output.wasm input.wasm
</code></pre>
<p>You should run this command on the final WASM file you deploy to your website,
after <code>wasm-bindgen</code> or other tools. If you run it before, <code>wasm-bindgen</code> can
get confused and panic.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="create-a-custom-web-page"><a class="header" href="#create-a-custom-web-page">Create a Custom Web Page</a></h1>
<p>If you want full control over your website, such as if you are a web developer
and you want to embed your Bevy game into a nice website you made, this page
will offer some tips.</p>
<h2 id="wasm-bindgen"><a class="header" href="#wasm-bindgen"><code>wasm-bindgen</code></a></h2>
<p>This is the "low level" tool for exporting/preparing a Rust WASM binary, so
it can be integrated into HTML/JS. It generates the bridge to JavaScript,
so that Rust/Bevy can work with the browser.</p>
<p>You will need to run it whenever you rebuild your game, to process the WASM
binaries generated by <code>cargo</code>.</p>
<p>You can install it using <code>cargo</code>:</p>
<pre><code class="language-sh">cargo install wasm-bindgen-cli
</code></pre>
<p>Now, to build your game, run:</p>
<pre><code class="language-sh">cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --no-typescript --target web \
    --out-dir ./out/ \
    --out-name "mygame" \
    ./target/wasm32-unknown-unknown/release/mygame.wasm
</code></pre>
<p>You need to provide the path to the compiled WASM binary in cargo's target directory.
It will be renamed according to the <code>--out-name</code> parameter.</p>
<p><code>./out/</code> is the directory where it will place the processed files. You will be
uploading these files to your server. You need to also put the <code>assets</code> folder
there. Bevy will expect to find it alongside the WASM file.</p>
<p>The final list of files for a minimal website will look something like this:</p>
<pre><code>assets/ index.html mygame.js mygame_bg.wasm
</code></pre>
<p>In a more compex website, you might want to have the game files be in a
subdirectory somewhere, and load them from a HTML file elsewhere.</p>
<p>For the HTML file, you can use this as a starting point:</p>
<details>
  <summary>
  <code>index.html</code>
  </summary>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;body style="margin: 0px;"&gt;
  &lt;script type="module"&gt;
    import init from './mygame.js'

    init().catch((error) =&gt; {
      if (!error.message.startsWith("Using exceptions for control flow, don't mind me. This isn't actually an error!")) {
        throw error;
      }
    });
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>Note: change <code>mygame.js</code> above to the actual name of the file outputted by <code>wasm-bindgen</code>.
It will match the <code>--out-name</code> parameter you provided on the commandline.</p>
<p>This minimal <code>index.html</code> will just display the Bevy game, without giving you
much control over the presentation. By default, Bevy will create its own HTML
canvas element to render in.</p>
</details>
<p>You can optionally run tools like <code>wasm-opt</code> on the final WASM file, to
<a href="platforms/wasm//platforms/wasm/size-opt.html">optimize the WASM further for size</a>. Run such tools <em>after</em>
<code>wasm-bindgen</code>, not on the original WASM file. Otherwise, <code>wasm-bindgen</code> will
panic with an error if you give it a file processed with <code>wasm-opt</code>.</p>
<h2 id="embedding-into-a-complex-web-page"><a class="header" href="#embedding-into-a-complex-web-page">Embedding into a complex web page</a></h2>
<p>You probably want control over how/where the game is displayed, so you can place
it on a fancier web page, alongside other content.</p>
<h3 id="iframe"><a class="header" href="#iframe">IFrame</a></h3>
<p>A simple/hacky way is using an IFrame. The advantage is that you don't need any
modifications to the Rust code.</p>
<p>You can create a minimal <code>index.html</code> as was shown previously.</p>
<p>You can then embed that into your larger webpage using a HTML IFrame element:</p>
<pre><code class="language-html">&lt;iframe id="mygame-iframe" src="wasm/index.html" width="1280" height="720"&gt;&lt;/iframe&gt;
</code></pre>
<p>You can place it wherever you like on your web page and style it however you
like using CSS. It is recommended to explicitly specify its dimensions.</p>
<p>Make sure to use the correct path to the HTML file in <code>src</code>. You might want to
rename/move it according to your website's needs.</p>
<h3 id="custom-canvas"><a class="header" href="#custom-canvas">Custom Canvas</a></h3>
<p>A more elegant way to accomplish this is by using your own canvas element. You
don't need a separate HTML file.</p>
<p>Create a HTML canvas and give it an ID string of your choice.</p>
<pre><code class="language-html">&lt;canvas id="mygame-canvas" width="1280" height="720"&gt;&lt;/canvas&gt;
</code></pre>
<p>You can place it wherever you like on your web page and style it however you
like using CSS. It is recommended to explicitly specify its dimensions.</p>
<p>On the Rust side, we need to tell Bevy the ID of the canvas element, so it can
use our canvas instead of trying to create its own.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let mut app = App::new();
    app.add_plugins(DefaultPlugins.set(WindowPlugin {
        primary_window: Some(Window {
            // provide the ID selector string here
            canvas: Some("#mygame-canvas".into()),
            // ... any other window properties ...
            ..default()
        }),
        ..default()
    }));
    // ...
    app.run();
}</code></pre>
<p>Unfortunately, this means if you want to rename the ID of the canvas, you will
have to make sure to update the Rust code and rebuild/redeploy the game.</p>
<h2 id="general-advice"><a class="header" href="#general-advice">General Advice</a></h2>
<p>Bevy WASM binaries are big. Even when [optimized for size][wasm::opt-size], they can be
upwards of 30MB (reduced down to 15MB with <code>wasm-opt</code>).</p>
<p>To make your page fast to load, you might want to delay the loading of the WASM.
Let the user see and interact with the page before you trigger it.</p>
<p>You could use some JavaScript to detect when the user clicks on the canvas, or
have a special button or link to trigger it.</p>
<p>Further, after the WASM loads and your Bevy game is running, your game will
probably want to load assets at runtime. Make sure your assets are
well-compressed/optimized, so they can load quickly. Try to design your game so
that it isn't unresponsive or making the user suffer annoying waits.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="hosting-on-github-pages"><a class="header" href="#hosting-on-github-pages">Hosting on GitHub Pages</a></h1>
<p>GitHub Pages is a hosting service that allows you to publish your website
on GitHub's servers.</p>
<p>For more details, visit the official <a href="https://docs.github.com/en/pages">GitHub Pages
documentation</a>.</p>
<p>Deploying a website (like your WASM game) to GitHub pages is done by
putting the files in a special branch in a GitHub repository. You could
create a separate repository for this, but you could also do it from the
same repository as your source code.</p>
<p>You will need the final website files for deployment.</p>
<hr />
<p>Create an empty branch in your git repository:</p>
<pre><code class="language-shell">git checkout --orphan web
git reset --hard
</code></pre>
<p>You should now be in an empty working directory.</p>
<p>Put all files necessary for hosting, including your HTML, WASM, JavaScript,
and <code>assets</code> files, and commit them into git:</p>
<pre><code class="language-shell">git add *
git commit
</code></pre>
<p>(or better, manually list your files in the above command, in place of the <code>*</code> wildcard)</p>
<p>Push your new branch to GitHub:</p>
<pre><code class="language-shell">git push -u origin web --force
</code></pre>
<p>In the GitHub Web UI, go to the repository settings, go to the "GitHub Pages"
section, then under "Source" pick the branch "web" and the <code>/</code> (root) folder.
Then click "Save".</p>
<p>Wait a little bit, and your site should become available at
<code>https://your-name.github.io/your-repo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h1>
<p>This sub-chapter covers how to set up a Rust toolchain to allow you to build
for a different Operating System than the one you are working on.</p>
<ul>
<li><a href="setup//setup/cross/linux-windows.html">Create Windows EXEs from Linux</a></li>
<li><a href="setup//setup/cross/macos-windows.html">Create Windows EXEs from macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/cross//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="build-windows-exes-from-linux"><a class="header" href="#build-windows-exes-from-linux">Build Windows EXEs from Linux</a></h1>
<p>(also check out the <a href="setup/cross//platforms/windows.html">Windows Platform page</a> for info
about developing for Windows generally)</p>
<p>If you are working in WSL2, please also see <a href="setup/cross//platforms/windows/wsl2.html">this page for additional instructions</a>.</p>
<hr />
<p>Rust offers two different toolchains for building for Windows:</p>
<ul>
<li><a href="setup/cross/linux-windows.html#first-time-setup-msvc">MSVC</a></li>
<li><a href="setup/cross/linux-windows.html#first-time-setup-gnu">GNU</a></li>
</ul>
<p>The instructions on this page use the <code>x86_64</code> architecture, but you could also
set up a toolchain to target <code>i686</code> (32-bit) or <code>aarch64</code> (Windows-on-Arm) the
same way.</p>
<h2 id="first-time-setup-gnu"><a class="header" href="#first-time-setup-gnu">First-Time Setup (GNU)</a></h2>
<p>On many Linux distros, the GNU/MINGW toolchain is the easier option. Your
distro likely provides packages that you can easily install. Also, you do
not need to accept any Microsoft licenses.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-gnu"><a class="header" href="#rust-toolchain-gnu">Rust Toolchain (GNU)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="mingw"><a class="header" href="#mingw">MINGW</a></h3>
<p>The GNU toolchain requires the MINGW environment to be installed. Your distro likely
provides a package for it. Search your distro for a cross-compilation mingw package.</p>
<p>It might be called something like: <code>mingw-w64-x86-64-dev</code>, <code>cross-x86_64-w64-mingw32</code>, etc.,
the name varies in different distros.</p>
<p>You don't need any files from Microsoft.</p>
</details>
<h2 id="first-time-setup-msvc"><a class="header" href="#first-time-setup-msvc">First-Time Setup (MSVC)</a></h2>
<p>The MSVC toolchain is the native Microsoft way to target Windows. It is what
the Rust community usually recommends for targetting the Windows platform. It
may provide better compatibility with Windows DLLs / libraries and tooling.</p>
<p>Even though it is meant to be used on Windows, you can actually set it up
and use it on Linux (and other UNIX-like systems). It requires downloading
the Windows SDKs and accepting the Microsoft license. There is a script to
automate that for you.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-msvc"><a class="header" href="#rust-toolchain-msvc">Rust Toolchain (MSVC)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-msvc
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="microsoft-windows-sdks"><a class="header" href="#microsoft-windows-sdks">Microsoft Windows SDKs</a></h3>
<p>You need to install the Microsoft Windows SDKs, just like when working on
Windows. On Linux, this can be done with an easy script called <code>xwin</code>. You
need to accept Microsoft's proprietary license.</p>
<p>Install <code>xwin</code>:</p>
<pre><code class="language-sh">cargo install xwin
</code></pre>
<p>Now, use <code>xwin</code> to accept the Microsoft license, download all the files
from Microsoft servers, and install them to a directory of your choosing.</p>
<p>(The <code>--accept-license</code> option is to not prompt you, assuming you have already
seen the license. To read the license and be prompted to accept it, omit that
option.)</p>
<p>To install to <code>.xwin/</code> in your home folder:</p>
<pre><code class="language-sh">xwin --accept-license splat --output /home/me/.xwin
</code></pre>
<h3 id="linking-msvc"><a class="header" href="#linking-msvc">Linking (MSVC)</a></h3>
<p>Rust needs to know how to link the final EXE file.</p>
<p>The default Microsoft linker (<code>link.exe</code>) is only available on Windows. Instead,
we need to use the LLD linker (this is also recommended when working on Windows
anyway). Just install the <code>lld</code> package from your Linux distro.</p>
<p>We also need to tell Rust the location of the Microsoft Windows SDK libraries
(that were installed with <code>xwin</code> in <a href="setup/cross/linux-windows.html#microsoft-windows-sdks">the previous step</a>).</p>
<p>Add this to <code>.cargo/config.toml</code> (in your home folder or in your bevy project):</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = "lld"
rustflags = [
  "-Lnative=/home/me/.xwin/crt/lib/x86_64",
  "-Lnative=/home/me/.xwin/sdk/lib/um/x86_64",
  "-Lnative=/home/me/.xwin/sdk/lib/ucrt/x86_64"
]
</code></pre>
<p>Note: you need to specify the correct full absolute paths to the SDK files,
wherever you installed them.</p>
</details>
<h2 id="building-your-project"><a class="header" href="#building-your-project">Building Your Project</a></h2>
<p>Finally, with all the setup done, you can just build your Rust/Bevy projects
for Windows:</p>
<p>GNU:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-gnu --release
</code></pre>
<p>MSVC:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<h2 id="bevy-caveats"><a class="header" href="#bevy-caveats">Bevy Caveats</a></h2>
<p>As of Bevy 0.12, a workaround is needed for building with MSVC. If you
use the MSVC toolchain, the <code>blake3</code> dependency assumes you are building
on Windows and tries to run some EXEs during its build process, which do
not exist in the Linux cross-compilation environment. The solution is
to tell it to not do that and use pure Rust code instead.</p>
<p>Set an environment variable when building:</p>
<pre><code class="language-sh">export CARGO_FEATURE_PURE=1
cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<p>Or add <code>blake3</code> to your <code>Cargo.toml</code> if you want to persist the configuration:</p>
<pre><code class="language-toml">[dependencies]
blake3 = { version = "1.5", features = [ "pure" ] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/cross//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="build-windows-exes-from-macos"><a class="header" href="#build-windows-exes-from-macos">Build Windows EXEs from macOS</a></h1>
<p>(also check out the <a href="setup/cross//platforms/windows.html">Windows Platform page</a> for info
about developing for Windows generally)</p>
<hr />
<p>Rust offers two different toolchains for building for Windows:</p>
<ul>
<li><a href="setup/cross/macos-windows.html#first-time-setup-msvc">MSVC</a></li>
<li><a href="setup/cross/macos-windows.html#first-time-setup-gnu">GNU</a></li>
</ul>
<p>The instructions on this page use the <code>x86_64</code> architecture, but you could also
set up a toolchain to target <code>i686</code> (32-bit) or <code>aarch64</code> (Windows-on-Arm) the
same way.</p>
<h2 id="first-time-setup-gnu-1"><a class="header" href="#first-time-setup-gnu-1">First-Time Setup (GNU)</a></h2>
<p>The GNU/MINGW toolchain is the easier option. It does not need much in terms of
special configuration. Also, you do not need to accept any Microsoft licenses.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-gnu-1"><a class="header" href="#rust-toolchain-gnu-1">Rust Toolchain (GNU)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="mingw-1"><a class="header" href="#mingw-1">MINGW</a></h3>
<p>The GNU toolchain requires the MINGW environment to be installed.</p>
<p>There is a package for it conveniently available in Homebrew. You can
just install it from there:</p>
<pre><code class="language-sh">brew install mingw-w64
</code></pre>
<p>You don't need any files from Microsoft.</p>
</details>
<h2 id="first-time-setup-msvc-1"><a class="header" href="#first-time-setup-msvc-1">First-Time Setup (MSVC)</a></h2>
<p>The MSVC toolchain is the native Microsoft way to target Windows. It is what
the Rust community usually recommends for targetting the Windows platform. It
may provide better compatibility with Windows DLLs / libraries and tooling.</p>
<p>Even though it is meant to be used on Windows, you can actually set it up and
use it on macOS (and Linux, and others). It requires downloading the Windows
SDKs and accepting the Microsoft license. There is a script to automate that for
you.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-msvc-1"><a class="header" href="#rust-toolchain-msvc-1">Rust Toolchain (MSVC)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-msvc
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="microsoft-windows-sdks-1"><a class="header" href="#microsoft-windows-sdks-1">Microsoft Windows SDKs</a></h3>
<p>You need to install the Microsoft Windows SDKs, just like when working on
Windows. This can be done with an easy script called <code>xwin</code>. You need to accept
Microsoft's proprietary license.</p>
<p>Install <code>xwin</code>:</p>
<pre><code class="language-sh">cargo install xwin
</code></pre>
<p>Now, use <code>xwin</code> to accept the Microsoft license, download all the files
from Microsoft servers, and install them to a directory of your choosing.</p>
<p>(The <code>--accept-license</code> option is to not prompt you, assuming you have already
seen the license. To read the license and be prompted to accept it, omit that
option.)</p>
<p>To install to <code>.xwin/</code> in your home folder:</p>
<pre><code class="language-sh">xwin --accept-license splat --disable-symlinks --output /Users/me/.xwin
</code></pre>
<p>On Windows and macOS, the filesystem is case-insensitive. On Linux and BSD, the
filesystem is case-sensitive. <code>xwin</code> was made for Linux, so it tries to work
around this by default, by creating symlinks. On macOS, we need to tell <code>xwin</code>
not to do this, using the <code>--disable-symlinks</code> option.</p>
<h3 id="linking-msvc-1"><a class="header" href="#linking-msvc-1">Linking (MSVC)</a></h3>
<p>Rust needs to know how to link the final EXE file.</p>
<p>The default Microsoft linker (<code>link.exe</code>) is only available on Windows. Instead,
we need to use the LLD linker (this is also recommended when working on Windows
anyway).</p>
<h4 id="installing-lld"><a class="header" href="#installing-lld">Installing LLD</a></h4>
<p>Unfortunately, last I checked, neither <code>brew</code> nor <code>macports</code> offer packages (LLD
is not commonly used when developing for macOS).</p>
<p>We can, however, build it ourselves from source. You need a C++ compiler and
CMake. You probably already have the C++ toolchain installed, if you have
installed Apple XCode development tools.</p>
<p>CMake can be installed from <code>brew</code> (<a href="https://brew.sh">Homebrew</a>):</p>
<pre><code class="language-sh">brew install cmake
</code></pre>
<p>Now, we are ready to compile LLD from the LLVM project:</p>
<p>Note: the <code>--depth=1</code> option to <code>git clone</code> allows us to save a lot of disk
space and download bandwidth, because the LLVM respository is <em>huge</em>.</p>
<pre><code class="language-sh">git clone --depth=1 https://github.com/llvm/llvm-project
cd llvm-project
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=lld -DCMAKE_INSTALL_PREFIX=/usr/local ../llvm
sudo make -j10 install # adjust `-j10` based on your number of CPU cores
cd ../../; rm -rf llvm-project # delete the git repo and build files to free disk space
</code></pre>
<p>This will install it to <code>/usr/local</code>. Change the path above if you would rather
have it somewhere else, to not pollute your macOS or need <code>sudo</code> / root privileges.</p>
<h4 id="using-lld"><a class="header" href="#using-lld">Using LLD</a></h4>
<p>We also need to tell Rust to use our linker, and the location of the Microsoft
Windows SDK libraries (that were installed with <code>xwin</code> in <a href="setup/cross/macos-windows.html#microsoft-windows-sdks">the previous
step</a>).</p>
<p>Add this to <code>.cargo/config.toml</code> (in your home folder or in your bevy project):</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = "/usr/local/bin/lld"
rustflags = [
  "-Lnative=/Users/me/.xwin/crt/lib/x86_64",
  "-Lnative=/Users/me/.xwin/sdk/lib/um/x86_64",
  "-Lnative=/Users/me/.xwin/sdk/lib/ucrt/x86_64"
]
</code></pre>
<p>Note: you need to specify the correct full absolute paths to the SDK files,
wherever you installed them.</p>
</details>
<h2 id="building-your-project-1"><a class="header" href="#building-your-project-1">Building Your Project</a></h2>
<p>Finally, with all the setup done, you can just build your Rust/Bevy projects
for Windows:</p>
<p>GNU:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-gnu --release
</code></pre>
<p>MSVC:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<h2 id="bevy-caveats-1"><a class="header" href="#bevy-caveats-1">Bevy Caveats</a></h2>
<p>As of Bevy 0.12, a workaround is needed for building with MSVC. If you
use the MSVC toolchain, the <code>blake3</code> dependency assumes you are building
on Windows and tries to run some EXEs during its build process, which do
not exist in the Linux cross-compilation environment. The solution is
to tell it to not do that and use pure Rust code instead.</p>
<p>Set an environment variable when building:</p>
<pre><code class="language-sh">export CARGO_FEATURE_PURE=1
cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<p>Or add <code>blake3</code> to your <code>Cargo.toml</code> if you want to persist the configuration:</p>
<pre><code class="language-toml">[dependencies]
blake3 = { version = "1.5", features = [ "pure" ] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="credits"><a class="header" href="#credits">Credits</a></h1>
<p>While the majority of this book was authored by me, Ida Iyes (<code>@inodentry</code>), a
number of folks have made large contributions to help! Thank you all so much! ❤️</p>
<hr />
<ul>
<li>Alice I. Cecile <code>@alice-i-cecile</code>: review, advice, reporting lots of good suggestions</li>
<li>nile <code>@TheRawMeatball</code>: review, useful issue reports</li>
<li><code>@Zaszi</code>: writing the initial draft of the WASM chapter</li>
<li><code>@skairunner</code> and <code>@mirenbharta</code>: developing the Pan+Orbit camera example</li>
</ul>
<p>Thanks to everyone who has submitted <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub issues</a>!</p>
<hr />
<p>Big thanks to all <a href="https://github.com/sponsors/inodentry">sponsors</a>! ❤️</p>
<p>Thanks to you, I can actually keep working on this book, improving and maintaining it!</p>
<hr />
<p>And of course, the biggest thanks goes to the <a href="https://github.com/bevyengine/bevy">Bevy project</a>
itself and its founder, <code>@cart</code>, for creating this awesome community and
game engine in the first place! It makes all of this possible. You literally
changed my life! ❤️</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="contact-me"><a class="header" href="#contact-me">Contact Me</a></h1>
<p>You can find me in the following places:</p>
<ul>
<li>Discord: <code>@iyesgames</code>, old: <code>Ida Iyes#0981</code></li>
<li>Mastodon: <a href="https://mastodon.gamedev.place/@iyes"><code>@iyes@mastodon.gamedev.place</code></a></li>
<li>GitHub: <a href="https://github.com/inodentry"><code>@inodentry</code></a></li>
<li>Reddit: <a href="https://reddit.com/u/iyesgames"><code>iyesgames</code></a></li>
<li>E-mail: iyesgames dot social at gmail (sorry, i'm writing it out like this to avoid spam bots)</li>
</ul>
<p>For improvements or fixes to this book, please file an issue
on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub</a>.</p>
<hr />
<p>If you need help with Bevy or Rust, I offer private tutoring.
Reach out if you are interested, to discuss rates and how I
could best help you. :)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="contributing-to-bevy"><a class="header" href="#contributing-to-bevy">Contributing to Bevy</a></h1>
<p>If you want to help out the Bevy Game Engine project, check out Bevy's
<a href="https://github.com/bevyengine/bevy/blob/main/CONTRIBUTING.md">official contributing guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>当前双语版本对应的是: 3d540e7, 日期: 2024/06/13, 等双语版本整个翻译完之后,再处理原始仓库的更新</code></p>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Be civil. If you need a code of conduct, have a look at Bevy's.</p>
<p>If you have any suggestions for the book, such as ideas for new content, or
if you notice anything that is incorrect or misleading, please file issues in
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">the GitHub repository</a>!</p>
<h2 id="github-issues"><a class="header" href="#github-issues">GitHub Issues</a></h2>
<p>If you want something to be added or changed in the book, <em>file an issue!</em> Tell
me what you want, and I will figure out how to present it in the book. If you
have some code snippet or other thing you want to include, you can
put it in the issue.</p>
<p>That sort of workflow works much better for me, compared to Pull Requests. I am
quite opinionated and meticulous about how everything is presented in the book,
so I often can't just merge/accept things as written by someone else.</p>
<h2 id="github-pull-requests"><a class="header" href="#github-pull-requests">GitHub Pull Requests</a></h2>
<p><strong>PLEASE DO NOT CREATE PULL REQUESTS FOR BOOK CONTENT.</strong></p>
<p>The only exception to this might be trivial fixes. If you are just fixing
a typo or small mistake, or a bug in some code example, that's fine.</p>
<p>If you are adding or changing any of the book content, your PR will probably be
ignored or closed. I will probably treat it like I do issues: go do the thing
myself eventually, and then close your PR.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<p>To avoid complications with copyright and licensing, you agree to provide
any contributions you make to the project under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 No Attribution
License</a>.</p>
<p>Note that this allows your work to be relicensed without preserving your
copyright.</p>
<p>As described previously, the actual published content in the book will be my
own derivative work based on your contributions. I will license it consistently
with the rest of the book; see: <a href="./introduction.html#license">License</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="nagbar.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
