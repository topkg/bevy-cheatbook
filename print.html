<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unofficial Bevy Cheat Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script async defer src="https://buttons.github.io/buttons.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="nagbar.css">
        <link rel="stylesheet" href="sidebar.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="overview.html">Chapter Overview</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="builtins.html">List of Bevy Builtins</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">1.</strong> Bevy Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/guide.html"><strong aria-hidden="true">1.1.</strong> Guided Tour</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook.html"><strong aria-hidden="true">2.</strong> Bevy Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/print-framerate.html"><strong aria-hidden="true">2.1.</strong> Show Framerate</a></li><li class="chapter-item expanded "><a href="cookbook/cursor2world.html"><strong aria-hidden="true">2.2.</strong> Convert cursor to world coordinates</a></li><li class="chapter-item expanded "><a href="cookbook/custom-projection.html"><strong aria-hidden="true">2.3.</strong> Custom Camera Projection</a></li><li class="chapter-item expanded "><a href="cookbook/pan-orbit-camera.html"><strong aria-hidden="true">2.4.</strong> 3D Pan+Orbit Camera</a></li><li class="chapter-item expanded "><a href="cookbook/print-resources.html"><strong aria-hidden="true">2.5.</strong> List All Resource Types</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">3.</strong> Bevy Setup Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="setup/editor.html"><strong aria-hidden="true">3.2.</strong> Text Editor / IDE</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/editor/vscode.html"><strong aria-hidden="true">3.2.1.</strong> Visual Studio Code</a></li><li class="chapter-item expanded "><a href="setup/editor/jetbrains.html"><strong aria-hidden="true">3.2.2.</strong> JetBrains (RustRover, IntelliJ, CLion)</a></li><li class="chapter-item expanded "><a href="setup/editor/kak.html"><strong aria-hidden="true">3.2.3.</strong> Kakoune</a></li><li class="chapter-item expanded "><a href="setup/editor/vim.html"><strong aria-hidden="true">3.2.4.</strong> Vim</a></li><li class="chapter-item expanded "><a href="setup/editor/emacs.html"><strong aria-hidden="true">3.2.5.</strong> Emacs</a></li></ol></li><li class="chapter-item expanded "><a href="setup/bevy-config.html"><strong aria-hidden="true">3.3.</strong> Customizing Bevy (features, modularity)</a></li><li class="chapter-item expanded "><a href="setup/unofficial-plugins.html"><strong aria-hidden="true">3.4.</strong> Community Plugin Ecosystem</a></li><li class="chapter-item expanded "><a href="setup/bevy-tools.html"><strong aria-hidden="true">3.5.</strong> Dev Tools and Editors for Bevy</a></li><li class="chapter-item expanded "><a href="setup/perf.html"><strong aria-hidden="true">3.6.</strong> Performance Tunables</a></li><li class="chapter-item expanded "><a href="setup/bevy-git.html"><strong aria-hidden="true">3.7.</strong> Using bleeding-edge Bevy (main)</a></li></ol></li><li class="chapter-item expanded "><a href="pitfalls.html"><strong aria-hidden="true">4.</strong> Common Pitfalls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pitfalls/build-errors.html"><strong aria-hidden="true">4.1.</strong> Strange compile errors from Bevy or dependencies</a></li><li class="chapter-item expanded "><a href="pitfalls/performance.html"><strong aria-hidden="true">4.2.</strong> Slow Performance</a></li><li class="chapter-item expanded "><a href="pitfalls/into-system.html"><strong aria-hidden="true">4.3.</strong> Error adding function as system</a></li><li class="chapter-item expanded "><a href="pitfalls/3d-not-rendering.html"><strong aria-hidden="true">4.4.</strong> 3D objects not displaying</a></li><li class="chapter-item expanded "><a href="pitfalls/split-borrows.html"><strong aria-hidden="true">4.5.</strong> Borrow multiple fields from struct</a></li><li class="chapter-item expanded "><a href="pitfalls/time.html"><strong aria-hidden="true">4.6.</strong> Jittering Time (choppy movement/animation)</a></li><li class="chapter-item expanded "><a href="pitfalls/uv-coordinates.html"><strong aria-hidden="true">4.7.</strong> Textures/Images are flipped</a></li></ol></li><li class="chapter-item expanded "><a href="fundamentals.html"><strong aria-hidden="true">5.</strong> Game Engine Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/coords.html"><strong aria-hidden="true">5.1.</strong> Coordinate System</a></li><li class="chapter-item expanded "><a href="fundamentals/transforms.html"><strong aria-hidden="true">5.2.</strong> Transforms</a></li><li class="chapter-item expanded "><a href="fundamentals/visibility.html"><strong aria-hidden="true">5.3.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="fundamentals/time.html"><strong aria-hidden="true">5.4.</strong> Time and Timers</a></li><li class="chapter-item expanded "><a href="fundamentals/log.html"><strong aria-hidden="true">5.5.</strong> Logging, Console Messages</a></li><li class="chapter-item expanded "><a href="fundamentals/hierarchy.html"><strong aria-hidden="true">5.6.</strong> Parent/Child Hierarchies</a></li><li class="chapter-item expanded "><a href="fundamentals/fixed-timestep.html"><strong aria-hidden="true">5.7.</strong> Fixed Timestep</a></li><li class="chapter-item expanded "><a href="fundamentals/gizmos.html"><strong aria-hidden="true">5.8.</strong> Gizmos</a></li></ol></li><li class="chapter-item expanded "><a href="graphics.html"><strong aria-hidden="true">6.</strong> General Graphics Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphics/camera.html"><strong aria-hidden="true">6.1.</strong> Cameras</a></li><li class="chapter-item expanded "><a href="graphics/hdr-tonemap.html"><strong aria-hidden="true">6.2.</strong> HDR and Tonemapping</a></li><li class="chapter-item expanded "><a href="graphics/bloom.html"><strong aria-hidden="true">6.3.</strong> Bloom</a></li></ol></li><li class="chapter-item expanded "><a href="2d.html"><strong aria-hidden="true">7.</strong> Working with 2D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2d/camera.html"><strong aria-hidden="true">7.1.</strong> 2D Camera Setup</a></li><li class="chapter-item expanded "><a href="2d/sprites.html"><strong aria-hidden="true">7.2.</strong> Sprites and Atlases</a></li></ol></li><li class="chapter-item expanded "><a href="3d.html"><strong aria-hidden="true">8.</strong> Working with 3D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3d/camera.html"><strong aria-hidden="true">8.1.</strong> 3D Camera Setup</a></li><li class="chapter-item expanded "><a href="3d/gltf.html"><strong aria-hidden="true">8.2.</strong> 3D Models and Scenes (GLTF)</a></li></ol></li><li class="chapter-item expanded "><a href="input.html"><strong aria-hidden="true">9.</strong> Input Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input/keyboard.html"><strong aria-hidden="true">9.1.</strong> Keyboard</a></li><li class="chapter-item expanded "><a href="input/mouse.html"><strong aria-hidden="true">9.2.</strong> Mouse</a></li><li class="chapter-item expanded "><a href="input/gamepad.html"><strong aria-hidden="true">9.3.</strong> Gamepad (Controller, Joystick)</a></li><li class="chapter-item expanded "><a href="input/touch.html"><strong aria-hidden="true">9.4.</strong> Touchscreen</a></li><li class="chapter-item expanded "><a href="input/gesture.html"><strong aria-hidden="true">9.5.</strong> Gestures</a></li><li class="chapter-item expanded "><a href="input/dnd.html"><strong aria-hidden="true">9.6.</strong> Drag-and-Drop (Files)</a></li><li class="chapter-item expanded "><a href="input/ime.html"><strong aria-hidden="true">9.7.</strong> IME (Advanced Text)</a></li></ol></li><li class="chapter-item expanded "><a href="window.html"><strong aria-hidden="true">10.</strong> Window Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="window/props.html"><strong aria-hidden="true">10.1.</strong> Window Properties</a></li><li class="chapter-item expanded "><a href="window/clear-color.html"><strong aria-hidden="true">10.2.</strong> Change the Background Color</a></li><li class="chapter-item expanded "><a href="window/mouse-grab.html"><strong aria-hidden="true">10.3.</strong> Grab/Capture the Mouse Cursor</a></li><li class="chapter-item expanded "><a href="window/icon.html"><strong aria-hidden="true">10.4.</strong> Set the Window Icon</a></li></ol></li><li class="chapter-item expanded "><a href="assets.html"><strong aria-hidden="true">11.</strong> Asset Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="assets/handles.html"><strong aria-hidden="true">11.1.</strong> Handles</a></li><li class="chapter-item expanded "><a href="assets/assetserver.html"><strong aria-hidden="true">11.2.</strong> Load Assets from Files</a></li><li class="chapter-item expanded "><a href="assets/data.html"><strong aria-hidden="true">11.3.</strong> Access the Asset Data</a></li><li class="chapter-item expanded "><a href="assets/assetevent.html"><strong aria-hidden="true">11.4.</strong> React to Changes with Asset Events</a></li><li class="chapter-item expanded "><a href="assets/ready.html"><strong aria-hidden="true">11.5.</strong> Track Loading Progress</a></li><li class="chapter-item expanded "><a href="assets/hot-reload.html"><strong aria-hidden="true">11.6.</strong> Hot-Reloading Assets</a></li><li class="chapter-item expanded "><a href="assets/processing.html"><strong aria-hidden="true">11.7.</strong> Processing Assets</a></li></ol></li><li class="chapter-item expanded "><a href="audio.html"><strong aria-hidden="true">12.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="audio/basic.html"><strong aria-hidden="true">12.1.</strong> Playing Sounds</a></li><li class="chapter-item expanded "><a href="audio/spatial.html"><strong aria-hidden="true">12.2.</strong> Spatial Audio</a></li><li class="chapter-item expanded "><a href="audio/custom.html"><strong aria-hidden="true">12.3.</strong> Custom Audio Streams</a></li></ol></li><li class="chapter-item expanded "><a href="ui.html"><strong aria-hidden="true">13.</strong> Bevy UI Framework</a></li><li class="chapter-item expanded "><a href="programming.html"><strong aria-hidden="true">14.</strong> Bevy Core Programming Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/ecs-intro.html"><strong aria-hidden="true">14.1.</strong> Intro to ECS</a></li><li class="chapter-item expanded "><a href="programming/intro-data.html"><strong aria-hidden="true">14.2.</strong> Intro: Your Data</a></li><li class="chapter-item expanded "><a href="programming/intro-code.html"><strong aria-hidden="true">14.3.</strong> Intro: Your Code</a></li><li class="chapter-item expanded "><a href="programming/app-builder.html"><strong aria-hidden="true">14.4.</strong> The App</a></li><li class="chapter-item expanded "><a href="programming/systems.html"><strong aria-hidden="true">14.5.</strong> Systems</a></li><li class="chapter-item expanded "><a href="programming/res.html"><strong aria-hidden="true">14.6.</strong> Resources</a></li><li class="chapter-item expanded "><a href="programming/ec.html"><strong aria-hidden="true">14.7.</strong> Entities, Components</a></li><li class="chapter-item expanded "><a href="programming/bundle.html"><strong aria-hidden="true">14.8.</strong> Bundles</a></li><li class="chapter-item expanded "><a href="programming/queries.html"><strong aria-hidden="true">14.9.</strong> Queries</a></li><li class="chapter-item expanded "><a href="programming/commands.html"><strong aria-hidden="true">14.10.</strong> Commands</a></li><li class="chapter-item expanded "><a href="programming/events.html"><strong aria-hidden="true">14.11.</strong> Events</a></li><li class="chapter-item expanded "><a href="programming/plugins.html"><strong aria-hidden="true">14.12.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="programming/local.html"><strong aria-hidden="true">14.13.</strong> Local Resources</a></li><li class="chapter-item expanded "><a href="programming/exclusive.html"><strong aria-hidden="true">14.14.</strong> Exclusive Systems</a></li><li class="chapter-item expanded "><a href="programming/world.html"><strong aria-hidden="true">14.15.</strong> Direct ECS World Access</a></li><li class="chapter-item expanded "><a href="programming/schedules.html"><strong aria-hidden="true">14.16.</strong> Schedules</a></li><li class="chapter-item expanded "><a href="programming/system-order.html"><strong aria-hidden="true">14.17.</strong> System Order of Execution</a></li><li class="chapter-item expanded "><a href="programming/run-conditions.html"><strong aria-hidden="true">14.18.</strong> Run Conditions</a></li><li class="chapter-item expanded "><a href="programming/system-sets.html"><strong aria-hidden="true">14.19.</strong> System Sets</a></li><li class="chapter-item expanded "><a href="programming/states.html"><strong aria-hidden="true">14.20.</strong> States</a></li><li class="chapter-item expanded "><a href="programming/change-detection.html"><strong aria-hidden="true">14.21.</strong> Change Detection</a></li><li class="chapter-item expanded "><a href="programming/one-shot-systems.html"><strong aria-hidden="true">14.22.</strong> One-Shot Systems</a></li><li class="chapter-item expanded "><a href="programming/par-iter.html"><strong aria-hidden="true">14.23.</strong> Internal Parallelism</a></li><li class="chapter-item expanded "><a href="programming/system-piping.html"><strong aria-hidden="true">14.24.</strong> System Piping</a></li><li class="chapter-item expanded "><a href="programming/paramset.html"><strong aria-hidden="true">14.25.</strong> ParamSet</a></li><li class="chapter-item expanded "><a href="programming/non-send.html"><strong aria-hidden="true">14.26.</strong> Non-Send</a></li></ol></li><li class="chapter-item expanded "><a href="gpu.html"><strong aria-hidden="true">15.</strong> Bevy Render (GPU) Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gpu/intro.html"><strong aria-hidden="true">15.1.</strong> Render Architecture Overview</a></li><li class="chapter-item expanded "><a href="gpu/stages.html"><strong aria-hidden="true">15.2.</strong> Render Stages</a></li></ol></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">16.</strong> Programming Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/generic-systems.html"><strong aria-hidden="true">16.1.</strong> Generic Systems</a></li><li class="chapter-item expanded "><a href="patterns/component-storage.html"><strong aria-hidden="true">16.2.</strong> Component Storage (Table/Sparse-Set)</a></li><li class="chapter-item expanded "><a href="patterns/manual-event-clear.html"><strong aria-hidden="true">16.3.</strong> Manual Event Clearing</a></li><li class="chapter-item expanded "><a href="patterns/system-tests.html"><strong aria-hidden="true">16.4.</strong> Writing Tests for Systems</a></li></ol></li><li class="chapter-item expanded "><a href="platforms.html"><strong aria-hidden="true">17.</strong> Bevy on Different Platforms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/linux.html"><strong aria-hidden="true">17.1.</strong> Linux Desktop</a></li><li class="chapter-item expanded "><a href="platforms/macos.html"><strong aria-hidden="true">17.2.</strong> macOS Desktop</a></li><li class="chapter-item expanded "><a href="platforms/windows.html"><strong aria-hidden="true">17.3.</strong> Windows Desktop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/windows/wsl2.html"><strong aria-hidden="true">17.3.1.</strong> Working in WSL2</a></li></ol></li><li class="chapter-item expanded "><a href="platforms/wasm.html"><strong aria-hidden="true">17.4.</strong> Browser (WebAssembly)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/wasm/size-opt.html"><strong aria-hidden="true">17.4.1.</strong> Optimize for Size</a></li><li class="chapter-item expanded "><a href="platforms/wasm/webpage.html"><strong aria-hidden="true">17.4.2.</strong> Create a Custom Web Page</a></li><li class="chapter-item expanded "><a href="platforms/wasm/gh-pages.html"><strong aria-hidden="true">17.4.3.</strong> Hosting on GitHub Pages</a></li></ol></li><li class="chapter-item expanded "><a href="setup/cross.html"><strong aria-hidden="true">17.5.</strong> Cross-Compilation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/cross/linux-windows.html"><strong aria-hidden="true">17.5.1.</strong> From Linux to Windows</a></li><li class="chapter-item expanded "><a href="setup/cross/macos-windows.html"><strong aria-hidden="true">17.5.2.</strong> From macOS to Windows</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="credits.html">Credits</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contact.html">Contact Me</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing-bevy.html">Contribute to Bevy</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Contribute to this Book</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Unofficial Bevy Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="unofficial-bevy-cheat-book"><a class="header" href="#unofficial-bevy-cheat-book">Unofficial Bevy Cheat Book</a></h1>
<p>This is a reference-style book for the <a href="https://bevyengine.org">Bevy game engine</a>
(<a href="https://github.com/bevyengine/bevy">GitHub</a>).</p>
<p>It aims to teach Bevy concepts in a concise way, help you be productive,
and discover the knowledge you need.</p>
<p>This book aggregates a lot of community wisdom that is often not covered
by official documentation, saving you the need to struggle with issues that
others have figured out already!</p>
<p>While it aims to be exhaustive, documenting an entire game engine is
a monumental task. I focus my time on whatever I believe the community
needs most.</p>
<p>Therefore, there are still a lot of omissions, both for basics and advanced
topics. Nevertheless, I am confident this book will prove to be a valuable
resource to you!</p>
<p><em><strong>Welcome! May this book serve you well!</strong></em></p>
<p>(don't forget to
<a class="github-button" href="https://github.com/bevy-cheatbook/bevy-cheatbook" data-icon="octicon-star" aria-label="Star bevy-cheatbook/bevy-cheatbook on GitHub">Star</a>
the book's <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub repository</a>,
and consider <a href="https://github.com/sponsors/inodentry">donating</a> ğŸ™‚)</p>
<p>è¿™æ˜¯bevyçš„å‚è€ƒä¹¦,ä½œè€…çš„ç›®çš„æ˜¯ç”¨ç®€å•çš„æ–¹å¼æ•™æˆbevyçš„æ¦‚å¿µ,æé«˜æˆ‘ä»¬çš„ç”Ÿäº§åŠ›,
å¿«é€Ÿå‘ç°æ‰€éœ€çŸ¥è¯†.è¿™é‡ŒåŒ…å«çš„å¤§å¤šæ˜¯å®˜æ–¹æ–‡æ¡£æœªæåŠ,ç”±ç¤¾åŒºå·²è§£å†³çš„é—®é¢˜.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>The pages in this book are not designed to be read in order. Each page covers
a standalone topic. Feel free to jump to whatever interests you.</p>
<p>If you have a specific topic in mind that you would like to learn about, you
can find it from the table-of-contents (sidebar) or using the search function
(in the top bar).</p>
<p>The <a href="/overview.html">Chapter Overview</a> page will give you a general idea
of how the book is structured.</p>
<p>The text on each page will link to other pages, where you can learn about other
things mentioned in the text. This helps you jump around the book.</p>
<p>If you are new to Bevy, or would like a more guided experience, try the
<a href="/tutorial/guide.html">Guided Tour tutorial</a>. It will help you navigate the book in
an order that makes sense for learning, from beginner to advanced topics.</p>
<p>The <a href="/builtins.html">Bevy Builtins</a> page is a concise cheatsheet of useful
information about types and features provided by Bevy.</p>
<p>æœ¬ä¹¦æ˜¯æŒ‰ä¸»é¢˜åˆ†ç±»,å¹¶æ— é˜…è¯»é¡ºåºè¦æ±‚.</p>
<h2 id="recommended-additional-resources"><a class="header" href="#recommended-additional-resources">Recommended Additional Resources</a></h2>
<p>Bevy has a rich collection of <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official code
examples</a>.</p>
<p>Check out <a href="https://bevyengine.org/assets">bevy-assets</a>, for community-made resources.</p>
<p>Our community is very friendly and helpful. Feel welcome to join the <a href="https://discord.gg/bevy">Bevy
Discord</a> to chat, ask questions, or get involved in the project!</p>
<p>If you want to see some games made with Bevy, see <a href="https://itch.io/games/tag-bevy">itch.io</a>
or <a href="https://bevyengine.org/assets/#input">Bevy Assets</a>.</p>
<p>å­¦ä¹ bevyæ¨èçš„å…¶ä»–èµ„æ–™: å®˜æ–¹æ–‡æ¡£/ç¤¾åŒºèµ„æº/itch.ioçš„æ¯”èµ›.</p>
<h2 id="is-this-book-up-to-date"><a class="header" href="#is-this-book-up-to-date">Is this book up to date?</a></h2>
<p>Bevy has a very rapid pace of development, with new major releases roughly every
three months. Every version brings a lot of changes, so keeping this book
updated can be a major challenge.</p>
<p>To ease the maintenance burden, the policy of the project is that the book may
contain content for different versions of Bevy. However, mixing Bevy versions
on the same page is not allowed.</p>
<p>At the top of every page, you will see the version it was last updated for.
All content on that page must be relevant for the stated Bevy version.</p>
<p>bevyå¼€å‘éå¸¸å¿«,ä¸€ä¸ªå­£åº¦ä¼šå‘ä¸€ä¸ªä¸»ç‰ˆæœ¬, æœ¬ä¹¦ä¹Ÿä¼šå³æ—¶æ›´æ–°.</p>
<h2 id="support-me"><a class="header" href="#support-me">Support Me</a></h2>
<p><a href="https://github.com/sponsors/inodentry"><button class="ghsponsors-button">GitHub Sponsors</button></a>
<a href="https://patreon.com/iyesgames"><button class="patreon-button">Patreon</button></a>
<a href="bitcoin:bc1qaf32uqsg6mngw9g4aqc3l2jvuv46qx0zw2438p"><button class="bitcoin-button">Bitcoin</button></a></p>
<p>If you like this book, please consider sponsoring me. Thank you! â¤ï¸</p>
<p>I'd like to keep improving and maintaining this book, to provide a high-quality
independent learning resource for the Bevy community.</p>
<h2 id="support-bevy"><a class="header" href="#support-bevy">Support Bevy</a></h2>
<p><a href="https://github.com/sponsors/cart"><button class="ghsponsors-button">GitHub Sponsors</button></a></p>
<p>If you like the Bevy Game Engine, you should consider donating to the project.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright Â© 2021-2024 Ida Borisova (IyesGames)</p>
<p>All code in the book is provided under the
<a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 License</a>.
At your option, you may also use it under the regular MIT License.</p>
<p>The text of the book is provided under the
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</p>
<p>Exception: If used for the purpose of contribution to the "Official Bevy
Project", the entire content of the book may be used under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0
License</a>.</p>
<p>"Official Bevy Project" is defined as:</p>
<ul>
<li>Contents of the Git repository hosted at <a href="https://github.com/bevyengine/bevy">https://github.com/bevyengine/bevy</a></li>
<li>Contents of the Git repository hosted at <a href="https://github.com/bevyengine/bevy-website">https://github.com/bevyengine/bevy-website</a></li>
<li>Anything publicly visible on the <a href="https://bevyengine.org">bevyengine.org</a> website</li>
</ul>
<p>The MIT-0 license applies as soon as your contribution has been accepted upstream.</p>
<p>GitHub Forks and Pull Requests created for the purposes of contributing to
the Official Bevy Project are given the following license exception: the
Attribution requirements of CC BY-NC-SA 4.0 are waived for as long as the
work is pending upstream review (Pull Request Open). If upstream rejects
your contribution, you are given a period of 1 month to comply with the
full terms of the CC BY-NC-SA 4.0 license or delete your work. If upstream
accepts your contribution, the MIT-0 license applies.</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Development of this book is hosted on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<p>Please file GitHub Issues for any wrong/confusing/misleading information,
as well as suggestions for new content you'd like to be added to the book.</p>
<p>Please do not create PRs. Or if you do, be prepared for them to be ignored
or closed if I find that they take up too much of my time or don't help me
enough.</p>
<p>See the <a href="/contributing.html">Contributing</a> section for all the details.</p>
<h2 id="stability-warning"><a class="header" href="#stability-warning">Stability Warning</a></h2>
<p>Bevy is still a new and experimental game engine! It has only been public
since August 2020!</p>
<p>While improvements have been happening at an incredible pace, and development
is active, Bevy simply hasn't yet had the time to mature.</p>
<p><em>There are no stability guarantees and breaking changes happen often!</em></p>
<p>Usually, it not hard to adapt to changes with new releases, but you have been
warned!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="chapter-overview"><a class="header" href="#chapter-overview">Chapter Overview</a></h1>
<p>The <a href="/builtins.html">Bevy Builtins</a> page is a concise cheatsheet of useful
information about types and features provided by Bevy.</p>
<p>The <a href="/tutorial.html">Bevy Tutorials</a> chapter is for tutorials/guides
that you can follow from start to finish.</p>
<p>The <a href="/cookbook.html">Bevy Cookbook</a> is for more self-contained /
narrow-scoped examples that teach you how to solve specific problems.</p>
<p>The rest of the book is designed as a reference, covering different aspects of
working with Bevy. Feel free to jump around the book, to learn about any topic
that interests you. On every page of the book, any time other topics are
mentioned, the relevant pages or official API documentation is linked.</p>
<p>If you would like a guided experience, or to browse the book by relative
difficulty (from beginner to advanced), try the <a href="/tutorial.html">guided tutorial
page</a>. It recommends topics in a logical order for learning.</p>
<p>The book has the following general chapters:</p>
<ul>
<li><a href="/setup.html">Bevy Setup Tips</a>: project setup advice, recommendations for tools and plugins</li>
<li><a href="/pitfalls.html">Common Pitfalls</a>: solutions for common issues encountered by the community</li>
<li><a href="/platforms.html">Bevy on Different Platforms</a>: information about working with specific plaforms / OSs</li>
</ul>
<!-- - [Appendix: General Concepts][chapter::concepts]: various general gamedev knowledge, not specific to Bevy -->
<p>To learn how to program in Bevy, see these chapters:</p>
<ul>
<li><a href="/programming.html">Bevy Core Programming Framework</a>: the ECS+App frameworks, the foundation of everything</li>
<li><a href="/patterns.html">Programming Patterns</a>: opinionated advice, patterns, idioms</li>
<li><a href="/gpu.html">Bevy Render (GPU) Framework</a>: working with the GPU and Bevy's rendering</li>
</ul>
<p>The following chapters cover various Bevy feature areas:</p>
<ul>
<li><a href="/fundamentals.html">Game Engine Fundamentals</a></li>
<li><a href="/graphics.html">General Graphics Features</a></li>
<li><a href="/2d.html">Working with 2D</a></li>
<li><a href="/3d.html">Working with 3D</a></li>
<li><a href="/input.html">Input Handling</a></li>
<li><a href="/window.html">Window Management</a></li>
<li><a href="/assets.html">Asset Management</a></li>
<li><a href="/audio.html">Audio</a></li>
<li><a href="/ui.html">Bevy UI Framework</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="list-of-bevy-builtins"><a class="header" href="#list-of-bevy-builtins">List of Bevy Builtins</a></h1>
<p>This page is a quick condensed listing of all the important things provided
by Bevy.</p>
<ul>
<li><a href="builtins.html#systemparams">SystemParams</a></li>
<li><a href="builtins.html#assets">Assets</a></li>
<li><a href="builtins.html#file-formats">File Formats</a></li>
<li><a href="builtins.html#gltf-asset-labels">GLTF Asset Labels</a></li>
<li><a href="builtins.html#shader-imports">Shader Imports</a></li>
<li><a href="builtins.html#wgpu-backends"><code>wgpu</code> Backends</a></li>
<li><a href="builtins.html#schedules">Schedules</a></li>
<li><a href="builtins.html#run-conditions">Run Conditions</a></li>
<li><a href="builtins.html#plugins">Plugins</a></li>
<li><a href="builtins.html#bundles">Bundles</a></li>
<li><a href="builtins.html#configuration-resources">Resources (Configuration)</a></li>
<li><a href="builtins.html#engine-resources">Resources (Engine User)</a>
<ul>
<li><a href="builtins.html#engine-resources">Main World</a></li>
<li><a href="builtins.html#render-world-resources">Render World</a></li>
<li><a href="builtins.html#low-level-wgpu-resources">Low-Level <code>wgpu</code> access</a></li>
</ul>
</li>
<li><a href="builtins.html#input-handling-resources">Resources (Input)</a></li>
<li><a href="builtins.html#input-events">Events (Input)</a></li>
<li><a href="builtins.html#engine-events">Events (Engine)</a></li>
<li><a href="builtins.html#system-and-control-events">Events (System/Control)</a></li>
<li><a href="builtins.html#components">Components</a></li>
</ul>
<p>è¿™é‡Œæ˜¯å¯¹bevyé‡è¦æ¦‚å¿µçš„ç®€è¦æè¿°.</p>
<h2 id="systemparams"><a class="header" href="#systemparams">SystemParams</a></h2>
<p>These are all the special types that can be used as <a href="/programming/systems.html">system</a> parameters.</p>
<p>systemå‚æ•°,è¿™é‡Œåˆ—å‡ºçš„éƒ½æ˜¯ç‰¹å®šçš„systemå‚æ•°.</p>
<p><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/trait.SystemParam.html#implementors">(List in API Docs)</a></p>
<p>In regular <a href="/programming/systems.html">systems</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>:
Manipulate the ECS using <a href="/programming/commands.html">commands</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Query.html"><code>Query&lt;T, F = ()&gt;</code></a> (can contain tuples of up to 15 types):
Access to <a href="/programming/intro-data.html#entities--components">entities and components</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>:
Shared access to a <a href="/programming/res.html">resource</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>:
Exclusive (mutable) access to a <a href="/programming/res.html">resource</a></li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code>:
Shared access to a resource that may not exist</li>
<li><code>Option&lt;ResMut&lt;T&gt;&gt;</code>:
Exclusive (mutable) access to a resource that may not exist</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="/programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>:
Receive <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>:
Send <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a>:
Read-only <a href="/programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet&lt;...&gt;</code></a> (with up to 8 params):
Resolve <a href="/programming/paramset.html">conflicts between incompatible system parameters</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Deferred.html"><code>Deferred&lt;T&gt;</code></a>:
Custom <a href="/programming/deferred.html">"deferred mutation"</a>, similar to <code>Commands</code>, but for your own things</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/removal_detection/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a>:
<a href="/programming/change-detection.html#removal-detection">Removal detection</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gizmos/gizmos/struct.Gizmos.html"><code>Gizmos</code></a>:
A way to <a href="/fundamentals/gizmos.html">draw lines and shapes</a> on the screen for debugging and dev purposes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/diagnostic/struct.Diagnostics.html"><code>Diagnostics</code></a>:
A way to <a href="/fundamentals/diagnostics.html">report measurements/debug data</a> to Bevy for tracking and visualization</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.SystemName.html"><code>SystemName</code></a>:
The name (string) of the system, may be useful for debugging</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ParallelCommands.html"><code>ParallelCommands</code></a>:
Abstraction to help use <code>Commands</code> when you will do your own parallelism</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/world/struct.WorldId.html"><code>WorldId</code></a>:
The World ID of the <a href="/programming/world.html">world</a> the system is running on</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.ComponentIdFor.html"><code>ComponentIdFor&lt;T&gt;</code></a>:
Get the <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.ComponentId.html"><code>ComponentId</code></a> of a given <a href="/programming/ec.html#components">component</a> type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/entity/struct.Entities.html"><code>Entities</code></a>:
Low-level ECS metadata: All entities</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.Components.html"><code>Components</code></a>:
Low-level ECS metadata: All components</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/bundle/struct.Bundles.html"><code>Bundles</code></a>:
Low-level ECS metadata: All bundles</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/archetype/struct.Archetypes.html"><code>Archetypes</code></a>:
Low-level ECS metadata: All archetypes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.SystemChangeTick.html"><code>SystemChangeTick</code></a>:
Low-level ECS metadata: Tick used for change detection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a>:
Shared access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>:
Exclusive access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><code>Option&lt;NonSend&lt;T&gt;&gt;</code>:
Shared access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data that may not exist</li>
<li><code>Option&lt;NonSendMut&lt;T&gt;&gt;</code>:
Exclusive access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data that may not exist</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.StaticSystemParam.html"><code>StaticSystemParam</code></a>:
Helper for generic system abstractions, to avoid lifetime annotations</li>
<li>tuples containing any of these types, with up to 16 members</li>
</ul>
<p>å¸¸è§„system,ä¸ç‹¬å ecs world.</p>
<ul>
<li><code>Commands</code>: å‘½ä»¤,ç»´æŠ¤ecsæœ€å¸¸ç”¨çš„æ–¹å¼</li>
<li><code>Query&lt;T, F= ()&gt;</code>: è®¿é—®å®ä½“å’Œç»„ä»¶çš„æ–¹å¼,æœ€å¤šå¯ä»¥è®¿é—®15ä¸ªç»„ä»¶,systemæœ€å¸¸ä½¿ç”¨çš„å‚æ•°</li>
<li><code>Res&lt;T&gt;</code>: å…±äº«è®¿é—®èµ„æºçš„æ–¹å¼</li>
<li><code>ResMut&lt;T&gt;</code>: ç‹¬å è®¿é—®èµ„æºçš„æ–¹å¼</li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code>: å…±äº«è®¿é—®èµ„æºçš„æ–¹å¼,èµ„æºå¯èƒ½ä¸å­˜åœ¨</li>
<li><code>Option&lt;ResMut&lt;T&gt;&gt;</code>: ç‹¬å è®¿é—®èµ„æºçš„æ–¹å¼,èµ„æºå¯èƒ½ä¸å­˜åœ¨</li>
<li><code>Local&lt;T&gt;</code>: systemè‡ªå·±çš„æ•°æ®,localä¸ä¿å­˜åœ¨worldä¸­,è€Œæ˜¯åœ¨systemä¸­,åœ¨systemåç»­è¿è¡Œä¸­ä¹Ÿå­˜åœ¨</li>
<li><code>EventReader&lt;T&gt;</code>: æ¥æ”¶äº‹ä»¶</li>
<li><code>EventWriter&lt;T&gt;</code>: å‘é€äº‹ä»¶</li>
<li><code>&amp;world</code>: ç›´æ¥è®¿é—®worldçš„æ–¹å¼,å…±äº«çš„</li>
<li><code>ParamSet&lt;...&gt;</code>: è§£å†³systemå‚æ•°ä¸å…¼å®¹çš„æ–¹å¼,ruståœ¨ç¼–è¯‘æœŸä¸çŸ¥é“bevyçš„ecs,è¿è¡Œæ—¶ecsè¦éµå¾ªrustçš„è§„åˆ™,é€šè¿‡æ­¤å‚æ•°å¯ä»¥å‘Šè¯‰bevyè¦å¤„ç†ä¸å…¼å®¹</li>
<li><code>Deferred&lt;T&gt;</code>: å»¶æ—¶å˜æ›´,Commandsåº•å±‚ä¹Ÿæ˜¯ä½¿ç”¨è¿™ä¸ª,æœ‰éœ€è¦å¯ä»¥ç›´æ¥ä½¿ç”¨</li>
<li><code>RemovedComponents&lt;T&gt;</code>: åˆ é™¤ç»„ä»¶</li>
<li><code>Gizmos</code>: åœ¨è°ƒè¯•æˆ–å¼€å‘æ—¶ç»˜åˆ¶çš„ä¸€äº›å°ç©æ„å„¿,çº¿æ¡æˆ–å½¢çŠ¶</li>
<li><code>Diagnostics</code>: è·Ÿè¸ªæˆ–æ˜¾ç¤ºbevyçš„è¯Šæ–­æ•°æ®</li>
<li><code>SystemName</code>: åœ¨è°ƒè¯•å¯èƒ½ç”¨ä½œè¯†åˆ«system</li>
<li><code>ParallelCommands</code>: å¹¶è¡Œå‘½ä»¤</li>
<li><code>WorldId</code>: world id æ ‡è¯†</li>
<li><code>ComponentIdFor&lt;T&gt;</code>: ä»ç»„ä»¶ç±»å‹è·å–ç»„ä»¶ID</li>
<li><code>Entities</code>: ecsåº•å±‚å…ƒæ•°æ®: æ‰€æœ‰å®ä½“</li>
<li><code>Components</code>: ecsåº•å±‚å…ƒæ•°æ®: æ‰€æœ‰ç»„ä»¶</li>
<li><code>Bundles</code>: ecsåº•å±‚å…ƒæ•°æ®: æ‰€æœ‰bundleä¿¡æ¯</li>
<li><code>Archetypes</code>: ecsåº•å±‚å…ƒæ•°æ®: æ‰€æœ‰åŸå‹.ä¸€ä¸ªåŸå‹è¡¨ç¤ºå…±äº«åŒä¸€ç»„ç»„ä»¶çš„å®ä½“é›†</li>
<li><code>SystemChangeTick</code>: ecsåº•å±‚å…ƒæ•°æ®: <code>å˜æ›´æ£€æµ‹</code>ä½¿ç”¨åˆ°çš„tick</li>
<li><code>NonSend&lt;T&gt;</code>: å…±äº«è®¿é—®Non-Sendæ•°æ®. Non-Sendæ•°æ®åªèƒ½åœ¨ä¸»çº¿ç¨‹ä¸­è®¿é—®,eg:çª—å£/å›¾å½¢/éŸ³é¢‘/å’ŒOSåº•å±‚æ¥å£äº¤äº’çš„.</li>
<li><code>NonSendMut&lt;T&gt;</code>: ç‹¬å è®¿é—®Non-Sendæ•°æ®.</li>
<li><code>Option&lt;NonSend&lt;T&gt;&gt;</code>: å…±äº«è®¿é—®Non-Sendæ•°æ®, æ•°æ®å¯èƒ½ä¸å­˜åœ¨.</li>
<li><code>Option&lt;NonSendMut&lt;T&gt;&gt;</code>: ç‹¬å è®¿é—®Non-Sendæ•°æ®, æ•°æ®å¯èƒ½ä¸å­˜åœ¨.</li>
<li><code>StaticSystemParam</code>: ç®€åŒ–ç”Ÿå‘½å‘¨æœŸå†™æ³•çš„è¾…åŠ©å™¨</li>
<li>å…ƒç»„,æœ€å¤š16ä¸ªç±»å‹</li>
</ul>
<p>In <a href="/programming/exclusive.html">exclusive systems</a>:</p>
<ul>
<li>[<code>&amp;mut World</code>]:
Full <a href="/programming/world.html">direct access to the ECS World</a></li>
<li>[<code>Local&lt;T&gt;</code>]:
Data <a href="/programming/local.html">local</a> to the system</li>
<li>[<code>&amp;mut SystemState&lt;P&gt;</code>][<code>SystemState</code>]:
Emulates a regular system, allowing you to easily access data from the World.
<code>P</code> are the system parameters.</li>
<li>[<code>&amp;mut QueryState&lt;Q, F = ()&gt;</code>][<code>QueryState</code>]:
Allows you to perform queries on the World, similar to a [<code>Query</code>] in regular systems.</li>
</ul>
<p>ç‹¬å systemçš„å‚æ•°(æ­¤ç±»systemåœ¨æ‰§è¡Œæ—¶ä¼šç‹¬å world):</p>
<ul>
<li><code>&amp;mut world</code>: ç›´æ¥è®¿é—®worldçš„æ–¹å¼,ç‹¬å çš„</li>
<li><code>Local&lt;T&gt;</code>: systemè‡ªå·±çš„æ•°æ®,localä¸ä¿å­˜åœ¨worldä¸­,è€Œæ˜¯åœ¨systemä¸­,åœ¨systemåç»­è¿è¡Œä¸­ä¹Ÿå­˜åœ¨</li>
<li><code>&amp;mut SystemState&lt;P&gt;</code> <code>SystemState</code>: æ¨¡æ‹Ÿæ™®é€šsystem,å¯ä»¥ç®€å•ä»worldè®¿é—®æ•°æ®,På°±æ˜¯systemå‚æ•°</li>
<li><code>&amp;mut QueryState&lt;Q, F= ()&gt;</code> <code>QueryState</code>: ä»worldæ‰§è¡ŒæŸ¥è¯¢,ç±»ä¼¼æ™®é€šsystemçš„Query</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<p>å‡½æ•°æœ€å¤šæœ‰16ä¸ªå‚æ•°,å¦‚æœéœ€è¦æ›´å¤š,å°±ä½¿ç”¨å…ƒç»„æ¥çªç ´é™åˆ¶.
å…ƒç»„åŒæ ·æœ€å¤šåªèƒ½æœ‰16ä¸ªå‚æ•°,ä½†æ²¡æœ‰åµŒå¥—é™åˆ¶.</p>
<p>Systems running during the <a href="/TODO.html">Extract schedule</a> can also use
<a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Extract.html"><code>Extract&lt;T&gt;</code></a>, to access data from the Main World instead of the
Render World. <code>T</code> can be any read-only system parameter type.</p>
<p>åœ¨å¤–éƒ¨è°ƒåº¦å™¨ä¸­çš„systemä¹Ÿå¯ä»¥ä½¿ç”¨<code>Extract&lt;T&gt;</code>ä»Main(ä¸æ˜¯Render)ä¸­è®¿é—®æ•°æ®,
Tå¯ä»¥æ˜¯ä»»æ„system å‚æ•°ç±»å‹.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p><a href="/assets.html">(more info about working with assets)</a></p>
<p>These are the Asset types registered by Bevy by default.</p>
<p>è¿™é‡Œçš„assetç±»å‹(èµ„äº§ç±»å‹)éƒ½æ˜¯bevyé»˜è®¤æ³¨å†Œçš„.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a>:
Pixel data, used as a texture for 2D and 3D rendering;
also contains the <a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a> for texture filtering settings</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a>:
2D "Sprite Sheet" defining sub-images within a single larger image</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a>:
3D Mesh (geometry data), contains vertex attributes (like position, UVs, normals)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a>:
GPU shader code, in one of the supported languages (WGSL/SPIR-V/GLSL)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.ColorMaterial.html"><code>ColorMaterial</code></a>:
Basic "2D material": contains color, optionally an image</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>:
"3D material" with support for Physically-Based Rendering</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a>:
Data for a single animation sequence, can be used with <a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationPlayer.html"><code>AnimationPlayer</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Font.html"><code>Font</code></a>:
Font data used for text rendering</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.Scene.html"><code>Scene</code></a>:
Scene composed of literal ECS entities to instantiate</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.DynamicScene.html"><code>DynamicScene</code></a>:
Scene composed with dynamic typing and reflection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a>:
<a href="/3d/gltf.html#gltf-master-asset">GLTF Master Asset</a>: index of the entire contents of a GLTF file</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a>:
Logical GLTF object in a scene</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>:
Logical GLTF 3D model, consisting of multiple <code>GltfPrimitive</code>s</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfPrimitive.html"><code>GltfPrimitive</code></a>:
Single unit to be rendered, contains the Mesh and Material to use</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a>:
Audio data for <code>bevy_audio</code></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.FontAtlasSet.html"><code>FontAtlasSet</code></a>:
(internal use for text rendering)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a>:
(internal use for skeletal animation)</li>
</ul>
<p>ç›®å‰èµ„äº§assetç±»å‹åŒ…å«ä»¥ä¸‹:</p>
<ul>
<li><code>Image</code>: åƒç´ æ•°æ®,åœ¨2d/3dæ¸²æŸ“ä¸­ç”¨ä½œçº¹ç†,ä¹ŸåŒ…å«çº¹ç†è¿‡æ»¤çš„GPUé‡‡æ ·æè¿°</li>
<li><code>TextureAtlas</code>: çº¹ç†å›¾é›†,å¤šä¸ªå¯¹è±¡å¯ä»¥ä»ä¸€ä¸ªå¤§å›¾ä¸­å–Image,è¿™æ ·å¯ä»¥å‡å°‘çº¹ç†åˆ‡æ¢çš„å¼€é”€</li>
<li><code>Mesh</code>: 3D Meshå¯¹è±¡æ˜¯ä¸€ç§å‡ ä½•æ•°æ®,åŒ…å«é¡¶ç‚¹å±æ€§(eg:ä½ç½®/UV/æ³•çº¿)</li>
<li><code>Shader</code>: ç€è‰²å™¨,æ”¯æŒWGSL/SPIRV/GLSLè¯­æ³•</li>
<li><code>ColorMaterial</code>: åŸºç¡€çš„2dæè´¨,åŒ…å«Imageä¸­çš„é¢œè‰²/é€æ˜åº¦</li>
<li><code>StandardMaterial</code>: æ”¯æŒåŸºäºç‰©ç†æ¸²æŸ“çš„3dæè´¨</li>
<li><code>AnimationClip</code>: å•ä¸ªåŠ¨ç”»åºåˆ—å¸§, ç”±<code>AnimationPlayer</code>ä½¿ç”¨</li>
<li><code>Font</code>: æ–‡æœ¬æ¸²æŸ“ä½¿ç”¨åˆ°çš„å­—ä½“æ•°æ®</li>
<li><code>Scene</code>: ä¸€ç»„å®ä½“/ç»„ä»¶/èµ„äº§çš„å‡ ä½•,worldå¯å¤ç”¨çš„ä¸€éƒ¨åˆ†</li>
<li><code>DynamicScene</code>: å¯åºåˆ—èµ„äº§å’ŒåŠ¨æ€å®ä½“çš„é›†åˆ</li>
<li><code>Gltf</code>: gltfä¸»è¦èµ„äº§,gltfæ–‡ä»¶å…¨éƒ¨å†…å®¹çš„ç´¢å¼•.gltfæ˜¯openglä¼ é€’æ ¼å¼,ç”¨äºä¼ è¾“å’ŒåŠ è½½3dåœºæ™¯å’Œæ¨¡å‹</li>
<li><code>GltfNode</code>: sceneä¸­çš„é€»è¾‘gltfå¯¹è±¡</li>
<li><code>GltfMesh</code>: gltf 3dæ¨¡å‹</li>
<li><code>GltfPrimitive</code>: gltfåŸè¯­,å•ä¸ªå¯æ¸²æŸ“å•å…ƒ,åŒ…æ‹¬Meshå’ŒMaterial</li>
<li><code>AudioSource</code>: bevy_audioä½¿ç”¨çš„éŸ³é¢‘æ•°æ®</li>
<li><code>FontAtlasSet</code>: å†…éƒ¨ä½¿ç”¨çš„,ç”¨äºæ–‡æœ¬æ¸²æŸ“</li>
<li><code>SkinnedMeshInverseBindposes</code>: å†…éƒ¨ä½¿ç”¨çš„,éª¨éª¼åŠ¨ç”»</li>
</ul>
<h2 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h2>
<p>These are the asset file formats (asset loaders) supported by Bevy. Support
for each one can be enabled/disabled using <a href="/setup/bevy-config.html">cargo features</a>. Some
are enabled by default, many are not.</p>
<p>ä»¥ä¸‹æ˜¯bevyæ”¯æŒçš„assetèµ„æºæ–‡ä»¶æ ¼å¼,é»˜è®¤å¯ç”¨äº†ä¸€æ‰¹,é€šè¿‡<code>åŠŸèƒ½</code>å¼€å¯å…¶ä»–çš„.</p>
<p>Image formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>PNG</td><td><code>"png"</code></td><td>Yes</td><td><code>.png</code></td></tr>
<tr><td>HDR</td><td><code>"hdr"</code></td><td>Yes</td><td><code>.hdr</code></td></tr>
<tr><td>KTX2</td><td><code>"ktx2"</code></td><td>Yes</td><td><code>.ktx2</code></td></tr>
<tr><td>KTX2+zstd</td><td><code>"ktx2", "zstd"</code></td><td>Yes</td><td><code>.ktx2</code></td></tr>
<tr><td>JPEG</td><td><code>"jpeg"</code></td><td>No</td><td><code>.jpg</code>, <code>.jpeg</code></td></tr>
<tr><td>WebP</td><td><code>"webp"</code></td><td>No</td><td><code>.webp</code></td></tr>
<tr><td>OpenEXR</td><td><code>"exr"</code></td><td>No</td><td><code>.exr</code></td></tr>
<tr><td>TGA</td><td><code>"tga"</code></td><td>No</td><td><code>.tga</code></td></tr>
<tr><td>PNM</td><td><code>"pnm"</code></td><td>No</td><td><code>.pam</code>, <code>.pbm</code>, <code>.pgm</code>, <code>.ppm</code></td></tr>
<tr><td>BMP</td><td><code>"bmp"</code></td><td>No</td><td><code>.bmp</code></td></tr>
<tr><td>DDS</td><td><code>"dds"</code></td><td>No</td><td><code>.dds</code></td></tr>
<tr><td>KTX2+zlib</td><td><code>"ktx2", "zlib"</code></td><td>No</td><td><code>.ktx2</code></td></tr>
<tr><td>Basis</td><td><code>"basis-universal"</code></td><td>No</td><td><code>.basis</code></td></tr>
</tbody></table>
</div>
<p>å¸¸è§çš„å›¾ç‰‡æ ¼å¼åŒ…æ‹¬:png/jpeg/webp/bmp.</p>
<ul>
<li>hdræ˜¯é«˜åŠ¨æ€èŒƒå›´å›¾åƒï¼ˆHigh-Dynamic Range Imageï¼‰çš„æ–‡ä»¶æ ¼å¼,èƒ½å­˜å‚¨æ›´å¤šäº®åº¦å’Œè‰²å½©ä¿¡æ¯</li>
<li>ktx2æ˜¯(Khronos Texture Container)æ ¼å¼çš„ç¬¬äºŒä»£ç‰ˆæœ¬ï¼Œä¸“ä¸ºé«˜æ•ˆå­˜å‚¨å’Œä¼ è¾“çº¹ç†æ•°æ®è€Œè®¾è®¡,ç‰¹åˆ«æ˜¯3då’Œæœ‰æ•ˆå¼€å‘é¢†åŸŸ</li>
<li>exræ˜¯ä¸€ç§é«˜åŠ¨æ€èŒƒå›´(HDR)å›¾åƒæ ¼å¼,æ˜¯OpenEXRæ ‡å‡†çš„ä¸€éƒ¨åˆ†</li>
<li>tgaçš„å…¨ç§°ä¸ºTagged Image File Formatæˆ–Tagged Graphicsï¼Œä¸€å®¶ç¾å›½å…¬å¸å¼€å‘çš„,åœ¨å›¾å½¢è®¾è®¡/è§†é¢‘ç¼–è¾‘/æ¸¸æˆå¼€å‘æœ‰å¹¿æ³›åº”ç”¨</li>
<li>pnmæ˜¯Netpbmï¼ˆNetwork Portable Graphicsï¼‰å›¾åƒæ–‡ä»¶æ ¼å¼å®¶æ—çš„ä¸€éƒ¨åˆ†,ä½¿ç”¨ç®€å•ä¾¿æºçš„æ–¹å¼æ¥å­˜å‚¨å’Œäº¤æ¢å›¾åƒæ•°æ®</li>
<li>ddså…¨ç§°ä¸ºDirectDraw Surface,å¾®è½¯å¼€å‘çš„ä¸€ç§å›¾åƒæ–‡ä»¶æ ¼å¼,ä¸»è¦ç”¨äºdirectXç¨‹åº,å¯ä¼˜åŒ–3då›¾å½¢æ¸²æŸ“çš„æ€§èƒ½</li>
<li>basisæ˜¯googleå¼€å‘çš„Basis Universalè´´å›¾æ ¼å¼,è½¬ä¸ºwebglå’Œå…¶ä»–3då®æ—¶åº”ç”¨è®¾è®¡,ä¿æŒé«˜è´¨é‡çš„åŒæ—¶è¿˜å‡å°‘äº†æ–‡ä»¶å¤§å°,é€‚åˆæ¸¸æˆ/vr/ç½‘ç»œåœºæ™¯,å¯ä½œä¸ºjpeg/pngçš„ä»£æ›¿å“,å­˜å‚¨æ•ˆç‡å’Œè·¨å¹³å°å…¼å®¹æ€§éƒ½éå¸¸ä¼˜ç§€</li>
</ul>
<p><em><strong>KTX2æ ¼å¼ç”±Khronos Groupå¼€å‘ï¼Œè¿™ä¸ªç»„ç»‡ä¹Ÿè´Ÿè´£ç»´æŠ¤OpenGLã€Vulkanå’ŒGltfç­‰å›¾å½¢APIæ ‡å‡†ã€‚</strong></em></p>
<p>Audio formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>OGG Vorbis</td><td><code>"vorbis"</code></td><td>Yes</td><td><code>.ogg</code>, <code>.oga</code>, <code>.spx</code></td></tr>
<tr><td>FLAC</td><td><code>"flac"</code></td><td>No</td><td><code>.flac</code></td></tr>
<tr><td>WAV</td><td><code>"wav"</code></td><td>No</td><td><code>.wav</code></td></tr>
<tr><td>MP3</td><td><code>"mp3"</code></td><td>No</td><td><code>.mp3</code></td></tr>
</tbody></table>
</div>
<p>éŸ³é¢‘æ ¼å¼,é»˜è®¤å¯ç”¨çš„ogg.</p>
<ul>
<li>ogg: å¼€æº,éŸ³è´¨æ¯”mp3å¥½;å…¼å®¹æ€§ä¸å¥½. åœ¨ç½‘ç»œæµåª’ä½“åœºæ™¯ä¸‹ç‰¹åˆ«èƒ½æ‰“</li>
<li>flac: æ— æŸ;æ–‡ä»¶ä½“ç§¯å¤§. åœ¨éŸ³ä¹åº“,é«˜è´¨é‡æµåª’ä½“åœºæ™¯ä¸‹ç‰¹åˆ«èƒ½æ‰“</li>
<li>wav: æ— æŸ; æœªå‹ç¼©ä½“ç§¯éå¸¸å¤§. ä¸“ä¸šå½•éŸ³,éŸ³é¢‘ç¼–è¾‘åœºæ™¯ä¸‹ç‰¹åˆ«èƒ½æ‰“</li>
<li>mp3: ä½“ç§¯å°; æœ‰æŸéŸ³è´¨å·®. éŸ³ä¹ä¸‹è½½,åœ¨çº¿éŸ³ä¹æœåŠ¡åœºæ™¯ä¸‹ç‰¹åˆ«èƒ½æ‰“</li>
</ul>
<p>3D asset (model or scene) formats:</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>GLTF</td><td><code>"bevy_gltf"</code></td><td>Yes</td><td><code>.gltf</code>, <code>.glb</code></td></tr>
</tbody></table>
</div>
<p>3dèµ„æºæ ¼å¼åªæ”¯æŒgltf.</p>
<p>Shader formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>WGSL</td><td>n/a</td><td>Yes</td><td><code>.wgsl</code></td></tr>
<tr><td>GLSL</td><td><code>"shader_format_glsl"</code></td><td>No</td><td><code>.vert</code>, <code>.frag</code>, <code>.comp</code></td></tr>
<tr><td>SPIR-V</td><td><code>"shader_format_spirv"</code></td><td>No</td><td><code>.spv</code></td></tr>
</tbody></table>
</div>
<p>ç€è‰²å™¨é»˜è®¤æ”¯æŒwgsl.</p>
<ul>
<li>wgsl: WebGPU Shading Language, æ˜¯WebGPUç¼–å†™ç€è‰²å™¨çš„è¯­æ³•</li>
<li>glsl: æ˜¯OpenGL ç€è‰²å™¨è¯­æ³•</li>
<li>spir-v: æ˜¯khronos group ä¸ºvulkanè®¾è®¡çš„,æ˜¯ä¸€ç§ç€è‰²å™¨çš„ä½çº§ä¸­é—´ä»¶è¡¨ç¤º(iræ ¼å¼),è·¨å¹³å°,é«˜æ€§èƒ½</li>
</ul>
<p>å…¶ä¸­vertæ˜¯é¡¶ç‚¹ç€è‰²å™¨,fragæ˜¯æ®µç€è‰²å™¨,geomæ˜¯å‡ ä½•ç€è‰²å™¨.</p>
<p>Font formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Font.html"><code>Font</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>TrueType</td><td>n/a</td><td>Yes</td><td><code>.ttf</code></td></tr>
<tr><td>OpenType</td><td>n/a</td><td>Yes</td><td><code>.otf</code></td></tr>
</tbody></table>
</div>
<p>å­—ä½“ttf/otfä¸¤ç§éƒ½æ˜¯é»˜è®¤æ”¯æŒçš„.</p>
<p>Bevy Scenes:</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>RON-serialized scene</td><td><code>.scn</code>,<code>.scn.ron</code></td></tr>
</tbody></table>
</div>
<p>åœºæ™¯æ ¼å¼æ”¯æŒscn,scné€šå¸¸æ˜¯æ¸¸æˆåœºæ™¯æ–‡ä»¶,åŒ…å«äº†åœºæ™¯å¿…è¦çš„ä¿¡æ¯,
å¦‚åœ°å½¢/å•ä½ä½ç½®/èƒœåˆ©æ¡ä»¶,æœ€åˆè¢«å®æ—¶ç­–ç•¥æ¸¸æˆä½¿ç”¨,ç°åœ¨ä½¿ç”¨éå¸¸å¹¿æ³›.
<code>.scn.ron</code>æ˜¯ä½¿ç”¨rustå¯¹è±¡æ ‡è®°æ ¼å¼è¿›è¡Œç¼–ç çš„,ronæ˜¯ä¸€ç§ç±»ä¼¼jsonçš„æ ¼å¼,
ruståŸç”Ÿæ”¯æŒron.</p>
<p>There are unofficial plugins available for adding support for even more file formats.</p>
<p>è¿˜æœ‰éå®˜æ–¹çš„æ’ä»¶æ”¯æŒäº†ä¸å°‘å…¶ä»–æ–‡ä»¶æ ¼å¼.</p>
<h2 id="gltf-asset-labels"><a class="header" href="#gltf-asset-labels">GLTF Asset Labels</a></h2>
<p><a href="/3d/gltf.html#assetpath-with-labels">Asset path labels to refer to GLTF sub-assets.</a></p>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Mesh{}/Primitive{}/MorphTargets</code>: Morph target animation data for a GLTF Primitive</li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<p>GLTF (Graphics Library Transmission Format)èµ„æºä¸­ä½¿ç”¨çš„æ ‡ç­¾ä¸»è¦æ¶‰åŠä»¥ä¸‹å‡ æ–¹é¢:
æè¿°3Dæ¨¡å‹ã€åœºæ™¯ç»“æ„ã€æè´¨ã€çº¹ç†ç­‰å…ƒç´ çš„å…ƒæ•°æ®ã€‚
è¿™äº›æ ‡ç­¾å¸®åŠ©ç»„ç»‡å’Œå®šä¹‰äº†GLTFæ–‡ä»¶ä¸­çš„ä¸åŒç»„ä»¶ï¼Œ
ä½¿å¾—å®ƒä»¬èƒ½å¤Ÿåœ¨ä¸åŒçš„å¹³å°å’Œåº”ç”¨ç¨‹åºé—´æœ‰æ•ˆä¼ è¾“å’Œæ¸²æŸ“ã€‚
ä»¥ä¸‹æ˜¯ä¸€äº›å…³é”®çš„GLTFèµ„æºæ ‡ç­¾åŠå…¶ç”¨é€”æ¦‚è¿°ï¼š</p>
<ul>
<li>asset: åŒ…å«äº†GLTFæ–‡ä»¶çš„åŸºæœ¬å…ƒæ•°æ®ï¼Œå¦‚ç‰ˆæœ¬å·ã€ç‰ˆæƒä¿¡æ¯ã€ç”Ÿæˆå·¥å…·ç­‰ã€‚</li>
<li>scene: å®šä¹‰åœºæ™¯çš„åŸºæœ¬æ„æˆï¼Œä¸€ä¸ªGLTFæ–‡ä»¶å¯ä»¥åŒ…å«å¤šä¸ªåœºæ™¯ï¼Œæ¯ä¸ªåœºæ™¯å¯ä»¥å¼•ç”¨ä¸åŒçš„èŠ‚ç‚¹é›†åˆã€‚</li>
<li>scenes: åœºæ™¯åˆ—è¡¨ï¼Œæ¯ä¸ªåœºæ™¯å®šä¹‰äº†åœºæ™¯çš„æ ¹èŠ‚ç‚¹ï¼Œä»¥åŠåˆå§‹é»˜è®¤åœºæ™¯ã€‚</li>
<li>nodes: èŠ‚ç‚¹åˆ—è¡¨ï¼Œå®šä¹‰äº†3Dç©ºé—´ä¸­çš„å¯¹è±¡ï¼ˆå¦‚æ¨¡å‹ã€ç¯å…‰ã€ç›¸æœºç­‰ï¼‰åŠå…¶å˜æ¢ï¼ˆä½ç½®ã€æ—‹è½¬ã€ç¼©æ”¾ï¼‰ã€‚</li>
<li>meshes: ç½‘æ ¼åˆ—è¡¨ï¼Œæè¿°äº†3Då¯¹è±¡çš„å‡ ä½•å½¢çŠ¶ï¼ŒåŒ…æ‹¬é¡¶ç‚¹ã€ç´¢å¼•å’Œé¡¶ç‚¹å±æ€§ï¼ˆå¦‚æ³•çº¿ã€UVåæ ‡ï¼‰ã€‚</li>
<li>materials: æè´¨åˆ—è¡¨ï¼Œå®šä¹‰äº†å¦‚ä½•æ¸²æŸ“ç½‘æ ¼è¡¨é¢ï¼ŒåŒ…æ‹¬é¢œè‰²ã€çº¹ç†ã€å…‰ç…§æ¨¡å‹ç­‰å±æ€§ã€‚</li>
<li>textures: çº¹ç†åˆ—è¡¨ï¼Œå­˜å‚¨å›¾åƒæ•°æ®ï¼Œç”¨äºæè´¨è´´å›¾ã€ç¯å¢ƒæ˜ å°„ç­‰ã€‚</li>
<li>images: å›¾åƒæ•°æ®åˆ—è¡¨ï¼Œå¯ä»¥æ˜¯å›¾ç‰‡æ–‡ä»¶çš„å¼•ç”¨æˆ–ç›´æ¥åµŒå…¥çš„å›¾åƒæ•°æ®ã€‚</li>
<li>samplers: å®šä¹‰äº†å¦‚ä½•é‡‡æ ·çº¹ç†ï¼Œå¦‚è¿‡æ»¤å’Œç¯ç»•æ–¹å¼ã€‚</li>
<li>accessors: æ•°æ®è®¿é—®å™¨ï¼Œæè¿°å¦‚ä½•ä»ç¼“å†²åŒºè§†å›¾ä¸­è¯»å–å’Œè§£é‡Šæ•°ç»„æ•°æ®ï¼ˆå¦‚é¡¶ç‚¹åæ ‡ã€é¢œè‰²æ•°æ®ç­‰ï¼‰ã€‚</li>
<li>bufferViews: ç¼“å†²åŒºè§†å›¾ï¼ŒæŒ‡å®šç¼“å†²åŒºä¸­æ•°æ®çš„åç§»é‡å’Œé•¿åº¦ï¼Œä»¥åŠæ•°æ®çš„å­—èŠ‚æ’åˆ—æ–¹å¼ã€‚</li>
<li>buffers: ç¼“å†²åŒºï¼Œå­˜å‚¨å¤§é‡çš„åŸå§‹äºŒè¿›åˆ¶æ•°æ®ï¼Œå¦‚é¡¶ç‚¹åæ ‡ã€ç´¢å¼•ç­‰ã€‚</li>
<li>cameras: ç›¸æœºå®šä¹‰ï¼Œæè¿°äº†å¦‚ä½•ä»3Dåœºæ™¯æ¸²æŸ“åˆ°2Då›¾åƒï¼ŒåŒ…æ‹¬é€è§†ç›¸æœºå’Œæ­£äº¤ç›¸æœºã€‚</li>
<li>animations: åŠ¨ç”»åˆ—è¡¨ï¼Œå®šä¹‰äº†åœºæ™¯ä¸­èŠ‚ç‚¹æˆ–æè´¨éšæ—¶é—´å˜åŒ–çš„åŠ¨ç”»åºåˆ—ã€‚</li>
<li>skins: çš®è‚¤ä¿¡æ¯ï¼Œç”¨äºç»‘å®šç½‘æ ¼é¡¶ç‚¹åˆ°éª¨éª¼ï¼Œå®ç°è’™çš®åŠ¨ç”»ã€‚</li>
<li>extensions: æ‰©å±•ï¼Œå…è®¸åœ¨GLTFè§„èŒƒåŸºç¡€ä¸Šæ·»åŠ é¢å¤–çš„åŠŸèƒ½æˆ–ç‰¹å®šå¹³å°çš„æ”¯æŒã€‚</li>
<li>extras: é™„åŠ æ•°æ®ï¼Œç”¨äºå­˜å‚¨ä¸è¢«GLTFè§„èŒƒç›´æ¥å®šä¹‰çš„ä¿¡æ¯ï¼Œé€šå¸¸ä¾›ç‰¹å®šåº”ç”¨ç¨‹åºæˆ–å·¥å…·ä½¿ç”¨ã€‚</li>
</ul>
<p>bevyä¸­ä½¿ç”¨åˆ°äº†: scene/node/mesh/meshåŸè¯­/å˜å½¢åŠ¨ç”»æ•°æ®/çº¹ç†/æè´¨/é»˜è®¤æè´¨/åŠ¨ç”»/çš®è‚¤.</p>
<h2 id="shader-imports"><a class="header" href="#shader-imports">Shader Imports</a></h2>
<p>TODO</p>
<h2 id="wgpu-backends"><a class="header" href="#wgpu-backends"><code>wgpu</code> Backends</a></h2>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Backends (in order of priority)</th></tr></thead><tbody>
<tr><td>Linux</td><td>Vulkan, GLES3</td></tr>
<tr><td>Windows</td><td>DirectX 12, Vulkan, GLES3</td></tr>
<tr><td>macOS</td><td>Metal</td></tr>
<tr><td>iOS</td><td>Metal</td></tr>
<tr><td>Android</td><td>Vulkan, GLES3</td></tr>
<tr><td>Web</td><td>WebGPU, WebGL2</td></tr>
</tbody></table>
</div>
<p>On GLES3 and WebGL2, some renderer features are unsupported and performance is worse.</p>
<p>WebGPU is experimental and few browsers support it.</p>
<p><code>wgpu</code>æ˜¯rustç¼–å†™çš„å›¾å½¢åº“,å®ç°äº†WebGPUè§„èŒƒ,ä¸ºwebå’ŒåŸç”Ÿåº”ç”¨æä¾›äº†è·¨å¹³å°ä¸€è‡´çš„api,
æ€§èƒ½å¾ˆé«˜,ç›¸æ¯”WebGL,WebGPUæ›´åŠ åº•å±‚,å¯¹äºGPUæ˜¯ç›´æ¥è®¿é—®,æ€§èƒ½å’Œçµæ´»æ€§éƒ½é«˜å¾ˆå¤š.
è·¨å¹³å°æ˜¯wgpuçš„ç‰¹ç‚¹,ç›®å‰å®‰å“åˆ°linux/web/macOS/windowséƒ½æ˜¯æ”¯æŒçš„.
æ˜¯ä¸‹ä¸€ä»£å›¾å½¢å¤„ç†æŠ€æœ¯.å¤æ‚å›¾å½¢æ¸²æŸ“/ä¸‰ç»´å®æ—¶å¯è§†åŒ–åœºæ™¯ä¸‹æ˜¯å¼ºé¡¹,
é€‚ç”¨äºæ¸¸æˆå¼€å‘/æ•°æ®å¯è§†åŒ–/ç§‘å­¦è®¡ç®—.<code>å¯ä»¥è¯´bevyèƒ½èµ·é£,wgpuå°±æ˜¯æ ¸å¿ƒåŸºçŸ³ä¹‹ä¸€</code>.
wgpuè·¨å¹³å°,Vulkan(é€šç”¨è·¨å¹³å°å›¾åƒåº“,ä¸‹ä¸€ä»£çš„æŠ€æœ¯)/Metal(Apple)/D3D12(windows)/
OpenGL/WebGL2å’ŒWebGPU(wasm),æ‰€ä»¥å¯ä»¥è·¨å¹³å°.</p>
<p>ä»ä¸Šé¢çš„è¡¨æ ¼ä¸Šçœ‹å„ä¸ªå¹³å°éƒ½æœ‰äº†æ”¯æŒ.æœªæ¥ä¸çŸ¥é“æ˜¯å¦å¯ä»¥æ”¯æŒä¸»æœºå¹³å°.</p>
<h2 id="schedules"><a class="header" href="#schedules">Schedules</a></h2>
<p>Internally, Bevy has these built-in <a href="/programming/schedules.html">schedules</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Main.html"><code>Main</code></a>:
runs every frame update cycle, to perform general app logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.ExtractSchedule.html"><code>ExtractSchedule</code></a>:
runs after <code>Main</code>, to copy data from the Main World into the Render World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Render.html"><code>Render</code></a>:
runs after <code>ExtractSchedule</code>, to perform all rendering/graphics, in parallel with the next <code>Main</code> run</li>
</ul>
<p>åœ¨bevyå†…ç½®äº†å¦‚ä¸‹è°ƒåº¦å™¨:</p>
<ul>
<li><code>Main</code>ä¸»è°ƒåº¦å™¨,æ¯å¸§éƒ½ä¼šè¿è¡Œ,ç”¨äºæ‰§è¡Œappçš„ä¸€èˆ¬é€»è¾‘.</li>
<li><code>ExtractSchedule</code>å¤–éƒ¨è°ƒåº¦å™¨,åœ¨Mainä¹‹åè¿è¡Œ,ç”¨äºå°†Mainä¸–ç•Œçš„æ•°æ®æ‹·è´åˆ°Renderä¸–ç•Œ.</li>
<li><code>Render</code>æ¸²æŸ“è°ƒåº¦å™¨,åœ¨ExtractScheduleä¹‹åè¿è¡Œ,æ‰§è¡Œå·¡æŸ“æ“ä½œ,ä¸ä¸‹ä¸€ä¸ªMainå¹¶è¡Œæ‰§è¡Œ.</li>
</ul>
<p>The <code>Main</code> schedule simply runs a sequence of other schedules:</p>
<p>On the first run (first frame update of the app):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PreStartup.html"><code>PreStartup</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Startup.html"><code>Startup</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PostStartup.html"><code>PostStartup</code></a></li>
</ul>
<p>On every run (controlled via the <a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> <a href="/programming/res.html">resource</a>):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.First.html"><code>First</code></a>: any initialization that must be done at the start of every frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>: for engine-internal systems intended to run before user logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a>: perform any pending <a href="/programming/states.html">state</a> transitions</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.RunFixedUpdateLoop.html"><code>RunFixedUpdateLoop</code></a>: runs the <a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> schedule as many times as needed</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Update.html"><code>Update</code></a>: for all user logic (your systems) that should run every frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>: for engine-internal systems intended to run after user logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Last.html"><code>Last</code></a>: any final cleanup that must be done at the end of every frame</li>
</ul>
<p><code>FixedUpdate</code> is for all user logic (your systems) that should run at a <a href="/fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<p><code>StateTransition</code> runs the
<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter(...)</code></a>/<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition(...)</code></a>/<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit(...)</code></a>
schedules for your <a href="/programming/states.html">states</a>, when you want to change state.</p>
<p>Mainè°ƒåº¦å™¨çš„å·¥ä½œä»…ä»…æ˜¯æŒ‰é¡ºåºè°ƒç”¨ä»¥ä¸‹è°ƒåº¦å™¨:</p>
<p>é¦–å¸§è¿è¡Œ:</p>
<ul>
<li>PreStartup</li>
<li>Startup</li>
<li>PostStartup</li>
</ul>
<p>æ¯å¸§è¿è¡Œ:</p>
<ul>
<li>First: å¸§åˆå§‹åŒ–</li>
<li>PreUpdate: å¼•æ“å†…éƒ¨çš„å‰ç½®å¤„ç†,ä¼šå…ˆäºç”¨æˆ·é€»è¾‘æ‰§è¡Œ</li>
<li>StateTransition: æ‰§è¡ŒæŒ‚èµ·çŠ¶æ€çš„è½¬æ¢</li>
<li>RunFixedUpdateLoop: æŒ‰éœ€æ‰§è¡Œå¤šæ¬¡FixedUpdateè°ƒåº¦å™¨</li>
<li>Update: æ‰€æœ‰ç”¨æˆ·é€»è¾‘(æˆ‘ä»¬ç¼–å†™çš„system)</li>
<li>PostUpdate: å¼•æ“å†…éƒ¨çš„åç½®å¤„ç†</li>
<li>Last: å¸§æ¸…ç†</li>
</ul>
<p><code>FixedUpdate</code>è°ƒåº¦å™¨é€‚åˆè¿™ç§system:ä¸ä¾èµ–æ˜¾ç¤ºå™¨åˆ·æ–°ç‡,è€Œæ˜¯æœ‰è‡ªå·±å›ºå®šçš„é¢‘ç‡,
appå¦‚æœæ‰§è¡Œå¿«,å°±å¯èƒ½è·³è¿‡FixedUpdate,å¦‚æœæ‰§è¡Œæ…¢,å°±å¯èƒ½æ‰§è¡Œå¤šæ¬¡FixedUpdate.</p>
<p>å½“ä½ æƒ³è¦æ”¹å˜çŠ¶æ€æ—¶,StateTransitionä¼šè¿è¡ŒOnEnter/OnTransition/OnExitè°ƒåº¦å™¨.</p>
<p>The <a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Render.html"><code>Render</code></a> schedule is organized using <a href="/programming/system-sets.html">sets</a> (<a href="https://docs.rs/bevy/0.11.0/bevy/render/enum.RenderSet.html"><code>RenderSet</code></a>):</p>
<ul>
<li><code>ExtractCommands</code>: apply <a href="/programming/deferred.html">deferred</a> buffers from systems that ran in <code>ExtractSchedule</code></li>
<li><code>Prepare</code>/<code>PrepareFlush</code>: set up data on the GPU (buffers, textures, etc.)</li>
<li><code>Queue</code>/<code>QueueFlush</code>: generate the render jobs to be run (usually <a href="/TODO.html">phase items</a>)</li>
<li><code>PhaseSort</code>/<code>PhaseSortFlush</code>: sort and batch <a href="/TODO.html">phase items</a> for efficient rendering</li>
<li><code>Render</code>/<code>RenderFlush</code>: execute the <a href="/TODO.html">render graph</a> to actually trigger the GPU to do work</li>
<li><code>Cleanup</code>/<code>CleanupFlush</code>: clear any data from the render World that should not persist to the next frame</li>
</ul>
<p>The <code>*Flush</code> variants are just to apply any <a href="/programming/deferred.html">deferred</a> buffers after every step, if needed.</p>
<p>Renderè°ƒåº¦å™¨æ˜¯ä½¿ç”¨RenderSetç»„ç»‡çš„:</p>
<ul>
<li>ExtractCommands: å¤–éƒ¨å‘½ä»¤, ä»ExtractScheduleå¤–éƒ¨è°ƒåº¦å™¨ä¸­è·å–buffer</li>
<li>Prepare/PrepareFlush: åœ¨GPUä¸Šè®¾ç½®æ•°æ®(buffer/çº¹ç†ç­‰)</li>
<li>Queue/QueueFlush: ç”Ÿæˆæ¸²æŸ“ä»»åŠ¡</li>
<li>PhaseSort/PhaseSortFlush: åˆ†é˜¶æ®µå¤„ç†, ä¸ºäº†æ›´æœ‰æ•ˆçš„æ¸²æŸ“åšå¿…è¦çš„æ’åºå’Œåˆ†æ‰¹æ¬¡å¤„ç†</li>
<li>Render/RenderFlush: è§¦å‘GPUå¼€å§‹å·¥ä½œ</li>
<li>Cleanup/CleanupFlush: åœ¨æ¸²æŸ“ä¸–ç•Œä¸­,æ¸…é™¤ä¸‹ä¸€å¸§ä¸éœ€è¦çš„æŒä¹…åŒ–çš„æ•°æ®</li>
</ul>
<p><code>Flush</code>ç³»åˆ—æ“ä½œæ˜¯åœ¨æ¯æ­¥ä¸­,å»¶æ—¶å¯¹bufferè¿›è¡Œå¤„ç†.</p>
<h2 id="run-conditions"><a class="header" href="#run-conditions">Run Conditions</a></h2>
<p>TODO</p>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>TODO</p>
<h2 id="bundles"><a class="header" href="#bundles">Bundles</a></h2>
<p>Bevy's built-in <a href="/programming/bundle.html">bundle</a> types, for spawning different common
kinds of entities.</p>
<p>Bundleæ˜¯bevyå†…ç½®çš„ç±»å‹,ç”¨äºç”Ÿæˆå®ä½“,ç”Ÿæˆå®ä½“æ—¶éœ€è¦æŒ‡å®šç»‘å®šçš„ç»„ä»¶,
è¿™ä¸ªBundleé‡Œä¿å­˜çš„å°±æ˜¯å„ç§ç»„ä»¶.</p>
<p><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/bundle/trait.Bundle.html#implementors">(List in API Docs)</a></p>
<p>Any tuples of up to 15 <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/trait.Component.html"><code>Component</code></a> types are valid bundles.</p>
<p>General:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a>:
Contains the required <a href="/fundamentals/transforms.html">transform</a> and <a href="/fundamentals/visibility.html">visibility</a>
components that must be included on <em>all</em> entities that need rendering or <a href="/fundamentals/hierarchy.html">hierarchy</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a>:
Contains only the transform types, subset of <code>SpatialBundle</code></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a>:
Contains only the visibility types, subset of <code>SpatialBundle</code></li>
</ul>
<p>bevyæä¾›äº†å®ç°Bundleçš„å…·ä½“ç±»å‹,éƒ½æ˜¯å…ƒç»„ç±»å‹,æœ€å¤šèƒ½æŒ‡å®š15ä¸ªç»„ä»¶,
bevyä¾æ®ä¸åŒçš„åœºæ™¯å†…ç½®äº†ä¸€äº›Bundleå®ç°,ä¸‹é¢çœ‹çœ‹å…·ä½“æœ‰å“ªäº›å®ç°.</p>
<p>é€šç”¨BundleåŒ…å«ä»¥ä¸‹ç±»å‹:</p>
<p><code>SpatialBundle</code>: ç©ºé—´Bundle. (å¦‚æœè¦ç»§æ‰¿,éœ€è¦åŒ…å«ä¸‹é¢4ä¸ªç»„ä»¶),ä¸‹åˆ—ç»„ä»¶åº”åŒ…å«åœ¨å†…:</p>
<ul>
<li><code>Visibility</code> å®ä½“æ˜¯å¦è¦æ˜¾ç¤º</li>
<li><code>ComputedVisibility</code> ç”±ç®—æ³•å†³å®šå®ä½“æ˜¯å¦è¦æ˜¾ç¤ºæˆ–æå–å‡ºæ¥åšæ¸²æŸ“</li>
<li><code>Transform</code> æ”¾ç½®æˆ–ç§»åŠ¨å®ä½“,è¡¨ç¤ºå®ä½“åŸºäºçˆ¶å¯¹è±¡çš„çš„ä½ç½®.(å¦‚æœæ²¡æœ‰çˆ¶å¯¹è±¡,å°±æ˜¯åŸºäºå¸§çš„ä½ç½®)</li>
<li><code>GlobalTransform</code> å®ä½“çš„å…¨å±€å˜æ¢,è¡¨ç¤ºå®ä½“åŸºäºå¸§çš„ä½ç½®</li>
</ul>
<p><em><strong>åœ¨Mainè°ƒåº¦ä¸­Updateä¹‹åæ˜¯PostUpdate,åœ¨PostUpdateä¸­ä¼šæ‰§è¡ŒTransformPropagate(è¿™æ˜¯ä¸€ä¸ªsystemé›†åˆ),
TransformPropagateé›†åˆä¸­æœ‰ä¸ªsystemæ˜¯Transform,åœ¨è¿™ä¸ªTransform systemä¸­ä¼šæ‰§è¡ŒGlobalTransformçš„å¤„ç†.</strong></em></p>
<p><code>Mainè°ƒåº¦</code> -- <code>PostUpdateè°ƒåº¦</code> -- <code>TransformPropagateç³»ç»Ÿé›†</code> -- <code>Transformç³»ç»Ÿ</code> -- <code>å¤„ç†GlobalTransform</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpatialBundle {
    pub visibility: Visibility,
    pub transform: Transform,
    pub computed: ComputedVisibility,
    pub global_transform: GlobalTransform,
}
<span class="boring">}</span></code></pre></pre>
<p><code>TransformBundle</code>: å˜æ¢Bundle,æ˜¯<code>SpatialBundle</code>çš„å˜æ¢å­é›†.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TransformBundle {
    pub local: Transform,
    pub global: GlobalTransform,
}
<span class="boring">}</span></code></pre></pre>
<p><code>VisibilityBundle</code>: å¯è§†Bundle,æ˜¯<code>SpatialBundle</code>çš„å¯è§†å­é›†.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VisibilityBundle {
    pub visibility: Visibility,
    pub computed: ComputedVisibility,
}
<span class="boring">}</span></code></pre></pre>
<p>Scenes:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.SceneBundle.html"><code>SceneBundle</code></a>:
Used for spawning scenes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.DynamicSceneBundle.html"><code>DynamicSceneBundle</code></a>:
Used for spawning dynamic scenes</li>
</ul>
<p>åœºæ™¯Bundle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SceneBundle {
    pub scene: Handle&lt;Scene&gt;,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub visibility: Visibility,
    pub computed_visibility: ComputedVisibility,
}

pub struct DynamicSceneBundle {
    pub scene: Handle&lt;DynamicScene&gt;,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub visibility: Visibility,
    pub computed_visibility: ComputedVisibility,
}
<span class="boring">}</span></code></pre></pre>
<p>sceneæ˜¯æè¿°åœºæ™¯çš„æ•°æ®,ä¸»è¦æ˜¯å®ä½“/ç»„ä»¶çš„æ•°æ®,å¯ä»¥è¿›è¡Œåºåˆ—å·å’Œååºåˆ—,
æœ‰äº†åœºæ™¯æ•°æ®,å°±èƒ½è¿›è¡Œå­˜ç›˜æˆ–ä»ç£ç›˜åŠ è½½.å…³å¡è®¾è®¡éƒ½å¯ä»¥ç”¨åˆ°scene.
é™æ€åœºæ™¯å¸¸è¡¨ç¤ºé™æ€çš„,åœ¨è®¾è®¡æ—¶å°±å®šä¹‰å¥½çš„åœºæ™¯;åŠ¨æ€åœºæ™¯åˆ™æ˜¯åŠ¨æ€ç”Ÿæˆ,è¿è¡Œæ—¶æ›´æ–°çš„åœºæ™¯.
åŠ¨æ€åœºæ™¯æä¾›äº†æ›´åŠ çµæ´»çš„æ›´æ–°å’Œå¢é‡ä¿®æ”¹èƒ½åŠ›.</p>
<p>Audio:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/type.AudioBundle.html"><code>AudioBundle</code></a>:
Play [audio][cb::audio] from an <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> asset</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/type.SpatialAudioBundle.html"><code>SpatialAudioBundle</code></a>:
Play <a href="/audio/spatial.html">positional audio</a> from an <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> asset</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSourceBundle.html"><code>AudioSourceBundle</code></a>:
Play audio from a <a href="/audio/custom.html">custom data source/stream</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.SpatialAudioSourceBundle.html"><code>SpatialAudioSourceBundle</code></a>:
Play positional audio from a <a href="/audio/custom.html">custom data source/stream</a></li>
</ul>
<p>éŸ³é¢‘Bundle.</p>
<ul>
<li><code>AudioBundle</code> ä»AudioSourceèµ„æºæ’­æ”¾éŸ³é¢‘</li>
<li><code>SpatialAudioBundle</code> ä»AudioSourceèµ„æºæ’­æ”¾ç©ºé—´éŸ³é¢‘</li>
<li><code>AudioSourceBundle</code> ä»<code>è‡ªå®šä¹‰æº/è‡ªå®šä¹‰æµ</code>æ’­æ”¾éŸ³é¢‘</li>
<li><code>SpatialAudioSourceBundle</code> ä»<code>è‡ªå®šä¹‰æº/è‡ªå®šä¹‰æµ</code>æ’­æ”¾ç©ºé—´éŸ³é¢‘</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AudioSource {
    // éŸ³é¢‘çš„åŸå§‹æ•°æ®,æ ¼å¼ä¸ºwav/ogg/flac/mp3ä¸­çš„ä¸€ç§,
    // bevyé»˜è®¤å¼€å¯æ”¯æŒçš„ogg,å…¶ä»–æ ¼å¼éœ€è¦åœ¨åŠŸèƒ½å‡ºå¼€å¯æ”¯æŒ.
    pub bytes: Arc&lt;[u8]&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Bevy 3D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/core_3d/struct.Camera3dBundle.html"><code>Camera3dBundle</code></a>:
3D camera, can use perspective (default) or orthographic projection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/experimental/taa/struct.TemporalAntiAliasBundle.html"><code>TemporalAntiAliasBundle</code></a>:
Add this to a 3D camera to enable TAA</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.ScreenSpaceAmbientOcclusionBundle.html"><code>ScreenSpaceAmbientOcclusionBundle</code></a>:
Add this to a 3D camera to enable SSAO</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>:
3D Object/Primitive: a Mesh and a custom Material to draw it with</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/type.PbrBundle.html"><code>PbrBundle</code></a>:
<code>MaterialMeshBundle</code> with the default Physically-Based Material (<a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.DirectionalLightBundle.html"><code>DirectionalLightBundle</code></a>:
3D directional light (like the sun)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.PointLightBundle.html"><code>PointLightBundle</code></a>:
3D point light (like a lamp or candle)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.SpotLightBundle.html"><code>SpotLightBundle</code></a>:
3D spot light (like a projector or flashlight)</li>
</ul>
<p>bevy 3d Bundle.</p>
<ul>
<li><code>Camera3dBundle</code> 3dæ‘„åƒå¤´,ç”¨äºé€è§†æŠ•å½±(é»˜è®¤)æˆ–æ­£äº¤æŠ•å½±</li>
<li><code>TemporalAntiAliasBundle</code> taa(æŠ—é”¯é½¿),å¯ç”¨äº3dæ‘„åƒå¤´</li>
<li><code>ScreenSpaceAmbientOcclusionBundle</code> ssao(å±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½),å¯ç”¨äº3dæ‘„åƒå¤´</li>
<li><code>MaterialMeshBundle</code> ç½‘æ ¼å’Œæè´¨,3dåŸè¯­</li>
<li><code>PbrBundle</code> æ˜¯<code>MaterialMeshBundle</code>çš„ä¸€ç§,æè´¨æ˜¯<code>StandardMaterial</code>(ä¸€ç§åŸºäºpbrçš„æè´¨,å¯ä»Color/Imageä¸­ç›´æ¥ç”Ÿæˆ)</li>
<li><code>DirectionalLightBundle</code> 3då®šå‘å…‰(eg:é˜³å…‰).(å®šå‘å…‰åœ¨ç°å®ä¸­å¹¶ä¸å­˜åœ¨,ä½†è¿‘ä¼¼ä¸ºå¾ˆè¿œçš„å…‰,æœˆå…‰å°±å±äºå®šå‘å…‰)</li>
<li><code>PointLightBundle</code> 3dç‚¹å…‰æº(eg:èœ¡çƒ›/å°ç¯).(ç‚¹å…‰æºæ˜¯ä»ä¸­å¿ƒç‚¹å‘å„ä¸ªæ–¹å‘å‘å°„å…‰çš„ç¯)</li>
<li><code>SpotLightBundle</code> 3dèšå…‰ç¯(eg:æŠ•å½±ä»ª/æ‰‹ç”µç­’).</li>
</ul>
<p>é€è§†æŠ•å½±ï¼ˆPerspective Projectionï¼‰å’Œ3Dæ­£äº¤æŠ•å½±ï¼ˆOrthographic Projectionï¼‰æ˜¯è®¡ç®—æœºå›¾å½¢å­¦ä¸­ä¸¤ç§åŸºæœ¬çš„æŠ•å½±æ–¹å¼ï¼Œ
ç”¨äºå°†ä¸‰ç»´åœºæ™¯æŠ•å½±åˆ°äºŒç»´å¹³é¢ä¸Šã€‚å®ƒä»¬åœ¨è§†è§‰æ•ˆæœå’Œåº”ç”¨åœºæ™¯ä¸Šæœ‰æ˜¾è‘—çš„åŒºåˆ«ã€‚<br />
<code>é€è§†æŠ•å½±</code>æ¨¡æ‹Ÿäº†äººç±»çœ¼ç›å’Œç›¸æœºçš„è§†è§’ç‰¹æ€§ï¼Œå³è¿œå¤„çš„ç‰©ä½“çœ‹èµ·æ¥ä¼šæ›´å°ï¼Œè¿‘å¤„çš„ç‰©ä½“ä¼šæ›´å¤§ã€‚
è¿™ç§æŠ•å½±æ–¹å¼èƒ½å¤Ÿæä¾›é€¼çœŸçš„æ·±åº¦æ„Ÿã€‚<br />
<code>æ­£äº¤æŠ•å½±</code>ä¸ä¼šæ ¹æ®ç‰©ä½“è·ç¦»ç›¸æœºçš„è¿œè¿‘è€Œç¼©æ”¾ç‰©ä½“å¤§å°ã€‚
å®ƒé€‚åˆäºéœ€è¦ç²¾ç¡®æµ‹é‡å’Œå¯¹æ¯”çš„åœºæ™¯ï¼Œå¦‚CADè½¯ä»¶ã€2Dæ¸¸æˆå’ŒæŸäº›ç±»å‹çš„ç­–ç•¥æ¸¸æˆã€‚</p>
<p>Temporal Anti-Aliasing(<code>TAA</code>)æ˜¯ä¸€ç§æŠ—é”¯é½¿æŠ€æœ¯ï¼Œç”¨äºè®¡ç®—æœºå›¾å½¢å­¦ä¸­ï¼Œä»¥å‡å°‘åŠ¨æ€åœºæ™¯ä¸­å‡ºç°çš„é”¯é½¿çŠ¶è¾¹ç¼˜ã€‚
TAA åˆ©ç”¨å¤šå¸§ä¿¡æ¯æ¥å¹³æ»‘å¯¹è±¡è¾¹ç¼˜ï¼Œä»è€Œåœ¨è¿åŠ¨ä¸­ä¿æŒé«˜è´¨é‡çš„è§†è§‰æ•ˆæœã€‚</p>
<p>å±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½ (Screen Space Ambient Occlusion, <code>SSAO</code>) æ˜¯ä¸€ç§åœ¨å®æ—¶æ¸²æŸ“ä¸­å¸¸ç”¨çš„æŠ€æœ¯ï¼Œ
ç”¨äºæ¨¡æ‹Ÿç¯å¢ƒå…‰é®è”½ï¼ˆAmbient Occlusion, AOï¼‰çš„æ•ˆæœã€‚
AO æ˜¯ä¸€ç§å…¨å±€å…‰ç…§æ•ˆæœï¼Œç”¨äºæ¨¡æ‹Ÿå…‰çº¿åœ¨ç‰©ä½“ä¹‹é—´åå¼¹æ—¶è¢«é®æŒ¡çš„æƒ…å†µï¼Œ
é€šå¸¸ç”¨äºå¢å¼ºç‰©ä½“ä¹‹é—´çš„é˜´å½±å’Œç»†èŠ‚ï¼Œä½¿åœºæ™¯çœ‹èµ·æ¥æ›´åŠ çœŸå®å’Œç«‹ä½“ã€‚</p>
<p>ç‰©ç†åŸºç¡€æ¸²æŸ“ï¼ˆPhysically Based Rendering, <code>PBR</code>ï¼‰
æ˜¯ä¸€ç§é€šè¿‡æ¨¡æ‹Ÿå…‰ä¸ç‰©ä½“è¡¨é¢äº¤äº’çš„ç‰©ç†ç°è±¡æ¥å®ç°æ›´é€¼çœŸå’Œä¸€è‡´è§†è§‰æ•ˆæœçš„æ¸²æŸ“æ–¹æ³•ã€‚
PBRå¹¿æ³›åº”ç”¨äºæ¸¸æˆã€ç”µå½±å’Œè™šæ‹Ÿç°å®ç­‰é¢†åŸŸï¼Œå®ƒèƒ½åœ¨å„ç§å…‰ç…§æ¡ä»¶ä¸‹ç”Ÿæˆä¸€è‡´ä¸”é€¼çœŸçš„å›¾åƒã€‚</p>
<p>Bevy 2D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>:
2D camera, uses orthographic projection + other special configuration for 2D</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.SpriteBundle.html"><code>SpriteBundle</code></a>:
2D sprite (<a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.SpriteSheetBundle.html"><code>SpriteSheetBundle</code></a>:
2D sprite (<a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.MaterialMesh2dBundle.html"><code>MaterialMesh2dBundle</code></a>:
2D shape, with custom Mesh and Material (similar to 3D objects)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Text2dBundle.html"><code>Text2dBundle</code></a>:
Text to be drawn in the 2D world (not the UI)</li>
</ul>
<p>bevy 2d Bundle.</p>
<ul>
<li><code>Camera2dBundle</code> 2dæ‘„åƒå¤´,ç”¨äºæ­£äº¤æŠ•å½±å’Œå…¶ä»–2Dçš„ç‰¹æ®Šé…ç½®</li>
<li><code>SpriteBundle</code> ç²¾çµ.Image assetèµ„æºè¡¨ç¤º</li>
<li><code>SpriteSheetBundle</code> ç²¾çµ. TextureAtlas assetèµ„æºè¡¨ç¤º. TextureAtlas(åŒ…å«å¤šä¸ªçº¹ç†å›¾é›†,eg: spritesheet ç²¾çµè¡¨,tilemap ç“¦ç‰‡å›¾)</li>
<li><code>MaterialMesh2dBundle</code> 2då½¢çŠ¶,å¸¦ç½‘æ ¼å’Œæè´¨.(å’Œ3dçš„MaterialMeshBundleç±»ä¼¼)</li>
<li><code>Text2dBundle</code> 2dä¸–ç•Œè¦æ¸²æŸ“çš„æ–‡æœ¬(é€šè¿‡2d Camera2dBundleåœ¨2d sceneè¦æ¸²æŸ“çš„æ–‡æœ¬)</li>
</ul>
<p><code>sprite</code> ç²¾çµ,ä¸€ä¸ªç‹¬ç«‹çš„å›¾åƒå…ƒç´ ,é€šå¸¸ç”¨äºè¡¨ç¤ºæ¸¸æˆä¸­çš„è§’è‰²ã€é“å…·ã€èƒŒæ™¯å…ƒç´ ç­‰ã€‚
ç²¾çµå¯ä»¥åœ¨å±å¹•ä¸Šç§»åŠ¨ã€æ—‹è½¬ã€ç¼©æ”¾ï¼Œå¹¶ä¸”å¯ä»¥è¿›è¡ŒåŠ¨ç”»ä»¥å±•ç°å„ç§æ•ˆæœã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpriteBundle {
    pub sprite: Sprite,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub texture: Handle&lt;Image&gt;,
    pub visibility: Visibility,
    pub computed_visibility: ComputedVisibility,
}
<span class="boring">}</span></code></pre></pre>
<p>Bevy UI:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.NodeBundle.html"><code>NodeBundle</code></a>:
Empty node element (like HTML <code>&lt;div&gt;</code>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.ButtonBundle.html"><code>ButtonBundle</code></a>:
Button element</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.ImageBundle.html"><code>ImageBundle</code></a>:
Image element (<a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.AtlasImageBundle.html"><code>AtlasImageBundle</code></a>:
Image element (<a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.TextBundle.html"><code>TextBundle</code></a>:
Text element</li>
</ul>
<p>ui Bundle.</p>
<ul>
<li><code>NodeBundle</code> ç©ºNodeå…ƒç´ ,å¯åŒ…å«å„ç§å­nodeçš„å®¹å™¨,æ˜¯æœ€åŸºç¡€çš„uiå…ƒç´ </li>
<li><code>ButtonBundle</code> æŒ‰é’®</li>
<li><code>ImageBundle</code> Imageå›¾åƒ</li>
<li><code>AtlasImageBundle</code> TextureAtlaså›¾åƒ.(åŒ…å«å¤šä¸ªçº¹ç†å›¾é›†)</li>
<li><code>TextBundle</code> æ–‡æœ¬</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p><a href="/programming/res.html">(more info about working with resources)</a></p>
<p>èµ„æºä¸»è¦åˆ†é…ç½®èµ„æº/å¼•æ“èµ„æº/æ¸²æŸ“èµ„æº/wgpuèµ„æº/è¾“å…¥å¤„ç†èµ„æº,ä»¥ä¸‹é€ä¸ªåˆ†æ.</p>
<h3 id="configuration-resources"><a class="header" href="#configuration-resources">Configuration Resources</a></h3>
<p>These resources allow you to change the settings for how various parts of Bevy work.</p>
<p>These may be inserted at the start, but should also be fine to change at runtime (from a
<a href="/programming/systems.html">system</a>):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/clear_color/struct.ClearColor.html"><code>ClearColor</code></a>:
Global renderer background color to clear the window at the start of each frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.GlobalVolume.html"><code>GlobalVolume</code></a>:
The overall volume for playing audio</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.AmbientLight.html"><code>AmbientLight</code></a>:
Global renderer "fake lighting", so that shadows don't look too dark / black</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/enum.Msaa.html"><code>Msaa</code></a>:
Global renderer setting for Multi-Sample Anti-Aliasing (some platforms might only support the values 1 and 4)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/struct.UiScale.html"><code>UiScale</code></a>:
Global scale value to make all UIs bigger/smaller</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gizmos/struct.GizmoConfig.html"><code>GizmoConfig</code></a>:
Controls how <a href="/fundamentals/gizmos.html">gizmos</a> are rendered</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/wireframe/struct.WireframeConfig.html"><code>WireframeConfig</code></a>:
Global toggle to make everything be rendered as wireframe</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a>:
Gamepad input device settings, like joystick deadzones and button sensitivities</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/winit/struct.WinitSettings.html"><code>WinitSettings</code></a>:
Settings for the OS Windowing backend, including update loop / power-management settings</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/enum.TimeUpdateStrategy.html"><code>TimeUpdateStrategy</code></a>:
Used to control how the <a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Time</code></a> is updated</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.Schedules.html"><code>Schedules</code></a>:
Stores all <a href="/programming/schedules.html">schedules</a>, letting you register additional functionality at runtime</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a>:
The sequence of <a href="/programming/schedules.html">schedules</a> that will run every frame update</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„é…ç½®èµ„æº.</p>
<ul>
<li><code>ClearColor</code> èƒŒæ™¯è‰²</li>
<li><code>GlobalVolume</code> éŸ³é‡å¤§å°</li>
<li><code>AmbientLight</code> ç¯å¢ƒå…‰(æœ‰äº†ç¯å¢ƒå…‰,é˜´å½±å°±ä¸ä¼šå¤ªæš—æˆ–ç›´æ¥æ˜¯é»‘è‰²)</li>
<li><code>Msaa</code> å¤šé‡é‡‡æ ·æŠ—é”¯é½¿,éƒ¨åˆ†å¹³å°åªæ”¯æŒ1-4ä¸ªæ ·æœ¬.bevyé»˜è®¤æ˜¯4ä¸ªæ ·æœ¬</li>
<li><code>UiScale</code> UIç¼©æ”¾å€¼,å¯å½±å“æ‰€æœ‰UI</li>
<li><code>GizmoConfig</code> å°ç©æ„çš„é…ç½®</li>
<li><code>WireframeConfig</code> ç½‘æ ¼çº¿æ¡†æ˜¯å¦æ˜¾ç¤º</li>
<li><code>GamepadSettings</code> æ‰‹æŸ„è®¾ç½®(eg:æ‘‡æ†æ­»åŒºå’ŒæŒ‰é’®çµæ•åº¦)</li>
<li><code>WinitSettings</code> çª—å£åç«¯è®¾ç½®,åŒ…æ‹¬æ›´æ–°å¾ªç¯/ç”µæºç®¡ç†è®¾ç½®(winitå°è£…äº†å„ä¸ªå¹³å°çª—å£çš„åŠŸèƒ½)</li>
<li><code>TimeUpdateStrategy</code> æ—¶é—´æ›´æ–°ç­–ç•¥.é»˜è®¤çš„<code>è‡ªåŠ¨ç­–ç•¥</code>å°±å¾ˆå¥½äº†;åœ¨æµ‹è¯•/ç½‘ç»œå¤„ç†,å¯ä»¥æ‰‹åŠ¨è®¾ç½®ä¸‹ä¸€ä¸ªæ—¶é—´.(æ¯ä¸ªæ¸¸æˆç³»ç»Ÿéƒ½æœ‰ä¸€ä¸ªæ—¶é—´ç³»ç»Ÿçš„)</li>
<li><code>Schedules</code> å­˜å‚¨äº†æ‰€æœ‰çš„è°ƒåº¦å™¨,åœ¨è¿è¡Œæ—¶å¯ä»¥æ³¨å†Œé™„åŠ é€»è¾‘</li>
<li><code>MainScheduleOrder</code> æŒ‡å®šæ¯å¸§è°ƒåº¦å™¨æ‰§è¡Œé¡ºåº(å½“ç„¶æ˜¯åœ¨Mainè°ƒåº¦å™¨ä¸­çš„,å› ä¸ºæ¯å¸§é€»è¾‘æ›´æ–°å°±æ˜¯åœ¨Mainè°ƒåº¦å™¨ä¸­)</li>
</ul>
<p>å¤šé‡é‡‡æ ·æŠ—é”¯é½¿ï¼ˆMultisample Anti-Aliasingï¼Œ<code>MSAA</code>ï¼‰æ˜¯ä¸€ç§å›¾å½¢å¤„ç†æŠ€æœ¯ï¼Œ
ç”¨äºå‡å°‘åœ¨æ¸²æŸ“3Då›¾å½¢æ—¶å‡ºç°çš„é”¯é½¿è¾¹ç¼˜ï¼ˆaliasingï¼‰ã€‚
é”¯é½¿è¾¹ç¼˜æ˜¯ç”±äºæœ‰é™çš„åˆ†è¾¨ç‡å’Œåƒç´ æ•°é‡åœ¨æç»˜æ–œçº¿æˆ–æ›²çº¿æ—¶é€ æˆçš„ã€‚
MSAAé€šè¿‡åœ¨æ¯ä¸ªåƒç´ å†…é‡‡æ ·å¤šä¸ªä½ç½®å¹¶å¹³å‡è¿™äº›æ ·æœ¬çš„é¢œè‰²æ¥å¹³æ»‘è¿™äº›é”¯é½¿è¾¹ç¼˜ã€‚</p>
<p>Settings that are not modifiable at runtime are not represented using resources. Instead,
they are configured via the respective <a href="builtins.html#plugins">plugins</a>.</p>
<p>bevyå†…ç½®çš„é…ç½®å½±å“äº†bevyå„ä¸ªæ¨¡å—çš„è¿è¡Œæ–¹å¼.é…ç½®èµ„æºåº”è¯¥åœ¨ç¨‹åºå¯åŠ¨æ—¶æ·»åŠ ,åœ¨è¿è¡ŒæœŸé—´ä¹Ÿè¦æ”¯æŒä¿®æ”¹(é€šè¿‡system).
<code>è¿è¡Œæ—¶ä¸ä¿®æ”¹çš„è®¾ç½®ä¸è¦ç”¨èµ„æºè¡¨ç¤º,è€Œåº”è¯¥ä½¿ç”¨æ’ä»¶è¡¨ç¤º</code>.</p>
<h3 id="engine-resources"><a class="header" href="#engine-resources">Engine Resources</a></h3>
<p>These resources provide access to different features of the game engine at runtime.</p>
<p>Access them from your <a href="/programming/systems.html">systems</a>, if you need their state, or to control the respective
parts of Bevy. These resources are in the <a href="/gpu/intro.html">Main World</a>. <a href="builtins.html#render-world">See here for the
resources in the Render World</a>.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Time</code></a>:
Global time-related information (current frame delta time, time since startup, etc.)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/fixed_timestep/struct.FixedTime.html"><code>FixedTime</code></a>:
Tracks remaining time until the next <a href="/fundamentals/fixed-timestep.html">fixed update</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>:
Control the asset system: Load assets, check load status, etc.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a>:
Contains the actual data of the loaded assets of a given type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.State.html"><code>State&lt;T&gt;</code></a>:
The current value of a <a href="/programming/states.html">states type</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.NextState.html"><code>NextState&lt;T&gt;</code></a>:
Used to queue a transition to another <a href="/programming/states.html">state</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a>:
Tracks the IDs for all currently-detected (connected) gamepad devices</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.SceneSpawner.html"><code>SceneSpawner</code></a>:
Direct control over spawning Scenes into the main app World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core/struct.FrameCount.html"><code>FrameCount</code></a>:
The total number of frames</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/window/screenshot/struct.ScreenshotManager.html"><code>ScreenshotManager</code></a>:
Used to request a screenshot of a window to be taken/saved</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/reflect/struct.AppTypeRegistry.html"><code>AppTypeRegistry</code></a>:
Access to the Reflection Type Registry</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.AsyncComputeTaskPool.html"><code>AsyncComputeTaskPool</code></a>:
Task pool for running background CPU tasks</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.ComputeTaskPool.html"><code>ComputeTaskPool</code></a>:
Task pool where the main app schedule (all the systems) runs</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.IoTaskPool.html"><code>IoTaskPool</code></a>:
Task pool where background i/o tasks run (like asset loading)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> (<a href="/programming/non-send.html">non-send</a>):
Raw state of the <code>winit</code> backend for each window</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/struct.NonSendMarker.html"><code>NonSendMarker</code></a>:
Dummy resource to ensure a system always runs on the main thread</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„å¼•æ“èµ„æº.</p>
<ul>
<li><code>Time</code> å…¨å±€å’Œæ—¶é—´ç›¸å…³çš„ä¿¡æ¯(å½“å‰å¸§çš„å¢é‡æ—¶é—´,å¯åŠ¨åˆ°ç°åœ¨çš„æ—¶é—´ç­‰)</li>
<li><code>FixedTime</code> è·Ÿè¸ªåˆ°ä¸‹ä¸€æ¬¡FixedUpdateçš„å‰©ä½™æ—¶é—´</li>
<li><code>AssetServer</code> Assetèµ„äº§æœåŠ¡,æ§åˆ¶ç€assetèµ„äº§çš„åŠ è½½/æ£€æŸ¥åŠ è½½çŠ¶æ€ç­‰</li>
<li><code>Assets&lt;T&gt;</code> æŒ‡å®šèµ„äº§çš„å®é™…æ•°æ®</li>
<li><code>State&lt;T&gt;</code> çŠ¶æ€ç±»å‹çš„å½“å‰å€¼</li>
<li><code>NextState&lt;T&gt;</code> è¦è½¬æ¢åˆ°å¦ä¸€ä¸ªçŠ¶æ€,å°±å°†è½¬æ¢è¿›è¡Œæ’é˜Ÿ</li>
<li><code>Gamepads</code> è·Ÿè¸ªå½“å‰å·²è¿æ¥çš„æ‰‹æŸ„è®¾å¤‡IDåˆ—è¡¨(ebitenä¸­è¿˜éœ€è¦è‡ªå·±æŸ¥,è¿™ä¸ªå°±ç›´æ¥è‡ªå·±å¤„ç†äº†,æ£’)</li>
<li><code>SceneSpawner</code> åœºæ™¯ç”Ÿæˆ,ç›´æ¥ç”Ÿæˆåœºæ™¯åˆ°main world</li>
<li><code>FrameCount</code> æ€»å¸§æ•°</li>
<li><code>ScreenshotManager</code> çª—å£æˆªå±(ç›®å‰å¤§éƒ¨åˆ†æ¸¸æˆéƒ½æ”¯æŒæˆªå±), æ­¤èµ„æºæ˜¯å¼€å…³æ§åˆ¶</li>
<li><code>AppTypeRegistry</code> è®¿é—®æ³¨å†Œç±»å‹</li>
<li><code>AsyncComputeTaskPool</code> å¼‚æ­¥GPUä»»åŠ¡æ± </li>
<li><code>ComputeTaskPool</code> Mainè°ƒåº¦ä¸­systemè¿è¡Œçš„ä»»åŠ¡æ± </li>
<li><code>IoTaskPool</code> åå°IOä»»åŠ¡æ± (eg:èµ„äº§åŠ è½½)</li>
<li><code>WinitWindows</code> (non-send),çª—å£çš„åŸå§‹çŠ¶æ€</li>
<li><code>NonSendMarker</code> ç¡®ä¿systemè¿è¡Œåœ¨mainçº¿ç¨‹çš„è™šæ‹Ÿèµ„æº</li>
</ul>
<p>bevyå†…ç½®çš„å¼•æ“èµ„æºå¯ä»¥è®¿é—®ä¸åŒçš„åŠŸèƒ½,é€šè¿‡systemè®¿é—®è¿™äº›èµ„æº,
è¿™äº›èµ„æºéƒ½æ˜¯åœ¨Main worldä¸­.</p>
<h4 id="render-world-resources"><a class="header" href="#render-world-resources">Render World Resources</a></h4>
<p>These resources are present in the <a href="/gpu/intro.html">Render World</a>. They can be accessed
from rendering systems (that run during <a href="/gpu/stages.html">render stages</a>).</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.MainWorld.html"><code>MainWorld</code></a>:
(extract schedule only!) access data from the Main World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_graph/struct.RenderGraph.html"><code>RenderGraph</code></a>:
<a href="/TODO.html">The Bevy Render Graph</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.PipelineCache.html"><code>PipelineCache</code></a>:
Bevy's manager of render pipelines. Used to store render pipelines used by the app, to avoid
recreating them more than once.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.TextureCache.html"><code>TextureCache</code></a>:
Bevy's manager of temporary textures. Useful when you need textures to use internally
during rendering.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_phase/struct.DrawFunctions.html"><code>DrawFunctions&lt;P&gt;</code></a>:
Stores draw functions for a given phase item type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_asset/struct.RenderAssets.html"><code>RenderAssets&lt;T&gt;</code></a>:
Contains handles to the GPU representations of currently loaded asset data</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.DefaultImageSampler.html"><code>DefaultImageSampler</code></a>:
The default sampler for <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset textures</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.FallbackImage.html"><code>FallbackImage</code></a>:
Dummy 1x1 pixel white texture. Useful for shaders that normally need a texture, when
you don't have one available.</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„æ¸²æŸ“èµ„æº.</p>
<ul>
<li><code>MainWrold</code> <strong>ä»…æå–è°ƒåº¦å™¨</strong>, è®¿é—®Main worldçš„æ•°æ®</li>
<li><code>RenderGraph</code> æ¸²æŸ“å›¾</li>
<li><code>PipelineCache</code> æ¸²æŸ“ç®¡é“,è¦é¿å…é‡å¤åˆ›å»º</li>
<li><code>TextureCache</code> ä¸´æ—¶çº¹ç†ç®¡ç†,æ¸²æŸ“æ—¶éå¸¸æœ‰ç”¨</li>
<li><code>DrawFunctions</code> ç»˜åˆ¶å‡½æ•°, å­˜å‚¨æŒ‡å®šé˜¶æ®µå…ƒç´ çš„ç±»å‹å¯¹åº”çš„ç»˜åˆ¶å‡½æ•°</li>
<li><code>RenderAssets&lt;T&gt;</code> æ¸²æŸ“èµ„äº§</li>
<li><code>DefaultImageSampler</code> Imageèµ„äº§é—®é¢˜çš„é»˜è®¤é‡‡æ ·å™¨</li>
<li><code>FallbackImage</code> 1x1çš„è™šæ‹Ÿç™½è‰²çº¹ç†,å¯¹äºç€è‰²å™¨æ¥è¯´,éœ€è¦çº¹ç†ä½†æ²¡æœ‰çº¹ç†æ—¶,ä½¿ç”¨è¿™ä¸ª</li>
</ul>
<p>There are many other resources in the Render World, which are not mentioned
here, either because they are internal to Bevy's rendering algorithms, or
because they are just extracted copies of the equivalent resources in the Main
World.</p>
<p>render worldä¸­çš„èµ„æº,åœ¨render systemä¸­è®¿é—®.
è¿˜æœ‰å¾ˆå¤šæ¸²æŸ“èµ„æºæ²¡åˆ—å‡ºæ¥,è¦ä¹ˆæ˜¯å› ä¸ºbevyå†…éƒ¨çš„æ¸²æŸ“ç®—æ³•ç”¨åˆ°,è¦ä¹ˆæ˜¯Main worldä¸­æ‹·è´è¿‡æ¥çš„å‰¯æœ¬.</p>
<h4 id="low-level-wgpu-resources"><a class="header" href="#low-level-wgpu-resources">Low-Level <code>wgpu</code> Resources</a></h4>
<p>Using these resources, you can have direct access to the <code>wgpu</code> APIs for controlling the GPU.
These are available in both the Main World and the Render World.</p>
<p>ä½¿ç”¨wgpuèµ„æº,å¯ä»¥ç›´æ¥è®¿é—®wgpuçš„API,è¿™æ ·å°±å¯ä»¥ç›´æ¥æ§åˆ¶GPUäº†,
åœ¨main worldå’Œrender worldéƒ½èƒ½ä½¿ç”¨.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderDevice.html"><code>RenderDevice</code></a>:
The GPU device, used for creating hardware resources for rendering/compute</li>
<li>[<code>RenderQueue</code>][bevy::RenderQueue]:
The GPU queue for submitting work to the hardware</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderAdapter.html"><code>RenderAdapter</code></a>:
Handle to the physical GPU hardware</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderAdapterInfo.html"><code>RenderAdapterInfo</code></a>:
Information about the GPU hardware that Bevy is running on</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„wgpuèµ„æº.</p>
<ul>
<li><code>RenderDevice</code> GPUè®¾å¤‡,ç”¨äºåˆ›å»ºæ¸²æŸ“/è®¡ç®—çš„ç¡¬ä»¶èµ„æº</li>
<li><code>RenderQueue</code> æäº¤ä»»åŠ¡ç»™ç¡¬ä»¶çš„GPUé˜Ÿåˆ—</li>
<li><code>RenderAdapter</code> ç‰©ç†GPUç¡¬ä»¶å¥æŸ„</li>
<li><code>RenderAdapterInfo</code> bevyæ­£åœ¨ä½¿ç”¨çš„GPUç¡¬ä»¶ä¿¡æ¯</li>
</ul>
<h3 id="input-handling-resources"><a class="header" href="#input-handling-resources">Input Handling Resources</a></h3>
<p>These resources represent the current state of different input devices. Read them from your
<a href="/programming/systems.html">systems</a> to <a href="/input.html">handle user input</a>.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/keyboard/enum.KeyCode.html"><code>Input&lt;KeyCode&gt;</code></a>:
Keyboard key state, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseButton.html"><code>Input&lt;MouseButton&gt;</code></a>:
Mouse button state, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Input&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadAxis.html"><code>Axis&lt;GamepadAxis&gt;</code></a>:
Analog <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Axis.html">Axis</a> gamepad inputs (joysticks and triggers)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Axis&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, represented as an analog <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Axis.html">Axis</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>:
The state of all fingers currently touching the touchscreen</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a>:
Registry of all the connected <a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepad.html"><code>Gamepad</code></a> IDs</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„è¾“å…¥èµ„æº.</p>
<ul>
<li><code>Input&lt;KeyCode&gt;</code> é”®ç›˜æŒ‰é”®çŠ¶æ€(KeyCodeè¡¨ç¤ºæŸä¸ªé”®,çŠ¶æ€ä¸ºå·²æŒ‰ä¸‹/åˆšåˆšæŒ‰ä¸‹/åˆšåˆšé‡Šæ”¾)</li>
<li><code>Input&lt;MouseButton&gt;</code> é¼ æ ‡æŒ‰é”®</li>
<li><code>Input&lt;GamepadButton&gt;</code> æ‰‹æŸ„æŒ‰é”®</li>
<li><code>Axis&lt;GamepadAxis&gt;</code> æ‰‹æŸ„æ‘‡æ†æ–¹å‘</li>
<li><code>Axis&lt;GamepadButton&gt;</code> æ‰‹æŸ„é¥æ„ŸæŒ‰é”®</li>
<li><code>Touches</code> è§¦æ‘¸çŠ¶æ€</li>
<li><code>Gamepads</code> å·²è¿æ¥æ‰‹æŸ„çš„IDåˆ—è¡¨</li>
</ul>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p><a href="/programming/events.html">(more info about working with events)</a></p>
<p>äº‹ä»¶ç”¨äºsystemä¼ é€’æ•°æ®,ä¸»è¦æœ‰è¾“å…¥äº‹ä»¶/å¼•æ“äº‹ä»¶/OSå’Œæ§åˆ¶äº‹ä»¶.</p>
<h3 id="input-events"><a class="header" href="#input-events">Input Events</a></h3>
<p>These <a href="/programming/events.html">events</a> fire on activity with input devices. Read them to [handle user input][cb::input].</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a>:
Changes in the state of mouse buttons</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a>:
Scrolling by a number of pixels or lines (<a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a>:
Relative movement of the mouse (pixels from previous frame), regardless of the OS pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a>:
New position of the OS mouse pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a>:
Changes in the state of keyboard keys (keypresses, not text)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.ReceivedCharacter.html"><code>ReceivedCharacter</code></a>:
Unicode text input from the OS (correct handling of the user's language and layout)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/enum.Ime.html"><code>Ime</code></a>:
Unicode text input from IME (support for advanced text input in different scripts)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a>:
Change in the state of a finger touching the touchscreen</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/enum.GamepadEvent.html"><code>GamepadEvent</code></a>:
Changes in the state of a gamepad or any of its buttons or axes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/enum.GamepadRumbleRequest.html"><code>GamepadRumbleRequest</code></a>:
Send these events to control gamepad rumble</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadMagnify.html"><code>TouchpadMagnify</code></a>:
Pinch-to-zoom gesture on laptop touchpad (macOS)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadRotate.html"><code>TouchpadRotate</code></a>:
Two-finger rotate gesture on laptop touchpad (macOS)</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„è¾“å…¥äº‹ä»¶.</p>
<ul>
<li><code>MouseButtonInput</code> é¼ æ ‡äº‹ä»¶</li>
<li><code>MouseWheel</code> é¼ æ ‡æ»šè½®äº‹ä»¶</li>
<li><code>MouseMotion</code> é¼ æ ‡çš„ç›¸å¯¹(ä¸Šå¸§)ç§»åŠ¨äº‹ä»¶</li>
<li><code>CursorMoved</code> å…‰æ ‡ç§»åŠ¨äº‹ä»¶</li>
<li><code>KeyboardInput</code> é”®ç›˜äº‹ä»¶(æŒ‰é”®ä¸æ˜¯è¾“å…¥)</li>
<li><code>ReceivedCharacter</code> è¾“å…¥Unicodeæ–‡æœ¬äº‹ä»¶</li>
<li><code>Ime</code> è¾“å…¥æ³•è¾“å…¥Unicodeæ–‡æœ¬äº‹ä»¶</li>
<li><code>TouchInput</code> è§¦æ‘¸æ¿äº‹ä»¶</li>
<li><code>GamepadEvent</code> æ‰‹æŸ„äº‹ä»¶</li>
<li><code>GamepadRumbleRequest</code> æ§åˆ¶æ‰‹æŸ„éœ‡åŠ¨çš„äº‹ä»¶</li>
<li><code>TouchpadMagnify</code> è§¦æ‘¸æ¿æåˆç¼©æ”¾äº‹ä»¶(macOSæ”¯æŒ)</li>
<li><code>TouchpadRotate</code> è§¦æ‘¸æ¿äºŒæŒ‡æ—‹è½¬äº‹ä»¶(macOSæ”¯æŒ)</li>
</ul>
<p>è¾“å…¥äº‹ä»¶ç”±è¾“å…¥è®¾å¤‡è§¦å‘,ä»inputå›è°ƒä¸­è¯»å–.</p>
<h3 id="engine-events"><a class="header" href="#engine-events">Engine Events</a></h3>
<p><a href="/programming/events.html">Events</a> related to various internal things happening during the
normal runtime of a Bevy app.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/enum.AssetEvent.html"><code>AssetEvent&lt;T&gt;</code></a>:
Sent by Bevy when <a href="/assets.html">asset data</a> has been added/modified/removed; <a href="/assets/assetevent.html">can be used to detect changes to assets</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/hierarchy/enum.HierarchyEvent.html"><code>HierarchyEvent</code></a>:
Sent by Bevy when entity <a href="/fundamentals/hierarchy.html">parents/children</a> change</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.AppExit.html"><code>AppExit</code></a>:
Tell Bevy to shut down</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„å¼•æ“äº‹ä»¶.</p>
<ul>
<li><code>AssetEvent&lt;T&gt;</code> èµ„äº§å¢åˆ æ”¹äº‹ä»¶,å¯ç”¨äºæ£€æµ‹èµ„äº§å˜åŒ–</li>
<li><code>HierarchyEvent</code> å®ä½“çˆ¶å­å…³ç³»å˜æ›´äº‹ä»¶</li>
<li><code>AppExit</code> è®©bevyå…³é—­çš„äº‹ä»¶</li>
</ul>
<p>bevyç¨‹åºæ­£å¸¸è¿è¡Œè¿‡ç¨‹ä¸­ä¼šäº§ç”Ÿçš„å„ç§å†…éƒ¨äº‹ä»¶.</p>
<h3 id="system-and-control-events"><a class="header" href="#system-and-control-events">System and Control Events</a></h3>
<p>Events from the OS / windowing system, or to control Bevy.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.RequestRedraw.html"><code>RequestRedraw</code></a>:
In an app that does not refresh continuously, request one more update before going to sleep</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a>:
The user drag-and-dropped a file into our app</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a>:
OS mouse pointer/cursor entered one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a>:
OS mouse pointer/cursor exited one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowCloseRequested.html"><code>WindowCloseRequested</code></a>:
OS wants to close one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowCreated.html"><code>WindowCreated</code></a>:
New application window opened</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowClosed.html"><code>WindowClosed</code></a>:
Bevy window closed</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowDestroyed.html"><code>WindowDestroyed</code></a>:
OS window freed/dropped after window close</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowFocused.html"><code>WindowFocused</code></a>:
One of our windows is now focused</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowMoved.html"><code>WindowMoved</code></a>:
OS/user moved one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowResized.html"><code>WindowResized</code></a>:
OS/user resized one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowScaleFactorChanged.html"><code>WindowScaleFactorChanged</code></a>:
One of our windows has changed its DPI scaling factor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowBackendScaleFactorChanged.html"><code>WindowBackendScaleFactorChanged</code></a>:
OS reports change in DPI scaling factor for a window</li>
</ul>
<p>ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„OS/çª—å£/æ§åˆ¶äº‹ä»¶.</p>
<ul>
<li><code>RequestRedraw</code> åœ¨ä¸è¿ç»­åˆ·æ–°çš„appä¸­,åœ¨sleepä¹‹å‰è¯·æ±‚1æ¬¡æˆ–å¤šæ¬¡æ›´æ–°çš„äº‹ä»¶</li>
<li><code>FileDragAndDrop</code> æ–‡ä»¶æ‹–æ‹½äº‹ä»¶</li>
<li><code>CursorEntered</code> å…‰æ ‡ç§»å…¥çª—å£çš„äº‹ä»¶</li>
<li><code>CursorLeft</code> å…‰æ ‡ç§»å‡ºçª—å£çš„äº‹ä»¶</li>
<li><code>WindowCloseRequested</code> OSæƒ³è¦å…³é—­ä¸€ä¸ªçª—å£çš„äº‹ä»¶</li>
<li><code>WindowCreated</code> æ–°çª—å£å·²æ‰“å¼€äº‹ä»¶</li>
<li><code>WindowClosed</code> çª—å£å·²å…³é—­äº‹ä»¶</li>
<li><code>WindowDestroyed</code> çª—å£å…³é—­å,OSå·²é‡Šæ”¾çª—å£çš„äº‹ä»¶</li>
<li><code>WindowFocused</code> çª—å£èšç„¦äº‹ä»¶</li>
<li><code>WindowMoved</code> çª—å£ç§»åŠ¨äº‹ä»¶</li>
<li><code>WindowResized</code> çª—å£resizeäº‹ä»¶</li>
<li><code>WindowScaleFactorChanged</code> DPIç¼©æ”¾å› å­ä¿®æ”¹å¯¼è‡´çª—å£å˜æ›´äº‹ä»¶</li>
<li><code>WindowBackendScaleFactorChanged</code> ç³»ç»ŸæŠ¥å‘Šçš„çª—å£DPIç¼©æ”¾å› å­æ”¹å˜äº‹ä»¶</li>
</ul>
<p>OS/çª—å£ç³»ç»Ÿäº§ç”Ÿçš„äº‹ä»¶,æˆ–æ§åˆ¶bevyç¨‹åºçš„äº‹ä»¶.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The complete list of individual component types is too specific to be useful to list here.</p>
<p>See: <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/trait.Component.html#implementors">(List in API Docs)</a></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-tutorials"><a class="header" href="#bevy-tutorials">Bevy Tutorials</a></h1>
<p>This chapter of the book contains tutorials. Tutorials teach you things in a
logical order from start to finish. If you are looking for something to guide
you through learning Bevy, maybe some of them will be useful to you.</p>
<p>The rest of this book is designed to be used as a reference, so you can jump
around to specific topics you want to learn about.</p>
<p>The first tutorial in this chapter, <a href="/tutorial/guide.html">Guided Tour</a>, simply
organizes all the topics in this book in an order suggested for learning, from
the basics to advanced concepts. You can use it as an alternative to the main
table of contents (the left side bar), if you are just learning Bevy and don't
know how to progress. If you are new to Bevy, you can start here to find your
way around.</p>
<p>If you would like more narrow-scoped examples that teach you how to solve
specific problems, those can be found in the <a href="/cookbook.html">Bevy Cookbook</a>
chapter.</p>
<p>You should also look at Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official collection of
examples</a>. There is something for almost every area of the
engine, though they usually only show simple usage of the APIs without much
explanation.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="tutorial//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="new-to-bevy-guided-tutorial"><a class="header" href="#new-to-bevy-guided-tutorial">New to Bevy? Guided Tutorial!</a></h1>
<p>Welcome to Bevy! :) We are glad to have you in our community!</p>
<p>This page will guide you through this book, to help you gain comprehensive
knowledge of how to work with Bevy. The topics are structured in an order
that makes sense for learning: from basics to advanced.</p>
<p>It is just a suggestion to help you navigate. Feel free to jump around the book
and read whatever interests you. The main table-of-contents (the left sidebar)
was designed to be a reference for Bevy users of any skill level.</p>
<hr />
<p>Make sure to also look at <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">the official Bevy examples</a>. If
you need help, use <a href="https://github.com/bevyengine/bevy/discussions">GitHub Discussions</a>, or feel welcome
to join us to chat and ask for help in <a href="https://discord.gg/bevy">Discord</a>.</p>
<p>If you run into issues, be sure to check the
<a href="tutorial//pitfalls.html">Common Pitfalls</a> chapter, to see if this book has something
to help you. Solutions to some of the most common issues that Bevy community
members have encountered are documented there.</p>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>These are the absolute essentials of using Bevy. Every Bevy project, even a
simple one, would require you to be familiar with these concepts.</p>
<p>You could conceivably make something like a simple game-jam game or prototype,
using just this knowledge. Though, as your project grows, you will likely
quickly need to learn more.</p>
<p>åŸºç¡€éƒ¨åˆ†,æ¯ä¸ªbevyé¡¹ç›®éƒ½ä¼šåŒ…å«çš„,åˆ©ç”¨è¿™äº›çŸ¥è¯†å¯ä»¥å¿«é€Ÿåšå‡ºä¸€ä¸ªåŸå‹,
å¦‚æœé¡¹ç›®è¦å¢é•¿,è¿˜éœ€è¦é¢å¤–çš„çŸ¥è¯†.</p>
<ul>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/getting-started.html">Getting Started</a></li>
</ul>
</li>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/ecs-intro.html">Intro to ECS</a></li>
<li><a href="tutorial//programming/intro-data.html#entities--components">Entities, Components</a></li>
<li><a href="tutorial//programming/bundle.html">Bundles</a></li>
<li><a href="tutorial//programming/res.html">Resources</a></li>
<li><a href="tutorial//programming/systems.html">Systems</a></li>
<li><a href="tutorial//programming/app-builder.html">App Builder</a></li>
<li><a href="tutorial//programming/queries.html">Queries</a></li>
<li><a href="tutorial//programming/commands.html">Commands</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/coords.html">Coordinate System</a></li>
<li><a href="tutorial//fundamentals/transforms.html">Transforms</a></li>
<li><a href="tutorial//fundamentals/time.html">Time and Timers</a></li>
</ul>
</li>
<li><a href="tutorial//graphics.html">General Graphics Features</a>
<ul>
<li><a href="tutorial//graphics/camera.html">Cameras</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/assetserver.html">Load Assets with AssetServer</a></li>
<li><a href="tutorial//assets/handles.html">Handles</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//input/keyboard.html">Keyboard</a></li>
<li><a href="tutorial//input/mouse.html">Mouse</a></li>
<li><a href="tutorial//input/gamepad.html">Gamepad (Controller)</a></li>
<li><a href="tutorial//input/touch.html">Touchscreen</a></li>
</ul>
</li>
<li><a href="tutorial//window.html">Window Management</a>
<ul>
<li><a href="tutorial//window/props.html">Window Properties</a></li>
<li><a href="tutorial//window/clear-color.html">Change the Background Color</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>
<ul>
<li><a href="tutorial//audio/basic.html">Playing Sounds</a></li>
</ul>
</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>You will likely need to learn most of these topics to make a non-trivial Bevy
project. After you are confident with the basics, you should learn these.</p>
<p>è¦æƒ³å“è¶Š,åœ¨ç†Ÿæ‚‰äº†åŸºç¡€çŸ¥è¯†çš„åŸºç¡€ä¸Š,è¿˜éœ€è¦å­¦ä¹ ä»¥ä¸‹çŸ¥è¯†.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/events.html">Events</a></li>
<li><a href="tutorial//programming/system-order.html">System Order of Execution</a></li>
<li><a href="tutorial//programming/run-criteria.html">Run Conditions</a></li>
<li><a href="tutorial//programming/system-sets.html">System Sets</a></li>
<li><a href="tutorial//programming/local.html">Local Resources</a></li>
<li><a href="tutorial//programming/schedules.html">Schedules</a></li>
<li><a href="tutorial//programming/states.html">States</a></li>
<li><a href="tutorial//programming/plugins.html">Plugins</a></li>
<li><a href="tutorial//programming/change-detection.html">Change Detection</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/hierarchy.html">Parent/Child Hierarchies</a></li>
<li><a href="tutorial//fundamentals/visibility.html">Visibility</a></li>
<li><a href="tutorial//fundamentals/log.html">Logging / Console Messages</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//cookbook/cursor2world.html">Convert cursor to world coordinates</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/data.html">Access the Asset Data</a></li>
<li><a href="tutorial//assets/hot-reload.html">Hot-Reloading Assets</a></li>
</ul>
</li>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/bevy-tools.html">Bevy Dev Tools and Editors</a></li>
<li><a href="tutorial//setup/unofficial-plugins.html">Community Plugin Ecosystem</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>:
<ul>
<li><a href="tutorial//audio/spatial.html">Spatial Audio</a></li>
</ul>
</li>
</ul>
<h2 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h2>
<p>These are more specialized topics. You may need some of them, depending on your
project.</p>
<p>æ›´å¤šå…·ä½“åœºæ™¯ä¸‹çš„ä¸»é¢˜,ä¸æ˜¯æ¯ä¸ªé¡¹ç›®éƒ½éœ€è¦,çœ‹å®é™…éœ€è¦.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/world.html">Direct World Access</a></li>
<li><a href="tutorial//programming/exclusive.html">Exclusive Systems</a></li>
<li><a href="tutorial//programming/paramset.html">Param Sets</a></li>
<li><a href="tutorial//programming/system-piping.html">System Piping</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/fixed-timestep.html">Fixed Timestep</a></li>
</ul>
</li>
<li><a href="tutorial//graphics.html">General Graphics Features</a>
<ul>
<li><a href="tutorial//graphics/hdr-tonemap.html">HDR, Tonemapping</a></li>
<li><a href="tutorial//graphics/bloom.html">Bloom</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/assetevent.html">React to Changes with Asset Events</a></li>
<li><a href="tutorial//assets/ready.html">Track asset loading progress</a></li>
</ul>
</li>
<li><a href="tutorial//patterns.html">Programming Patterns</a>
<ul>
<li><a href="tutorial//patterns/system-tests.html">Write tests for systems</a></li>
<li><a href="tutorial//patterns/generic-systems.html">Generic Systems</a></li>
<li><a href="tutorial//patterns/manual-event-clear.html">Manual Event Clearing</a></li>
</ul>
</li>
<li><a href="tutorial//window.html">Window Management</a>
<ul>
<li><a href="tutorial//window/mouse-grab.html">Grab/Capture the Mouse Cursor</a></li>
<li><a href="tutorial//window/icon.html">Set the Window Icon</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>
<ul>
<li><a href="tutorial//audio/custom.html">Custom Audio Streams</a></li>
</ul>
</li>
</ul>
<h2 id="advanced"><a class="header" href="#advanced">Advanced</a></h2>
<p>These topics are for niche technical situations. You can learn them, if you want
to know more about how Bevy works internally, extend the engine with custom
functionality, or do other advanced things with Bevy.</p>
<p>ä¸€äº›æŠ€æœ¯æ–¹æ¡ˆä¸»é¢˜,å¯ä»¥äº†è§£bevyå†…éƒ¨çš„å·¥ä½œæœºåˆ¶,æ–¹ä¾¿è‡ªå®šä¹‰åŠŸèƒ½æˆ–åšäº›é«˜çº§äº‹æƒ….</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/non-send.html">Non-Send</a></li>
</ul>
</li>
<li><a href="tutorial//patterns.html">Programming Patterns</a>
<ul>
<li><a href="tutorial//patterns/component-storage.html">Component Storage</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//input/dnd.html">Drag-and-Drop files</a></li>
<li><a href="tutorial//input/ime.html">IME for advanced text input</a></li>
</ul>
</li>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/bevy-config.html">Customizing Bevy (cargo crates and features)</a></li>
<li><a href="tutorial//setup/bevy-git.html">Using bleeding-edge Bevy (main)</a></li>
</ul>
</li>
<li><a href="tutorial//gpu.html">Bevy Render (GPU) Framework</a>
<ul>
<li><a href="tutorial//gpu/intro.html">Render Architecture Overview</a></li>
<li><a href="tutorial//gpu/stages.html">Render Sets</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-cookbook"><a class="header" href="#bevy-cookbook">Bevy Cookbook</a></h1>
<p>This chapter shows you how to do various practical things using Bevy.</p>
<p>Every page is focused on a specific problem and provides explanations and
example code to teach you how to solve it.</p>
<p>It is assumed that you are already familiar with
<a href="/programming.html">Bevy Programming</a>.</p>
<p>You should also look at Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official collection of
examples</a>. There is something for almost every area of the
engine, though they usually only show simple usage of the APIs without much
explanation.</p>
<p>If you would like step-by-step tutorials that you can follow from start to
finish, those are in the <a href="/tutorial.html">Bevy Tutorials</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="show-framerate"><a class="header" href="#show-framerate">Show Framerate</a></h1>
<p>You can use Bevy's builtin diagnostics to measure framerate (FPS), for
monitoring performance.</p>
<p>To enable it, add Bevy's diagnostic plugin to your <a href="cookbook//programming/app-builder.html">app</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::FrameTimeDiagnosticsPlugin;
app.add_plugins(FrameTimeDiagnosticsPlugin::default());</code></pre>
<p>ä¸ºäº†ç›‘æ§æ€§èƒ½,å¯ä»¥ä½¿ç”¨bevyå†…ç½®çš„è¯Šæ–­ç³»ç»Ÿæ¥æµ‹é‡FPS.</p>
<h2 id="print-to-console--log"><a class="header" href="#print-to-console--log">Print to Console / Log</a></h2>
<p>The simplest way to use it is to print the diagnostics to the console
(<a href="cookbook//fundamentals/log.html">log</a>). If you want to only do it in dev builds, you can add
a conditional-compilation attribute.</p>
<pre><code class="language-rust no_run noplayground">#[cfg(debug_assertions)] // debug/dev builds only
{
    use bevy::diagnostic::LogDiagnosticsPlugin;
    app.add_plugins(LogDiagnosticsPlugin::default());
}</code></pre>
<h2 id="in-game--on-screen-fps-counter"><a class="header" href="#in-game--on-screen-fps-counter">In-Game / On-Screen FPS counter</a></h2>
<p>UPDATE! I have now released a Bevy plugin which provides a much better
version of the code on this page, ready for you to use! Consider trying
my <a href="https://github.com/IyesGames/iyes_perf_ui"><code>iyes_perf_ui</code></a> plugin!</p>
<p>Bevy maintainers have expressed interest in upstreaming it, and we will
try to make it official in the next Bevy release (0.14)!</p>
<p>For now, I am also keeping the old code example below in the book, for
completeness:</p>
<hr />
<p>You can use Bevy UI to create an in-game FPS counter.</p>
<p>It is recommended that you create a new UI root (entity without
a parent) with absolute positioning, so that you can control the
exact position where the FPS counter appears, and so it doesn't
affect the rest of your UI.</p>
<p>Here is some example code showing you how to make a very nice-looking and
readable FPS counter:</p>
<details>
  <summary>
  <code>Code Example (Long):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::DiagnosticsStore;
use bevy::diagnostic::FrameTimeDiagnosticsPlugin;

/// Marker to find the container entity so we can show/hide the FPS counter
#[derive(Component)]
struct FpsRoot;

/// Marker to find the text entity so we can update it
#[derive(Component)]
struct FpsText;

fn setup_fps_counter(
    mut commands: Commands,
) {
    // create our UI root node
    // this is the wrapper/container for the text
    let root = commands.spawn((
        FpsRoot,
        NodeBundle {
            // give it a dark background for readability
            background_color: BackgroundColor(Color::BLACK.with_a(0.5)),
            // make it "always on top" by setting the Z index to maximum
            // we want it to be displayed over all other UI
            z_index: ZIndex::Global(i32::MAX),
            style: Style {
                position_type: PositionType::Absolute,
                // position it at the top-right corner
                // 1% away from the top window edge
                right: Val::Percent(1.),
                top: Val::Percent(1.),
                // set bottom/left to Auto, so it can be
                // automatically sized depending on the text
                bottom: Val::Auto,
                left: Val::Auto,
                // give it some padding for readability
                padding: UiRect::all(Val::Px(4.0)),
                ..Default::default()
            },
            ..Default::default()
        },
    )).id();
    // create our text
    let text_fps = commands.spawn((
        FpsText,
        TextBundle {
            // use two sections, so it is easy to update just the number
            text: Text::from_sections([
                TextSection {
                    value: "FPS: ".into(),
                    style: TextStyle {
                        font_size: 16.0,
                        color: Color::WHITE,
                        // if you want to use your game's font asset,
                        // uncomment this and provide the handle:
                        // font: my_font_handle
                        ..default()
                    }
                },
                TextSection {
                    value: " N/A".into(),
                    style: TextStyle {
                        font_size: 16.0,
                        color: Color::WHITE,
                        // if you want to use your game's font asset,
                        // uncomment this and provide the handle:
                        // font: my_font_handle
                        ..default()
                    }
                },
            ]),
            ..Default::default()
        },
    )).id();
    commands.entity(root).push_children(&amp;[text_fps]);
}

fn fps_text_update_system(
    diagnostics: Res&lt;DiagnosticsStore&gt;,
    mut query: Query&lt;&amp;mut Text, With&lt;FpsText&gt;&gt;,
) {
    for mut text in &amp;mut query {
        // try to get a "smoothed" FPS value from Bevy
        if let Some(value) = diagnostics
            .get(&amp;FrameTimeDiagnosticsPlugin::FPS)
            .and_then(|fps| fps.smoothed())
        {
            // Format the number as to leave space for 4 digits, just in case,
            // right-aligned and rounded. This helps readability when the
            // number changes rapidly.
            text.sections[1].value = format!("{value:&gt;4.0}");

            // Let's make it extra fancy by changing the color of the
            // text according to the FPS value:
            text.sections[1].style.color = if value &gt;= 120.0 {
                // Above 120 FPS, use green color
                Color::rgb(0.0, 1.0, 0.0)
            } else if value &gt;= 60.0 {
                // Between 60-120 FPS, gradually transition from yellow to green
                Color::rgb(
                    (1.0 - (value - 60.0) / (120.0 - 60.0)) as f32,
                    1.0,
                    0.0,
                )
            } else if value &gt;= 30.0 {
                // Between 30-60 FPS, gradually transition from red to yellow
                Color::rgb(
                    1.0,
                    ((value - 30.0) / (60.0 - 30.0)) as f32,
                    0.0,
                )
            } else {
                // Below 30 FPS, use red color
                Color::rgb(1.0, 0.0, 0.0)
            }
        } else {
            // display "N/A" if we can't get a FPS measurement
            // add an extra space to preserve alignment
            text.sections[1].value = " N/A".into();
            text.sections[1].style.color = Color::WHITE;
        }
    }
}

/// Toggle the FPS counter when pressing F12
fn fps_counter_showhide(
    mut q: Query&lt;&amp;mut Visibility, With&lt;FpsRoot&gt;&gt;,
    kbd: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    if kbd.just_pressed(KeyCode::F12) {
        let mut vis = q.single_mut();
        *vis = match *vis {
            Visibility::Hidden =&gt; Visibility::Visible,
            _ =&gt; Visibility::Hidden,
        };
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_fps_counter);
app.add_systems(Update, (
    fps_text_update_system,
    fps_counter_showhide,
));</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="convert-cursor-to-world-coordinates"><a class="header" href="#convert-cursor-to-world-coordinates">Convert cursor to world coordinates</a></h1>
<h2 id="2d-games"><a class="header" href="#2d-games">2D games</a></h2>
<p>If you only have one window (the primary window), as is the case for most apps
and games, you can do this:</p>
<details>
  <summary>
  <code>Code (simple version):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::window::PrimaryWindow;

/// We will store the world position of the mouse cursor here.
#[derive(Resource, Default)]
struct MyWorldCoords(Vec2);

/// Used to help identify our main camera
#[derive(Component)]
struct MainCamera;

fn setup(mut commands: Commands) {
    // Make sure to add the marker component when you set up your camera
    commands.spawn((Camera2dBundle::default(), MainCamera));
}

fn my_cursor_system(
    mut mycoords: ResMut&lt;MyWorldCoords&gt;,
    // query to get the window (so we can read the current cursor position)
    q_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get camera transform
    q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform), With&lt;MainCamera&gt;&gt;,
) {
    // get the camera info and transform
    // assuming there is exactly one main camera entity, so Query::single() is OK
    let (camera, camera_transform) = q_camera.single();

    // There is only one primary window, so we can similarly get it from the query:
    let window = q_window.single();

    // check if the cursor is inside the window and get its position
    // then, ask bevy to convert into world coordinates, and truncate to discard Z
    if let Some(world_position) = window.cursor_position()
        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
        .map(|ray| ray.origin.truncate())
    {
        mycoords.0 = world_position;
        eprintln!("World coords: {}/{}", world_position.x, world_position.y);
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyWorldCoords&gt;();
app.add_systems(Startup, setup);
app.add_systems(Update, my_cursor_system);</code></pre>
</details>
<p>If you have a more complex application with multiple windows, here is a more
complex version of the code that can handle that:</p>
<details>
  <summary>
  <code>Code (multi-window version):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::RenderTarget;
use bevy::window::WindowRef;

/// We will add this to each camera we want to compute cursor position for.
/// Add the component to the camera that renders to each window.
#[derive(Component, Default)]
struct WorldCursorCoords(Vec2);

fn setup_multiwindow(mut commands: Commands) {
    // TODO: set up multiple cameras for multiple windows.
    // See bevy's example code for how to do that.

    // Make sure we add our component to each camera
    commands.spawn((Camera2dBundle::default(), WorldCursorCoords::default()));
}

fn my_cursor_system_multiwindow(
    // query to get the primary window
    q_window_primary: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get other windows
    q_window: Query&lt;&amp;Window&gt;,
    // query to get camera transform
    mut q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform, &amp;mut WorldCursorCoords)&gt;,
) {
    for (camera, camera_transform, mut worldcursor) in &amp;mut q_camera {
        // get the window the camera is rendering to
        let window = match camera.target {
            // the camera is rendering to the primary window
            RenderTarget::Window(WindowRef::Primary) =&gt; {
                q_window_primary.single()
            },
            // the camera is rendering to some other window
            RenderTarget::Window(WindowRef::Entity(e_window)) =&gt; {
                q_window.get(e_window).unwrap()
            },
            // the camera is rendering to something else (like a texture), not a window
            _ =&gt; {
                // skip this camera
                continue;
            }
        };

        // check if the cursor is inside the window and get its position
        // then, ask bevy to convert into world coordinates, and truncate to discard Z
        if let Some(world_position) = window.cursor_position()
            .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
            .map(|ray| ray.origin.truncate())
        {
            worldcursor.0 = world_position;
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_multiwindow);
app.add_systems(Update, my_cursor_system_multiwindow);</code></pre>
</details>
<h2 id="3d-games"><a class="header" href="#3d-games">3D games</a></h2>
<p>If you'd like to be able to detect what 3D object the cursor is pointing at, select
objects, etc., there is a good (unofficial) plugin:
<a href="https://github.com/aevyrie/bevy_mod_picking"><code>bevy_mod_picking</code></a>.</p>
<p>For a simple top-down camera view game with a flat ground plane, it might be
sufficient to just compute the coordinates on the ground under the cursor.</p>
<p><button class="button_wasm_cbexample" id="button_cursor_3d_ground_plane">Load Interactive Example</button></p>
<p>In the interactive example, there is a ground plane with a non-default position
and rotation. There is a red cube, which is positioned using the global
coordinates, and a blue cube, which is a <a href="cookbook//fundamentals/hierarchy.html">child entity</a> of the
ground plane and positioned using local coordinates. They should both follow the
cursor.</p>
<details>
  <summary>
  <code>Code and explanation:</code>
  </summary>
<pre><code class="language-rust no_run noplayground">/// Here we will store the position of the mouse cursor on the 3D ground plane.
#[derive(Resource, Default)]
struct MyGroundCoords {
    // Global (world-space) coordinates
    global: Vec3,
    // Local (relative to the ground plane) coordinates
    local: Vec2,
}

/// Used to help identify our main camera
#[derive(Component)]
struct MyGameCamera;

/// Used to help identify our ground plane
#[derive(Component)]
struct MyGroundPlane;

fn setup_3d_scene(mut commands: Commands) {
    // Make sure to add the marker component when you set up your camera
    commands.spawn((
        MyGameCamera,
        Camera3dBundle {
            // ... your camera configuration ...
            ..default()
        },
    ));
    // Spawn the ground
    commands.spawn((
        MyGroundPlane,
        PbrBundle {
            // feel free to change this to rotate/tilt or reposition the ground
            transform: Transform::default(),
            // TODO: set up your mesh / visuals for rendering:
            // mesh: ...
            // material: ...
            ..default()
        },
    ));
}

fn cursor_to_ground_plane(
    mut mycoords: ResMut&lt;MyGroundCoords&gt;,
    // query to get the window (so we can read the current cursor position)
    // (we will only work with the primary window)
    q_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get camera transform
    q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform), With&lt;MyGameCamera&gt;&gt;,
    // query to get ground plane's transform
    q_plane: Query&lt;&amp;GlobalTransform, With&lt;MyGroundPlane&gt;&gt;,
) {
    // get the camera info and transform
    // assuming there is exactly one main camera entity, so Query::single() is OK
    let (camera, camera_transform) = q_camera.single();

    // Ditto for the ground plane's transform
    let ground_transform = q_plane.single();

    // There is only one primary window, so we can similarly get it from the query:
    let window = q_window.single();

    // check if the cursor is inside the window and get its position
    let Some(cursor_position) = window.cursor_position() else {
        // if the cursor is not inside the window, we can't do anything
        return;
    };

    // Mathematically, we can represent the ground as an infinite flat plane.
    // To do that, we need a point (to position the plane) and a normal vector
    // (the "up" direction, perpendicular to the ground plane).

    // We can get the correct values from the ground entity's GlobalTransform
    let plane_origin = ground_transform.translation();
    let plane = Plane3d::new(ground_transform.up());

    // Ask Bevy to give us a ray pointing from the viewport (screen) into the world
    let Some(ray) = camera.viewport_to_world(camera_transform, cursor_position) else {
        // if it was impossible to compute for whatever reason; we can't do anything
        return;
    };

    // do a ray-plane intersection test, giving us the distance to the ground
    let Some(distance) = ray.intersect_plane(plane_origin, plane) else {
        // If the ray does not intersect the ground
        // (the camera is not looking towards the ground), we can't do anything
        return;
    };

    // use the distance to compute the actual point on the ground in world-space
    let global_cursor = ray.get_point(distance);

    mycoords.global = global_cursor;
    eprintln!("Global cursor coords: {}/{}/{}",
        global_cursor.x, global_cursor.y, global_cursor.z
    );

    // to compute the local coordinates, we need the inverse of the plane's transform
    let inverse_transform_matrix = ground_transform.compute_matrix().inverse();
    let local_cursor = inverse_transform_matrix.transform_point3(global_cursor);

    // we can discard the Y coordinate, because it should always be zero
    // (our point is supposed to be on the plane)
    mycoords.local = local_cursor.xz();
    eprintln!("Local cursor coords: {}/{}", local_cursor.x, local_cursor.z);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyGroundCoords&gt;();
app.add_systems(Startup, setup_3d_scene);
app.add_systems(Update, cursor_to_ground_plane);</code></pre>
<p>If the ground is tilted/rotated or moved, the global and local coordinates
will differ, and may be useful for different use cases, so we compute both.</p>
<p>For some examples:</p>
<ul>
<li>if you want to spawn a <a href="cookbook//fundamentals/hierarchy.html">child</a> entity, or to quantize
the coordinates to a grid (for a tile-based game, to detect the grid tile under the cursor),
the local coordinates will be more useful</li>
<li>if you want to spawn some overlays, particle effects, other independent game entities,
at the position of the cursor, the global coordinates will be more useful</li>
</ul>
</details>
<script type="module" src="/loadwasm.js"/>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="custom-camera-projection"><a class="header" href="#custom-camera-projection">Custom Camera Projection</a></h1>
<p><strong>Note</strong>: this example is showing you how to do something not officially
supported/endorsed by Bevy. Do at your own risk.</p>
<p>Camera with a custom projection (not using one of Bevy's standard perspective
or orthographic projections).</p>
<p>You could also use this to change the coordinate system, if you insist on
using something other than <a href="cookbook//fundamentals/coords.html">Bevy's default coordinate system</a>,
for whatever reason.</p>
<p>Here we implement a simple orthographic projection that maps <code>-1.0</code> to <code>1.0</code>
to the vertical axis of the window, and respects the window's aspect ratio
for the horizontal axis:</p>
<p>See how Bevy constructs its camera bundles, for reference:</p>
<ul>
<li><a href="https://github.com/bevyengine/bevy/blob/v0.9.0/crates/bevy_core_pipeline/src/core_2d/camera_2d.rs#L46">2d</a></li>
<li><a href="https://github.com/bevyengine/bevy/blob/v0.9.0/crates/bevy_core_pipeline/src/core_3d/camera_3d.rs#L72">3d</a></li>
</ul>
<p>This example is based on the setup for a 2D camera:</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::Tonemapping;
use bevy::render::primitives::Frustum;
use bevy::render::camera::{Camera, CameraProjection};
use bevy::render::view::VisibleEntities;

#[derive(Component, Debug, Clone, Reflect)]
#[reflect(Component, Default)]
struct SimpleOrthoProjection {
    near: f32,
    far: f32,
    aspect: f32,
}

impl CameraProjection for SimpleOrthoProjection {
    fn get_projection_matrix(&amp;self) -&gt; Mat4 {
        Mat4::orthographic_rh(
            -self.aspect, self.aspect, -1.0, 1.0, self.near, self.far
        )
    }

    // what to do on window resize
    fn update(&amp;mut self, width: f32, height: f32) {
        self.aspect = width / height;
    }

    fn far(&amp;self) -&gt; f32 {
        self.far
    }
}

impl Default for SimpleOrthoProjection {
    fn default() -&gt; Self {
        Self { near: 0.0, far: 1000.0, aspect: 1.0 }
    }
}

fn setup(mut commands: Commands) {
    // We need all the components that Bevy's built-in camera bundles would add
    // Refer to the Bevy source code to make sure you do it correctly:

    // here we show a 2d example

    let projection = SimpleOrthoProjection::default();

    // position the camera like bevy would do by default for 2D:
    let transform = Transform::from_xyz(0.0, 0.0, projection.far - 0.1);

    // frustum construction code copied from Bevy
    let view_projection =
        projection.get_projection_matrix() * transform.compute_matrix().inverse();
    let frustum = Frustum::from_view_projection(
        &amp;view_projection,
        &amp;transform.translation,
        &amp;transform.back(),
        projection.far,
    );

    commands.spawn((
        bevy::render::camera::CameraRenderGraph::new(bevy::core_pipeline::core_2d::graph::NAME),
        projection,
        frustum,
        transform,
        GlobalTransform::default(),
        VisibleEntities::default(),
        Camera::default(),
        Camera2d::default(),
        Tonemapping::Disabled,
    ));
}

fn main() {
    // need to add bevy-internal camera projection management functionality
    // for our custom projection type
    use bevy::render::camera::CameraProjectionPlugin;

    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup)
        .add_plugin(CameraProjectionPlugin::&lt;SimpleOrthoProjection&gt;::default())
        .run();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="pan--orbit-camera"><a class="header" href="#pan--orbit-camera">Pan + Orbit Camera</a></h1>
<p>This is a camera controller similar to the ones in 3D editors like Blender.</p>
<p>To make the implementation simpler, we do not manipulate the
<a href="cookbook//fundamentals/transforms.html">transform</a> directly. Instead, we work with values inside of
a custom <a href="cookbook//programming/ec.html#components">component</a> struct and then compute the transform
at the end.</p>
<p>Furthermore, for completeness, this example will also show a simple way of
making the input controls reconfigurable / rebindable.</p>
<hr />
<p>First, let's define our data. Create some <a href="cookbook//programming/ec.html#components">component</a>
types, which we will store on the <a href="cookbook//3d/camera.html">3D camera</a>
<a href="cookbook//programming/intro-data.html">entity</a>, and a <a href="cookbook//programming/bundle.html">bundle</a> to make it easy to
spawn the camera:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">// Bundle to spawn our custom camera easily
#[derive(Bundle, Default)]
pub struct PanOrbitCameraBundle {
    pub camera: Camera3dBundle,
    pub state: PanOrbitState,
    pub settings: PanOrbitSettings,
}

// The internal state of the pan-orbit controller
#[derive(Component)]
pub struct PanOrbitState {
    pub center: Vec3,
    pub radius: f32,
    pub upside_down: bool,
    pub pitch: f32,
    pub yaw: f32,
}

/// The configuration of the pan-orbit controller
#[derive(Component)]
pub struct PanOrbitSettings {
    /// World units per pixel of mouse motion
    pub pan_sensitivity: f32,
    /// Radians per pixel of mouse motion
    pub orbit_sensitivity: f32,
    /// Exponent per pixel of mouse motion
    pub zoom_sensitivity: f32,
    /// Key to hold for panning
    pub pan_key: Option&lt;KeyCode&gt;,
    /// Key to hold for orbiting
    pub orbit_key: Option&lt;KeyCode&gt;,
    /// Key to hold for zooming
    pub zoom_key: Option&lt;KeyCode&gt;,
    /// What action is bound to the scroll wheel?
    pub scroll_action: Option&lt;PanOrbitAction&gt;,
    /// For devices with a notched scroll wheel, like desktop mice
    pub scroll_line_sensitivity: f32,
    /// For devices with smooth scrolling, like touchpads
    pub scroll_pixel_sensitivity: f32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PanOrbitAction {
    Pan,
    Orbit,
    Zoom,
}</code></pre>
</details>
<p>We can implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> to give them reasonable default values:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">impl Default for PanOrbitState {
    fn default() -&gt; Self {
        PanOrbitState {
            center: Vec3::ZERO,
            radius: 1.0,
            upside_down: false,
            pitch: 0.0,
            yaw: 0.0,
        }
    }
}

impl Default for PanOrbitSettings {
    fn default() -&gt; Self {
        PanOrbitSettings {
            pan_sensitivity: 0.001, // 1000 pixels per world unit
            orbit_sensitivity: 0.1f32.to_radians(), // 0.1 degree per pixel
            zoom_sensitivity: 0.01,
            pan_key: Some(KeyCode::ControlLeft),
            orbit_key: Some(KeyCode::AltLeft),
            zoom_key: Some(KeyCode::ShiftLeft),
            scroll_action: Some(PanOrbitAction::Zoom),
            scroll_line_sensitivity: 16.0, // 1 "line" == 16 "pixels of motion"
            scroll_pixel_sensitivity: 1.0,
        }
    }
}</code></pre>
</details>
<p>We need a setup <a href="cookbook//programming/systems.html">system</a> to spawn our camera:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">fn spawn_camera(mut commands: Commands) {
    let mut camera = PanOrbitCameraBundle::default();
    // Position our camera using our component,
    // not Transform (it would get overwritten)
    camera.state.center = Vec3::new(1.0, 2.0, 3.0);
    camera.state.radius = 50.0;
    camera.state.pitch = 15.0f32.to_radians();
    camera.state.yaw = 30.0f32.to_radians();
    commands.spawn(camera);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, spawn_camera);</code></pre>
</details>
<p>And finally, the actual implementation of the camera controller:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::{MouseMotion, MouseScrollUnit, MouseWheel};

use std::f32::consts::{FRAC_PI_2, PI, TAU};

fn pan_orbit_camera(
    kbd: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    mut evr_motion: EventReader&lt;MouseMotion&gt;,
    mut evr_scroll: EventReader&lt;MouseWheel&gt;,
    mut q_camera: Query&lt;(
        &amp;PanOrbitSettings,
        &amp;mut PanOrbitState,
        &amp;mut Transform,
    )&gt;,
) {
    // First, accumulate the total amount of
    // mouse motion and scroll, from all pending events:
    let mut total_motion: Vec2 = evr_motion.read()
        .map(|ev| ev.delta).sum();

    // Reverse Y (Bevy's Worldspace coordinate system is Y-Up,
    // but events are in window/ui coordinates, which are Y-Down)
    total_motion.y = -total_motion.y;

    let mut total_scroll_lines = Vec2::ZERO;
    let mut total_scroll_pixels = Vec2::ZERO;
    for ev in evr_scroll.read() {
        match ev.unit {
            MouseScrollUnit::Line =&gt; {
                total_scroll_lines.x += ev.x;
                total_scroll_lines.y -= ev.y;
            }
            MouseScrollUnit::Pixel =&gt; {
                total_scroll_pixels.x += ev.x;
                total_scroll_pixels.y -= ev.y;
            }
        }
    }

    for (settings, mut state, mut transform) in &amp;mut q_camera {
        // Check how much of each thing we need to apply.
        // Accumulate values from motion and scroll,
        // based on our configuration settings.

        let mut total_pan = Vec2::ZERO;
        if settings.pan_key.map(|key| kbd.pressed(key)).unwrap_or(false) {
            total_pan -= total_motion * settings.pan_sensitivity;
        }
        if settings.scroll_action == Some(PanOrbitAction::Pan) {
            total_pan -= total_scroll_lines
                * settings.scroll_line_sensitivity * settings.pan_sensitivity;
            total_pan -= total_scroll_pixels
                * settings.scroll_pixel_sensitivity * settings.pan_sensitivity;
        }

        let mut total_orbit = Vec2::ZERO;
        if settings.orbit_key.map(|key| kbd.pressed(key)).unwrap_or(false) {
            total_orbit -= total_motion * settings.orbit_sensitivity;
        }
        if settings.scroll_action == Some(PanOrbitAction::Orbit) {
            total_orbit -= total_scroll_lines
                * settings.scroll_line_sensitivity * settings.orbit_sensitivity;
            total_orbit -= total_scroll_pixels
                * settings.scroll_pixel_sensitivity * settings.orbit_sensitivity;
        }

        let mut total_zoom = Vec2::ZERO;
        if settings.zoom_key.map(|key| kbd.pressed(key)).unwrap_or(false) {
            total_zoom -= total_motion * settings.zoom_sensitivity;
        }
        if settings.scroll_action == Some(PanOrbitAction::Zoom) {
            total_zoom -= total_scroll_lines
                * settings.scroll_line_sensitivity * settings.zoom_sensitivity;
            total_zoom -= total_scroll_pixels
                * settings.scroll_pixel_sensitivity * settings.zoom_sensitivity;
        }

        // Upon starting a new orbit maneuver (key is just pressed),
        // check if we are starting it upside-down
        if settings.orbit_key.map(|key| kbd.just_pressed(key)).unwrap_or(false) {
            state.upside_down = state.pitch &lt; -FRAC_PI_2 || state.pitch &gt; FRAC_PI_2;
        }

        // If we are upside down, reverse the X orbiting
        if state.upside_down {
            total_orbit.x = -total_orbit.x;
        }

        // Now we can actually do the things!

        let mut any = false;

        // To ZOOM, we need to multiply our radius.
        if total_zoom != Vec2::ZERO {
            any = true;
            // in order for zoom to feel intuitive,
            // everything needs to be exponential
            // (done via multiplication)
            // not linear
            // (done via addition)

            // so we compute the exponential of our
            // accumulated value and multiply by that
            state.radius *= (-total_zoom.y).exp();
        }

        // To ORBIT, we change our pitch and yaw values
        if total_orbit != Vec2::ZERO {
            any = true;
            state.yaw += total_orbit.x;
            state.pitch += total_orbit.y;
            // wrap around, to stay between +- 180 degrees
            if state.yaw &gt; PI {
                state.yaw -= TAU; // 2 * PI
            }
            if state.yaw &lt; -PI {
                state.yaw += TAU; // 2 * PI
            }
            if state.pitch &gt; PI {
                state.pitch -= TAU; // 2 * PI
            }
            if state.pitch &lt; -PI {
                state.pitch += TAU; // 2 * PI
            }
        }

        // To PAN, we can get the UP and RIGHT direction
        // vectors from the camera's transform, and use
        // them to move the center point. Multiply by the
        // radius to make the pan adapt to the current zoom.
        if total_pan != Vec2::ZERO {
            any = true;
            let radius = state.radius;
            state.center += transform.right() * total_pan.x * radius;
            state.center += transform.up() * total_pan.y * radius;
        }

        // Finally, compute the new camera transform.
        // (if we changed anything, or if the pan-orbit
        // controller was just added and thus we are running
        // for the first time and need to initialize)
        if any || state.is_added() {
            // YXZ Euler Rotation performs yaw/pitch/roll.
            transform.rotation =
                Quat::from_euler(EulerRot::YXZ, state.yaw, state.pitch, 0.0);
            // To position the camera, get the backward direction vector
            // and place the camera at the desired radius from the center.
            transform.translation = state.center + transform.back() * state.radius;
        }
    }
}</code></pre>
<p>We can add a <a href="cookbook//programming/run-criteria.html">Run Condition</a> to tell Bevy to run
our system only if pan-orbit entities exist:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(Update,
    pan_orbit_camera
        .run_if(any_with_component::&lt;PanOrbitState&gt;),
);</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="list-all-resource-types"><a class="header" href="#list-all-resource-types">List All Resource Types</a></h1>
<p>This example shows how to print a list of all types that have been added as
<a href="cookbook//programming/res.html">resources</a>.</p>
<pre><code class="language-rust no_run noplayground">fn print_resources(world: &amp;World) {
    let components = world.components();

    let mut r: Vec&lt;_&gt; = world
        .storages()
        .resources
        .iter()
        .map(|(id, _)| components.get_info(id).unwrap())
        .map(|info| info.name())
        .collect();

    // sort list alphebetically
    r.sort();
    r.iter().for_each(|name| println!("{}", name));
}</code></pre>
<pre><code class="language-rust no_run noplayground">// print main world resources
app.add_systems(Last, print_resources);

// print render world resources
app.sub_app_mut(RenderApp)
    .add_systems(Render, print_resources.in_set(RenderSet::Render));</code></pre>
<p>It lists the types of all the resources <em>that currently exist</em> in your <a href="cookbook//programming/intro-data.html">ECS
World</a> (by all registered plugins, your own, etc.).</p>
<p>Note that this does <em>not</em> give you a list of every type that is
useful as a resource. For that, you should consult API documentation,
looking for implementers of the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/trait.Resource.html"><code>Resource</code></a> trait.</p>
<p><a href="cookbook//builtins.html">See here for a summary of types provided in Bevy.</a></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-setup-tips"><a class="header" href="#bevy-setup-tips">Bevy Setup Tips</a></h1>
<p>This chapter is a collection of additional tips for configuring
your project or development tools, collected from the Bevy
community, beyond what is covered in Bevy's <a href="https://bevyengine.org/learn/book/getting-started/setup/">official setup
documentation</a>.</p>
<p>Feel free to suggest things to add under this chapter.</p>
<hr />
<p>Also see the following other relevant content from this book:</p>
<ul>
<li><a href="/platforms.html">Platform-specific information</a></li>
<li><a href="/pitfalls/performance.html">Configuration to fix slow performance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This page covers the basic setup needed for Bevy development.</p>
<hr />
<p>For the most part, Bevy is just like any other Rust library. You need to
install Rust and setup your dev environment just like for any other Rust
project. You can install Rust using <a href="https://rustup.rs">Rustup</a>. See
<a href="https://www.rust-lang.org/learn/get-started">Rust's official setup page</a>.</p>
<p>On Linux, you need the development files for some system libraries. See the
<a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">official Bevy Linux dependencies page</a>.</p>
<p>Also see the <a href="https://bevyengine.org/learn/book/getting-started/setup/">Setup page in the official Bevy Book</a>
and the <a href="https://github.com/bevyengine/bevy/blob/main/README.md">official Bevy Readme</a>.</p>
<h2 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a New Project</a></h2>
<p>You can simply create a new Rust project, either from your IDE/editor, or the commandline:</p>
<pre><code class="language-sh">cargo new --bin my_game
</code></pre>
<p>(creates a project called <code>my_game</code>)</p>
<p>The <code>Cargo.toml</code> file contains all the configuration of your project.
Add the latest version of <code>bevy</code> as a dependency. Your file should now
look something like this:</p>
<pre><code class="language-toml">[package]
name = "my_game"
version = "0.1.0"
edition = "2021"

[dependencies]
bevy = "0.13"
</code></pre>
<p>The <code>src/main.rs</code> file is your main source code file. This is where you
start writing your Rust code. For a minimal Bevy <a href="setup//programming/app-builder.html">app</a>, you need
at least the following:</p>
<pre><code class="language-rust no_run noplayground">use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .run();
}</code></pre>
<p>You can now compile and run your project. The first time, this will take a
while, as it needs to build the whole Bevy engine and dependencies. Subsequent
runs should be fast. You can do this from your IDE/editor, or the commandline:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>You can generate your own docs (like what is on <a href="https://docs.rs">docs.rs</a>), for
offline use, including everything from your own project and all dependencies, in
one place.</p>
<pre><code class="language-sh">cargo doc --open
</code></pre>
<p>This will build all the HTML docs and open them in your web browser.</p>
<p>It does not require an internet connection, and gives you an easy way to search
the API docs for all crates in your dependency tree all at once. It is more
useful than the online version of the docs.</p>
<h2 id="optional-extra-setup"><a class="header" href="#optional-extra-setup">Optional Extra Setup</a></h2>
<p>You will likely quickly run into unusably slow performance with the default
Rust unoptimized dev builds. <a href="setup//pitfalls/performance.html">See here how to fix.</a></p>
<p>Iterative recompilation speed is important to keep you productive, so you don't
have to wait long for the Rust compiler to rebuild your project every time you
want to test your game. <a href="https://bevyengine.org/learn/book/getting-started/setup/">Bevy's getting started page</a>
has advice about how to speed up compile times.</p>
<p>Also have a look in the <a href="setup//setup/bevy-tools.html">Dev Tools and Editors</a> page for suggestions
about additional external dev tools that may be helpful.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>Have a look at the <a href="setup//tutorial.html">guided tutorial</a> page of this book,
and Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official examples</a>.</p>
<p>Check out the <a href="https://bevyengine.org/assets">Bevy Assets Website</a> to find other tutorials
and learning resources from the community, and <a href="setup//setup/unofficial-plugins.html">plugins</a>
to use in your project.</p>
<p>Join the community on <a href="https://discord.gg/bevy">Discord</a> to chat with us!</p>
<h2 id="running-into-issues"><a class="header" href="#running-into-issues">Running into Issues?</a></h2>
<p>If something is not working, be sure to check the <a href="setup//pitfalls.html">Common
Pitfalls</a> chapter, to see if this book has something to
help you. Solutions to some of the most common issues that Bevy community
members have encountered are documented there.</p>
<p>If you need help, use <a href="https://github.com/bevyengine/bevy/discussions">GitHub Discussions</a>, or feel
welcome to come chat and ask for help in <a href="https://discord.gg/bevy">Discord</a>.</p>
<h2 id="gpu-drivers"><a class="header" href="#gpu-drivers">GPU Drivers</a></h2>
<p>To work at its best, Bevy needs DirectX 12 (Windows) or Vulkan (Linux, Android,
Windows). macOS/iOS should just work, without any special driver setup, using
Metal.</p>
<p>OpenGL (GLES3) can be used as a fallback, but will likely have issues (some
bugs, unsupported features, worse performance).</p>
<p>Make sure you have compatible hardware and drivers installed on your system.
Your users will also need to satisfy this requirement.</p>
<p>If Bevy is not working, install the latest drivers for your OS, or check with
your Linux distribution whether Vulkan needs additional packages to be
installed.</p>
<p>Web games are supported and should work in any modern browser, using WebGL2.
Performance is limited and some Bevy features will not work. The new
experimental high-performance WebGPU API is also supported, but browser adoption
is still limited.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="text-editor--ide"><a class="header" href="#text-editor--ide">Text Editor / IDE</a></h1>
<p>This sub-chapter contains tips for different text editors and IDEs.</p>
<p>Bevy is, for the most part, like any other Rust project. If your editor/IDE
is set up for Rust, that might be all you need. This sub-chapter contains
additional information that may be useful for Bevy specifically.</p>
<p>If you have any tips/advice/configurations for your editor of choice,
that you'd like to share with the community, please create a
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>, so we can add it to the book.
If your editor is not in the list, I will add it.</p>
<ul>
<li><a href="setup//setup/editor/vscode.html">Visual Studio Code</a></li>
<li><a href="setup//setup/editor/jetbrains.html">JetBrains (RustRover, IntelliJ, CLion)</a></li>
<li><a href="setup//setup/editor/kak.html">Kakoune</a></li>
<li><a href="setup//setup/editor/vim.html">Vim</a></li>
<li><a href="setup//setup/editor/emacs.html">Emacs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h1>
<p>If you are a VSCode user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support"><a class="header" href="#rust-language-support">Rust Language Support</a></h2>
<p>For good Rust support, install the Rust Analyzer plugin.</p>
<h3 id="speed-up-rust-analyzer"><a class="header" href="#speed-up-rust-analyzer">Speed Up Rust Analyzer</a></h3>
<p>If you have used <code>.cargo/config.toml</code> to set a non-default linker for fast
compiles, Rust Analyzer will ignore it unfortunately. You need to also
configure RA to use it, with the following setting (in VSCode <code>settings.json</code>):</p>
<p>Windows:</p>
<pre><code class="language-json">"rust-analyzer.cargo.extraEnv": {
    "RUSTFLAGS": "-Clinker=rust-lld.exe"
}
</code></pre>
<p>Linux (mold):</p>
<pre><code class="language-json">"rust-analyzer.cargo.extraEnv": {
    "RUSTFLAGS": "-Clinker=clang -Clink-arg=-fuse-ld=mold"
}
</code></pre>
<p>Linux (lld):</p>
<pre><code class="language-json">"rust-analyzer.cargo.extraEnv": {
    "RUSTFLAGS": "-Clinker=clang -Clink-arg=-fuse-ld=lld"
}
</code></pre>
<h2 id="cargo_manifest_dir"><a class="header" href="#cargo_manifest_dir"><code>CARGO_MANIFEST_DIR</code></a></h2>
<p>When running your app/game, Bevy will search for the <code>assets</code> folder in the path
specified in the <code>BEVY_ASSET_ROOT</code> or <code>CARGO_MANIFEST_DIR</code> environment variable.
This allows <code>cargo run</code> to work correctly from the terminal.</p>
<p>If you want to run your project from VSCode in a non-standard way (say, inside a
debugger), you have to be sure to set that correctly.</p>
<p>If this is not set, Bevy will search for <code>assets</code> alongside the executable
binary, in the same folder where it is located. This makes things easy for
distribution. However, during development, since your executable is located
in the <code>target</code> directory where <code>cargo</code> placed it, Bevy will be unable to
find the <code>assets</code>.</p>
<p>Here is a snippet showing how to create a run configuration for debugging Bevy
(with <code>lldb</code>):</p>
<p>(this is for development on Bevy itself, and testing with the <code>breakout</code> example)</p>
<p>(adapt to your needs if using for your project)</p>
<pre><code class="language-json">{
    "type": "lldb",
    "request": "launch",
    "name": "Debug example 'breakout'",
    "cargo": {
        "args": [
            "build",
            "--example=breakout",
            "--package=bevy"
        ],
        "filter": {
            "name": "breakout",
            "kind": "example"
        }
    },
    "args": [],
    "cwd": "${workspaceFolder}",
    "env": {
        "CARGO_MANIFEST_DIR": "${workspaceFolder}",
    }
}
</code></pre>
<p>To support dynamic linking, you should also add the following, inside the <code>"env"</code> section:</p>
<p>Linux:</p>
<pre><code class="language-json">"LD_LIBRARY_PATH": "${workspaceFolder}/target/debug/deps:${env:HOME}/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib",
</code></pre>
<p>(replace <code>stable-x86_64-unknown-linux-gnu</code> if you use a different toolchain/architecture)</p>
<p>Windows: I don't know. If you do, please <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">file an issue</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="jetbrains-rustrover-intellij-clion"><a class="header" href="#jetbrains-rustrover-intellij-clion">JetBrains (RustRover, IntelliJ, CLion)</a></h1>
<p>If you are a JetBrains user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support-1"><a class="header" href="#rust-language-support-1">Rust Language Support</a></h2>
<p>When using <a href="setup/editor//programming/queries.html">queries</a>, type information gets lost due to Bevy relying
on procedural macros. You can fix this by enabling <a href="https://github.com/intellij-rust/intellij-rust/issues/6908">procedural macro
support</a> in the IDE.</p>
<ol>
<li>type <code>Experimental feature</code> in the dialog of the <code>Help | Find Action</code> action</li>
<li>enable the features <code>org.rust.cargo.evaluate.build.scripts</code> and <code>org.rust.macros.proc</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="kakoune"><a class="header" href="#kakoune">Kakoune</a></h1>
<p>If you are a Kakoune user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support-2"><a class="header" href="#rust-language-support-2">Rust Language Support</a></h2>
<p>You can use <code>kak-lsp</code> with <code>rust-analyzer</code>.</p>
<p>You want to install just the RA server, without the official VSCode plugin.</p>
<p>You can manage it via <code>rustup</code>:</p>
<pre><code class="language-sh">rustup component add rust-analyzer
</code></pre>
<p>Or you can build/install it yourself from git:</p>
<pre><code class="language-sh">git clone https://github.com/rust-lang/rust-analyzer
cd rust-analyzer
git checkout release # use the `release` branch instead of `main`
cargo xtask install --server
</code></pre>
<p>The easiest way to set up <code>kak-lsp</code> is using <code>plug.kak</code>.</p>
<p>If you don't have <code>plug.kak</code>, put the following in <code>~/.config/kak/kakrc</code>:</p>
<pre><code class="language-kak">evaluate-commands %sh{
    plugins="$kak_config/plugins"
    mkdir -p "$plugins"
    [ ! -e "$plugins/plug.kak" ] &amp;&amp; \
        git clone -q https://github.com/andreyorst/plug.kak.git "$plugins/plug.kak"
    printf "%s\n" "source '$plugins/plug.kak/rc/plug.kak'"
}
plug "andreyorst/plug.kak" noload
</code></pre>
<p>And then to set up <code>kak-lsp</code> with Rust support:</p>
<pre><code class="language-kak">plug "kak-lsp/kak-lsp" do %{
    cargo install --force --path .
} config %{
    set global lsp_cmd "kak-lsp -s %val{session}"

    # create a command to let you restart LSP if anything goes wrong / gets glitched
    define-command lsp-restart -docstring 'restart lsp server' %{ lsp-stop; lsp-start }

    # helper command to enable LSP
    define-command -hidden lsp-init %{
        lsp-enable-window
        # preferences:
        set window lsp_auto_highlight_references true
        lsp-auto-signature-help-enable
        # keybind: use "," to get a menu of available LSP commands
        map global normal "," ": enter-user-mode lsp&lt;ret&gt;" -docstring "LSP mode"
    }

    hook global KakEnd .* lsp-exit

    # autoenable LSP when opening Rust files
    hook global WinSetOption filetype=rust %{
        lsp-init
    }
}
# formatting settings for Rust files
hook global BufSetOption filetype=rust %{
    set buffer tabstop 4
    set buffer indentwidth 4
    set buffer formatcmd 'rustfmt'
    set buffer autowrap_column 100
    expandtab
}
</code></pre>
<p>Put the following in <code>~/.config/kak-lsp/kak-lsp.toml</code> to use <code>rust-analyzer</code>:</p>
<pre><code class="language-toml">[server]
# Shut down the `rust-analyzer` process after a period of inactivity
timeout = 900

[language.rust]
filetypes = ["rust"]
roots = ["Cargo.toml"]
command = "rust-analyzer"
settings_section = "rust-analyzer"

[language.rust.settings.rust-analyzer]
# Proc Macro support is important for Bevy projects
procMacro.enable = true
# disable hover actions, can be laggy on complex projects like Bevy
hoverActions.enable = false
# do not use the data generated by `cargo check`, again, because it can be slow and laggy
cargo.loadOutDirsFromCheck = false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="vim"><a class="header" href="#vim">Vim</a></h1>
<p>If you are a Vim user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="emacs"><a class="header" href="#emacs">Emacs</a></h1>
<p>If you are an Emacs user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="configuring-bevy"><a class="header" href="#configuring-bevy">Configuring Bevy</a></h1>
<p>Bevy is very modular and configurable. It is implemented as many separate
cargo crates, allowing you to remove the parts you don't need. Higher-level
functionality is built on top of lower-level foundational crates, and can
be disabled or replaced with alternatives.</p>
<p>The lower-level core crates (like the Bevy ECS) can also be used completely
standalone, or integrated into otherwise non-Bevy projects.</p>
<p>bevyæ˜¯æ¨¡å—åŒ–å’Œé…ç½®åŒ–çš„,ç”±å¾ˆå¤šå•ç‹¬çš„crateç»„æˆ,å¯æŒ‰éœ€ç§»é™¤.
é«˜å±‚æ¬¡åŠŸèƒ½ä¾èµ–ä½å±‚æ¬¡åŠŸèƒ½,å‡å¯ä»¥æ›¿æ¢æˆ–disable.</p>
<p>ECSå°±æ˜¯bevyåº•å±‚çš„åŠŸèƒ½,å¯å•ç‹¬æ‹¿å‡ºæ¥ä½¿ç”¨,ç”šè‡³åœ¨ébevyé¡¹ç›®ä¸­ä½¿ç”¨.</p>
<h2 id="bevy-cargo-features"><a class="header" href="#bevy-cargo-features">Bevy Cargo Features</a></h2>
<p>In Bevy projects, you can enable/disable various parts of Bevy using cargo features.</p>
<p>Many common features are enabled by default. If you want to disable some of
them, you need to disable all of them and re-enable the ones you need.
Unfortunately, Cargo does not let you just disable individual default features.</p>
<p>Here is how you might configure your Bevy:</p>
<pre><code class="language-toml">[dependencies.bevy]
version = "0.12"
# Disable the default features if there are any that you do not want
default-features = false
features = [
  # These are the default features:
  # (re-enable whichever you like)

  # Bevy functionality:
  "multi-threaded",     # Run with multithreading
  "bevy_asset",         # Assets management
  "bevy_audio",         # Builtin audio
  "bevy_gilrs",         # Gamepad input support
  "bevy_scene",         # Scenes management
  "bevy_winit",         # Window management (cross-platform Winit backend)
  "bevy_render",        # Rendering framework core
  "bevy_core_pipeline", # Common rendering abstractions
  "bevy_gizmos",        # Support drawing debug lines and shapes
  "bevy_sprite",        # 2D (sprites) rendering
  "bevy_pbr",           # 3D (physically-based) rendering
  "bevy_gltf",          # GLTF 3D assets format support
  "bevy_text",          # Text/font rendering
  "bevy_ui",            # UI toolkit
  "animation",          # Animation support
  "tonemapping_luts",   # Support different camera Tonemapping modes (enables KTX2+zstd)
  "default_font",       # Embed a minimal default font for text/UI

  # File formats:
  "png",    # PNG image format for simple 2D images
  "hdr",    # HDR images
  "ktx2",   # Preferred format for GPU textures
  "zstd",   # ZSTD compression support in KTX2 files
  "vorbis", # Audio: OGG Vorbis

  # Platform-specific:
  "x11",                   # Linux: Support X11 windowing system
  "android_shared_stdcxx", # Android: use shared C++ library
  "webgl2",                # Web: use WebGL2 instead of WebGPU

  # These are other (non-default) features that may be of interest:
  # (add any of these that you need)

  # Bevy functionality:
  "asset_processor",      # Asset processing
  "filesystem_watcher",   # Asset hot-reloading
  "subpixel_glyph_atlas", # Subpixel antialiasing for text/fonts
  "serialize",            # Support for `serde` Serialize/Deserialize
  "async-io",             # Make bevy use `async-io` instead of `futures-lite`
  "pbr_transmission_textures", # Enable Transmission textures in PBR materials
                               # (may cause issues on old/lowend GPUs)

  # File formats:
  "dds",  # Alternative DirectX format for GPU textures, instead of KTX2
  "jpeg", # JPEG lossy format for 2D photos
  "webp", # WebP image format
  "bmp",  # Uncompressed BMP image format
  "tga",  # Truevision Targa image format
  "exr",  # OpenEXR advanced image format
  "pnm",  # PNM (pam, pbm, pgm, ppm) image format
  "basis-universal", # Basis Universal GPU texture compression format
  "zlib", # zlib compression support in KTX2 files
  "flac", # Audio: FLAC lossless format
  "mp3",  # Audio: MP3 format (not recommended)
  "wav",  # Audio: Uncompressed WAV
  "symphonia-all", # All Audio formats supported by the Symphonia library
  "shader_format_glsl", # GLSL shader support
  "shader_format_spirv", # SPIR-V shader support

  # Platform-specific:
  "wayland",              # (Linux) Support Wayland windowing system
  "accesskit_unix",       # (Unix-like) AccessKit integration for UI Accessibility
  "bevy_dynamic_plugin",  # (Desktop) support for loading of `DynamicPlugin`s

  # Development/Debug features:
  "dynamic_linking",   # Dynamic linking for faster compile-times
  "trace",             # Enable tracing for performance measurement
  "detailed_trace",    # Make traces more verbose
  "trace_tracy",       # Tracing using `tracy`
  "trace_tracy_memory", # + memory profiling
  "trace_chrome",      # Tracing using the Chrome format
  "wgpu_trace",        # WGPU/rendering tracing
  "debug_glam_assert", # Assertions to validate math (glam) usage
  "embedded_watcher",  # Hot-reloading for Bevy's internal/builtin assets
]
</code></pre>
<p>(See <a href="https://docs.rs/crate/bevy/0.12.0/features">here</a> for a full list of Bevy's cargo features.)</p>
<p>bevyçš„æ€æƒ³æ˜¯crateç»„åˆ,è¿™å°±è®©bevyæä¾›çš„åŠŸèƒ½èƒ½æŒ‰éœ€å¯ç”¨,é»˜è®¤çš„pluginåŒ…å«äº†å¤§é‡å¸¸ç”¨åŠŸèƒ½,
ä¹Ÿå¯ä»¥è‡ªå·±æŒ‰éœ€åŒ…å«.</p>
<p>ä¸‹é¢æ˜¯é»˜è®¤å¯ç”¨çš„åŠŸèƒ½,å¯ä»¥åœ¨Cargo.tomlä¸­é€šè¿‡<code>default-features = false</code>è¿›è¡Œdisable.
åŠŸèƒ½ä¸»è¦åˆ†ç±»ä¸º: bevyåŠŸèƒ½,æ–‡ä»¶æ ¼å¼,å…·ä½“å¹³å°ç»‘å®šå€¼.</p>
<p>é»˜è®¤æ”¯æŒçš„bevyåŠŸèƒ½:</p>
<ul>
<li><code>multi-threaded</code>: å¤šçº¿ç¨‹</li>
<li><code>bevy_asset</code>: èµ„äº§ç®¡ç†</li>
<li><code>bevy_audio</code>: å†…ç½®éŸ³é¢‘</li>
<li><code>bevy_gilrs</code>: æ‰‹æŸ„è¾“å…¥æ”¯æŒ</li>
<li><code>bevy_scene</code>: sceneç®¡ç†</li>
<li><code>bevy_winit</code>: çª—å£ç®¡ç†(è·¨å¹³å°)</li>
<li><code>bevy_render</code>: æ¸²æŸ“æ¡†æ¶æ ¸å¿ƒ</li>
<li><code>bevy_core_pipeline</code>: é€šç”¨æ¸²æŸ“æŠ½è±¡å±‚</li>
<li><code>bevy_gizmos</code>: è°ƒè¯•ç”¨,ç»˜åˆ¶çº¿æ¡å’Œå½¢çŠ¶çš„å°ç©æ„</li>
<li><code>bevy_sprite</code>: 2d ç²¾çµæ¸²æŸ“</li>
<li><code>bevy_pbr</code>: 3d(åŸºäºç‰©ç†çš„)çš„æ¸²æŸ“</li>
<li><code>bevy_gltf</code>: gltf 3dèµ„äº§æ ¼å¼æ”¯æŒ. (gltfæ˜¯å…è´¹3dä¼ è¾“å­˜å‚¨æ ¼å¼,è·¨å¹³å°,å¯¹GLå›¾å½¢apiå‹å¥½)</li>
<li><code>bevy_text</code>: æ–‡æœ¬/å­—ä½“æ¸²æŸ“</li>
<li><code>bevy_ui</code>: uiå·¥å…·åŒ…</li>
<li><code>animation</code>: åŠ¨ç”»</li>
<li><code>tonemapping_luts</code>: æ”¯æŒä¸åŒçš„ç›¸æœºè‰²è°ƒæ˜ å°„æ¨¡å¼(æ”¯æŒå¯åŠ¨ktx2+zstd)</li>
<li><code>default_font</code>: å†…åµŒä¸€ä¸ªæœ€å°å­—ä½“,ç”¨äºæ”¯æŒtext/ui</li>
</ul>
<p>é»˜è®¤æ”¯æŒçš„æ–‡ä»¶æ ¼å¼:</p>
<ul>
<li><code>png</code>: ç®€å•2då›¾</li>
<li><code>hdr</code>: é«˜åˆ†è¾¨ç‡å›¾</li>
<li><code>ktx2</code>: GPUçº¹ç†æ¨èæ ¼å¼</li>
<li><code>zstd</code>: æ”¯æŒzstdå‹ç¼©çš„ktx2æ–‡ä»¶</li>
<li><code>vorbis</code>: éŸ³é¢‘oggæ ¼å¼(vorbis ogg)</li>
</ul>
<p>é»˜è®¤æ”¯æŒçš„å…·ä½“å¹³å°ç»‘å®šå€¼:</p>
<ul>
<li><code>x11</code>: linuxé»˜è®¤æ”¯æŒçš„çª—å£åç«¯</li>
<li><code>android_shared_stdcxx</code>: androidé»˜è®¤åç«¯</li>
<li><code>webgl2</code>: webç«¯é»˜è®¤ä½¿ç”¨WebGL2ä»£æ›¿WebGPU</li>
</ul>
<p>éé»˜è®¤æ”¯æŒçš„bevyåŠŸèƒ½:</p>
<ul>
<li><code>asset_processor</code>: èµ„äº§å¤„ç†</li>
<li><code>filesystem_watcher</code> èµ„äº§çƒ­åŠ è½½</li>
<li><code>subpixel_glyph_atlas</code> æ–‡æœ¬å­—ä½“çš„<code>å­åƒç´ æŠ—é”¯é½¿</code></li>
<li><code>serialize</code>: serderåºåˆ—åŒ–(serderæ˜¯rustä¸­çš„ä¸€ä¸ªåºåˆ—åŒ–/ååºåˆ—åŒ–åº“)</li>
<li><code>async-io</code>: ä½¿ç”¨async-ioä»£æ›¿futures-lite</li>
<li><code>pbr_transmission_textures</code> : åœ¨bprç‰©æ–™ä¸­å¯ç”¨ä¼ è¾“çº¹ç†(bpræ˜¯åŸºäºç‰©ç†çš„æ¸²æŸ“,è®©ç‰©æ–™åœ¨å„ç§å…‰ç…§ä¸‹éƒ½èƒ½å‘ˆç°é€¼çœŸæ•ˆæœ)</li>
</ul>
<p>éé»˜è®¤æ”¯æŒçš„æ–‡ä»¶æ ¼å¼:</p>
<ul>
<li><code>dds</code>: GPUçº¹ç†,ä»£æ›¿directxæ ¼å¼,ä¸æ˜¯ktx2</li>
<li><code>jpeg</code>: æœ‰æŸ2då›¾ç‰‡</li>
<li><code>webp</code>: webpå›¾ç‰‡æ ¼å¼</li>
<li><code>bmp</code>: æœªå‹ç¼©bmpå›¾ç‰‡æ ¼å¼</li>
<li><code>tga</code>: ä¸€å®¶ç¾å›½å…¬å¸å¼€å‘çš„å›¾ç‰‡æ ¼å¼</li>
<li><code>exr</code>: OpenEXRæ ‡å‡†ä¸­çš„é«˜åŠ¨æ€èŒƒå›´å›¾ç‰‡</li>
<li><code>pnm</code>: ä¾¿æºä¸”ç®€å•å­˜å‚¨çš„å›¾ç‰‡æ ¼å¼</li>
<li><code>basis-universal</code>: googleå¼€å‘çš„è´´å›¾æ ¼å¼</li>
<li><code>zlib</code>: ktx2,å¤–åŠ zlibå‹ç¼©</li>
<li><code>flac</code>: æœ‰æŸéŸ³é¢‘æ ¼å¼</li>
<li><code>mp3</code>: é€‚ç”¨äºéŸ³ä¹ä¸‹è½½å’Œå­˜å‚¨,æ¸¸æˆåœºæ™¯ä¸æ¨è</li>
<li><code>wav</code>: æœªå‹ç¼©éŸ³é¢‘æ ¼å¼</li>
<li><code>symphonia-all</code>: rustéŸ³é¢‘åº“,æ”¯æŒå¤šç§éŸ³é¢‘æ ¼å¼çš„ç¼–è§£ç åº“</li>
<li><code>shader_format_glsl</code>: glslç€è‰²å™¨</li>
<li><code>shader_format_spirv</code> spri-ç€è‰²å™¨(é»˜è®¤æ”¯æŒçš„ç€è‰²å™¨æ˜¯wgsl)</li>
</ul>
<p>éé»˜è®¤æ”¯æŒçš„å…·ä½“å¹³å°ç»‘å®šå€¼:</p>
<ul>
<li><code>wayland</code>: linuxæ”¯æŒçš„çª—å£åç«¯(sway/hyprlandå‡æ˜¯åŸºäºwaylandçš„)</li>
<li><code>accesskit_unix</code>: unix-like uiæ— éšœç¢äº¤äº’å·¥å…·åŒ…</li>
<li><code>bevy_dynamic_plugin</code>: æ¡Œé¢,æ”¯æŒåŠ¨æ€æ’ä»¶åŠ è½½</li>
</ul>
<p>éé»˜è®¤æ”¯æŒçš„å¼€å‘/è°ƒè¯•åŠŸèƒ½:</p>
<ul>
<li><code>dynamic_linking</code>: åŠ¨æ€é“¾æ¥: ç¼–è¯‘ä¼šæ›´å¿«</li>
<li><code>trace</code>: å¼€å¯æ€§èƒ½è§‚æµ‹è·Ÿè¸ª</li>
<li><code>detailed_trace</code>: æ›´è¯¦ç»†çš„è·Ÿè¸ªæ•°æ®</li>
<li><code>trace_tracy</code>: è·Ÿè¸ªä½¿ç”¨tracy(tracyæ˜¯ä¸€ä¸ªå¯è§†åŒ–å¸§åˆ†æå’Œæ€§èƒ½è°ƒè¯•å·¥å…·)</li>
<li><code>trace_chrome</code>: è·Ÿè¸ªæ•°æ®ä½¿ç”¨chromeæ ¼å¼(rustè·Ÿè¸ªæ•°æ®å¯å¯¼å‡ºåˆ°chromeä¸­æŸ¥çœ‹)</li>
<li><code>wgpu_trace</code>: å¼€å¯ wgpu/æ¸²æŸ“ è·Ÿè¸ª</li>
<li><code>embedded_watcher</code>: bevyå†…éƒ¨èµ„äº§/å†…ç½®èµ„äº§çš„çƒ­åŠ è½½</li>
</ul>
<h3 id="graphics--rendering"><a class="header" href="#graphics--rendering">Graphics / Rendering</a></h3>
<p>For a graphical application or game (most Bevy projects), you can include
<code>bevy_winit</code> and your selection of Rendering features. For
<a href="setup//platforms/linux.html">Linux</a> support, you need at least one of <code>x11</code> or <code>wayland</code>.</p>
<p><code>bevy_render</code> and <code>bevy_core_pipeline</code> are required for any application using
Bevy rendering.</p>
<p>If you only need 2D and no 3D, add <code>bevy_sprite</code>.</p>
<p>If you only need 3D and no 2D, add <code>bevy_pbr</code>. If you are <a href="setup//3d/gltf.html">loading 3D models
from GLTF files</a>, add <code>bevy_gltf</code>.</p>
<p>If you are using Bevy UI, you need <code>bevy_text</code> and <code>bevy_ui</code>. <code>default_font</code>
embeds a simple font file, which can be useful for prototyping, so you don't
need to have a font asset in your project. In a real project, you probably
want to use your own fonts, so your text can look good with your game's art
style. In that case, you can disable the <code>default_font</code> feature.</p>
<p>If you want to draw debug lines and shapes on-screen, add <code>bevy_gizmos</code>.</p>
<p>If you don't need any graphics (like for a dedicated game server, scientific
simulation, etc.), you may remove all of these features.</p>
<p>å¯¹äºå¸¦ç•Œé¢çš„ç¨‹åº,éœ€è¦å¸¦<code>bevy_winit</code>.å¦‚æœæ˜¯linux,<code>x11</code>å’Œ<code>wayland</code>è‡³å°‘é€‰ä¸€ä¸ª.</p>
<p>åªè¦æ˜¯æ¸²æŸ“çš„,éƒ½éœ€è¦<code>bevy_render</code>å’Œ<code>bevy_core_pipeline</code>.</p>
<p>å¦‚æœåªæ˜¯2dä¸åŒ…å«3dçš„,<code>bevy_sprite</code>è¦åŒ…å«;
å¦‚æœåªæ˜¯3dè€Œä¸æ˜¯2dçš„,<code>bevy_pbr</code>è¦åŒ…å«,å¦‚æœ3dèµ„äº§æ˜¯é€šè¿‡gltfæ–‡ä»¶åŠ è½½çš„,
<code>bevy_gltf</code>è¦åŒ…å«.</p>
<p>å¦‚æœä½¿ç”¨bevy ui,<code>bevy_text</code>å’Œ<code>bevy_ui</code>æ˜¯éœ€è¦çš„,
<code>default_font</code>å†…åµŒäº†ä¸€ä¸ªç®€å•çš„å­—ä½“,åŸå‹å¼€å‘å¾ˆç”¨,
çœŸå®é¡¹ç›®ä¸­,è¿˜éœ€è¦å°†å…¶æ›¿æ¢æˆè‡ªå·±çš„å­—ä½“,é‚£æ—¶å°±ä¸éœ€è¦<code>default_font</code>äº†.</p>
<p>å¦‚æœè¦ç”»ä¸€äº›è°ƒè¯•çš„çº¿æˆ–å½¢çŠ¶,<code>bevy_gizmos</code>æœ‰å¸®åŠ©.</p>
<p>å¦‚æœä¸éœ€è¦å›¾åƒ(eg:åªæ˜¯ä¸€ä¸ªæ¸¸æˆæœåŠ¡å™¨),ä¸Šé¢è¿™äº›éƒ½å¯ä»¥ç§»é™¤.</p>
<h3 id="file-formats-1"><a class="header" href="#file-formats-1">File Formats</a></h3>
<p>You can use the relevant cargo features to enable/disable support for loading
assets with various different file formats.</p>
<p>See <a href="setup//builtins.html#file-formats">here</a> for more information.</p>
<h3 id="input-devices"><a class="header" href="#input-devices">Input Devices</a></h3>
<p>If you do not care about <a href="setup//input/gamepad.html">gamepad (controller/joystick)</a>
support, you can disable <code>bevy_gilrs</code>.</p>
<p><code>bevy_gilrs</code>æ˜¯æ‰‹æŸ„æ”¯æŒ,é»˜è®¤æ˜¯æ”¯æŒçš„,å¯ä¾éœ€æ±‚å»æ‰.</p>
<h3 id="platform-specific"><a class="header" href="#platform-specific">Platform-specific</a></h3>
<h4 id="linux-windowing-backend"><a class="header" href="#linux-windowing-backend">Linux Windowing Backend</a></h4>
<p>On <a href="setup//platforms/linux.html">Linux</a>, you can choose to support X11, Wayland,
or both. Only <code>x11</code> is enabled by default, as it is the legacy system
that should be compatible with most/all distributions, to make your builds
smaller and compile faster. You might want to additionally enable <code>wayland</code>,
to fully and natively support modern Linux environments. This will add a few
extra transitive dependencies to your project.</p>
<p>Some Linux distros or platforms might struggle with X11 and work better with
Wayland. You should enable both for best compatibility.</p>
<p>linuxä¸‹é»˜è®¤å¯ç”¨çš„æ˜¯x11,è™½ç„¶æ˜¯è€ä¸€ä»£çš„äº§ç‰©,ä½†ç¨³å®šæ€§å’Œå…¼å®¹æ€§ä¾ç„¶æœ€å¼º.
å¤§å¤šæ•°å‘è¡Œç‰ˆéƒ½å®‰è£…äº†x11,èƒ½è®©ç¨‹åºå°å¾ˆå¤š.waylandæ˜¯æ–°æ ‡å‡†,éœ€è¦é¢å¤–çš„ä¾èµ–.</p>
<p>å¹¶ä¸æ˜¯è¯´waylandä¸€å®šå¥½äºx11,çœ‹å‘è¡Œç‰ˆå¯¹çª—å£åç«¯çš„å…¼å®¹æ€§.</p>
<h4 id="webgpu-vs-webgl2"><a class="header" href="#webgpu-vs-webgl2">WebGPU vs WebGL2</a></h4>
<p>On [Web/WASM][platform::web], you have a choice between these two rendering backends.</p>
<p>WebGPU is the modern experimental solution, offering good performance and
full feature support, but browser support for it is limited (only known to
work in very recent versions of Chrome and Firefox nightly).</p>
<p>WebGL2 gives the best compatibility with all browsers, but has worse performance
and some limitations on what kinds of graphics features you can use in Bevy.</p>
<p>The <code>webgl2</code> cargo feature selects WebGL2 if enabled. If disabled, WebGPU is used.</p>
<p>web/wasmä¸Šèƒ½æ‰“çš„å°±WebGPUå’ŒWebGL2.
WebGPUæ˜¯é«˜æ€§èƒ½,ä¸”åŠŸèƒ½æ”¯æŒå…¨é¢,ä½†åªæœ‰æœ€è¿‘å‡ ä¸ªç‰ˆæœ¬çš„chrome/firefoxæ‰æ”¯æŒ.
WebGL2å¯¹æ‰€æœ‰æµè§ˆå™¨éƒ½å…¼å®¹çš„éå¸¸å¥½,ä½†æ€§èƒ½å·®äº†ä¸å°‘.</p>
<p>è™½ç„¶webgl2æ˜¯é»˜è®¤å¼€å¯çš„,ä½†å¯ä»¥æŒ‰éœ€æ›¿æ¢.</p>
<h3 id="development-features"><a class="header" href="#development-features">Development Features</a></h3>
<p>While you are developing your project, these features might be useful:</p>
<p>å¼€å‘ä¸­ä»¥ä¸‹å‡ ä¸ªåŠŸèƒ½å¯èƒ½éå¸¸æœ‰ç”¨.</p>
<h4 id="asset-hot-reloading-and-processing"><a class="header" href="#asset-hot-reloading-and-processing">Asset hot-reloading and processing</a></h4>
<p>The <code>filesystem_watcher</code> feature enables support for <a href="setup//assets/hot-reload.html">hot-reloading of
assets</a>, supported on desktop platforms.</p>
<p>The <code>asset_processor</code> feature enables support for <a href="setup//assets/processing.html">asset
processing</a>, allowing you to automatically convert and
optimize assets during development.</p>
<p>èµ„äº§çš„çƒ­åŠ è½½å’Œå¤„ç†.
æ¡Œé¢å¹³å°,<code>filesystem_watcher</code>æ”¯æŒèµ„äº§çš„çƒ­åŠ è½½.
<code>asset_processor</code>å…è®¸è‡ªåŠ¨è½¬æ¢å’Œä¼˜åŒ–èµ„äº§.</p>
<h4 id="dynamic-linking"><a class="header" href="#dynamic-linking">Dynamic Linking</a></h4>
<p><code>dynamic_linking</code> causes Bevy to be built and linked as a shared/dynamic
library. This will make recompilation <em>much</em> faster during development.</p>
<p>This is only supported on desktop platforms. Known to work very well on Linux.
Windows and macOS are also supported, but are less tested and have had issues in
the past.</p>
<p>It is not recommended to enable this for release builds you intend to publish
to other people, unless you have a very good special reason to and you know
what you are doing. It introduces unneeded complexity (you need to bundle
extra files) and potential for things to not work correctly. You should only
use it during development.</p>
<p>For this reason, it may be convenient to specify the feature as a commandline
option to <code>cargo</code>, instead of putting it in your <code>Cargo.toml</code>. Simply run your
project like this:</p>
<pre><code class="language-sh">cargo run --features bevy/dynamic_linking
</code></pre>
<p>You could also add this to your <a href="setup//setup/editor.html">IDE/editor configuration</a>.</p>
<p><code>åŠ¨æ€é“¾æ¥</code>åªåœ¨æ¡Œé¢ç³»ç»Ÿæ”¯æŒ,è¿è¡Œæœ€å¥½çš„æ˜¯linux,è‡³äºwindowså’ŒmacOSåˆšåˆš60åˆ†.
releaseç‰ˆæœ¬ä¸æ¨èå¼€å¯<code>åŠ¨æ€é“¾æ¥</code>,è¦å¼€å¯è¿™ä¸ªåŠŸèƒ½,åªèƒ½ä»å‘½ä»¤è¡Œæ“ä½œ,Cargo.tomlæ˜¯ä¸è¡Œçš„.</p>
<pre><code class="language-shell">cargo run --features bevy_dynamic_plugin
</code></pre>
<h4 id="tracing"><a class="header" href="#tracing">Tracing</a></h4>
<p>The features <code>trace</code> and <code>wgpu_trace</code> may be useful for profiling and
diagnosing performance issues.</p>
<p><code>trace_chrome</code> and <code>trace_tracy</code> choose the backend you want to use to
visualize the traces.</p>
<p>See <a href="https://github.com/bevyengine/bevy/blob/main/docs/profiling.md">Bevy's official docs on profiling</a> to learn more.</p>
<p>è·Ÿè¸ª,ä¸»è¦æ˜¯åœ¨æ€§èƒ½å‰–æå’Œè¯Šæ–­ä¸Šéå¸¸æœ‰æ•ˆ.
<code>trace</code>å’Œ<code>wgpu_trace</code>å¯å¼€å¯è·Ÿè¸ª,<code>trace_chrome</code>å’Œ<code>trace_tracy</code>æ˜¯å¯é€‰çš„è·Ÿè¸ªå¯è§†åŒ–åç«¯,ç”¨ä¸€ä¸ªå°±è¡Œ.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="community-plugins-ecosystem"><a class="header" href="#community-plugins-ecosystem">Community Plugins Ecosystem</a></h1>
<p>There is a growing ecosystem of unofficial community-made plugins for Bevy.
They provide a lot of functionality that is not officially included with the
engine. You might greatly benefit from using some of these in your projects.</p>
<p>To find such plugins, you should search the <a href="https://bevyengine.org/assets">Bevy Assets</a>
page on the official Bevy website. This is the official registry of known
community-made things for Bevy. If you publish your own plugins for Bevy,
you should <a href="https://github.com/bevyengine/bevy-assets">contribute a link to be added to that page</a>.</p>
<p>Beware that some 3rd-party plugins may use unusual licenses! Be sure to
check the license before using a plugin in your project.</p>
<p>bevyçš„ç”Ÿæ€ä¸­æœ‰å¾ˆå¤šæ’ä»¶,åœ¨<a href="https://bevyengine.org/assets/">è¿™é‡Œ</a>.
<em><strong>ä½¿ç”¨ç¬¬ä¸‰æ–¹æ’ä»¶,éœ€è¦æ³¨æ„è®¸å¯è¯</strong></em>.</p>
<hr />
<p>Other pages in this book with valuable information when using 3rd-party plugins:</p>
<ul>
<li>Some plugins may require you to <a href="setup//setup/bevy-config.html">configure Bevy in some specific way</a>.</li>
<li>If you are <a href="setup//setup/bevy-git.html">using bleeding-edge unreleased Bevy (main)</a>, you may encounter difficulties with plugin compatibility.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="dev-tools-and-editors-for-bevy"><a class="header" href="#dev-tools-and-editors-for-bevy">Dev Tools and Editors for Bevy</a></h1>
<p>Bevy does not yet have an official editor or other such tools. An official
editor is planned as a long-term future goal. In the meantime, here are
some community-made tools to help you.</p>
<p>bevyå®˜æ–¹æ²¡æœ‰ç¼–è¾‘å™¨æˆ–ç±»ä¼¼å·¥å…·,ä½†ç¤¾åŒºæä¾›äº†.</p>
<hr />
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy-inspector-egui"><code>bevy_inspector_egui</code></a> gives you a simple
editor-like property inspector window in-game. It lets you modify the values of
your components and resources in real-time as the game is running.</p>
<p><code>bevy_inspector_egui</code>åœ¨æ¸¸æˆä¸­æä¾›äº†ä¸€ä¸ªç±»ä¼¼ç¼–è¾‘å™¨çš„å±æ€§æ£€æŸ¥å™¨çª—å£,
å¯ä»¥å®æ—¶ä¿®æ”¹ç»„ä»¶/èµ„æºçš„å€¼.ç›®å‰æœ‰3k+é¡¹ç›®åœ¨ä½¿ç”¨è¿™ä¸ªå·¥å…·.</p>
<p><a href="https://github.com/jakobhellermann/bevy_editor_pls"><code>bevy_editor_pls</code></a> is an editor-like interface that
you can embed into your game. It has even more features, like switching app
states, fly camera, performance diagnostics, and inspector panels.</p>
<p><code>bevy_editor_pls</code>æä¾›äº†ç±»ä¼¼ç¼–è¾‘å™¨çš„æ¥å£,å¯å†…åµŒåˆ°æ¸¸æˆä¸­,
è°ƒè¯•åŠŸèƒ½ç‰¹åˆ«å¤š:åˆ‡æ¢appçŠ¶æ€,ç›¸æœºfly,æ€§èƒ½è¯Šæ–­,å¹³é¢æ£€æŸ¥.
ç›®å‰æœ‰500+é¡¹ç›®åœ¨ä½¿ç”¨.</p>
<p><a href="https://github.com/rewin123/space_editor"><code>space_editor</code></a> is another such editor that can be
embedded into your game. It seems to be designed for a Unity-inspired prefab
workflow.</p>
<p><code>space_editor</code>æ˜¯åˆä¸€ä¸ªå¯ä»¥å†…åµŒåˆ°æ¸¸æˆä¸­çš„ç¼–è¾‘å™¨,å—unityçš„å¯å‘è€Œäº§ç”Ÿçš„é¡¹ç›®.</p>
<p>You can also use <a href="https://www.blender.org/">Blender</a> as a level/scene editor,
by exporting your scenes to <a href="setup//3d/gltf.html">GLTF</a>. The <a href="https://github.com/kaosat-dev/Blender_bevy_components_workflow">Blender Bevy Components
Workflow</a> project improves on this
experience, by allowing you to setup your Bevy ECS <a href="setup//programming/ec.html#components">Components</a>
in Blender, include them in the exported GLTF, and use them in Bevy.</p>
<p><code>blender</code>ä¹Ÿå¯ç”¨ä½œç­‰çº§/åœºæ™¯ç¼–è¾‘å™¨,é€‚ç”¨äºå°†sceneå¯¼å‡ºåˆ°gltfçš„åœºæ™¯.</p>
<p>blenderæ˜¯ä¸€ä¸ªå¼€æºçš„ä¸‰ç»´è®¡ç®—æœºå›¾å½¢è½¯ä»¶,å¹¿æ³›ç”¨äºåŠ¨ç”»åˆ¶ä½œ,è§†è§‰ç‰¹æ•ˆ,å»ºæ¨¡,æ¸²æŸ“å’Œæ¸¸æˆå¼€å‘ç­‰é¢†åŸŸ.
blenderåœæ­¢äº†è‡ªå·±çš„æ¸¸æˆå¼•æ“å¼€å‘,ä½†æ”¯æŒå¯¼å‡ºæ•°æ®ç»™å…¶ä»–æ¸¸æˆå¼•æ“ä½¿ç”¨.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy_mod_debugdump"><code>bevy_mod_debugdump</code></a> is a tool to help visualize
your <a href="setup/../programming/app-builder.html">App Schedules</a> (all of the registered
<a href="setup/../programming/systems.html">systems</a> with their <a href="setup/../programming/system-order.html">ordering
dependencies</a>), and the Bevy Render Graph.</p>
<p><code>bevy_mod_debugdump</code>æ˜¯è°ƒåº¦å¯è§†åŒ–çš„è¯Šæ–­å·¥å…·,è¿˜åŒ…å«äº†bevyçš„æ¸²æŸ“å›¾è¯Šæ–­.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="performance-tunables"><a class="header" href="#performance-tunables">Performance Tunables</a></h1>
<p>Bevy offers a lot of features that should improve performance in most cases, and
most of them are enabled by default. However, they might be detrimental to some
projects.</p>
<p>Luckily, most of them are configurable. Most users should probably not touch
these settings, but if your game does not perform well with Bevy's default
configuration, this page will show you some things you can try to change, to see
if they help your project.</p>
<p>Bevy's default configruation is designed with <em>scalability</em> in mind. That is, so
that you don't have to worry too much about performance, as you add more
features and complexity to your project. Bevy will automatically take care to
distribute the workload as to make good use of the available hardware (GPU, CPU
multithreading).</p>
<p>However, it might hurt simpler projects or have undesirable implications in some
cases.</p>
<p>This trade-off is good, because small and simple games will probably be fast
enough anyway, even with the additional overhead, but large and complex games
will benefit from the advanced scheduling to avoid bottlenecks. You can
develop your game without performance degrading much as you add more stuff.</p>
<p>æ€§èƒ½å¯è°ƒå‚æ•°.</p>
<p>bevyæä¾›äº†å¤§é‡åŠŸèƒ½,åœ¨å¤§å¤šæ•°åœºæ™¯ä¸‹éƒ½èƒ½æé«˜æ€§èƒ½,è¿™äº›å¤§å¤šæ˜¯é»˜è®¤å¼€å¯çš„.
åœ¨éƒ¨åˆ†é¡¹ç›®ä¸­,è¿™äº›é»˜è®¤å¼€å¯çš„å¯èƒ½ä¼šèµ·åˆ°åæ•ˆæœ.</p>
<p>è¿™äº›å‚æ•°éƒ½æ˜¯å¯è°ƒçš„.</p>
<p>bevyçš„è®¾è®¡æƒè¡¡æ˜¯å¯æ‰©å±•,æœ‰äº›æœºåˆ¶å¯ç”¨ååœ¨ç®€å•é¡¹ç›®ä¸­ä¸æ˜¯æœ€ä¼˜,ä½†æ¶ˆè€—ä¹Ÿèƒ½æ¥å—,
åœ¨å¤æ‚é¡¹ç›®ä¸­å°±èƒ½å¾—åˆ°å¾ˆå¥½çš„æ”¶ç›Š,eg:å¤šçº¿ç¨‹(åœ¨è‡ªå®šä¹‰bevyä¸€èŠ‚ä¸­,å¤šçº¿ç¨‹æ˜¯ç¬¬ä¸€ä¸ªé»˜è®¤å¯ç”¨çš„åŠŸèƒ½).</p>
<h2 id="multithreading-overhead"><a class="header" href="#multithreading-overhead">Multithreading Overhead</a></h2>
<p>Bevy has a smart multithreaded executor, so that your <a href="setup//programming/systems.html">systems</a> can
automatically <a href="setup//programming/intro-code.html">run in parallel</a> across multiple CPU cores,
when they don't need conflicting access to the same data, while <a href="setup//programming/system-order.html">honoring ordering
constraints</a>. This is great, because you can just keep adding
more systems to do different things and implement more features in your game,
and Bevy will make good use of modern multi-core CPUs with no effort from you!</p>
<p>However, the smart scheduling adds some overhead to all common operations (such
as every time a <a href="setup//programming/systems.html">system</a> runs). In projects that have little work to
do every frame, especially if all of your systems complete very quickly, the
overhead can add up to overshadow the actual useful work you are doing!</p>
<p>You might want to try disabling multithreading, to see if your game might
perform better without it.</p>
<p>å¤šçº¿ç¨‹,è¿™æ ·å¤šä¸ªsystemå°±å¯ä»¥åœ¨å¤šä¸ªcpuå¹¶è¡Œå¤„ç†,é…åˆsystemçš„<code>é¡ºåºçº¦å®š</code>,
bevyå°±è‡ªåŠ¨å¤„ç†äº†å¤šæ ¸è°ƒåº¦.</p>
<p>bevyè‡ªåŠ¨è°ƒåº¦ä¸æ˜¯æ²¡æœ‰ä»£ä»·çš„,è€Œä¸”è¿˜å¾ˆå¤§,å¦‚æœsysteméƒ½æ˜¯æ‰§è¡Œç®€å•ä»»åŠ¡,
å¤šçº¿ç¨‹çš„æ”¶ç›Šä¸ä¸€å®šèƒ½è¦†ç›–ä½bevyè‡ªåŠ¨è°ƒåº¦çš„æ¶ˆè€—.
æ¢è¨€ä¹‹,systemä»»åŠ¡è¶Šå¤æ‚,å¤šçº¿ç¨‹è°ƒåº¦çš„æ”¶ç›Šè¶Šé«˜.</p>
<h3 id="disabling-multithreading-for-update-schedule-only"><a class="header" href="#disabling-multithreading-for-update-schedule-only">Disabling Multithreading for Update Schedule Only</a></h3>
<p>Multithreading can be disabled per-<a href="setup//programming/schedules.html">schedule</a>. This means it
is easy to disable it only for your code / game logic (in the <code>Update</code> schedule),
while still leaving it enabled for all the Bevy engine internal systems.</p>
<p>This could speed up simple games that don't have much gameplay logic, while still
letting the engine run with multithreading.</p>
<p>You can edit the settings of a specific <a href="setup//programming/schedules.html">schedule</a> via the <a href="setup//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">    use bevy::ecs::schedule::ExecutorKind;

    App::new()
        .add_plugins(DefaultPlugins)
        .edit_schedule(Update, |schedule| {
            schedule.set_executor_kind(ExecutorKind::SingleThreaded);
        })
        // ...</code></pre>
<p>bevyä¸­æœ‰å¾ˆå¤šè°ƒåº¦å™¨,å…¶ä¸­Updateå°±æ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„æ¸¸æˆé€»è¾‘,å…¶ä»–å¾ˆå¤šæ˜¯bevyå†…ç½®çš„system,
è¿™é‡Œæä¾›äº†ä¸€ç§æ–¹å¼åªè®©Updateè°ƒåº¦å™¨ç¦æ­¢ä½¿ç”¨å¤šçº¿ç¨‹.è¿™å¯¹ç®€å•é¡¹ç›®æ˜¯æœ‰æ€§èƒ½æé«˜çš„.</p>
<p>å¦‚ä¸Šå›¾æ‰€ç¤º,æŒ‡å®šè°ƒåº¦å™¨ç±»å‹ä¸ºå•çº¿ç¨‹å³å¯.</p>
<h3 id="disabling-multithreading-completely"><a class="header" href="#disabling-multithreading-completely">Disabling Multithreading Completely</a></h3>
<p>If you want to try to completely disable multithreading for everything,
you can do so by removing the <code>multi-threaded</code> default Cargo feature.</p>
<p>In <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies.bevy]
version = "0.12"
default-features = false
features = [
   # re-enable everything you need, without `multi-threaded`
   # ...
]
</code></pre>
<p><a href="setup//setup/bevy-config.html">(see here for how to configure Bevy's cargo features)</a></p>
<p>This is generally not recommended. Bevy is designed to work with multithreading.
Only consider it if you really need it (like if you are making a special build
of your project to run on a system where it makes sense, like WASM or old
hardware).</p>
<p>å¦‚æœè¦ç¦æ­¢æ‰€æœ‰systemçš„å¤šçº¿ç¨‹è¿è¡Œ,é€šè¿‡featuresç¦ç”¨<code>multi-threaded</code>å³å¯.
è¿™ä¸ªä¸€èˆ¬å‡ºç°åœ¨wasmæˆ–è€æ—§ç¡¬ä»¶çš„é¡¹ç›®ä¸­.</p>
<h2 id="multithreading-configuration"><a class="header" href="#multithreading-configuration">Multithreading Configuration</a></h2>
<p>You can configure how many CPU threads Bevy uses.</p>
<p>Bevy creates threads for 3 different purposes:</p>
<ul>
<li>Compute: where all your systems and all per-frame work is run</li>
<li>AsyncCompute: for background processing independent from framerate</li>
<li>I/O: for loading of assets and other disk/network activity</li>
</ul>
<p>By default, Bevy <em>splits/partitions</em> the available CPU threads as follows:</p>
<ul>
<li>I/O: 25% of the available CPU threads, minimum 1, maximum 4</li>
<li>AsyncCompute: 25% of the available CPU threads, minimum 1, maximum 4</li>
<li>Compute: all remaining threads</li>
</ul>
<p>This means <em>no overprovisioning</em>. Every hardware CPU thread is used
for one specific purpose.</p>
<p>This provides a good balance for mixed CPU workloads. Particularly for games
that load a lot of assets (especially if assets are loaded dynamically during
gameplay), the dedicated I/O threads will reduce stuttering and load times.
Background computation will not affect your framerate. Etc.</p>
<p>Examples:</p>
<div class="table-wrapper"><table><thead><tr><th>CPU Cores/Threads</th><th># I/O</th><th># AsyncCompute</th><th># Compute</th></tr></thead><tbody>
<tr><td>1-3</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>4</td><td>1</td><td>1</td><td>2</td></tr>
<tr><td>6</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>8</td><td>2</td><td>2</td><td>4</td></tr>
<tr><td>10</td><td>3</td><td>3</td><td>4</td></tr>
<tr><td>12</td><td>3</td><td>3</td><td>6</td></tr>
<tr><td>16</td><td>4</td><td>4</td><td>8</td></tr>
<tr><td>24</td><td>4</td><td>4</td><td>16</td></tr>
<tr><td>32</td><td>4</td><td>4</td><td>24</td></tr>
</tbody></table>
</div>
<p>Note: Bevy does not currently have any special handling for asymmetric
(big.LITTLE or Intel P/E cores) CPUs. In an ideal world, maybe it would be nice
to use the number of big/P cores for Compute and little/E cores for I/O.</p>
<p>è¿›ä¸€æ­¥è¿˜å¯ä»¥é…ç½®bevyèƒ½ä½¿ç”¨åˆ°çš„çº¿ç¨‹æ•°,bevyåˆ›å»ºçš„çº¿ç¨‹ä¸€èˆ¬è¦å¹²3ä»¶äº‹:</p>
<ul>
<li>è®¡ç®—,æ‰€æœ‰çš„systemå’Œæ¯å¸§å‰ç½®çš„å·¥ä½œ</li>
<li>å¼‚æ­¥è®¡ç®—,ç‹¬ç«‹äºå¸§ç‡çš„åå°å¤„ç†é€»è¾‘</li>
<li>io,èµ„äº§åŠ è½½æˆ–æ´»è·ƒçš„ç£ç›˜ç½‘ç»œæ´»åŠ¨</li>
</ul>
<p>é»˜è®¤bevyæ˜¯æŒ‰å¦‚ä¸‹æ–¹å¼åˆ†é…cpuçº¿ç¨‹çš„:</p>
<ul>
<li>io: 25%å¯ç”¨çº¿ç¨‹æ•°,æœ€å°‘1ä¸ª,æœ€å¤š4ä¸ª</li>
<li>å¼‚æ­¥è®¡ç®—: 25%å¯ç”¨çº¿ç¨‹æ•°,æœ€å°‘1ä¸ª,æœ€å¤š4ä¸ª</li>
<li>è®¡ç®—:å‰©ä¸‹çº¿ç¨‹æ•°</li>
</ul>
<p>è¿™ä¸ªé…ç½®å¾ˆå¹³è¡¡,èµ„æºåŠ è½½(å¤§ä¸€ç‚¹çš„æ¸¸æˆéƒ½æ˜¯åŠ¨æ€åŠ è½½èµ„æºçš„)å’Œioä¼šå‡å°‘æ¸¸æˆå¡é¡¿å’ŒåŠ è½½æ—¶é—´,
åå°çš„å¼‚æ­¥è®¡ç®—ä¹Ÿä¸ä¼šå—å¸§ç‡å½±å“,è¿™æ˜¯è¿™ä¹ˆè®¾è®¡çš„è€ƒè™‘.</p>
<p>å¦‚ä¸Šè¡¨æ‰€ç¤º: 8æ ¸çš„åˆ†é…æ˜¯2/2/4(å¯¹ç€è¡¨æ ¼çœ‹),24æ ¸çš„åˆ†é…æ˜¯4/4/16.</p>
<h3 id="overprovisioning"><a class="header" href="#overprovisioning">Overprovisioning</a></h3>
<p>However, if your game does very little I/O (asset loading) or background
computation, this default configuration might be sub-optimal. Those threads will
be sitting idle a lot of the time. Meanwhile, Compute, which is your frame
update loop and is important to your game's overall framerate, is limited to
fewer threads. This can be especially bad on CPUs with few cores (less than 4
total threads).</p>
<p>For example, in my projects, I usually load all my assets during a loading
screen, so the I/O threads are unused during normal gameplay. I rarely use
AsyncCompute.</p>
<p>If your game is like that, you might want to make all CPU threads available for
Compute. This could boost your framerate, especially on CPUs with few cores.
However, any AsyncCompute or I/O workloads during gameplay could impact your
game's performance / framerate consistency.</p>
<p>Here is how to do that:</p>
<pre><code class="language-rust no_run noplayground">    use bevy::core::TaskPoolThreadAssignmentPolicy;
    use bevy::tasks::available_parallelism;

    App::new()
        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
            // DefaultPlugins.set() å°±æ˜¯è‡ªå®šä¹‰æŸä¸ªæ’ä»¶,
            // TaskPoolPlugin é‡Œé¢åŒ…å«äº†3ä¸ªä»»åŠ¡æ± ,åˆ†åˆ«æ˜¯å¼‚æ­¥è®¡ç®—/è®¡ç®—/io.
            task_pool_options: TaskPoolOptions {
                compute: TaskPoolThreadAssignmentPolicy {
                    // set the minimum # of compute threads
                    // to the total number of available threads
                    // é€šè¿‡è®¾ç½®æœ€å°çº¿ç¨‹æ•°ä¸ºæœ€å¤§å¯ç”¨çº¿ç¨‹æ•°æ¥å±è”½å¼‚æ­¥è®¡ç®—å’Œioçš„çº¿ç¨‹æ•°.
                    min_threads: available_parallelism(),
                    max_threads: std::usize::MAX, // unlimited max threads
                    percent: 1.0,                 // this value is irrelevant in this case
                },
                // keep the defaults for everything else
                ..default()
            },
        }))
        // ...</code></pre>
<p>And here is an example of an entirely custom configuration:</p>
<pre><code class="language-rust no_run noplayground">    App::new()
        .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
            task_pool_options: TaskPoolOptions {
                min_total_threads: 1,
                max_total_threads: std::usize::MAX, // unlimited threads
                io: TaskPoolThreadAssignmentPolicy {
                    // say we know our app is i/o intensive (asset streaming?)
                    // so maybe we want lots of i/o threads
                    // ioå¯†é›†å‹ç¨‹åº.
                    min_threads: 4,
                    max_threads: std::usize::MAX,
                    percent: 0.5, // use 50% of available threads for I/O
                },
                async_compute: TaskPoolThreadAssignmentPolicy {
                    // say our app never does any background compute,
                    // so we don't care, but keep one thread just in case
                    // å¼‚æ­¥è®¡ç®—è™½ç„¶æ²¡æœ‰,å¯ä»¥æŒ‡å®šä¸º1ä¸ª.
                    min_threads: 1,
                    max_threads: 1,
                    percent: 0.0,
                },
                compute: TaskPoolThreadAssignmentPolicy {
                    // say we want to use at least half the CPU for compute
                    // (maybe over-provisioning if there are very few cores)
                    // æœ€å°‘ä¿è¯ä¸€åŠçš„çº¿ç¨‹åœ¨è®¡ç®—ä¸Š.
                    min_threads: available_parallelism() / 2,
                    // but limit it to a maximum of 8 threads
                    max_threads: 8,
                    // 1.0 in this case means "use all remaining threads"
                    // (that were not assigned to io/async_compute)
                    // (clamped to min_threads..=max_threads)
                    percent: 1.0,
                },
            },
        }))
        // ...</code></pre>
<p>å½“ç„¶,å¦‚æœæˆ‘ä»¬çš„æ¸¸æˆåœ¨èµ„äº§åŠ è½½(io)å’Œå¼‚æ­¥è®¡ç®—æ–¹é¢çš„ä»»åŠ¡éå¸¸å°‘,é»˜è®¤é…ç½®å°±ä¸æ˜¯æœ€ä¼˜çš„,
åœ¨å¾ˆå¤šæ—¶é—´å†…,åˆ†é…ç»™ioå’Œå¼‚æ­¥è®¡ç®—çš„çº¿ç¨‹å°±æ˜¯é—²ç€çš„,å¦‚æœcpuçº¿ç¨‹æ•°å¤šä¸€ç‚¹,
è¿™ç‚¹é—²ç½®å¯¹æ¸¸æˆè¿˜æ²¡å•¥å¤§å½±å“,å¦‚æœcpuçº¿ç¨‹æ•°å¾ˆå°‘(å°äº4ä¸ª),è¿™ç‚¹æµªè´¹å°±æ˜¯å·¨å¤§çš„æµªè´¹.</p>
<p>eg:åœ¨å±å¹•åŠ è½½ç”»é¢ä¸­,èµ„äº§å·²ç»åŠ è½½å®Œæ¯•,è¿™æ„å‘³ç€æ²¡å•¥io,å¦‚æœå¼‚æ­¥è®¡ç®—ä¹Ÿå°‘,
è¿™ç§æƒ…å†µä¸‹,è°ƒæ•´é»˜è®¤é…ç½®å°±æ˜¯å¾ˆæœ‰å¿…è¦çš„.</p>
<h2 id="pipelined-rendering"><a class="header" href="#pipelined-rendering">Pipelined Rendering</a></h2>
<p>Bevy has a <a href="setup//gpu/intro.html">pipelined rendering architecture</a>. This
means Bevy's GPU-related <a href="setup//programming/systems.html">systems</a> (that run on the CPU to prepare
work for the GPU every frame) will run in parallel with all the normal systems
for the next frame. Bevy will render the previous frame in parallel with the
next frame update.</p>
<p>This will improve GPU utilization (make it less likely the GPU will sit idle
waiting for the CPU to give it work to do), by making better use of CPU
multithreading. Typically, it can result in 10-30% higher framerate, sometimes
more.</p>
<p>However, it can also affect perceived input latency ("click-to-photon"
latency), often for the worse. The effects of the player's input might be
shown on screen delayed by one frame. It might be compensated by the faster
framerate, or it might not be. Here is a diagram to visualize what happens:</p>
<p><img src="setup/../img/pipelined-latency.png" alt="Timeline comparing pipelined and non-pipelined rendering. In the pipelined case, one additional frame is displayed before the effects of the mouse click can be seen on-screen." /></p>
<p>The actual mouse click happens in-between frames. In both cases, frame #4 is
when the input is detected by Bevy. In the pipelined case, rendering
of the previous frame is done in parallel, so an additional frame without
the input appears on-screen.</p>
<p>Without pipelining, the user will see their input delayed by 1 frame. With
pipelining, it will be delayed by 2 frames.</p>
<p>However, in the diagram above, the frame rate increase from pipelining is
big enough that overall the input is processed and displayed sooner. Your
application might not be so lucky.</p>
<p>bevyçš„æ¸²æŸ“æ˜¯ç®¡é“å¼æ¶æ„.GPUåœ¨æ˜¾å¡ä¸Š,è¿è¡Œåœ¨cpuçš„systemä¼šå°†æ¯å¸§è¦æŠ•é€’ç»™GPUæ•°æ®å‡†å¤‡å¥½,
GPUå’ŒCPUæ˜¯å¹¶è¡Œè¿è¡Œçš„.è¿™ç±»systemç§°ä¸º<code>GPUç›¸å…³çš„system</code>,
å…¶ç‰¹ç‚¹æ˜¯å½“å‰å¸§çš„GPU systemå’Œä¸‹å¸§çš„æ™®é€šsystemæ˜¯å¹¶è¡Œæ‰§è¡Œçš„.</p>
<p>è¿™ç§è®¾è®¡æé«˜äº†GPUçš„åˆ©ç”¨ç‡,é…åˆå¤šçº¿ç¨‹,æ€»ä½“èƒ½æé«˜10-30%çš„å¸§ç‡.</p>
<p>å› ä¸ºGPU systemçš„å®é™…ä¸Šå·¥ä½œåœ¨ä¸‹å¸§,åœ¨ä½å»¶æ—¶çš„åœºæ™¯ä¸‹, å¯¹è¾“å…¥çš„æ„ŸçŸ¥ä¼šé€ æˆå½±å“,
è¿™æ˜¯æé«˜å¸§ç‡çš„ä»£ä»·ä¹‹ä¸€.é«˜å¸§ç‡æ¯”ä½å¸§ç‡çš„å½±å“å°ä¸€äº›.</p>
<p>å¦‚ä¸Šå›¾æ‰€ç¤º,é¼ æ ‡ç‚¹å‡»å,åœ¨4å¤„bevyæ„ŸçŸ¥åˆ°äº†ç‚¹å‡»äº‹ä»¶,
åœ¨æ²¡æœ‰pipelineæœºåˆ¶æ—¶,åœ¨5å¤„å°±é€šè¿‡ç”»é¢åé¦ˆåˆ°ç©å®¶äº†,ç”¨äº†1å¸§;
åœ¨ä½¿ç”¨pipelineæœºåˆ¶æ—¶,åœ¨6å¤„æ‰åé¦ˆåˆ°ç©å®¶,ç”¨äº†2å¸§.</p>
<p>åœ¨é«˜å¸§ç‡ä¸‹,pipelineæœºåˆ¶çš„ä»£ä»·ä¼šè¢«æ”¶ç›Šè¦†ç›–,æˆ‘ä»¬çš„ç¨‹åºå…·ä½“æ˜¯å’‹æ ·çš„,
éœ€è¦å…·ä½“åˆ†æ.</p>
<hr />
<p>If you care more about latency than framerate, you might want to disable
pipelined rendering. For the best latency, you probably also want to
<a href="setup//window/props.html#vsync">disable VSync</a>.</p>
<p>Here is how to disable pipelined rendering:</p>
<pre><code class="language-rust no_run noplayground">    use bevy::render::pipelined_rendering::PipelinedRenderingPlugin;

    App::new()
        .add_plugins(DefaultPlugins.build().disable::&lt;PipelinedRenderingPlugin&gt;())
        // ...
        .run();</code></pre>
<p>pipelineçš„å¼€å…³å¦‚ä¸Šå›¾æ“ä½œ.</p>
<h2 id="clustered-forward-rendering"><a class="header" href="#clustered-forward-rendering">Clustered Forward Rendering</a></h2>
<p>By default, Bevy uses a Clustered Forward Rendering architecture for 3D.  The
viewport (on-screen area where the game is displayed) is split into
rectangles/voxels, so that the lighting can be handled separately for each small
portion of the scene. This allows you to use many lights in your 3D scenes,
without destroying performance.</p>
<p>The dimensions of these clusters can affect rendering performance. The default
settings are good for most 3D games, but fine-tuning them could improve
performance, depending on your game.</p>
<p>In games with a top-down-view camera (such as many strategy and simulation
games), most of the lights tend to be a similar distance away from the camera.
In such cases, you might want to reduce the number of Z slices (so that the
screen is split into smaller X/Y rectangles, but each one covering more
distance/depth):</p>
<pre><code class="language-rust no_run noplayground">    use bevy::pbr::ClusterConfig;

    commands.spawn((
        Camera3dBundle {
            // ... your 3D camera configruation
            ..Default::default()
        },
        ClusterConfig::FixedZ {
            // å›ºå®šz, é€‚åˆä»ä¸Šåˆ°ä¸‹è§†è§’çš„æ¸¸æˆ,eg:ç­–ç•¥æˆ–æ¨¡æ‹Ÿæ¸¸æˆ.

            // 4096 clusters is the Bevy default
            // if you don't have many lights, you can reduce this value
            // ç¯å…‰æ•°å°‘,å°±å‡å°‘totalå€¼. é»˜è®¤é›†ç¾¤åˆ†ç»„æ•°æ˜¯4096.
            total: 4096,
            // Bevy default is 24 Z-slices
            // For a top-down-view game, 1 is probably optimal.
            // ä»ä¸Šåˆ°ä¸‹è§†è§’çš„æ¸¸æˆä¸­,è®¾ç½®zä¸º1.
            z_slices: 1,
            dynamic_resizing: true,
            z_config: Default::default(),
        },
    ));</code></pre>
<p>For games that use very few lights, or where lights affect the entire scene (
such as inside a small room / indoor area), you might want to try disabling
clustering:</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn((
        Camera3dBundle {
            // ... your 3D camera configruation
            ..Default::default()
        },
        ClusterConfig::Single, // å¦‚æœæ˜¯å®¤å†…,å…‰æºå•ä¸€,å¯ä»¥disableé›†ç¾¤.
    ));</code></pre>
<p>Changing these settings will probably result in bad performance for many games,
outside of the specific scenarios described above.</p>
<p>é»˜è®¤bevyåœ¨3dæ¸²æŸ“ä¸­ä½¿ç”¨<code>é›†ç¾¤å‘å‰æ¸²æŸ“</code>,
è§†å£ï¼ˆæ˜¾ç¤ºæ¸¸æˆçš„å±å¹•åŒºåŸŸï¼‰è¢«åˆ†å‰²æˆçŸ©å½¢/ä½“ç´ ï¼Œè¿™æ ·å¯ä»¥é’ˆå¯¹åœºæ™¯çš„æ¯ä¸ªå°éƒ¨åˆ†å•ç‹¬å¤„ç†ç…§æ˜ã€‚
è¿™æ ·ï¼Œå¯ä»¥åœ¨ 3D åœºæ™¯ä¸­ä½¿ç”¨è®¸å¤šç¯å…‰ï¼Œè€Œä¸ä¼šå½±å“æ€§èƒ½ã€‚</p>
<p>é›†ç¾¤åˆ†ç»„çš„å°ºå¯¸ä¼šå½±å“æ¸²æŸ“æ€§èƒ½,é€‚åˆçš„è®¾ç½®ä¼šæå‡æ€§èƒ½.
åœ¨é‡‡ç”¨è‡ªä¸Šè€Œä¸‹è§†è§’çš„æ¸¸æˆä¸­ï¼ˆä¾‹å¦‚è®¸å¤šç­–ç•¥å’Œæ¨¡æ‹Ÿæ¸¸æˆï¼‰ï¼Œå¤§å¤šæ•°ç¯å…‰ä¸ç›¸æœºçš„è·ç¦»éƒ½å·®ä¸å¤šã€‚
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½éœ€è¦å‡å°‘ Z åˆ‡ç‰‡çš„æ•°é‡
(ä»¥ä¾¿å°†å±å¹•åˆ†å‰²æˆæ›´å°çš„ X/Y çŸ©å½¢ï¼Œä½†æ¯ä¸ªçŸ©å½¢è¦†ç›–æ›´å¤§çš„è·ç¦»/æ·±åº¦).</p>
<p><em><strong>å¤§å¤šæ•°åœºæ™¯ä¸‹ä¸éœ€è¦è¿™ä¹ˆè®¾ç½®,åªåœ¨ç‰¹æ®Šåœºæ™¯ä¸‹ä½¿ç”¨ä¼šæé«˜æ€§èƒ½.</strong></em></p>
<p>é›†ç¾¤å‘å‰æ¸²æŸ“æ˜¯ä¸€ç§ç°ä»£æ¸²æŸ“æŠ€æœ¯.<br />
ç»“åˆäº†ä¼ ç»Ÿçš„å‰å‘æ¸²æŸ“ï¼ˆForward Renderingï¼‰å’Œé›†ç¾¤ï¼ˆClusteredï¼‰åˆ†ç»„çš„æ–¹æ³•ï¼Œ
ä»¥æ›´é«˜æ•ˆåœ°å¤„ç†å¤æ‚åœºæ™¯ä¸­çš„å…‰æºå’Œé˜´å½±ã€‚
å®ƒåœ¨å¤„ç†å¤§é‡å…‰æºæ—¶æ¯”ä¼ ç»Ÿçš„å‰å‘æ¸²æŸ“æ›´é«˜æ•ˆï¼Œ
å¹¶ä¸”åœ¨æ€§èƒ½å’Œçµæ´»æ€§ä¸Šæ¯”å»¶è¿Ÿæ¸²æŸ“ï¼ˆDeferred Renderingï¼‰æœ‰ä¸€äº›ä¼˜åŠ¿ã€‚</p>
<p>å‰å‘æ¸²æŸ“ï¼ˆForward Renderingï¼‰:<br />
ä¼ ç»Ÿçš„æ¸²æŸ“æŠ€æœ¯ï¼Œå…¶ä¸­æ¯ä¸ªå¯¹è±¡åœ¨æ¸²æŸ“æ—¶ç›´æ¥åº”ç”¨æ‰€æœ‰å½±å“å®ƒçš„å…‰æºã€‚
è¿™ç§æ–¹æ³•åœ¨å¤„ç†å°‘é‡å…‰æºæ—¶æ¯”è¾ƒé«˜æ•ˆï¼Œä½†éšç€å…‰æºæ•°é‡çš„å¢åŠ ï¼Œæ€§èƒ½ä¼šæ˜¾è‘—ä¸‹é™ã€‚</p>
<p>å»¶è¿Ÿæ¸²æŸ“ï¼ˆDeferred Renderingï¼‰ï¼š<br />
å»¶è¿Ÿæ¸²æŸ“é¦–å…ˆæ¸²æŸ“åœºæ™¯å‡ ä½•ä¿¡æ¯åˆ°å¤šä¸ªç¼“å†²åŒºï¼Œç„¶ååœ¨ä¸€ä¸ªå•ç‹¬çš„å…‰ç…§é˜¶æ®µåº”ç”¨å…‰æºã€‚
å®ƒèƒ½å¾ˆå¥½åœ°å¤„ç†å¤§é‡å…‰æºï¼Œä½†éœ€è¦æ›´å¤šçš„å†…å­˜å¸¦å®½å’Œè¾ƒå¤æ‚çš„åæœŸå¤„ç†ã€‚</p>
<p>é›†ç¾¤åˆ†ç»„ï¼ˆClusteredï¼‰ï¼š<br />
åœºæ™¯è¢«åˆ†å‰²æˆå¤šä¸ªå°çš„ä¸‰ç»´åŒºåŸŸï¼ˆé›†ç¾¤ï¼‰ã€‚
å…‰æºå’Œç‰©ä½“çš„å…³ç³»åªåœ¨è¿™äº›é›†ç¾¤å†…è¿›è¡Œè®¡ç®—ï¼Œä»è€Œå‡å°‘æ¯ä¸ªå¯¹è±¡éœ€è¦å¤„ç†çš„å…‰æºæ•°é‡ã€‚
è¿™ç§æ–¹æ³•æé«˜äº†å…‰æºç®¡ç†çš„æ•ˆç‡ã€‚</p>
<p>Clustered Forward Rendering çš„æµç¨‹:</p>
<p>ç©ºé—´åˆ’åˆ†ï¼šå°†è§†é”¥ï¼ˆè§†å›¾ä½“ç§¯ï¼‰åˆ’åˆ†ä¸ºå¤šä¸ªé›†ç¾¤ï¼Œ
è¿™äº›é›†ç¾¤é€šå¸¸æ˜¯è§†é”¥å†…çš„å›ºå®šå¤§å°çš„ä½“ç§¯å•å…ƒï¼ˆå¦‚ç«‹æ–¹ä½“ï¼‰ã€‚</p>
<p>å…‰æºåˆ†é…ï¼šéå†æ‰€æœ‰å…‰æºï¼Œå¹¶å°†æ¯ä¸ªå…‰æºåˆ†é…åˆ°å…¶å½±å“çš„é›†ç¾¤ä¸­ã€‚
æ¯ä¸ªå…‰æºçš„å½±å“èŒƒå›´é€šè¿‡ç®€å•çš„å‡ ä½•è®¡ç®—ç¡®å®šï¼Œè¿™æ ·æ¯ä¸ªé›†ç¾¤åªä¼šå­˜å‚¨å½±å“å®ƒçš„å…‰æºåˆ—è¡¨ã€‚</p>
<p>æ¸²æŸ“é˜¶æ®µï¼šåœ¨æ¸²æŸ“æ¯ä¸ªåƒç´ æ—¶ï¼Œé¦–å…ˆç¡®å®šè¯¥åƒç´ æ‰€åœ¨çš„é›†ç¾¤ï¼Œ
ç„¶åä»…åº”ç”¨è¯¥é›†ç¾¤ä¸­çš„å…‰æºè¿›è¡Œå…‰ç…§è®¡ç®—ã€‚
è¿™å‡å°‘äº†æ¯ä¸ªåƒç´ éœ€è¦å¤„ç†çš„å…‰æºæ•°é‡ï¼Œæé«˜äº†æ¸²æŸ“æ•ˆç‡ã€‚</p>
<p>ä¼˜ç‚¹: å¤„ç†å¤§é‡å…‰æº, çµæ´», æ€§èƒ½ä¼˜åŒ–.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="using-bleeding-edge-bevy-bevy-main"><a class="header" href="#using-bleeding-edge-bevy-bevy-main">Using bleeding-edge Bevy (bevy main)</a></h1>
<p>Bevy development moves very fast, and there are often exciting new things that
are yet unreleased. This page will give you advice about using development
versions of bevy.</p>
<p>ä½¿ç”¨å¼€å‘åˆ†æ”¯çš„bevy.è¿™æ ·å¯ä»¥ä½“éªŒæœªå‘å¸ƒçš„æ–°å¥‡åŠŸèƒ½.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>If you are <em>not</em> using any 3rd-party plugins and just want to use the bevy
main development branch:</p>
<pre><code class="language-toml">[dependencies]
bevy = { git = "https://github.com/bevyengine/bevy" }
</code></pre>
<p>However, if you <em>are</em> working with external plugins, you should read the rest
of this page. You will likely need to do more to make everything compatible.</p>
<p>å¦‚æœä¸æƒ³ä½¿ç”¨ç¬¬ä¸‰æ–¹æ’ä»¶,ç›´æ¥åˆ¶å®šbevyçš„ç‰ˆæœ¬ä¸ºmainåˆ†æ”¯å³å¯;
å¦‚æœæƒ³è¦ä½¿ç”¨ç¬¬ä¸‰æ–¹æ’ä»¶,ä¸ºäº†å…¼å®¹æ€§,è¿˜æ˜¯éœ€è¦å°†ä¸‹æ–‡çœ‹å®Œ.</p>
<h2 id="should-you-use-bleeding-edge-bevy-what-version-of-bevy-should-you-use"><a class="header" href="#should-you-use-bleeding-edge-bevy-what-version-of-bevy-should-you-use">Should you use bleeding-edge Bevy? What version of Bevy should you use?</a></h2>
<p>Bevy follows a "train release" model, with loose deadlines. Every 3 months,
a new major release is prepared, which will contain all new developments
(features, fixes, etc.) since the last release. The release date is not
strict and is often delayed by a few weeks to tie up loose ends.</p>
<p>Further, Bevy usually follows up every major release with a patch release
or two, as needed, to fix any bugs discovered soon after release. It will
not contain all fixes, just small non-breaking things that are considered
critical enough.</p>
<p>Most Bevy projects should use the latest release on crates.io. If you want
to play it safe, you can wait until the first patch release (<code>0.*.1</code>),
before upgrading to a new major version. You might also want to wait for
any 3rd-party plugins you are using to support the new Bevy version.</p>
<p>On the other hand, for experimentation and for Bevy development, you are
encouraged to try the latest in-development code from git! The latest
release is often missing the freshest bug fixes, usability improvements,
and features. It may be compelling to join in on the action!</p>
<p>If you are new to Bevy, this might not be for you. You will be more
comfortable using the released version. It will have the best compatibility
with community plugins and documentation.</p>
<p>The in-development version of Bevy has frequent breaking changes. Therefore,
it can be very annoying to use for real projects. Also, 3rd-party plugin
authors often don't bother to stay compatible. You will face breakage often
and probably have to fix it yourself.</p>
<p>It is only recommended to do this for more experimental or toy projects.</p>
<p>Though, there are ways you can manage the breakage and make it less of a
problem. Thanks to cargo, you can update bevy at your convenience, whenever you
feel ready to handle any possible breaking changes.</p>
<p>You may want to consider forking the repositories of Bevy and any plugins you
use. Using your own forks allows you to easily apply fixes if needed, or edit
their <code>Cargo.toml</code> for any special configuration to make your project work.</p>
<p>If you choose to use Bevy main, you are highly encouraged to interact with
the Bevy community on <a href="https://discord.gg/bevy">Discord</a> and <a href="https://github.com/bevyengine/bevy">GitHub</a>, so
you can keep track of what's going on, get help, or participate in discussions.</p>
<p>bevyé‡‡ç”¨<code>ç«è½¦å‘å¸ƒ</code>æ¨¡å¼,æœŸé™å¾ˆçŸ­.æ¯3ä¸ªæœˆå°±å‘å¸ƒä¸€ä¸ªä¸»ç‰ˆæœ¬,é€šå¸¸ä¼šå»¶æ—¶å‡ å‘¨å‘å¸ƒ,
ç”¨ä»¥è§£å†³å‘å¸ƒé—®é¢˜.æ¯ä¸ªç‰ˆæœ¬ä¹Ÿä¸æ˜¯é•¿æœŸæ”¯æŒ,åŸºæœ¬ä¼šæœ‰ä¸¤ä¸ªä¿®å¤ç‰ˆæœ¬å‡ºæ¥,
å°±ç®—æ˜¯ä¿®å¤ä¹Ÿåªä¼šä¿®å¤é‡è¦ä¸”éç ´åæ€§çš„å†…å®¹.
å¤§éƒ¨åˆ†ä½¿ç”¨bevyçš„é¡¹ç›®éƒ½æ˜¯ä½¿ç”¨æœ€æ–°çš„ä¸»ç‰ˆæœ¬.å¦‚æœè¿½æ±‚ç¨³å®šæ€§,å¯ä»¥è€ƒè™‘ä½¿ç”¨ä¿®å¤ç‰ˆæœ¬.
eg:v0.13.2.è¿˜å¯èƒ½éœ€è¦ç­‰ä½¿ç”¨çš„æ’ä»¶ä¹ŸåŒæ­¥æ”¯æŒåˆ°bevyçš„ç‰ˆæœ¬.</p>
<p>é€šå¸¸ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬æ˜¯æœ€å¥½çš„,å› ä¸ºbugä¿®å¤,æ–°å¢åŠŸèƒ½éƒ½æ˜¯æœ€èšç„¦çš„.
å¯¹äºæ–°æ‰‹æ¥è¯´å¹¶ä¸æ˜¯å¦‚æ­¤,é€‰ä¸€ä¸ªç¨³å®šçš„ç‰ˆæœ¬,èƒ½ä½¿ç”¨å¤§å¤šæ•°æ’ä»¶,è¿™å¯èƒ½æ›´é‡è¦ä¸€äº›.
æœ€æ–°çš„mainåˆ†æ”¯è¿˜å¯èƒ½æœ‰ç ´åæ€§å˜æ›´,è¿™ç‚¹æ˜¯æœ€çƒ¦äººçš„,
å¦å¤–ç¬¬ä¸‰æ–¹æ’ä»¶å¦‚æœä¸åŠæ—¶æ›´æ–°ä¿æŒå…¼å®¹æ€§,ä¹Ÿæ˜¯éå¸¸çƒ¦äººçš„,è¿™å°±æ˜¯bevyç”Ÿæ€è¿˜å¾ˆæ¬ ç¼ºçš„ç”±æ¥.
å½“ç„¶æœ€ç»ˆè¿˜æ˜¯å¯ä»¥è‡ªå·±ä»æ’ä»¶åˆ†æ”¯æ‹‰ä»£ç ,è‡ªå·±æ¥ä¿®å¤,ä½†è¿™æ¡è·¯æ˜¯æ‰˜åº•æ“ä½œ.</p>
<h2 id="common-pitfall-mysterious-compile-errors"><a class="header" href="#common-pitfall-mysterious-compile-errors">Common pitfall: mysterious compile errors</a></h2>
<p>When changing between different versions of Bevy (say, transitioning an existing
project from the released version to the git version), you might get lots of
strange unexpected build errors.</p>
<p>You can typically fix them by removing <code>Cargo.lock</code> and the <code>target</code> directory:</p>
<pre><code class="language-sh">rm -rf Cargo.lock target
</code></pre>
<p>See <a href="setup//pitfalls/build-errors.html">this page</a> for more info.</p>
<p>If you are still getting errors, it is probably because cargo is trying
to use multiple different versions of bevy in your dependency tree
simultaneously. This can happen if some of the plugins you use have specified
a different Bevy version/commit from your project.</p>
<p>If you are using any 3rd-party plugins, please consider forking them, so you can
edit their <code>Cargo.toml</code> and have control over how everything is configured.</p>
<p>ä½¿ç”¨mainåˆ†æ”¯,å¸¸è§çš„ç¼–è¯‘é”™è¯¯æ˜¯ç¼–è¯‘å‡ºç°é—®é¢˜,æ­¤æ—¶åˆ é™¤Cargo.tomlå’Œtargetç›®å½•,
å¦‚æœè¿˜ä¸è¡Œ,å¯èƒ½å°±æ˜¯æ’ä»¶ä½¿ç”¨äº†å…·ä½“çš„bevyç‰ˆæœ¬,
æ€»ä¹‹,ä½¿ç”¨bevyçš„mainåˆ†æ”¯æ—¶,æ¨èforkæ’ä»¶,å¹¶å˜æ›´æ’ä»¶ä»¥æ¥çš„bevyç‰ˆæœ¬.æœ‰ç‚¹å¤æ‚.</p>
<h2 id="cargo-patches"><a class="header" href="#cargo-patches">Cargo Patches</a></h2>
<p>In some cases, you might be able to use "cargo patches" to locally override
dependencies. For example, you might be able to point plugins to use your
fork of bevy, without forking and editing the plugin's <code>Cargo.toml</code>, by
doing something like this:</p>
<pre><code class="language-toml"># replace the bevy git URL source with ours
[patch."https://github.com/bevyengine/bevy"]
# if we have our own fork
bevy = { git = "https://github.com/me/bevy" }
# if we want to use a local path
bevy = { path = "../bevy" }
# some plugins might depend on individual bevy crates,
# instead of all of bevy, which means we need to patch
# every individual bevy crate specifically:
bevy_ecs = { path = "../bevy/crates/bevy_ecs" }
bevy_app = { path = "../bevy/crates/bevy_app" }
# ...

# replace released versions of crates (crates.io source) with ours
[patch.crates-io]
bevy_some_plugin = { git = "https://github.com/me/bevy_some_plugin", branch = "bevy_main" }
# also replace bevy itself
bevy = { path = "../bevy" }
# ...
</code></pre>
<p>ä¹Ÿå¯ä»¥å…ˆforkæ’ä»¶,å†é€šè¿‡cargo patchæ‰“è¡¥ä¸çš„æ–¹å¼æ¥å¼•ç”¨bevy.</p>
<h2 id="updating-bevy"><a class="header" href="#updating-bevy">Updating Bevy</a></h2>
<p>It is recommended that you specify a known-good Bevy commit in your
<code>Cargo.toml</code>, so that you can be sure that you only update it when you
actually want to do so, avoiding unwanted breakage.</p>
<pre><code class="language-toml">bevy = { git = "https://github.com/bevyengine/bevy", rev = "7a1bd34e" }
</code></pre>
<p>When you change anything, be sure to run:</p>
<pre><code class="language-sh">cargo update
</code></pre>
<p>(or delete <code>Cargo.lock</code>)</p>
<p>Otherwise you risk errors from cargo not resolving dependencies correctly.</p>
<p>ä½¿ç”¨mainåˆ†æ”¯,æœ€å¥½æ˜¯åˆ¶å®šgitæäº¤å·,å›ºå®šç‰ˆæœ¬æ‰æ˜¯æœ€æ˜ç¡®çš„.</p>
<h2 id="advice-for-plugin-authors"><a class="header" href="#advice-for-plugin-authors">Advice for plugin authors</a></h2>
<p>If you are publishing a plugin crate, here are some recommendations:</p>
<ul>
<li>Use the main branch in your repository for targeting the released version of Bevy</li>
<li>Have a separate branch in your repository, to keep support for bevy main
separate from your version for the released version of bevy</li>
<li>Put information in your README to tell people how to find it</li>
<li>Set up CI to notify you if your plugin is broken by new changes in bevy</li>
</ul>
<p>Feel free to follow all the advice from this page, including cargo patches
as needed. Cargo patches only apply when you build your project directly,
not as a dependency, so they do not affect your users and can be safely kept
in your <code>Cargo.toml</code>.</p>
<p>å¯¹äºæ’ä»¶ä½œè€…,æœ‰ä»¥ä¸‹å»ºè®®:</p>
<ul>
<li>ä½¿ç”¨bevyçš„mainåˆ†æ”¯</li>
<li>æ’ä»¶ä»“åº“æœ€å¥½æœ‰ä¸ªå•ç‹¬çš„åˆ†æ”¯æ¥æ”¯æŒbevyçš„mainåˆ†æ”¯</li>
<li>åœ¨READMEä¸­æ·»åŠ æè¿°ä¿¡æ¯,è®©åˆ«äººèƒ½å¾ˆå¥½æ‰¾åˆ°è¿™ä¸ªä¿¡æ¯</li>
<li>é€šè¿‡CIæ¥æé†’å¤±è´¥</li>
</ul>
<h3 id="ci-setup"><a class="header" href="#ci-setup">CI Setup</a></h3>
<p>Here is an example for GitHub Actions. This will run at 8:00 AM (UTC) every day
to verify that your code still compiles. GitHub will notify you when it fails.</p>
<pre><code class="language-yaml">name: check if code still compiles

on:
  schedule:
    - cron: '0 8 * * *'

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'my-bevy-main-support-branch'

      - name: Install Dependencies
        run: sudo apt-get update &amp;&amp; sudo apt-get install g++ pkg-config libx11-dev libasound2-dev libudev-dev

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Check code
        run: cargo update &amp;&amp; cargo check --lib --examples
</code></pre>
<p>æ­¤å¤„æ˜¯github action æ¯å¤©æ—©æ—©ç‚¹è¿›è¡Œç¼–è¯‘çš„ä¾‹å­.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h1>
<p>This chapter covers some common issues or surprises that you might be
likely to encounter when working with Bevy, with specific advice about how
to address them.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="strange-build-errors"><a class="header" href="#strange-build-errors">Strange Build Errors</a></h1>
<p>Sometimes, you can get strange and confusing build errors when trying to
compile your project.</p>
<p>ç¼–è¯‘å‡ºç°å¥‡æ€ªçš„é”™è¯¯,å¯æŒ‰ä»¥ä¸‹æ–¹å¼å°è¯•è§£å†³.</p>
<h2 id="update-your-rust"><a class="header" href="#update-your-rust">Update your Rust</a></h2>
<p>First, make sure your Rust is up-to-date. Bevy only supports the latest
stable version of Rust, or nightly.</p>
<p>If you are using <a href="https://rustup.rs"><code>rustup</code></a> to manage your Rust installation, you
can run:</p>
<pre><code class="language-shell">rustup update
</code></pre>
<p>æ›´æ–°rustç‰ˆæœ¬,å› ä¸ºbevyåªæ”¯æŒæœ€æ–°rustç‰ˆæœ¬.</p>
<h2 id="clear-the-cargo-state"><a class="header" href="#clear-the-cargo-state">Clear the cargo state</a></h2>
<p>Many kinds of build errors can often be fixed by forcing <code>cargo</code> to regenerate
its internal state (recompute dependencies, etc.). You can do this by deleting
the <code>Cargo.lock</code> file and the <code>target</code> directory.</p>
<pre><code class="language-shell">rm -rf target Cargo.lock
</code></pre>
<p>Try building your project again after doing this. It is likely that the
mysterious errors will go away.</p>
<p>If not, another reason might be that you have multiple versions of Bevy if
your dependency tree. If you are using 3rd-party plugins, make sure you have
specified the correct versions of all the plugins you use and that they are
compatible with the Bevy version you are using.</p>
<p>If none of this helps you, your issue might require further
investigation. Reach out to the Bevy community via GitHub or
<a href="https://discord.gg/bevy">Discord</a>, and ask for help.</p>
<p>If you are using bleeding-edge Bevy ("main"), and the above does not solve
the problem, your errors might be caused by 3rd-party plugins. See <a href="pitfalls/../setup/bevy-git.html#how-to-use-bleeding-edge-bevy">this
page</a> for solutions.</p>
<h2 id="new-cargo-resolver"><a class="header" href="#new-cargo-resolver">New Cargo Resolver</a></h2>
<p>Cargo recently added a new dependency resolver algorithm, that is incompatible
with the old one. Bevy <em>requires</em> the new resolver.</p>
<p>If you are just creating a new blank Cargo project, don't worry. This should
already be setup correctly by <code>cargo new</code>.</p>
<p>If you are getting weird compiler errors from Bevy dependencies, read on. Make sure
you have the correct configuration, and then <a href="pitfalls//pitfalls/build-errors.html#clear-the-cargo-state">clear the cargo state</a>.</p>
<h3 id="single-crate-projects"><a class="header" href="#single-crate-projects">Single-Crate Projects</a></h3>
<p>In a single-crate project (if you only have one <code>Cargo.toml</code> file in your project),
if you are using the latest Rust2021 Edition, the new resolver is automatically
enabled.</p>
<p>So, you need either one of these settings in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
edition = "2021"
</code></pre>
<p>or</p>
<pre><code class="language-toml">[package]
resolver = "2"
</code></pre>
<h3 id="multi-crate-workspaces"><a class="header" href="#multi-crate-workspaces">Multi-Crate Workspaces</a></h3>
<p>In a multi-crate Cargo workspace, the resolver is a global setting for the
whole workspace. It will <em>not</em> be enabled by default.</p>
<p>This can bite you if you are transitioning a single-crate project into a workspace.</p>
<p>You <em>must</em> add it manually to the top-level <code>Cargo.toml</code> for your Cargo Workspace:</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
</code></pre>
<p>å¾ˆå¤šç¼–è¯‘é”™è¯¯éƒ½æ˜¯å› ä¸ºcargoå†…éƒ¨çŠ¶æ€å¯¼è‡´çš„,æ¸…ç†ä¹‹åé‡æ–°ç”Ÿæˆå¯è§£å†³å¤§éƒ¨åˆ†é—®é¢˜.
<code>rm -rf target Cargo.lock</code> ä¹‹åé‡æ–°ç¼–è¯‘å³å¯.
å¦‚æœè¿™æ­¥è¿˜ä¸è¡Œ,å°±éœ€è¦æ’é™¤å¤šbevyç‰ˆæœ¬çš„é—®é¢˜,ç‰¹åˆ«æ˜¯ä½¿ç”¨ç¬¬ä¸‰æ–¹æ’ä»¶æ—¶,
éœ€è¦æ³¨æ„å¤šbevyç‰ˆæœ¬çš„é—®é¢˜.</p>
<p>å¦‚æœåˆ°è¿™æ­¥è¿˜ä¸èƒ½è§£å†³é—®é¢˜,éœ€è¦åˆ°ç¤¾åŒºå¯»æ‰¾æ–¹æ³•.</p>
<hr />
<p>æ–°çš„cargoè§£æå™¨</p>
<p>Cargo æœ€è¿‘æ·»åŠ äº†ä¸€ç§æ–°çš„ä¾èµ–è§£æå™¨ç®—æ³•ï¼Œè¯¥ç®—æ³•ä¸æ—§ç®—æ³•ä¸å…¼å®¹ã€‚ Bevy éœ€è¦æ–°çš„è§£æå™¨ã€‚
å¦‚æœè¦æ–°å»ºé¡¹ç›®,ä½¿ç”¨cargo new, è¿™æ ·å°±å¯ç”¨äº†æ–°çš„è§£æç®—æ³•.</p>
<p>å¦‚æœé¡¹ç›®æ˜¯å•åŒ…é¡¹ç›®(é¡¹ç›®ä¸­åªæœ‰ä¸€ä¸ªCargo.toml),ä¸‹é¢ä¸¤ä¸ªè®¾ç½®éƒ½ä¼šè‡ªåŠ¨ä½¿ç”¨æ–°çš„è§£æç®—æ³•:</p>
<pre><code class="language-toml">[package]
edition = "2021"

# æˆ–æ˜¯,äºŒé€‰ä¸€å³å¯.
[package]
resolver = "2"
</code></pre>
<p>å¦‚æœé¡¹ç›®æ˜¯å¤šåŒ…é¡¹ç›®å·¥ä½œç©ºé—´,åœ¨workspaceçš„é¡¶çº§Cargo.tomlä¸­è¦æ·»åŠ :</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<h2 id="unoptimized-debug-builds"><a class="header" href="#unoptimized-debug-builds">Unoptimized debug builds</a></h2>
<p>You can partially enable compiler optimizations in debug/dev mode!</p>
<p>You can enable higher optimizations for dependencies (incl. Bevy), but not
your own code, to keep recompilations fast!</p>
<p>In <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml"># Enable max optimizations for dependencies, but not for our code:
[profile.dev.package."*"]
opt-level = 3
</code></pre>
<p>The above is enough to make Bevy run fast. It will only slow down clean
builds, without affecting recompilation times for your project.</p>
<p>If your own code does CPU-intensive work, you might want to also enable some
optimization for it.</p>
<pre><code class="language-toml"># Enable only a small amount of optimization in debug mode
[profile.dev]
opt-level = 1
</code></pre>
<p><strong>Warning!</strong> If you are using a debugger (like <code>gdb</code> or <code>lldb</code>) to step through
your code, any amount of compiler optimization can mess with the experience.
Your breakpoints might be skipped, and the code flow might jump around in
unexpected ways. If you want to debug / step through your code, you might want
<code>opt-level = 0</code>.</p>
<p>åœ¨è°ƒè¯•æ¨¡å¼å’Œå¼€å‘æ¨¡å¼,å¯éƒ¨åˆ†å¯ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–.å¸¸ç”¨çš„æ˜¯å¯¹ä¾èµ–è¿›è¡Œæœ€é«˜ä¼˜åŒ–,
å¯¹è‡ªå·±çš„ä»£ç é€»è¾‘ä¸è¿›è¡Œä¼˜åŒ–,æ–¹ä¾¿è°ƒè¯•.åœ¨Cargo.tomlä¸­å¯ç”¨ä¸‹é¢é…ç½®,
æˆ–æ˜¯åœ¨.cargo/config.tomlä¸­è¿›è¡Œå…¨å±€å¯ç”¨.</p>
<pre><code class="language-toml"># Enable max optimizations for dependencies, but not for our code:
[profile.dev.package."*"]
opt-level = 3
</code></pre>
<p>å¦‚æœä»£ç æ˜¯cpuå¯†é›†å‹,è¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–.(å“ªä¸ªæ¸¸æˆé€»è¾‘ä¸æ˜¯CPUå¯†é›†å‹å‘¢?)</p>
<pre><code class="language-toml"># Enable only a small amount of optimization in debug mode
[profile.dev]
opt-level = 1
</code></pre>
<p>ä¸Šé¢çš„ä¼˜åŒ–åœ¨ä½¿ç”¨gdb/lldbçš„åœºæ™¯ä¸‹<code>ä¸é€‚ç”¨</code>. åœ¨gdb/lldbè¦æƒ³æ–­ç‚¹ä¸ä¹±,
éœ€è¦æ˜¯å“¦é‚£ä¸ª<code>opt-level = 0</code>.</p>
<h3 id="why-is-this-necessary"><a class="header" href="#why-is-this-necessary">Why is this necessary?</a></h3>
<p>Rust without compiler optimizations is <em>very slow</em>. With Bevy in
particular, the default cargo build debug settings will lead to <em>awful</em> runtime
performance. Assets are slow to load and FPS is low.</p>
<p>Common symptoms:</p>
<ul>
<li>Loading high-res 3D models with a lot of large textures, from GLTF
files, can take minutes! This can trick you into thinking
that your code is not working, because you will not see anything on
the screen until it is ready.</li>
<li>After spawning even a few 2D sprites or 3D models, framerate may drop
to unplayable levels.</li>
</ul>
<p>ä¼—æ‰€å‘¨çŸ¥,æ²¡æœ‰ç¼–è¯‘å™¨ä¼˜åŒ–çš„rustç¨‹åºéå¸¸æ…¢,åœ¨bevyä¸­,rustçš„é»˜è®¤ç¼–è¯‘é…ç½®å¤ªæ…¢.</p>
<ul>
<li>ä»gltfæ–‡ä»¶ä¸­åŠ è½½å¤§é‡çº¹ç†çš„3dæ¨¡å‹,è¦å‡ åˆ†é’Ÿ.</li>
<li>åœ¨ç”Ÿæˆå‡ ä¸ª2d/3dç²¾çµå,å¸§ç‡ä¼šæ€¥é€Ÿä¸‹é™.</li>
</ul>
<h3 id="why-not-use---release"><a class="header" href="#why-not-use---release">Why not use <code>--release</code>?</a></h3>
<p>You may have heard the advice: just run with <code>--release</code>! However, this is
bad advice. Don't do it.</p>
<p>Release mode also disables "debug assertions": extra checks useful during
development. Many libraries also include additional stuff under that
setting. In Bevy and WGPU that includes validation for shaders and GPU API
usage. Release mode disables these checks, causing less-informative crashes,
issues with hot-reloading, or potentially buggy/invalid logic going unnoticed.</p>
<p>Release mode also makes incremental recompilation slow. That negates
Bevy's fast compile times, and can be very annoying while you develop.</p>
<p>æ—¢ç„¶è°ƒè¯•æ¨¡å¼ä¸‹æ€§èƒ½å·®,ä¸ºå•¥ä¸ç›´æ¥ä½¿ç”¨releaseç‰ˆæœ¬? ç­”æ¡ˆæ˜¯ä¸å»ºè®®è¿™ä¹ˆåš.
å› ä¸ºrustçš„åŸå› ,å‘å¸ƒç‰ˆæ˜¯å‡å°‘å¾ˆå¤šæ£€æŸ¥ä¸ºä»£ä»·çš„,å‰ç½®çš„debugæ£€æŸ¥éƒ½ä¼šè¢«å¿½ç•¥,
å¯èƒ½ä¼šå¯¼è‡´panic/çƒ­åŠ è½½å¼‚å¸¸/é”™è¯¯é€»è¾‘/æ— æ•ˆé€»è¾‘.
è¿™ä¹ˆçœ‹æ¥,releaseæ¨¡å¼å¹¶ä¸æ˜¯è¦†ç›–debugæ¨¡å¼çš„,è€Œæ˜¯debugä¸¥æ ¼æ£€æŸ¥æ¨¡å¼æ’é›·,
releaseæ¨¡å¼ä¸¢å¼ƒæ£€æŸ¥æ¥æ¢å–é«˜æ€§èƒ½.</p>
<p>å†è€…,releaseçš„ç¼–è¯‘æ˜¯å…¨é‡ç¼–è¯‘,ä¸€èˆ¬çš„bevyé¡¹ç›®ä¹Ÿè¦èŠ±å¾ˆé•¿æ—¶é—´,è¿™ä¸ªä»£ä»·ä¹Ÿå¾ˆå¤§.</p>
<hr />
<p>With the advice at the top of this page, you don't need to build with
<code>--release</code>, just to test your game with adequate performance. You can use
it for <em>actual</em> release builds that you send to your users.</p>
<p>If you want, you can also enable LTO (Link-Time-Optimization) for the actual
release builds, to squeeze out even more performance at the cost of very
slow compile times.</p>
<p>Here is a configuration for the most aggressive optimizations possible:</p>
<pre><code class="language-toml">[profile.release]
lto = true
opt-level = 3
codegen-units = 1
incremental = false
debug = false
</code></pre>
<p>å½“ç„¶,releaseç‰ˆæœ¬ä¸‹è¿˜å¯ä»¥ä½¿ç”¨LTO(é“¾æ¥æ—¶é—´ä¼˜åŒ–)æ¥åŠ å¿«releaseçš„æ„å»º.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="obscure-rust-compiler-errors"><a class="header" href="#obscure-rust-compiler-errors">Obscure Rust compiler errors</a></h1>
<p>You can get scary-looking compiler errors when you try to add <a href="pitfalls//programming/systems.html">systems</a>
to your Bevy <a href="pitfalls//programming/app-builder.html">app</a>.</p>
<p>å‘appæ·»åŠ systemå¯èƒ½é‡åˆ°ä»¥ä¸‹é”™è¯¯.</p>
<h2 id="common-beginner-mistakes"><a class="header" href="#common-beginner-mistakes">Common beginner mistakes</a></h2>
<ul>
<li>Using <code>commands: &amp;mut Commands</code> instead of <code>mut commands: Commands</code>.</li>
<li>Using <code>Query&lt;MyStuff&gt;</code> instead of <code>Query&lt;&amp;MyStuff&gt;</code> or <code>Query&lt;&amp;mut MyStuff&gt;</code>.</li>
<li>Using <code>Query&lt;&amp;ComponentA, &amp;ComponentB&gt;</code> instead of <code>Query&lt;(&amp;ComponentA, &amp;ComponentB)&gt;</code>
(forgetting the tuple)</li>
<li>Using your <a href="pitfalls//programming/res.html">resource</a> types directly without <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res</code></a> or <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>.</li>
<li>Using your <a href="pitfalls//programming/ec.html#components">component</a> types directly without putting them in a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Query.html"><code>Query</code></a>.</li>
<li>Using a <a href="pitfalls//programming/bundle.html">bundle</a> type in a <a href="pitfalls//programming/queries.html">query</a>. You want individual components.</li>
<li>Using other arbitrary types in your function.</li>
</ul>
<p>Note that <code>Query&lt;Entity&gt;</code> is correct, because the Entity ID is special;
it is not a component.</p>
<p>æ–°æ‰‹å¸¸è§é”™è¯¯ä¸»è¦åœ¨systemå‚æ•°ä¸Š:</p>
<ul>
<li>é”™å°†<code>mut commands: Commands</code> å†™æˆ<code>commands: &amp;mut Commands</code>, mutæ˜¯ä¿®é¥°å˜é‡çš„,è€Œä¸æ˜¯ä¿®é¥°ç±»å‹çš„</li>
<li>é”™å†™ä¸º<code>Query&lt;MyStuff&gt;</code>, åº”è¯¥ç”¨å¼•ç”¨æˆ–å¯å˜å¼•ç”¨,ä¸ç„¶æŸ¥ä¸€æ¬¡å°±å˜æ›´äº†æ‰€æœ‰æƒ,ä¸‹ä¸€æ¬¡æŸ¥å°±ä¼šå‡ºé”™</li>
<li>é”™å†™ä¸º<code>Query&lt;&amp;A,&amp;B&gt;</code>, åº”è¯¥å†™ä¸º(&amp;A,&amp;B),ä½œä¸ºå…ƒç»„æ¥è¿‡æ»¤å®ä½“</li>
<li>èµ„æºéœ€è¦ä½¿ç”¨Res/ResMutæ¥è®¿é—®</li>
<li>ç»„ä»¶éœ€è¦é€šè¿‡Queryå°è£…æ¥è®¿é—®å®ä½“</li>
<li>Queryä¸­ä¸èƒ½ä½¿ç”¨Bundle,Bundleåªèƒ½åœ¨å®ä½“æ„é€ çš„é€»è¾‘ä¸­ä½¿ç”¨</li>
<li>åœ¨systemå‡½æ•°ä¸­ä½¿ç”¨å…¶ä»–ä»»æ„ç±»å‹(systemæ˜¯æ¸¸æˆé€»è¾‘,æ‰€æœ‰çš„æ•°æ®å‡è‡ªå‡½æ•°å…¥å‚)</li>
</ul>
<h2 id="error-adding-function-as-system"><a class="header" href="#error-adding-function-as-system">Error adding function as system</a></h2>
<p>The errors can look like this:</p>
<pre><code>error[E0277]: `for&lt;'a, 'b, 'c&gt; fn(â€¦) {my_system}` does not describe a valid system configuration
   --&gt; src/main.rs:11:30
    |
11  |         .add_systems(Update, my_system)
    |          -----------         ^^^^^^^^^ invalid system configuration
    |          |
    |          required by a bound introduced by this call
    |
    = help: the trait `IntoSystem&lt;(), (), _&gt;` is not implemented for fn item `for&lt;'a, 'b, 'c&gt; fn(â€¦) {my_system}`, which is required by `for&lt;'a, 'b, 'c&gt; fn(â€¦) {my_system}: IntoSystemConfigs&lt;_&gt;`
    = help: the following other types implement trait `IntoSystemConfigs&lt;Marker&gt;`:
              &lt;(S0, S1) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1)&gt;&gt;
              &lt;(S0, S1, S2) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2)&gt;&gt;
              &lt;(S0, S1, S2, S3) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5, S6) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5, P6)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5, S6, S7) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5, P6, P7)&gt;&gt;
              &lt;(S0, S1, S2, S3, S4, S5, S6, S7, S8) as IntoSystemConfigs&lt;(SystemConfigTupleMarker, P0, P1, P2, P3, P4, P5, P6, P7, P8)&gt;&gt;
            and 14 others
    = note: required for `for&lt;'a, 'b, 'c&gt; fn(â€¦) {my_system}` to implement `IntoSystemConfigs&lt;_&gt;`
note: required by a bound in `bevy::prelude::App::add_systems`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_app-0.14.0-rc.2/src/app.rs:287:23
    |
284 |     pub fn add_systems&lt;M&gt;(
    |            ----------- required by a bound in this associated function
...
287 |         systems: impl IntoSystemConfigs&lt;M&gt;,
    |                       ^^^^^^^^^^^^^^^^^^^^ required by this bound in `App::add_systems`
</code></pre>
<p>The error (confusingly) points to the place in your code where you try to add the system,
but in reality, the problem is actually in the <code>fn</code> function definition!</p>
<p>This is caused by your function having invalid parameters. <a href="pitfalls//builtins.html#systemparams">Bevy can
only accept special types as system parameters!</a></p>
<p>ä¸Šé¢çš„é”™è¯¯æ„æ€æ˜¯systemå‡½æ•°æœ‰æ— æ•ˆå‚æ•°.</p>
<h2 id="error-on-malformed-queries"><a class="header" href="#error-on-malformed-queries">Error on malformed queries</a></h2>
<p>You might also errors that look like this:</p>
<pre><code>error[E0277]: `bevy::prelude::AnimationPlayer` is not valid to request as data in a `Query`
   --&gt; src/main.rs:60:18
    |
60  |     mut players: Query&lt;AnimationPlayer, &amp;Transform&gt;,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid `Query` data
    |
    = help: the trait `QueryData` is not implemented for `bevy::prelude::AnimationPlayer`
    = help: the following other types implement trait `QueryData`:
              &amp;'__w mut T
              &amp;Archetype
              &amp;T
              ()
              (F0, F1)
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
            and 41 others
note: required by a bound in `bevy::prelude::Query`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.14.0-rc.2/src/system/query.rs:349:37
    |
349 | pub struct Query&lt;'world, 'state, D: QueryData, F: QueryFilter = ()&gt; {
    |                                     ^^^^^^^^^ required by this bound in `Query`

error[E0277]: `&amp;bevy::prelude::Transform` is not a valid `Query` filter
   --&gt; src/main.rs:60:18
    |
60  |     mut query: Query&lt;AnimationPlayer, &amp;Transform&gt;,
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid `Query` filter
    |
    = help: the trait `QueryFilter` is not implemented for `&amp;bevy::prelude::Transform`
    = note: a `QueryFilter` typically uses a combination of `With&lt;T&gt;` and `Without&lt;T&gt;` statements
    = help: the following other types implement trait `QueryFilter`:
              ()
              (F0, F1)
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
              (F0, F1, F2, F3, F4, F5)
              (F0, F1, F2, F3, F4, F5, F6)
              (F0, F1, F2, F3, F4, F5, F6, F7)
            and 28 others
note: required by a bound in `bevy::prelude::Query`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.14.0-rc.2/src/system/query.rs:349:51
    |
349 | pub struct Query&lt;'world, 'state, D: QueryData, F: QueryFilter = ()&gt; {
    |                                                   ^^^^^^^^^^^ required by this bound in `Query`

error[E0107]: struct takes at most 2 generic arguments but 3 generic arguments were supplied
   --&gt; src/main.rs:60:18
    |
60  |     mut query: Query&lt;AnimationPlayer, &amp;Transform, &amp;mut GlobalTransform&gt;,
    |                ^^^^^                              -------------------- help: remove this generic argument
    |                |
    |                expected at most 2 generic arguments
    |
note: struct defined here, with at most 2 generic parameters: `D`, `F`
   --&gt; /home/iyes/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.14.0-rc.2/src/system/query.rs:349:12
    |
349 | pub struct Query&lt;'world, 'state, D: QueryData, F: QueryFilter = ()&gt; {
    |            ^^^^^                 -             -------------------
</code></pre>
<p>To access your components, you need to use reference syntax (<code>&amp;</code> or <code>&amp;mut</code>).</p>
<p>When you want to query for multiple components, you need to put them in a tuple:
<code>Query&lt;(&amp;mut Transform, &amp;Camera, &amp;MyComponent)&gt;</code>.</p>
<p>è¿™ä¸ªå°±æ˜¯Queryé‡Œçš„å‚æ•°ä¸æ˜¯å¼•ç”¨ç±»å‹.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="3d-objects-not-displaying"><a class="header" href="#3d-objects-not-displaying">3D objects not displaying</a></h1>
<p>This page will list some common issues that you may encounter, if you are
trying to spawn a 3D object, but cannot see it on the screen.</p>
<p>3då¯¹è±¡æ²¡æœ‰åœ¨å±å¹•ä¸Šæ¸²æŸ“å‡ºæ¥,å¯èƒ½æ˜¯ä»¥ä¸‹é”™è¯¯.</p>
<h2 id="missing-visibility-components-on-parent"><a class="header" href="#missing-visibility-components-on-parent">Missing visibility components on parent</a></h2>
<p>If your entity is in a hierarchy, all its parents need to have
<a href="pitfalls//fundamentals/visibility.html">visibility</a> components. It is required even if those parent
entities are not supposed to render anything.</p>
<p>Fix it by inserting a <a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.entity(parent)
    .insert(VisibilityBundle::default());
<span class="boring">}</span></code></pre></pre>
<p>Or better, make sure to spawn the parent entities correctly in the first place.
You can use a <a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a> or
<a href="https://docs.rs/bevy/0.11.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> (with <a href="pitfalls//fundamentals/transforms.html">transforms</a>) if you
are not using a bundle that already includes these components.</p>
<p>å¦‚æœå®ä½“æ˜¯ç»§æ‰¿çš„,éœ€è¦æ£€æŸ¥çˆ¶è¾ˆçš„<code>å¯è§æ€§</code>,å³ä½¿çˆ¶è¾ˆå®ä½“ä¸éœ€è¦ä»»ä½•æ¸²æŸ“,ä¹Ÿéœ€è¦<code>å¯è§æ€§</code>ç»„ä»¶.
è§£å†³æ–¹æ³•æ˜¯1:ç»™çˆ¶è¾ˆå®ä½“æ·»åŠ <code>å¯è§æ€§</code>ç»„ä»¶;2:å°½é‡åœ¨çˆ¶è¾ˆå®ä½“æ„é€ æ—¶è®¾ç½®å¯è§æ€§.</p>
<p>å¯è§æ€§çš„ç»„ä»¶æœ‰ä¸¤ç§å†…ç½®çš„:SpatialBundle(ç©ºé—´Bundle)å’ŒVisibilityBundle(å¯è§æ€§Bundle).</p>
<h2 id="too-far-from-camera"><a class="header" href="#too-far-from-camera">Too far from camera</a></h2>
<p>If something is further away than a certain distance from the camera, it will be
culled (not rendered). The default value is <code>1000.0</code> units.</p>
<p>You can control this using the <code>far</code> field of
<a href="https://docs.rs/bevy/0.11.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.spawn(Camera3dBundle {
    projection: Projection::Perspective(PerspectiveProjection {
        far: 10000.0, // change the maximum render distance
        ..default()
    }),
    ..default()
});
<span class="boring">}</span></code></pre></pre>
<p>å¦‚æœç‰©ä½“ç¦»ç›¸æœºæœ‰1000ä¸ªå•ä½,åœ¨æ¸²æŸ“æ—¶ä¼šè¢«è¿‡æ»¤æ‰çš„,æ‰€ä»¥è¦æ¸²æŸ“å°±ä¸è¦é‡Œç›¸æœºå¤ªè¿œ.
å½“ç„¶ä¹Ÿå¯ä»¥å°†1000å•ä½æ”¹ä¸ºæ›´å¤§çš„æ•°å€¼.</p>
<h2 id="missing-vertex-attributes"><a class="header" href="#missing-vertex-attributes">Missing Vertex Attributes</a></h2>
<p>Make sure your <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> includes all vertex attributes required
by your shader/material.</p>
<p>Bevy's default PBR <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
requires <em>all</em> meshes to have:</p>
<ul>
<li>Positions</li>
<li>Normals</li>
</ul>
<p>Some others that may be required:</p>
<ul>
<li>UVs (if using textures in the material)</li>
<li>Tangents (only if using normal maps, otherwise not required)</li>
</ul>
<p>If you are generating your own mesh data, make sure to provide everything
you need.</p>
<p>If you are loading meshes from asset files, make sure they include everything
that is needed (check your export settings).</p>
<p>If you need Tangents for normal maps, it is recommended that you include them
in your GLTF files. This avoids Bevy having to autogenerate them at runtime.
Many 3D editors (like Blender) do not enable this option by default.</p>
<p>ç¡®ä¿ç€è‰²å™¨/æè´¨åŒ…å«çš„Meshæ‹¥æœ‰æ‰€éœ€è¦çš„é¡¶ç‚¹ä¿¡æ¯.</p>
<p>bevyçš„é»˜è®¤pbr(åŸºäºç‰©ç†çš„æ¸²æŸ“)æ˜¯æ ‡å‡†æè´¨StandardMaterial,åŒ…å«ä½ç½®å’Œæ³•çº¿.
å…¶ä»–æè´¨å¯èƒ½éœ€è¦UV(æè´¨ä½¿ç”¨çº¹ç†æ—¶æ‰éœ€è¦)å’Œåˆ‡çº¿(æ³•çº¿è´´å›¾æ—¶æ‰éœ€è¦).</p>
<p>å¦‚æœè‡ªå·±ç”Ÿæˆmeshæ—¶,ç¡®ä¿æä¾›æ‰€éœ€ä¿¡æ¯.å¦‚æœä»èµ„äº§æ–‡ä»¶ä¸­å¯¼å…¥meshæ—¶,
ç¡®ä¿å…¶æä¾›äº†æ‰€éœ€ä¿¡æ¯.</p>
<p>å°½é‡é¿å…è®©bevyåœ¨è¿è¡Œæ—¶è‡ªåŠ¨ç”Ÿæˆè¿™äº›ä¿¡æ¯,ä¸ç„¶æ€§èƒ½å°±æ‹‰ä½äº†.
å¾ˆå¤š3dæ¨¡å‹ç¼–è¾‘å™¨(eg:blender)æ˜¯é»˜è®¤ä¸å¯ç”¨è¿™äº›é€‰é¡¹çš„.</p>
<h2 id="incorrect-usage-of-bevy-gltf-assets"><a class="header" href="#incorrect-usage-of-bevy-gltf-assets">Incorrect usage of Bevy GLTF assets</a></h2>
<p>Refer to the <a href="pitfalls//3d/gltf.html">GLTF page</a> to learn how to correctly
use GLTF with Bevy.</p>
<p>GLTF files are complex. They contain many sub-assets, represented by
different Bevy types. Make sure you are using the correct thing.</p>
<p>Make sure you are spawning a GLTF Scene, or using the correct
<a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
associated with the correct GLTF Primitive.</p>
<p>If you are using an asset path, be sure to include a label for the sub-asset you want:</p>
<pre><code class="language-rust no_run noplayground">let handle_scene: Handle&lt;Scene&gt; = asset_server.load("my.gltf#Scene0");</code></pre>
<p>If you are spawning the top-level <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="pitfalls//3d/gltf.html#gltf-master-asset">master asset</a>, it won't work.</p>
<p>If you are spawning a GLTF Mesh, it won't work.</p>
<p>gltf 3dæ¨¡å‹æ–‡ä»¶éå¸¸å¤æ‚,åŒ…å«å„ç§bevyéœ€è¦çš„èµ„äº§,gltfåœºæ™¯éœ€è¦ä½¿ç”¨æ­£ç¡®çš„åŸè¯­æ¥ç”Ÿæˆ.
èµ„äº§ç”Ÿæˆå¥½äº†,åœ¨bevyä¸­å¼•ç”¨æ—¶,è·¯å¾„éœ€è¦æ³¨æ„.</p>
<p>ä¸èƒ½ç”Ÿæˆé¡¶çº§gltfä¸»èµ„äº§,ä¸èƒ½ç”Ÿæˆgltf mesh,è¿™äº›éƒ½ä¸èƒ½æ­£å¸¸å·¥ä½œ.</p>
<h2 id="unsupported-gltf"><a class="header" href="#unsupported-gltf">Unsupported GLTF</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this yet. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<p>bevyåªæ”¯æŒgltfçš„éƒ¨åˆ†åŠŸèƒ½,å¹¶ä¸æ˜¯æ‰€æœ‰çš„gltfæ–‡ä»¶éƒ½èƒ½åŠ è½½è¿›bevy.
åœ¨éƒ¨åˆ†åœºæ™¯ä¸‹,è¿˜å¾—ä¸åˆ°ä»»ä½•é”™è¯¯çš„è¯Šæ–­ä¿¡æ¯:</p>
<ul>
<li>gltfæ–‡ä»¶ä¸­,çº¹ç†ç»è¿‡äº†base64ç¼–ç ,è¿™ç§æ–‡ä»¶æ— æ³•åŠ è½½</li>
<li>mipè´´å›¾ä¹‹åœ¨ktx2/ddsçº¹ç†æ–‡ä»¶ä¸­æ”¯æŒ</li>
</ul>
<p>è¿™ä¸ªåˆ—è¡¨å¹¶ä¸å…¨,è¿˜æœ‰äº›é”™è¯¯æœªåŒ…å«è¿›æ¥.</p>
<h2 id="vertex-order-and-culling"><a class="header" href="#vertex-order-and-culling">Vertex Order and Culling</a></h2>
<p>By default, the Bevy renderer assumes Counter-Clockwise vertex order and has
back-face culling enabled.</p>
<p>If you are generating your <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> from code, make sure your
vertices are in the correct order.</p>
<p>é»˜è®¤æƒ…å†µä¸‹,bevyæ¸²æŸ“å‡è®¾é€†æ—¶é’ˆé¡¶ç‚¹é¡ºåº,èƒŒé¢å‰”é™¤.
å¦‚æœæ˜¯åœ¨ä»£ç ä¸­ç”Ÿæˆmesh,éœ€è¦ç¡®ä¿é¡¶ç‚¹çš„é¡ºåºæ˜¯æ­£ç¡®çš„.</p>
<h2 id="unoptimized--debug-builds"><a class="header" href="#unoptimized--debug-builds">Unoptimized / Debug builds</a></h2>
<p>Maybe your asset just takes a while to load? Bevy is very slow without
compiler optimizations. It's actually possible that complex GLTF files with
big textures can take over a minute to load and show up on the screen. It
would be almost instant in optimized builds. <a href="pitfalls//pitfalls/performance.html">See here</a>.</p>
<p>æœªä¼˜åŒ–çš„ä»£ç ,å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ¥åŠ è½½èµ„æº.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="borrow-multiple-fields-from-struct"><a class="header" href="#borrow-multiple-fields-from-struct">Borrow multiple fields from struct</a></h1>
<p>When you have a <a href="pitfalls//programming/ec.html#components">component</a> or <a href="pitfalls//programming/res.html">resource</a>, that is
larger struct with multiple fields, sometimes you want to borrow several of
the fields at the same time, possibly mutably.</p>
<pre><code class="language-rust no_run noplayground">struct MyThing {
    a: Foo,
    b: Bar,
}

fn my_system(mut q: Query&lt;&amp;mut MyThing&gt;) {
    for thing in q.iter_mut() {
        // åªæœ‰åœ¨è¿™é‡Œé‡æ–°å€Ÿç”¨,æ‰ä¸ä¼šå¼•ç”¨è§„åˆ™å†²çª(åŒæ—¶å‡ºç°å…±äº«å¼•ç”¨å’Œç‹¬å å¯å˜å¼•ç”¨).
        helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    }
}

// å¦‚æœè¿™ä¸¤ä¸ªå‚æ•°å¼•ç”¨åŒä¸€ä¸ªç»“æ„ä½“çš„å¤šå„å­—æ®µ,é‚£ä¹ˆä¼šå‡ºç°å†²çª
fn helper_func(foo: &amp;Foo, bar: &amp;mut Bar) {
    // do something
}</code></pre>
<p>This can result in a compiler error about conflicting borrows:</p>
<pre><code>error[E0502]: cannot borrow `thing` as mutable because it is also borrowed as immutable
    |
    |         helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    |         -----------  -----         ^^^^^ mutable borrow occurs here
    |         |            |
    |         |            immutable borrow occurs here
    |         immutable borrow later used by call
</code></pre>
<p>The solution is to use the "reborrow" idiom, a common but non-obvious trick in Rust programming:</p>
<pre><code class="language-rust no_run noplayground">// add this at the start of the for loop, before using `thing`:
let thing = &amp;mut *thing;

// or, alternatively, Bevy provides a method, which does the same:
let thing = thing.into_inner();</code></pre>
<p>Note that this line triggers <a href="pitfalls//programming/change-detection.html">change detection</a>. Even if
you don't modify the data afterwards, the component gets marked as changed.</p>
<p>é€šè¿‡é‡æ–°å¼•ç”¨æ¥ç»•å¼€<code>å˜æ›´æ£€æµ‹</code>,
é‡æ–°å¼•ç”¨æœ¬èº«å°±æ˜¯ä¸ºäº†åœ¨ä¸åŒçš„ä½œç”¨åŸŸå†…ä½¿ç”¨åŒä¸€ä¸ªå¯¹è±¡ï¼Œè€Œæ— éœ€æ”¾å¼ƒå½“å‰çš„å€Ÿç”¨ã€‚</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>Bevy typically gives you access to your data via special wrapper types (like
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, and <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.Mut.html"><code>Mut&lt;T&gt;</code></a> (when <a href="pitfalls//programming/queries.html">querying</a> for
components mutably)). This lets Bevy track access to the data.</p>
<p>These are "smart pointer" types that use the Rust <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>Deref</code></a> trait to dereference
to your data. They usually work seamlessly and you don't even notice them.</p>
<p>However, in a sense, they are opaque to the compiler. The Rust language allows
fields of a struct to be borrowed individually, when you have direct access to
the struct, but this does not work when it is wrapped in another type.</p>
<p>The "reborrow" trick shown above, effectively converts the wrapper into a
regular Rust reference. <code>*thing</code> dereferences the wrapper via <a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>, and
then <code>&amp;mut</code> borrows it mutably. You now have <code>&amp;mut MyStuff</code> instead of
<code>Mut&lt;MyStuff&gt;</code>.</p>
<p>bevyæ˜¯é€šè¿‡ä¸åŒçš„å°è£…ç±»å‹æ¥è®¿é—®ä¸åŒçš„æ•°æ®çš„.
è¿™äº›å°è£…ç±»å‹æœ‰ç‚¹å‘æ™ºèƒ½æŒ‡é’ˆ,ä¼šè‡ªåŠ¨è§£å¼•ç”¨.</p>
<p>ä¸Šé¢çš„é‡æ–°å¼•ç”¨å°±æ˜¯å°†å°è£…ç±»å‹è½¬æ¢æˆrustå¼•ç”¨ç±»å‹.
rustçš„æ˜¯å…è®¸ç»“æ„ä½“çš„å­—æ®µè¢«å•ç‹¬å¼•ç”¨çš„.bevyçš„å°è£…ç±»å‹ä½¿ç”¨æ—¶å°±éœ€è¦æ³¨æ„äº†.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-time-vs-rustos-time"><a class="header" href="#bevy-time-vs-rustos-time">Bevy Time vs. Rust/OS time</a></h1>
<p>Do <em>not</em> use <a href="https://doc.rust-lang.org/stable/std/time/struct.Instant.html"><code>std::time::Instant::now()</code></a> to get the
current time. <a href="pitfalls//fundamentals/time.html">Get your timing information from Bevy</a>, using
<a href="https://docs.rs/bevy/0.13.0/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a>.</p>
<p>Rust (and the OS) give you the precise time of the moment you call that
function. However, that's not what you want.</p>
<p>Your game systems are run by Bevy's parallel scheduler, which means that they
could be called at vastly different instants every frame! This will result in
inconsistent / jittery timings and make your game misbehave or look stuttery.</p>
<p>Bevy's <a href="https://docs.rs/bevy/0.13.0/bevy/time/struct.Time.html"><code>Time</code></a> gives you timing information that is consistent throughout the
frame update cycle. It is intended to be used for game logic.</p>
<p>This is not Bevy-specific, but applies to game development in general. Always
get your time from your game engine, not from your programming language or
operating system.</p>
<p>æŠ–åŠ¨æ—¶é—´,ä¸è¦ä½¿ç”¨æ ‡å‡†åº“æ¥è·å–å½“å‰æ—¶é—´,è€Œæ˜¯è¦ç”¨<code>Res&lt;Time&gt;</code>æ¥è·å–.</p>
<p>åœ¨æ¸¸æˆä¸­éœ€è¦ä½¿ç”¨æ¸¸æˆä¸­çš„æ—¶é—´,å› ä¸ºæ¸¸æˆå¯ä»¥æš‚åœ,å¯ä»¥å¿«æ”¾,å¯ä»¥æ…¢æ”¾.
ä½¿ç”¨rustæˆ–OSçš„æ—¶é—´éƒ½ä¼šå‡ºç°å¼‚å¸¸.</p>
<p>bevyè´Ÿè´£åœ¨ä¸åŒçš„æ—¶é—´è°ƒåº¦system,å¦‚æœä½¿ç”¨ébevyæ—¶é—´,ä¼šå¯¼è‡´æ¸¸æˆå¼‚å¸¸æˆ–å¡é¡¿.
bevyå†…ç½®çš„æ—¶é—´å°±æ˜¯ç”¨æ¥è§£å†³Updateä¸€è‡´æ€§é—®é¢˜çš„.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="uv-coordinates-in-bevy"><a class="header" href="#uv-coordinates-in-bevy">UV coordinates in Bevy</a></h1>
<p>In Bevy, the vertical axis for the pixels of textures / images, and when
sampling textures in a shader, points <em>downwards</em>, from top to bottom. The
origin is at the top left.</p>
<p>This is inconsistent with the <a href="pitfalls//fundamentals/coords.html">World-coordinate system used everywhere else
in Bevy</a>, where the Y axis points up.</p>
<p>It is, however, consistent with how most image file formats store pixel data,
and with how most graphics APIs work (including DirectX, Vulkan, Metal,
WebGPU, but <em>not</em> OpenGL).</p>
<p>OpenGL (and frameworks based on it) is different. If your prior experience
is with that, you may find that your textures appear flipped vertically.</p>
<hr />
<p>If you are using a mesh, make sure it has the correct UV values. If it was
created with other software, be sure to select the correct settings.</p>
<p>If you are writing a custom shader, make sure your UV arithmetic is correct.</p>
<p>3dä¸­çš„UVæ˜¯å°†2dçº¹ç†æ˜ å°„åˆ°3dæ¨¡å‹è¡¨é¢çš„ä¸€ç§æ–¹å¼,UVåæ ‡ç”¨äºå®šä½çº¹ç†åæ ‡,
å’Œ3dç©ºé—´çš„xyzå¯¹åº”.</p>
<p>åœ¨ Bevy ä¸­ï¼Œçº¹ç†/å›¾åƒåƒç´ çš„å‚ç›´è½´ä»¥åŠåœ¨ç€è‰²å™¨ä¸­é‡‡æ ·çº¹ç†æ—¶ï¼Œä»ä¸Šåˆ°ä¸‹å‘ä¸‹æŒ‡å‘ã€‚
åŸç‚¹ä½äºå·¦ä¸Šè§’ã€‚</p>
<p>å¤§éƒ¨åˆ†å›¾ç‰‡æ ¼å¼éƒ½æ˜¯ç¬¦åˆè¿™ç§è®¾è®¡çš„, åŒ…æ‹¬DirectX, Vulkan, Metal, WebGPU,
ä½†ä¸åŒ…æ‹¬OpenGL. OpenGLä¸­çœ‹èµ·æ¥æ˜¯å‚ç›´ç¿»è½¬çš„.</p>
<h2 id="sprites"><a class="header" href="#sprites">Sprites</a></h2>
<p>If the images of your 2D sprites are flipped (for whatever reason), you can
correct that using Bevy's sprite-flipping feature:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn(SpriteBundle {
    sprite: Sprite {
        flip_y: true,
        flip_x: false,
        ..Default::default()
    },
    ..Default::default()
});</code></pre>
<p>å¦‚æœ2dä¸­çš„ç²¾çµå›¾åƒçœ‹èµ·æ¥ç¿»è½¬äº†,å¯é€šè¿‡ä¸Šé¢çš„ä¾‹å­å¤„ç†ä¸€ä¸‹.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="game-engine-fundamentals"><a class="header" href="#game-engine-fundamentals">Game Engine Fundamentals</a></h1>
<p>This chapter covers the fundamentals of using Bevy as a game engine.</p>
<p>You are expected to be familiar with Bevy programming in general. For that,
see the <a href="/programming.html">Bevy Programming Framework</a> chapter.</p>
<p>The topics covered in this chapter are applicable to all projects that want
to use Bevy as more than just an ECS library. If you are making a game or
other app using Bevy, this is for you.</p>
<p>This chapter only covers the general fundamentals. Complex topics that
deserve more extensive coverage have their own chapters in the book:</p>
<ul>
<li><a href="/input.html">Input Handling</a></li>
<li><a href="/window.html">Window Management</a></li>
<li><a href="/assets.html">Asset Management</a></li>
<li><a href="/graphics.html">General Graphics Features</a></li>
<li><a href="/2d.html">2D Graphics</a></li>
<li><a href="/3d.html">3D Graphics</a></li>
<li><a href="/audio.html">Audio</a></li>
<li><a href="/ui.html">Bevy UI Framework</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h1>
<h2 id="2d-and-3d-scenes-and-cameras"><a class="header" href="#2d-and-3d-scenes-and-cameras">2D and 3D scenes and cameras</a></h2>
<p>Bevy uses a right-handed Y-up coordinate system for the game world. The
coordinate system is the same for 3D and 2D, for consistency.</p>
<p>It is easiest to explain in terms of 2D:</p>
<ul>
<li>The X axis goes from left to right (+X points right).</li>
<li>The Y axis goes from bottom to top (+Y points up).</li>
<li>The Z axis goes from far to near (+Z points towards you, out of the screen).</li>
<li>For 2D, the origin (X=0.0; Y=0.0) is at the <em>center of the screen</em> by default.</li>
</ul>
<p>When you are working with 2D sprites, you can put the background on Z=0.0, and
place other sprites at increasing positive Z coordinates to layer them on top.</p>
<p>In 3D, the axes are oriented the same way:</p>
<ul>
<li>Y points up</li>
<li>The forward direction is -Z</li>
</ul>
<p>This is a right-handed coordinate system. You can use the fingers of your right
hand to visualize the 3 axes: thumb=X, index=Y, middle=Z.</p>
<p>It is the same as Godot, Maya, and OpenGL. Compared to Unity, the Z axis
is inverted.</p>
<p><img src="fundamentals/../img/handedness.png" alt="Chart comparing coordinate system orientation in different game engines and 3D software" /></p>
<p>(graphic modifed and used with permission; original by <a href="https://twitter.com/FreyaHolmer">@FreyaHolmer</a>)</p>
<p>bevyä¸­çš„åæ ‡ç³»ç»Ÿå’Œä¸­å­¦æ•°å­¦çš„åæ ‡ç³»æ˜¯ä¸€è‡´çš„,
å¯¹äº2dæ¥è¯´,åŸç‚¹ä½äºå±å¹•ä¸­å¿ƒ,èƒŒæ™¯å›¾çš„zä¸ºä»–,å…¶ä»–ç²¾çµçš„zä¾æ¬¡å¢åŠ ,æ„å‘³ç€å‰åçš„å·®åˆ«.
å¯¹äº3dæ¥è¯´,xyzåˆ†åˆ«è¡¨ç¤º3å„è½´å‘,å‰è¿›æ–¹å‘ä¸º-z.</p>
<h2 id="ui"><a class="header" href="#ui">UI</a></h2>
<p>For UI, Bevy follows the same convention as most other UI toolkits, the Web, etc.</p>
<ul>
<li>The origin is at the top left corner of the screen</li>
<li>The Y axis points downwards</li>
<li>X goes from 0.0 (left screen edge) to the number of screen pixels (right screen edge)</li>
<li>Y goes from 0.0 (top screen edge) to the number of screen pixels (bottom screen edge)</li>
</ul>
<p>The units represent logical (compensated for DPI scaling) screen pixels.</p>
<p>UI layout flows from top to bottom, similar to a web page.</p>
<p>å¯¹äºUI,bevyéµå¾ªçš„è§„åˆ™å’Œå¤§å¤šæ•°UIå·¥å…·/webéµå¾ªçš„è§„åˆ™ä¸€è‡´.</p>
<ul>
<li>åŸç‚¹ä½äºå±å¹•å·¦ä¸Šè§’</li>
<li>yè½´æŒ‡å‘ä¸‹æ–¹</li>
<li>xè½´æ˜¯æ²¿ç€å±å¹•è¾¹ç¼˜ä»å·¦åˆ°å³,æœ€å¤§æ•°å€¼ä¸ºå±å¹•åƒç´ å€¼</li>
</ul>
<p>å•ä½æ˜¯é€»è¾‘åƒç´ å€¼, UIå¸ƒå±€æ˜¯ä»ä¸Šåˆ°ä¸‹,ç±»ä¼¼webé¡µé¢.</p>
<h2 id="cursor-and-screen"><a class="header" href="#cursor-and-screen">Cursor and Screen</a></h2>
<p>The cursor position and any other window (screen-space) coordinates follow the same
conventions as UI, as described above.</p>
<p>å…‰æ ‡å’Œå±å¹•çš„åæ ‡å’ŒUIçš„åæ ‡ä½“ç³»ä¿æŒä¸€è‡´.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/transform.rs"><code>transform</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/translation.rs"><code>translation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/2d/rotation.rs"><code>rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/3d_rotation.rs"><code>3d_rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/transforms/scale.rs"><code>scale</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/2d/move_sprite.rs"><code>move_sprite</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/3d/parenting.rs"><code>parenting</code></a>,
anything that spawns 2D or 3D objects.</p>
<hr />
<p>First, a quick definition, if you are new to game development:</p>
<p>A Transform is what allows you to place an object in the game world. It
is a combination of the object's "translation" (position/coordinates),
"rotation", and "scale" (size adjustment).</p>
<p>You move objects around by modifying the translation, rotate them by modifying
the rotation, and make them larger or smaller by modifying the scale.</p>
<pre><code class="language-rust no_run noplayground">// To simply position something at specific coordinates
let xf_pos567 = Transform::from_xyz(5.0, 6.0, 7.0);

// To scale an object, making it twice as big in all dimensions
let xf_scale = Transform::from_scale(Vec3::splat(2.0));

// To rotate an object in 2D (Z-axis rotation) by 30Â°
// (angles are in radians! must convert from degrees!)
let xf_rot2d = Transform::from_rotation(Quat::from_rotation_z((30.0_f32).to_radians()));

// 3D rotations can be complicated; explore the methods available on `Quat`

// Simple 3D rotation by Euler-angles (X, Y, Z)
let xf_rot2d = Transform::from_rotation(Quat::from_euler(
    // YXZ order corresponds to the common
    // "yaw"/"pitch"/"roll" convention
    EulerRot::YXZ,
    (20.0_f32).to_radians(),
    (10.0_f32).to_radians(),
    (30.0_f32).to_radians(),
));

// Everything:
let xf = Transform::from_xyz(1.0, 2.0, 3.0)
    .with_scale(Vec3::new(0.5, 0.5, 1.0))
    .with_rotation(Quat::from_rotation_y(0.125 * std::f32::consts::PI));</code></pre>
<p>å˜æ¢çš„å®šä¹‰æ˜¯:åœ¨æ¸¸æˆä¸–ç•Œä¸­,å°†ä¸€ä¸ªå¯¹è±¡å¦‚ä½•æ”¾ç½®.
å¥¹ç”±å¯¹è±¡çš„ä½ç½®/åæ ‡/æ—‹è½¬/ç¼©æ”¾çš„ä¸€ä¸ªç»„åˆ.</p>
<p>åœ¨è‹±æ–‡ä¸­,transformæ˜¯å˜æ¢,æ„ä¹‰æ›´å¹¿,æ¶µç›–äº†å¯¹ç‰©ä½“ä½ç½®ã€æ—‹è½¬å’Œç¼©æ”¾ç­‰å±æ€§çš„ç»¼åˆæ“ä½œã€‚
translationä¹Ÿæ˜¯å˜æ¢,ä½†æ›´å¤šçš„æ˜¯è¡¨ç¤ºå¹³ç§»(ä»…ä»…æ˜¯ä½ç½®ç§»åŠ¨),ä¸æ¶‰åŠæ—‹è½¬å’Œç¼©æ”¾.</p>
<h2 id="transform-components"><a class="header" href="#transform-components">Transform Components</a></h2>
<p>In Bevy, transforms are represented by <strong>two</strong> <a href="fundamentals//programming/ec.html#components">components</a>:
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>.</p>
<p>Any <a href="fundamentals//programming/ecs-intro.html">Entity</a> that represents an object in the game world
needs to have both. All of Bevy's <a href="fundamentals//builtins.html#bundles">built-in bundle types</a>
include them.</p>
<p>If you are creating a custom entity without using those <a href="fundamentals//programming/bundle.html">bundles</a>,
you can use one of the following to ensure you don't miss them:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> for transforms + <a href="fundamentals//fundamentals/visibility.html">visibility</a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a> for just the transforms</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn spawn_special_entity(
    mut commands: Commands,
) {
    // create an entity that does not use one of the common Bevy bundles,
    // but still needs transforms and visibility
    commands.spawn((
        ComponentA,
        ComponentB,
        SpatialBundle {
            transform: Transform::from_scale(Vec3::splat(3.0)),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}</code></pre>
<p>åœ¨bevyä¸­,å˜æ¢æœ‰ä¸¤ä¸ªåŸºç¡€ç»„ä»¶<code>Transform</code>å’Œ<code>GlobalTransform</code>,
ä¸¤è€…ç»„åˆè¿˜æœ‰ç©ºé—´Bunlde,å˜æ¢Bundle.</p>
<p>worldä¸­çš„ä»»ä½•å®ä½“éƒ½éœ€è¦è¿™ä¸¤ä¸ªåŸºç¡€ç»„ä»¶,å®ä½“æ„é€ æ—¶ä¸èƒ½ç¼º.</p>
<h3 id="transform"><a class="header" href="#transform"><code>Transform</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> is what you typically work with. It is a <code>struct</code> containing the
translation, rotation, and scale. To read or manipulate these values, access it
from your <a href="fundamentals//programming/systems.html">systems</a> using a <a href="fundamentals//programming/queries.html">query</a>.</p>
<p>If the entity has a <a href="fundamentals//fundamentals/hierarchy.html">parent</a>, the <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> component is
relative to the parent. This means that the child object will move/rotate/scale
along with the parent.</p>
<pre><code class="language-rust no_run noplayground">fn inflate_balloons(
    mut query: Query&lt;&amp;mut Transform, With&lt;Balloon&gt;&gt;,
    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    // every time the Spacebar is pressed,
    // make all the balloons in the game bigger by 25%
    if keyboard.just_pressed(KeyCode::Space) {
        for mut transform in &amp;mut query {
            transform.scale *= 1.25;
        }
    }
}

fn throwable_fly(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;&amp;mut Transform, With&lt;ThrowableProjectile&gt;&gt;,
) {
    // every frame, make our projectiles fly across the screen and spin
    for mut transform in &amp;mut query {
        // do not forget to multiply by the time delta!
        // this is required to move at the same speed regardless of frame rate!
        transform.translation.x += 100.0 * time.delta_seconds();
        transform.rotate_z(2.0 * time.delta_seconds());
    }
}</code></pre>
<p>é€šå¸¸ä½¿ç”¨Transformå°±å¤Ÿäº†,è¿™ä¸ªç»“æ„ä½“é‡ŒåŒ…å«äº†ç§»åŠ¨/æ—‹è½¬/ç¼©æ”¾.
å¦‚æœå®ä½“æœ‰ç»§æ‰¿å…³ç³»,åˆ™Transformæ˜¯åŸºäºçˆ¶å®ä½“çš„.</p>
<h3 id="globaltransform"><a class="header" href="#globaltransform"><code>GlobalTransform</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> represents the absolute global position in the world.</p>
<p>If the entity does not have a <a href="fundamentals//fundamentals/hierarchy.html">parent</a>, then this will match the
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>.</p>
<p>The value of <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> is calculated/managed internally by Bevy
(<a href="fundamentals/transforms.html#transform-propagation">"transform propagation"</a>).</p>
<p>Unlike <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, the translation/rotation/scale are not accessible
directly. The data is stored in an optimized way (using <a href="https://docs.rs/bevy/0.13.0/bevy/math/struct.Affine3A.html"><code>Affine3A</code></a>) and it is
possible to have complex transformations in a hierarchy that cannot be
represented as a simple transform. For example, a combination of rotation and
scale across multiple parents, resulting in shearing.</p>
<p>If you want to try to convert a <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> back into a workable
translation/rotation/scale representation, you can try the methods:</p>
<ul>
<li><code>.translation()</code></li>
<li><code>.to_scale_rotation_translation()</code> (may be invalid)</li>
<li><code>.compute_transform()</code> (may be invalid)</li>
</ul>
<p>GlobalTransform æ˜¯é’ˆå¯¹worldä¸–ç•Œçš„ç»å¯¹ä½ç½®. å€¼çš„è®¡ç®—å’Œç®¡ç†ç›´æ¥ç”±bevyå†…éƒ¨ç®¡ç†,
è¿™ä¹Ÿæ˜¯æ­£å¸¸çš„,æ¯•ç«Ÿbevyæ˜¯è·¨å¤šä¸ªå¹³å°,è‡ªèº«å°±æ˜¯è¦ç»´æŠ¤ä¸åŒå¹³å°çš„ä¸ä¸€è‡´,
åŸºäºworldçš„æ­£å¥½äº¤ç»™bevyç®¡ç†.è€ŒTransformåˆ™æ˜¯ä¸ºäº†ç®€åŒ–å¼€å‘è€Œç‹¬ç«‹å‡ºæ¥çš„.</p>
<p>GlobalTransformçš„ç§»åŠ¨/æ—‹è½¬/ç¼©æ”¾ä¸æ˜¯ç®€å•çš„æ”¹å€¼,å¤„ç†èµ·æ¥ä¹Ÿå¾ˆéº»çƒ¦,
å¤šä¸ªé¡¶çº§çˆ¶å¯¹è±¡ä¹‹å‰è¿˜å­˜åœ¨é®æŒ¡,è®¡ç®—ä¹Ÿé¢‡ä¸ºéº»çƒ¦,ä¼˜åŒ–ä¹Ÿæ˜¯é‡‡ç”¨<code>Affine3A</code>æŠ€æœ¯.</p>
<h2 id="transform-propagation"><a class="header" href="#transform-propagation">Transform Propagation</a></h2>
<p>The two components are synchronized by a bevy-internal system (the "transform
propagation system"), which runs in the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> <a href="fundamentals//programming/schedules.html">schedule</a>.</p>
<p>Beware: When you mutate the <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, the <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> is not
updated immediately. They will be out-of-sync until the transform propagation
system runs.</p>
<p>If you need to work with <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> directly, you should <a href="fundamentals//programming/app-builder.html">add</a>
your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> <a href="fundamentals//programming/schedules.html">schedule</a> and
<a href="fundamentals//programming/system-order.html">order it after</a> <a href="https://docs.rs/bevy/0.13.0/bevy/transform/enum.TransformSystem.html"><code>TransformSystem::TransformPropagate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Print the up-to-date global coordinates of the player
fn debug_globaltransform(
    query: Query&lt;&amp;GlobalTransform, With&lt;Player&gt;&gt;,
) {
    let gxf = query.single();
    debug!("Player at: {:?}", gxf.translation());
}</code></pre>
<pre><code class="language-rust no_run noplayground">// the label to use for ordering
use bevy::transform::TransformSystem;

app.add_systems(PostUpdate,
    debug_globaltransform
        // we want to read the GlobalTransform after
        // it has been updated by Bevy for this frame
        .after(TransformSystem::TransformPropagate)
);</code></pre>
<p>å˜æ¢ä¼ æ’­,è¿™ä¸¤ä¸ªåŸºç¡€ç»„ä»¶åœ¨bevyå†…éƒ¨systemä¸­è°ƒç”¨,æ—¶æœºæ˜¯PostUpdateè°ƒåº¦ä¸­.
é€šè¿‡Transformä¿®æ”¹å€¼å,GlobalTransformå¹¶ä¸ä¼šç«‹é©¬æ›´æ–°,è€Œæ˜¯ç­‰å˜æ¢ä¼ æ’­æ‰§è¡Œå®Œæ‰è¿›è¡ŒåŒæ­¥.</p>
<p>å¦‚æœè¦ç›´æ¥æ“ä½œGlobalTransform,éœ€è¦åœ¨PostUpdateè°ƒåº¦ä¸­æ·»åŠ system,
å¹¶å°†systemçš„é¡ºåºæ”¾åœ¨å˜æ¢ä¼ æ’­(TransformSystem::TransformPropagate)åé¢.</p>
<h2 id="transformhelper"><a class="header" href="#transformhelper"><code>TransformHelper</code></a></h2>
<p>If you need to get an up-to-date <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> in a <a href="fundamentals//programming/systems.html">system</a>
that has to run before transform propagation, you can use the special
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a> system parameter.</p>
<p>It allows you to compute a specific entity's <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> immediately, on
demand.</p>
<p>An example of where this could be useful might be a system to make a camera
follow an entity on-screen. You need to update the camera's <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> (which
means you have to do it before Bevy's transform propagation, so it can account
for the camera's new transform), but you also need to know the current
up-to-date position of the entity you are following.</p>
<pre><code class="language-rust no_run noplayground">fn camera_look_follow(
    q_target: Query&lt;Entity, With&lt;MySpecialMarker&gt;&gt;,
    mut transform_params: ParamSet&lt;(
        TransformHelper,
        Query&lt;&amp;mut Transform, With&lt;MyGameCamera&gt;&gt;,
    )&gt;,
) {
    // get the Entity ID we want to target
    let e_target = q_target.single();
    // compute its actual current GlobalTransform
    // (could be Err if entity doesn't have transforms)
    let Ok(global) = transform_params.p0().compute_global_transform(e_target) else {
        return;
    };
    // get camera transform and make it look at the global translation
    transform_params.p1().single_mut().look_at(global.translation(), Vec3::Y);
}</code></pre>
<p>Internally, <a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a> behaves like two read-only <a href="fundamentals//programming/queries.html">queries</a>.
It needs access to the <a href="https://docs.rs/bevy/0.13.0/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> components to do its job. It
would conflict with our other <code>&amp;mut Transform</code> query. That's why we have to use
a <a href="fundamentals//programming/paramset.html">param set</a> in the example above.</p>
<p>Note: if you over-use <a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a>, it could become a performance issue.
It calculates the global transform for you, but it does not update the data
stored in the entity's <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>. Bevy will still do the same
computation again later, during transform propagation. It leads to repetitive
work. If your system can run after transform propagation, so it can just read
the value after Bevy updates it, you should prefer to do that instead of using
<a href="https://docs.rs/bevy/0.13.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a>.</p>
<p>å¦‚æœè¦åœ¨å˜æ¢ä¼ æ’­ä¹‹å‰è·å–æœ€æ–°çš„GlobalTransformå€¼,éœ€è¦å€ŸåŠ©TransformHelper systemå‚æ•°.</p>
<p>ä¸€ä¸ªå¸¸ç”¨çš„åœºæ™¯æ˜¯:ç›¸æœºè¦è·Ÿéšå±å¹•ä¸Šçš„å®ä½“,å°±éœ€è¦æ›´æ–°ç›¸æœºçš„Transform,
è€Œä¸”è¿™ä¸ªæ“ä½œè¦åœ¨å˜æ¢ä¼ æ’­ä¹‹å‰å¤„ç†å®Œ.</p>
<p>ä»£ç å¦‚ä¸Šå›¾æ‰€ç¤º,ä½¿ç”¨äº†systemå‚æ•°: ParamSet/TransformHelper.</p>
<p>TransformHelperçš„è¡Œä¸ºç±»ä¼¼ä¸¤ä¸ªåªè¯»query,åˆ†åˆ«è®¿é—®Parentå’ŒTransformç»„ä»¶.
å› ä¸ºå·²ç»æœ‰äº†ä¸€ä¸ªcameraçš„Transform,ç›´æ¥ä½¿ç”¨ä¸¤ä¸ªqueryä¼šå¯¼è‡´å†²çª,
æ‰€ä»¥ä½¿ç”¨ParamSetæ¥é¿å…å†²çª.</p>
<p>TransformHelperè¿‡åº¦ä½¿ç”¨ä¼šæœ‰æ€§èƒ½é—®é¢˜,å› ä¸ºåªè®¡ç®—,ä¸æ›´æ–°GlobalTransformçš„æ•°æ®,
åœ¨å˜æ¢ä¼ æ’­æ—¶,bevyä¹Ÿæ˜¯è¦è¿›è¡ŒåŒæ ·çš„è®¡ç®—.è¿™æ ·å°±å­˜åœ¨é‡å¤è®¡ç®—.
å¦‚æœæ˜¯åœ¨ä¼ æ’­å˜æ¢ä¹‹åè·å–GlobalTransform,ç›´æ¥è¯»å°±è¡Œ,ä¸éœ€è¦TransformHelper,
è¿™æ ·æ€§èƒ½ä¼šæ›´é«˜.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Visibility is used to control if something is to be rendered or not. If you
want an entity to exist in the world, just not be displayed, you can hide it.</p>
<pre><code class="language-rust no_run noplayground">/// Prepare the game map, but do not display it until later
fn setup_map_hidden(
    mut commands: Commands,
) {
    commands.spawn((
        GameMapEntity,
        SceneBundle {
            scene: todo!(),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}

/// When everything is ready, un-hide the game map
fn reveal_map(
    mut query: Query&lt;&amp;mut Visibility, With&lt;GameMapEntity&gt;&gt;,
) {
    let mut vis_map = query.single_mut();
    *vis_map = Visibility::Visible;
}</code></pre>
<p>å¯è§†åŒ–æ§åˆ¶ä¸€ä¸ªå¯¹è±¡æ˜¯å¦è¿›è¡Œæ¸²æŸ“,ä¸è¿›è¡Œå¯è§†åŒ–,ç­‰åŒäºéšè—.</p>
<h2 id="visibility-components"><a class="header" href="#visibility-components">Visibility Components</a></h2>
<p>In Bevy, visibility is represented by <strong>multiple</strong> <a href="fundamentals//programming/ec.html#components">components</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/enum.Visibility.html"><code>Visibility</code></a>: the user-facing toggle (here is where you set what you want)</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a>: used by Bevy to keep track of the state from any <a href="fundamentals//fundamentals/hierarchy.html">parent entities</a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a>: used by Bevy to track if the entity should actually be displayed</li>
</ul>
<p>Any <a href="fundamentals//programming/ecs-intro.html">Entity</a> that represents a renderable object in
the game world needs to have them all. All of Bevy's <a href="fundamentals//builtins.html#bundles">built-in bundle
types</a> include them.</p>
<p>If you are creating a custom entity without using those <a href="fundamentals//programming/bundle.html">bundles</a>,
you can use one of the following to ensure you don't miss them:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> for <a href="fundamentals//fundamentals/transforms.html">transforms</a> + visibility</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a> for just visibility</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn spawn_special_entity(
    mut commands: Commands,
) {
    // create an entity that does not use one of the common Bevy bundles,
    // but still needs transforms and visibility
    commands.spawn((
        ComponentA,
        ComponentB,
        SpatialBundle {
            transform: Transform::from_scale(Vec3::splat(3.0)),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}</code></pre>
<p>If you don't do this correctly (say, you manually add just the <code>Visibility</code>
component and forget the others, because you don't use a bundle), your entities
will not render!</p>
<p>å¯è§†åŒ–ç”±å¤šä¸ªå¯è§†åŒ–ç»„ä»¶è¡¨ç¤º:</p>
<ul>
<li><code>Visibility</code> é¢å¯¹ç”¨æˆ·çš„å¼€å…³</li>
<li><code>InheritedVisibility</code> ç”±bevyè·Ÿè¸ªçš„å®ä½“çŠ¶æ€,ä»ç»§æ‰¿ä½“ç³»ä¸Šå¾—åˆ°</li>
<li><code>ViewVisibility</code> ç”±bevyè·Ÿè¸ª,çœ‹å®ä½“å®é™…ä¸Šæ˜¯å¦åº”è¯¥æ˜¾ç¤º</li>
</ul>
<h3 id="visibility-1"><a class="header" href="#visibility-1"><code>Visibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/enum.Visibility.html"><code>Visibility</code></a> is the "user-facing toggle". This is where you specify what you
want for the current entity:</p>
<ul>
<li><code>Inherited</code> (default): show/hide depending on <a href="fundamentals//fundamentals/hierarchy.html">parent</a></li>
<li><code>Visible</code>: always show the entity, regardless of parent</li>
<li><code>Hidden</code>: always hide the entity, regardless of parent</li>
</ul>
<p>If the current entity has any <a href="fundamentals//fundamentals/hierarchy.html">children</a> that have <code>Inherited</code>,
their visibility will be affected if you set the current entity to <code>Visible</code>
or <code>Hidden</code>.</p>
<p>If an entity has a parent, but the parent entity is missing the
visibility-related components, things will behave as if there was no parent.</p>
<p>å¯¹äºå®ä½“,å¯è®¾ç½®3ä¸ªå€¼:</p>
<ul>
<li><code>Inherited</code> é»˜è®¤, æ˜¯å¦æ˜¾ç¤ºè·Ÿç€çˆ¶å¯¹è±¡èµ°</li>
<li><code>Visible</code> ä¸å—çˆ¶å¯¹è±¡å½±å“,æ˜¾ç¤º</li>
<li><code>Hidden</code> ä¸å—çˆ¶å¯¹è±¡å½±å“,éšè—</li>
</ul>
<p>å½“å‰å®ä½“æœ‰å­å®ä½“,é‚£ä¹ˆå˜æ›´è®¾ç½®ä¼šå½±å“å­å®ä½“çš„æ˜¾ç¤ºæ•ˆæœ.
å¦‚æœå½“å‰å®ä½“æœ‰çˆ¶å®ä½“,ä½†çˆ¶å®ä½“æ²¡æœ‰<code>å¯è§†ç»„ä»¶</code>,é‚£ä¹ˆå½“å‰å®ä½“çš„è¡Œä¸ºå°±å’Œæ²¡æœ‰çˆ¶å®ä½“ç±»ä¼¼.</p>
<h3 id="inheritedvisibility"><a class="header" href="#inheritedvisibility"><code>InheritedVisibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a> represents the state the current entity would have based
on its <a href="fundamentals//fundamentals/hierarchy.html">parent</a>'s visibility.</p>
<p>The value of <a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a> should be considered read-only. It is
managed internally by Bevy, in a manner similar to <a href="fundamentals//fundamentals/transforms.html#transform-propagation">transform
propagation</a>. A "visibility propagation"
<a href="fundamentals//programming/systems.html">system</a> runs in the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> <a href="fundamentals//programming/schedules.html">schedule</a>.</p>
<p>If you want to read the up-to-date value for the current frame, you should
<a href="fundamentals//programming/app-builder.html">add</a> your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> and <a href="fundamentals//programming/system-order.html">order it after</a>
<a href="https://docs.rs/bevy/0.13.0/bevy/render/view/visibility/enum.VisibilitySystems.html"><code>VisibilitySystems::VisibilityPropagate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Check if a specific UI button is visible
/// (could be hidden if the whole menu is hidden?)
fn debug_player_visibility(
    query: Query&lt;&amp;InheritedVisibility, With&lt;MyAcceptButton&gt;&gt;,
) {
    let vis = query.single();

    debug!("Button visibility: {:?}", vis.get());
}</code></pre>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::VisibilitySystems;

app.add_systems(PostUpdate,
    debug_player_visibility
        .after(VisibilitySystems::VisibilityPropagate)
);</code></pre>
<p>ç»§æ‰¿å¯è§†åŒ–,å¯è§†çŠ¶æ€è·Ÿç€çˆ¶å®ä½“èµ°.InheritedVisibilityçš„å€¼æ˜¯åªè¯»,ç”±bevyç»´æŠ¤.
å’Œå˜æ¢ä¼ æ’­ç±»ä¼¼,å¯è§†ä¼ æ’­çš„systemä¹Ÿæ˜¯åœ¨PostUpdateè°ƒåº¦ä¸­.</p>
<p>å¦‚æœè¦è·å–å½“å‰å¸§çš„å¯è§†çŠ¶æ€,éœ€è¦æ·»åŠ systemåœ¨PostUpdateè°ƒåº¦ä¸­,
ä¸”æ”¾åœ¨å¯è§†ä¼ æ’­(VisibilitySystems::VisibilityPropagate)çš„åé¢.</p>
<h3 id="viewvisibility"><a class="header" href="#viewvisibility"><code>ViewVisibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a> represents the actual final decision made by Bevy about
whether this entity needs to be rendered.</p>
<p>The value of <a href="https://docs.rs/bevy/0.13.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a> is read-only. It is managed internally by Bevy.</p>
<p>It is used for "culling": if the entity is not in the range of
any Camera or Light, it does not need to be rendered, so Bevy will hide it
to improve performance.</p>
<p>Every frame, after "visibility propagation", Bevy will check what entities
can be seen by what view (camera or light), and store the outcome in these
components.</p>
<p>If you want to read the up-to-date value for the current frame, you should
<a href="fundamentals//programming/app-builder.html">add</a> your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> and <a href="fundamentals//programming/system-order.html">order it after</a>
<a href="https://docs.rs/bevy/0.13.0/bevy/render/view/visibility/enum.VisibilitySystems.html"><code>VisibilitySystems::CheckVisibility</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Check if balloons are seen by any Camera, Light, etcâ€¦ (not culled)
fn debug_balloon_visibility(
    query: Query&lt;&amp;ViewVisibility, With&lt;Balloon&gt;&gt;,
) {
    for vis in query.iter() {
        if vis.get() {
            debug!("Balloon will be rendered.");
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::VisibilitySystems;

app.add_systems(PostUpdate,
    debug_balloon_visibility
        .after(VisibilitySystems::CheckVisibility)
);</code></pre>
<p>æœ€ç»ˆå¯è§†åŒ–,æœ€ç»ˆèƒ½ä¸èƒ½æ˜¾ç¤ºå°±çœ‹è¿™ä¸ªå€¼,åªè¯»,ç”±bevyå†…éƒ¨ç»´æŠ¤.</p>
<p>æœ‰ä¸ªå‰”é™¤è§„åˆ™: å¦‚æœå½“å‰å¯¹è±¡ä¸åœ¨Cameraçš„èŒƒå›´å†…,æˆ–ä¸åœ¨ç¯å…‰èŒƒå›´å†…,
é‚£è¿™ä¸ªå¯¹è±¡å°±ä¸ç”¨æ¸²æŸ“.è¿™æ ·å¯ä»¥æé«˜æ€§èƒ½,ä¹Ÿç¬¦åˆé€»è¾‘.</p>
<p>æ¯å¸§,åœ¨å¯è§†ä¼ æ’­æ‰§è¡Œå®Œå,bevyä¼šæ£€æŸ¥Camera/ç¯å…‰å’Œå®ä½“çš„å…³ç³»,
ç„¶åå°†ç»“æœå­˜å‚¨åœ¨ViewVisibilityç»„ä»¶çš„å€¼ä¸­.</p>
<p>å¦‚æœæƒ³è¦è·å–æœ€ç»ˆå¯è§†çš„å€¼,åœ¨PostUpdateä¸­æ·»åŠ system,
åœ¨VisibilitySystems::CheckVisibilityä¹‹åè·å–å€¼å³å¯.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="time-and-timers"><a class="header" href="#time-and-timers">Time and Timers</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/timers.rs"><code>timers</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/2d/move_sprite.rs"><code>move_sprite</code></a>.</p>
<hr />
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> <a href="fundamentals//programming/res.html">resource</a> is your main global source
of timing information, that you can access from any <a href="fundamentals//programming/systems.html">system</a>
that does anything that needs time. <a href="fundamentals//pitfalls/time.html">You should derive all timings from
it</a>.</p>
<p>Bevy updates these values at the beginning of every frame.</p>
<p>bevyä¸­çš„æ—¶é—´æ˜¯èµ„æº,å¯é€šè¿‡ä»»æ„systemè®¿é—®,bevyä¼šåœ¨æ¯å¸§ä¹‹å‰æ›´æ–°è¿™ä¸ªå€¼.</p>
<h3 id="delta-time"><a class="header" href="#delta-time">Delta Time</a></h3>
<p>The most common use case is "delta time" â€“ how much time passed between
the previous frame update and the current one. This tells you how fast the
game is running, so you can scale things like movement and animations. This
way everything can happen smoothly and run at the same speed, regardless of
the game's frame rate.</p>
<pre><code class="language-rust no_run noplayground">fn asteroids_fly(time: Res&lt;Time&gt;, mut q: Query&lt;&amp;mut Transform, With&lt;Asteroid&gt;&gt;) {
    for mut transform in q.iter_mut() {
        // move our asteroids along the X axis
        // at a speed of 10.0 units per second
        transform.translation.x += 10.0 * time.delta_seconds();
    }
}</code></pre>
<p>æ—¶é—´æœ€å¸¸ç”¨çš„åœºæ™¯æ˜¯:å¢é‡æ—¶é—´,ä¸Šä¸€å¸§åˆ°ç°åœ¨è¿‡å»äº†å¤šé•¿æ—¶é—´.
æœ‰äº†è¿™ä¸ªæ—¶é—´å°±å¯ä»¥æ§åˆ¶ç‰©ä½“çš„ç§»åŠ¨å’ŒåŠ¨ç”»çš„æ’­æ”¾,è¿™æ ·æ— è®ºæ¸¸æˆå¸§ç‡æ˜¯å¤šå°‘,
æ‰€æœ‰çš„æ˜¾ç¤ºéƒ½æ˜¯é¡ºæ»‘,å¹¶æŒ‰åŒæ ·çš„é€Ÿåº¦è¿›è¡Œçš„.</p>
<p>ä¸Šå›¾æ‰€ç¤º,å°±æ˜¯1ç§’ç§»åŠ¨çš„10ä¸ªå•ä½,è¿™ç§å¤„ç†æ–¹å¼å¤§å¤§å‡å°‘äº†å¼€å‘éš¾åº¦.</p>
<h3 id="ongoing-time"><a class="header" href="#ongoing-time">Ongoing Time</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> can also give you the total running time since startup.
Use this if you need a cumulative, increasing, measurement of time.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Instant;

/// Say, for whatever reason, we want to keep track
/// of when exactly some specific entities were spawned.
#[derive(Component)]
struct SpawnedTime(Instant);

fn spawn_my_stuff(mut commands: Commands, time: Res&lt;Time&gt;) {
    commands
        .spawn((/* ... */))
        // we can use startup time and elapsed duration
        .insert(SpawnedTime(time.startup() + time.elapsed()))
        // or just the time of last update
        .insert(SpawnedTime(time.last_update().unwrap()));
}</code></pre>
<p>æŒç»­æ—¶é—´,å¦‚æœè¦æƒ³è®¡ç®—:ç´¯è®¡/å¢é‡/æµ‹é‡æ—¶é—´,ä½¿ç”¨è¿™ä¸ª.</p>
<h2 id="timers-and-stopwatches"><a class="header" href="#timers-and-stopwatches">Timers and Stopwatches</a></h2>
<p>There are also facilities to help you track specific intervals or timings:
<a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Timer.html"><code>Timer</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Stopwatch.html"><code>Stopwatch</code></a>. You can create
many instances of these, to track whatever you want. You can use them in
your own <a href="fundamentals//programming/ec.html#components">component</a> or <a href="fundamentals//programming/res.html">resource</a> types.</p>
<p>Timers and Stopwatches need to be ticked. You need to have some system
calling <code>.tick(delta)</code>, for it to make progress, or it will be inactive.
The delta should come from the <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> resource.</p>
<p>å®šæ—¶å™¨å’Œç§’è¡¨. è¿™æ˜¯ä¸¤ä¸ªè·Ÿè¸ªå›ºå®šé—´éš”çš„å·¥å…·,å¯ä»¥åˆ›å»ºå¾ˆå¤šæ¥è·Ÿè¸ªå„ç§äº‹ç‰©,
å¯ä»¥åœ¨ç»„ä»¶æˆ–èµ„æºä¸­ä½¿ç”¨.</p>
<p>ä¸ç®¡æ˜¯å®šæ—¶å™¨è¿˜æ˜¯ç§’è¡¨,éƒ½éœ€è¦åœ¨systemä¸­è°ƒç”¨<code>.tick(delta)</code>è¿›è¡Œå¯åŠ¨æˆ–å–æ¶ˆ,
å…¶ä¸­å‚æ•°deltaå°±æ¥è‡ªäºTimeèµ„æº.</p>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Timer.html"><code>Timer</code></a> allows you to detect when a certain interval of time
has elapsed. Timers have a set duration. They can be "repeating" or
"non-repeating".</p>
<p>Both kinds can be manually "reset" (start counting the time interval from the
beginning) and "paused" (they will not progress even if you keep ticking them).</p>
<p>Repeating timers will automatically reset themselves after they reach their
set duration.</p>
<p>Use <code>.finished()</code> to detect when a timer has reached its set duration. Use
<code>.just_finished()</code>, if you need to detect only on the exact tick when the
duration was reached.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Duration;

#[derive(Component)]
struct FuseTime {
    /// track when the bomb should explode (non-repeating timer)
    timer: Timer,
}

fn explode_bombs(mut commands: Commands, mut q: Query&lt;(Entity, &amp;mut FuseTime)&gt;, time: Res&lt;Time&gt;) {
    for (entity, mut fuse_timer) in q.iter_mut() {
        // timers gotta be ticked, to work
        fuse_timer.timer.tick(time.delta());

        // if it finished, despawn the bomb
        if fuse_timer.timer.finished() {
            commands.entity(entity).despawn();
        }
    }
}

#[derive(Resource)]
struct BombsSpawnConfig {
    /// How often to spawn a new bomb? (repeating timer)
    timer: Timer,
}

/// Spawn a new bomb in set intervals of time
fn spawn_bombs(mut commands: Commands, time: Res&lt;Time&gt;, mut config: ResMut&lt;BombsSpawnConfig&gt;) {
    // tick the timer
    config.timer.tick(time.delta());

    if config.timer.finished() {
        commands.spawn((
            FuseTime {
                // create the non-repeating fuse timer
                timer: Timer::new(Duration::from_secs(5), TimerMode::Once),
            },
            // ... other components ...
        ));
    }
}

/// Configure our bomb spawning algorithm
fn setup_bomb_spawning(mut commands: Commands) {
    commands.insert_resource(BombsSpawnConfig {
        // create the repeating timer
        timer: Timer::new(Duration::from_secs(10), TimerMode::Repeating),
    })
}</code></pre>
<p>Note that Bevy's timers do <em>not</em> work like typical real-life timers (which
count downwards toward zero). Bevy's timers start from zero and count <em>up</em>
towards their set duration. They are basically like stopwatches with extra
features: a maximum duration and optional auto-reset.</p>
<p>å®šæ—¶å™¨,å…è®¸æ£€æŸ¥æŸä¸ªé—´éš”çš„æ—¶é—´æ˜¯å¦å·²ç»åˆ°äº†.å®šæ—¶å™¨é™¤äº†å¯ä»¥è®¾ç½®æ—¶é•¿,
è¿˜å¯ä»¥æ·»åŠ æ˜¯å¦é‡å¤çš„æ ‡ç­¾,ä¸ç®¡æ˜¯ä¸æ˜¯é‡å¤çš„å®šæ—¶å™¨,éƒ½å¯ä»¥è¿›è¡Œreset/pausedæ“ä½œ.</p>
<p>é‡å¤æ€§å®šæ—¶å™¨åœ¨è¾¾åˆ°æ—¶é•¿å,ä¼šè‡ªåŠ¨è°ƒç”¨resetæ¥é‡ç½®çŠ¶æ€.</p>
<p>ä½¿ç”¨<code>.finished()</code>æ¥æ£€æµ‹å®šæ—¶æœ‰æ²¡æœ‰åˆ°è¾¾.
ä½¿ç”¨<code>.just_finished()</code>ä»…åœ¨å®šæ—¶åˆ°è¾¾æ—¶è¿”å›true.</p>
<h3 id="stopwatch"><a class="header" href="#stopwatch">Stopwatch</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Stopwatch.html"><code>Stopwatch</code></a> allow you to track how much time has passed
since a certain point.</p>
<p>It will just keep accumulating time, which you can check with
<code>.elapsed()</code>/<code>.elapsed_secs()</code>. You can manually reset it at any time.</p>
<pre><code class="language-rust no_run noplayground">use bevy::time::Stopwatch;

#[derive(Component)]
struct JumpDuration {
    time: Stopwatch,
}

fn jump_duration(
    time: Res&lt;Time&gt;,
    mut q_player: Query&lt;&amp;mut JumpDuration, With&lt;Player&gt;&gt;,
    kbd: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    // assume we have exactly one player that jumps with Spacebar
    let mut jump = q_player.single_mut();

    if kbd.just_pressed(KeyCode::Space) {
        jump.time.reset();
    }

    // è¿™ä¸ªä¾‹å­éå¸¸æœ‰æ„æ€,æŒ‰ä¸‹ç©ºæ ¼è¡¨ç§’é‡ç½®,
    // æŒç»­æŒ‰ä¸‹,æŒç»­ç´¯ç§¯æ—¶é—´.
    // è¿™ä¸ªå’Œè·³æ ¼å­æ¸¸æˆéå¸¸åƒ.æœ‰æ„æ€.
    if kbd.pressed(KeyCode::Space) {
        println!("Jumping for {} seconds.", jump.time.elapsed_secs());
        // stopwatch has to be ticked to progress
        jump.time.tick(time.delta());
    }
}</code></pre>
<p>ç§’è¡¨å¯ä»¥ç”¨æ¥è·Ÿè¸ªæŸä¸ªæ—¶é—´ç‚¹åˆ°ç°åœ¨è¿‡äº†å¤šé•¿æ—¶é—´.
ç§’è¡¨ä¼šä¸€ç›´ç´¯ç§¯æ—¶é—´.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="logging-console-messages"><a class="header" href="#logging-console-messages">Logging, Console Messages</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/app/logs.rs"><code>logs</code></a>.</p>
<hr />
<p>You may have noticed how, when you run your Bevy project, you get messages
in your console window. For example:</p>
<pre><code>2022-06-12T13:28:25.445644Z  WARN wgpu_hal::vulkan::instance: Unable to find layer: VK_LAYER_KHRONOS_validation
2022-06-12T13:28:25.565795Z  INFO bevy_render::renderer: AdapterInfo { name: "AMD Radeon RX 6600 XT", vendor: 4098, device: 29695, device_type: DiscreteGpu, backend: Vulkan }
2022-06-12T13:28:25.565795Z  INFO mygame: Entered new map area.
</code></pre>
<p>Log messages like this can come from Bevy, dependencies (like wgpu), and
also from your own code.</p>
<p>Bevy offers a logging framework that is much more advanced than simply using
<code>println</code>/<code>eprintln</code> from Rust. Log messages can have metadata, like the
level, timestamp, and Rust module where it came from. You can see that this
metadata is printed alongside the contents of the message.</p>
<p>This is set up by Bevy's <a href="https://docs.rs/bevy/0.12.0/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>. It is part of the
<a href="https://docs.rs/bevy/0.12.0/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> plugin group, so most Bevy users
will have it automatically in every typical Bevy project.</p>
<p>ä¸Šå›¾ä¸­çš„æ—¥å¿—æ¥è‡ªäºbevy,ç¡®åˆ‡è¯´æ˜¯wgpu.
ç›¸æ¯”rustæä¾›çš„println/eprintlnå®,bevyæä¾›äº†ä¸€ä¸ªé«˜çº§çš„æ—¥å¿—åº“.
DefaultPluginsæ’ä»¶åˆ—è¡¨ä¸­åŒ…å«äº†LogPluginæ’ä»¶.</p>
<h2 id="levels"><a class="header" href="#levels">Levels</a></h2>
<p>Levels determine how important a message is, and allow messages to be filtered.</p>
<p>The available levels are: <code>off</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code>.</p>
<p>A rough guideline for when to use each level, could be:</p>
<ul>
<li><code>off</code>: disable all log messages</li>
<li><code>error</code>: something happened that prevents things from working correctly</li>
<li><code>warn</code>: something unusual happened, but things can continue to work</li>
<li><code>info</code>: general informational messages</li>
<li><code>debug</code>: for development, messages about what your code is doing</li>
<li><code>trace</code>: for very verbose debug data, like dumping values</li>
</ul>
<p>æ—¥å¿—ç­‰çº§,offè¡¨ç¤ºä¸è¦æ—¥å¿—,å‰©ä¸‹çš„ä¾æ¬¡ä¸°å¯Œ.</p>
<h2 id="printing-your-own-log-messages"><a class="header" href="#printing-your-own-log-messages">Printing your own log messages</a></h2>
<p>To display a message, just use the macro named after the level of the
message. The syntax is exactly the same as with Rust's <code>println</code>. See the
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> documentation for more details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error!("Unknown condition!");
warn!("Something unusual happened!");
info!("Entered game level: {}", level_id);
debug!("x: {}, state: {:?}", x, state);
trace!("entity transform: {:?}", transform);
<span class="boring">}</span></code></pre></pre>
<p>ä½¿ç”¨ä¹Ÿéå¸¸ç®€å•,ä½¿ç”¨å®å³å¯.</p>
<h2 id="filtering-messages"><a class="header" href="#filtering-messages">Filtering messages</a></h2>
<p>To control what messages you would like to see, you can configure Bevy's
<a href="https://docs.rs/bevy/0.12.0/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::log::LogPlugin;

app.add_plugins(DefaultPlugins.set(LogPlugin {
    filter: "info,wgpu_core=warn,wgpu_hal=warn,mygame=debug".into(),
    level: bevy::log::Level::DEBUG,
}));
<span class="boring">}</span></code></pre></pre>
<p>The <code>filter</code> field is a string specifying a list of rules for what level to
enable for different Rust modules/crates. In the example above, the string
means: show up to <code>info</code> by default, limit <code>wgpu_core</code> and <code>wgpu_hal</code>
to <code>warn</code> level, for <code>mygame</code> show <code>debug</code>.</p>
<p>All levels higher than the one specified are also enabled. All levels lower
than the one specified are disabled, and those messages will not be displayed.</p>
<p>The <code>level</code> filter is a global limit on the lowest level to use. Messages
below that level will be ignored and most of the performance overhead avoided.</p>
<p>filterå¯è¿›ä¸€æ­¥æŒ‡å®šå„ä¸ªæ¨¡å—çš„æ—¥å¿—ç­‰çº§.</p>
<h3 id="environment-variable"><a class="header" href="#environment-variable">Environment Variable</a></h3>
<p>You can override the filter string when running your app, using the <code>RUST_LOG</code>
environment variable.</p>
<pre><code class="language-sh">RUST_LOG="warn,mygame=debug" ./mygame
</code></pre>
<p>Note that other Rust projects, such as <code>cargo</code>, also use the same
environment variable to control their logging. This can lead to unexpected
consequences. For example, doing:</p>
<pre><code class="language-sh">RUST_LOG="debug" cargo run
</code></pre>
<p>will cause your console to also be filled with debug messages from <code>cargo</code>.</p>
<p>ä¸æƒ³ä»£ç æŒ‡å®šæ—¥å¿—ç­‰çº§,ä¹Ÿå¯ä»¥ä½¿ç”¨ç¯å¢ƒå˜é‡RUST_LOGæ¥æŒ‡å®š.ä¸æ¨èè¿™ç§æ–¹å¼.</p>
<h3 id="different-settings-for-debug-and-release-builds"><a class="header" href="#different-settings-for-debug-and-release-builds">Different settings for debug and release builds</a></h3>
<p>If you want to do different things in your Rust code for debug/release
builds, an easy way to achieve it is using conditional compilation on
"debug assertions".</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::log::LogPlugin;

// this code is compiled only if debug assertions are enabled (debug mode)
#[cfg(debug_assertions)]
app.add_plugins(DefaultPlugins.set(LogPlugin {
    level: bevy::log::Level::DEBUG,
    filter: "debug,wgpu_core=warn,wgpu_hal=warn,mygame=debug".into(),
}));

// this code is compiled only if debug assertions are disabled (release mode)
#[cfg(not(debug_assertions))]
app.add_plugins(DefaultPlugins.set(LogPlugin {
    level: bevy::log::Level::INFO,
    filter: "info,wgpu_core=warn,wgpu_hal=warn".into(),
}));
<span class="boring">}</span></code></pre></pre>
<p>This is a good reason why <a href="fundamentals//pitfalls/performance.html">you should not use release mode during development
just for performance reasons</a>.</p>
<p>On Microsoft Windows, your game EXE will also launch with a console window for
displaying log messages by default. You might not want that in release builds.
<a href="fundamentals//platforms/windows.html#disabling-the-windows-console">See here.</a></p>
<p>ä½¿ç”¨æ¡ä»¶ç¼–è¯‘æ¥åˆ†åˆ«æ§åˆ¶debug/releaseçš„ä¸åŒæ—¥å¿—ç­‰çº§.è¿™ä¹Ÿæ˜¯æé«˜æ€§èƒ½çš„ä¸€ç§æ–¹å¼.</p>
<p>windowsä¸­,ä½ è‚¯å®šä¸æƒ³releaseç‰ˆæœ¬å¼¹å‡ºä¸€ä¸ªå‘½ä»¤çª—å£æ¥å§.</p>
<h2 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h2>
<p>Printing messages to the console is a relatively slow operation.</p>
<p>However, if you are not printing a large volume of messages, don't worry
about it. Just avoid spamming lots of messages from performance-sensitive
parts of your code like inner loops.</p>
<p>You can disable log levels like <code>trace</code> and <code>debug</code> in release builds.</p>
<p>æ§åˆ¶å°æ‰“å°æ—¥å¿—æ˜¯éå¸¸æ…¢çš„æ“ä½œ.
å¦‚æœä¸æ˜¯å¤§é‡æ‰“å°æ—¥å¿—,è¿™ç‚¹å½±å“ä¸ç®—ä»€ä¹ˆ.
å¾ªç¯å¤šçš„åœ°æ–¹,å°±æ˜¯æ€§èƒ½æ•æ„Ÿçš„åœ°æ–¹,ä¸è¦åœ¨è¿™é‡Œæ‰“å¤§é‡çš„æ—¥å¿—.</p>
<p>releaseç‰ˆæœ¬å¯æ˜¯ä»infoçº§åˆ«å¼€å§‹æ‰“èµ·.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="hierarchical-parentchild-entities"><a class="header" href="#hierarchical-parentchild-entities">Hierarchical (Parent/Child) Entities</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/hierarchy.rs"><code>hierarchy</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Technically, the <a href="fundamentals//programming/intro-data.html#entities--components">Entities/Components</a> themselves cannot form a
hierarchy (the <a href="fundamentals//programming/ecs-intro.html">ECS</a> is a flat data structure). However,
logical hierarchies are a common pattern in games.</p>
<p>Bevy supports creating such a logical link between entities, to form
a virtual "hierarchy", by simply adding <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and
<a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> components on the respective entities.</p>
<p>When using <a href="fundamentals//programming/commands.html">Commands</a> to spawn entities,
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> has methods for adding children to entities,
which automatically add the correct components:</p>
<pre><code class="language-rust no_run noplayground">    // spawn the parent and get its Entity id
    let parent = commands.spawn(MyParentBundle::default()).id();

    // do the same for the child
    let child = commands.spawn(MyChildBundle::default()).id();

    // add the child to the parent
    commands.entity(parent).push_children(&amp;[child]);

    // you can also use `with_children`:
    commands
        .spawn(MyParentBundle::default())
        .with_children(|parent| {
            parent.spawn(MyChildBundle::default());
        });</code></pre>
<p>Note that this only sets up the <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and
<a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> components, and nothing else. Notably, it does not
add <a href="fundamentals//fundamentals/transforms.html">transforms</a> or <a href="fundamentals//fundamentals/visibility.html">visibility</a> for you.  If you
need that functionality, you need to add those components yourself, using
something like <a href="https://docs.rs/bevy/0.9.1/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a>.</p>
<p>You can despawn an entire hierarchy with a single <a href="fundamentals//programming/commands.html">command</a>:</p>
<pre><code class="language-rust no_run noplayground">fn close_menu(mut commands: Commands, query: Query&lt;Entity, With&lt;MainMenuUI&gt;&gt;) {
    for entity in query.iter() {
        // despawn the entity and its children
        commands.entity(entity).despawn_recursive();
    }
}</code></pre>
<p>æŠ€æœ¯ä¸Šè®²,ECSçš„å®ä½“/ç»„ä»¶æ²¡æœ‰ç»§æ‰¿å…³ç³»,å› ä¸ºè¿™ä¸¤è€…éƒ½æ˜¯æ‰å¹³åŒ–çš„ç»“æ„.</p>
<p>å®ä½“,é€»è¾‘ä¸Šè¿˜æ˜¯æœ‰ä¸€äº›ç»§æ‰¿å…³ç³»çš„,bevyå°±æ˜¯è¿™ä¹ˆè®¾è®¡çš„.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Parent ä»…ä»…æ˜¯å°†Entityå°è£…äº†ä¸€å±‚.
#[derive(Component, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "reflect", derive(bevy_reflect::Reflect))]
#[cfg_attr(feature = "reflect", reflect(Component, MapEntities, PartialEq))]
pub struct Parent(pub(crate) Entity);

// Children å°±æ˜¯ä¸€ä¸ªEntityåˆ—è¡¨
#[derive(Component, Debug)]
#[cfg_attr(feature = "reflect", derive(bevy_reflect::Reflect))]
#[cfg_attr(feature = "reflect", reflect(Component, MapEntities))]
pub struct Children(pub(crate) SmallVec&lt;[Entity; 8]&gt;);
<span class="boring">}</span></code></pre></pre>
<p>ä¸Šå›¾çš„ä¾‹å­å°±é€šè¿‡ä¸¤ç§æ–¹å¼æ¥äººä¸ºåˆ›å»ºäº†ä¸€å¯¹çˆ¶å­å…³ç³».
ä¾‹å­ä¸­å¹¶æ²¡æœ‰æ·»åŠ å˜æ¢/å¯è§†ç­‰ç‰¹æ€§,éœ€è¦æˆ‘ä»¬è‡ªå·±å•ç‹¬æ·»åŠ .
æœ‰ç»§æ‰¿å…³ç³»çš„å®ä½“,é€šè¿‡<code>despawn_recursive</code>å¯ä»¥å°†å½“å‰å®ä½“å’Œå­å®ä½“éƒ½é”€æ¯.</p>
<h2 id="accessing-the-parent-or-children"><a class="header" href="#accessing-the-parent-or-children">Accessing the Parent or Children</a></h2>
<p>To make a system that works with the hierarchy, you typically need two <a href="fundamentals//programming/queries.html">queries</a>:</p>
<ul>
<li>one with the components you need from the child entities</li>
<li>one with the components you need from the parent entities</li>
</ul>
<p>One of the two queries should include the appropriate component, to obtain the
entity ids to use with the other one:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> in the child query, if you want to iterate entities
and look up their parents, or</li>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> in the parent query, if you want to iterate entities
and look up their children</li>
</ul>
<p>For example, if we want to get the <a href="https://docs.rs/bevy/0.9.1/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>
of cameras (<a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.Camera.html"><code>Camera</code></a>) that have a parent, and the
<a href="https://docs.rs/bevy/0.9.1/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> of their parent:</p>
<pre><code class="language-rust no_run noplayground">fn camera_with_parent(
    q_child: Query&lt;(&amp;Parent, &amp;Transform), With&lt;Camera&gt;&gt;,
    q_parent: Query&lt;&amp;GlobalTransform&gt;,
) {
    for (parent, child_transform) in q_child.iter() {
        // `parent` contains the Entity ID we can use
        // to query components from the parent:
        let parent_global_transform = q_parent.get(parent.get());

        // do something with the components
    }
}</code></pre>
<p>As another example, say we are making a strategy game, and we have Units
that are children of a Squad. Say we need to make a system that works on
each Squad, and it needs some information about the children:</p>
<pre><code class="language-rust no_run noplayground">fn process_squad_damage(
    q_parent: Query&lt;(&amp;MySquadDamage, &amp;Children)&gt;,
    q_child: Query&lt;&amp;MyUnitHealth&gt;,
) {
    // get the properties of each squad
    for (squad_dmg, children) in q_parent.iter() {
        // `children` is a collection of Entity IDs
        for &amp;child in children.iter() {
            // get the health of each child unit
            let health = q_child.get(child);

            // do something
        }
    }
}</code></pre>
<p>å¦‚æœè¦è®¿é—®çˆ¶/å­å®ä½“,éœ€è¦ä¸¤ä¸ªquery(çˆ¶å®ä½“å¯¹åº”çš„ç»„ä»¶åˆ—è¡¨,å­å®ä½“å¯¹åº”çš„ç»„ä»¶åˆ—è¡¨),
éšä¾¿æ‰¾åˆ°å“ªä¸ªå°±èƒ½æ‰¾åˆ°å¯¹åº”çš„çˆ¶å­äº†.</p>
<p>ä¸Šé¢çš„ä¾‹å­å±•ç¤ºäº†ä¸€çˆ¶å¤šå­å’Œå¤šä¸ªä¸€çˆ¶å¤šå­çš„ä¾‹å­.</p>
<h2 id="transform-and-visibility-propagation"><a class="header" href="#transform-and-visibility-propagation">Transform and Visibility Propagation</a></h2>
<p>If your entities represent "objects in the game world", you probably expect
the children to be affected by the parent.</p>
<p><a href="fundamentals//fundamentals/transforms.html">Transform</a> propagation allows children to be positioned
relative to their parent and move with it.</p>
<p><a href="fundamentals//fundamentals/visibility.html">Visibility</a> propagation allows children to be hidden if
you manually hide their parent.</p>
<p>Most <a href="fundamentals//builtins.html#bundles">Bundles that come with Bevy</a> provide these behaviors
automatically. Check the docs for the bundles you are using.  Camera bundles,
for example, have transforms, but not visibility.</p>
<p>Otherwise, you can use <a href="https://docs.rs/bevy/0.9.1/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> to make sure
your entities have all the necessary components.</p>
<p>å¦‚æœè¦å®ä½“èƒ½æ˜¾ç¤ºå‡ºæ¥,è¿˜éœ€è¦å—çˆ¶å®ä½“æ¥å½±å“,å°±å¯ä»¥ä½¿ç”¨å˜å½¢ä¼ æ’­/å¯è§†ä¼ æ’­.</p>
<p>bevyæä¾›çš„å¾ˆå¤šBundleéƒ½è‡ªåŠ¨æ·»åŠ äº†è¿™äº›è¡Œä¸º.eg:CamearBundle,æ·»åŠ äº†å˜æ¢,æ²¡æœ‰æ·»åŠ å¯è§†.
æˆ–è€…ç®€å•ç‚¹,æ·»åŠ ç©ºé—´Bundle SpatialBundle,è¿™æ ·å˜æ¢å’Œå¯è§†éƒ½æ·»åŠ äº†.</p>
<h2 id="known-pitfalls"><a class="header" href="#known-pitfalls">Known Pitfalls</a></h2>
<h3 id="despawning-child-entities"><a class="header" href="#despawning-child-entities">Despawning Child Entities</a></h3>
<p>If you despawn an entity that has a parent, Bevy does not remove it from the
parent's <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a>.</p>
<p>If you then query for that parent entity's children, you will get an invaild
entity, and any attempt to manipulate it will likely lead to this error:</p>
<pre><code>thread 'main' panicked at 'Attempting to create an EntityCommands for entity 7v0, which doesn't exist.'
</code></pre>
<p>The workaround is to manually call <code>remove_children</code> alongside the <code>despawn</code>:</p>
<pre><code class="language-rust no_run noplayground">    commands
        .entity(parent_entity)
        .remove_children(&amp;[child_entity]);
    commands.entity(child_entity).despawn();</code></pre>
<p>å¸¸è§å¤±è´¥åœºæ™¯:å­å®ä½“é”€æ¯.</p>
<p>å¦‚æœå­å®ä½“é”€æ¯äº†,ä½†çˆ¶å®ä½“æ²¡æœ‰é”€æ¯å…¶å…³ç³»,è¿™å°±æ˜¯é—®é¢˜.
æŠ¥é”™å’Œè§£å†³æ–¹æ³•å¦‚ä¸Šæ‰€ç¤º.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="fixed-timestep"><a class="header" href="#fixed-timestep">Fixed Timestep</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/fixed_timestep.rs"><code>fixed_timestep</code></a>.</p>
<hr />
<p>If you need to run some <a href="fundamentals//programming/systems.html">systems</a> at a fixed rate, independent
of the display frame rate, Bevy provides a solution.</p>
<pre><code class="language-rust no_run noplayground">    // These systems will run every frame
    // (at the framerate being rendered to your screen)
    app.add_systems(Update, (camera_movement, animation, juicy_explosions));

    // These systems will run as many times as needed
    // as to maintain a fixed rate on average
    app.add_systems(
        FixedUpdate,
        (physics_collisions, enemy_ai, gameplay_simulation),
    );</code></pre>
<p>Every frame update, Bevy will run the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> schedule as many times as
needed to catch up. If the game is running slow, it might run multiple times. If
the game is running fast, it might be skipped.</p>
<p>This happens before the regular <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> schedule runs for that frame, but
after <a href="fundamentals//programming/states.html">state transitions</a>.</p>
<p>The default fixed timestep interval is 64 Hz. If you want something else,
you can configure it as follows:</p>
<pre><code class="language-rust no_run noplayground">    // Set the Fixed Timestep interval to 96 Hz
    app.insert_resource(Time::&lt;Fixed&gt;::from_hz(96.0));

    // Set the Fixed Timestep interval to 250 milliseconds
    app.insert_resource(Time::&lt;Fixed&gt;::from_seconds(0.25));</code></pre>
<p>å¦‚æœéƒ¨åˆ†systemä¸éœ€è¦ä»¥æ¥å¸§ç‡,bevyä¹Ÿæä¾›äº†æ–¹æ¡ˆ:<code>å›ºå®šæ—¶é—´æˆ³</code>.
è¿™ç±»systemæ”¾åœ¨FixedUpdateè°ƒåº¦ä¸­,bevyä¼šè¯„ä¼°å½“å‰å¸§çš„å¯ç”¨æ—¶é—´,
å¦‚æœæ—¶é—´å¤Ÿç”¨å°±ä¼šå¤šæ¬¡æ‰§è¡Œsystem,å¦‚æœæ—¶é—´ä¸å¤Ÿç”¨å°±è·³è¿‡.
ä½†ä¸ç®¡å•å¸§è¿è¡Œå¤šæ¬¡æ¬¡,bevyä¼šåŠªåŠ›ä¿è¯è°ƒç”¨çš„å¹³å‡å›ºå®šé€Ÿç‡.
é»˜è®¤è°ƒåº¦é—´éš”æ˜¯64Hz.ä¹Ÿå¯ä»¥è°ƒæ•´ä¸º96Hzæˆ–ä»¥æ—¶é—´ä¸ºé—´éš”,å¦‚ä¸Šå›¾.</p>
<h2 id="checking-the-time"><a class="header" href="#checking-the-time">Checking the Time</a></h2>
<p>Just use <a href="https://docs.rs/bevy/0.13.0/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a> as normal. When your system is running in
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, Bevy will automatically detect that, and all the timing
information (such as delta) will represent the fixed timestep instead of the
display frame rate.</p>
<pre><code class="language-rust no_run noplayground">fn print_time_delta(time: Res&lt;Time&gt;) {
    // If we add this system to `Update`, this will print the time delta
    // between subsequent frames (the display frame rate)
    // åœ¨Updateä¸­,delta_secondsè·å–çš„æ˜¯ä¸¤å¸§ä¹‹é—´çš„æ—¶é—´å·®.

    // If we add this system to `FixedUpdate`, this will always print the
    // same value (equal to the fixed timestep interval).
    // åœ¨FixedUpdateä¸­,delta_secondsè·å–çš„æ˜¯å›ºå®šæ—¶é—´æˆ³çš„é—´éš”(æœ€å¼€å§‹è®¾å®šçš„å›ºå®šå€¼).

    println!("Elapsed seconds: {}", time.delta_seconds());
}

// This system will access the Fixed time
// regardless of what schedule it runs in
fn print_fixed_time_info(time_fixed: Res&lt;Time&lt;Fixed&gt;&gt;) {
    // Time&lt;Fixed&gt;,è®¿é—®çš„æ˜¯å›ºå®šæ—¶é—´æˆ³

    // `Time&lt;Fixed&gt;` gives us some additional methods, such as checking
    // the overstep (partial timestep / amount of extra time accumulated)
    println!(
        "Time remaining until the next fixed update run: {}",
        time_fixed.delta_seconds() - time_fixed.overstep().as_secs_f32()
    );
}

// This system will access the regular frame time regardless
// of what schedule it runs in
fn check_virtual_time(time_fixed: Res&lt;Time&lt;Virtual&gt;&gt;) { // Time&lt;Virtual&gt;,è®¿é—®çš„æ˜¯æ™®é€šæ—¶é—´
                                                        // ...
}</code></pre>
<p>If you need to access the regular frame-time from a system running under
fixed timestep, you can use <code>Res&lt;Time&lt;Virtual&gt;&gt;</code> instead. <code>Res&lt;Time&lt;Real&gt;&gt;</code>
gives you the real (wall-clock) time, without pausing or scaling.</p>
<p>If you need to access the fixed-timestep-time from a system running outside
of fixed timestep, you can use <code>Res&lt;Time&lt;Fixed&gt;&gt;</code> instead.</p>
<p>åœ¨systemä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨Time,bevyä¼šè‡ªåŠ¨ç»´æŠ¤è¿™ä¸ªèµ„æº,ä½†è¿™ä¸ªèµ„æºé‡Œçš„æ•°æ®å«ä¹‰ä¼šæœ‰å˜åŒ–,
ä»å¸§ç‡æ”¹ä¸ºäº†æ—¶é—´æ­¥é•¿.</p>
<p>Timeæä¾›äº†3ç§å†…ç½®æ—¶é—´:</p>
<ul>
<li>Virtual, bevyå†…ç½®çš„æ™®é€šæ—¶é—´</li>
<li>Fixed, bevyåŸºäºVirtualç»§ç»­å°è£…çš„å›ºå®šæ—¶é—´æˆ³</li>
<li>Real, çœŸå®ä¸–ç•Œçš„æ—¶é—´,è¿™ä¸ªå¯èƒ½ç”¨çš„éå¸¸å°‘,åœ¨æ—¥å¿—æ‰“å°æ—¶ä¼šç”¨åˆ°</li>
</ul>
<h2 id="should-i-put-my-systems-in-update-or-fixedupdate"><a class="header" href="#should-i-put-my-systems-in-update-or-fixedupdate">Should I put my systems in <code>Update</code> or <code>FixedUpdate</code>?</a></h2>
<p>The purpose of fixed timestep is to make gameplay code behave predictably
and reliably. Things such as physics and simulation work best if they are
computed with fixed time intervals, as that avoids floating point errors
from accumulating and glitchy behavior from variable framerate.</p>
<p>The following things should probably be done in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>:</p>
<ul>
<li>Physics and collision detection</li>
<li>Networking / netcode</li>
<li>AI for enemies and NPCs (pathfinding, decisions, etc.)</li>
<li>Spawning/despawning gameplay-related entities</li>
<li>Other simulation and decision-making</li>
</ul>
<p>However, anything that directly affects what is displayed on-screen should
run per-frame, in order to look smooth. If you do movement or animation under
fixed timestep, it will look choppy, especially on high-refresh-rate screens.</p>
<p>The following things should probably be done in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>:</p>
<ul>
<li>Camera movement and controls</li>
<li>Animations</li>
<li>UI</li>
<li>Visual effects</li>
<li>Anything that is part of your game's graphics/visuals or interactivity</li>
<li><a href="fundamentals//programming/states.html">App state</a> transitions</li>
</ul>
<p>å›ºå®šæ—¶é—´æˆ³å¼•å…¥çš„ç›®çš„æ˜¯ä¸ºäº†è®©æ¸¸æˆä»£ç æ›´å…·æœ‰å¯é¢„æµ‹æ€§å’Œå¯é æ€§.
è¯¸å¦‚ç‰©ç†å’Œæ¨¡æ‹Ÿä¹‹ç±»çš„äº‹æƒ…å¦‚æœä»¥å›ºå®šçš„æ—¶é—´é—´éš”è¿›è¡Œè®¡ç®—ï¼Œæ•ˆæœæœ€å¥½ï¼Œ
å› ä¸ºè¿™å¯ä»¥é¿å…æµ®ç‚¹é”™è¯¯çš„ç´¯ç§¯å’Œå¯å˜å¸§é€Ÿç‡çš„æ•…éšœè¡Œä¸ºã€‚</p>
<p>ä¸‹åˆ—åœºæ™¯åº”è¯¥ä½¿ç”¨å›ºå®šæ—¶é—´æˆ³:</p>
<ul>
<li>ç‰©ç†å’Œç¢°æ’æ£€æµ‹</li>
<li>ç½‘ç»œä»£ç </li>
<li>æ•Œäººå’ŒNPCçš„AI,åŒ…æ‹¬(å¯»è·¯/å†³ç­–ç­‰)</li>
<li>å®ä½“çš„ç”Ÿæˆå’Œé”€æ¯(FixedUpdateè°ƒåº¦åœ¨Updateä¹‹å‰,åœ¨æŒ‚èµ·çŠ¶æ€è°ƒæ•´ä¹‹å)</li>
<li>å…¶ä»–æ¨¡æ‹Ÿå’Œå†³ç­–</li>
</ul>
<p>ä»»ä½•åœ¨å±å¹•ä¸Šæ˜¾ç¤ºçš„éƒ½åº”è¯¥æŒ‰å¸§è¿è¡Œ,è¿™æ ·çœ‹èµ·æ¥å°±ä¼šå¾ˆæµç•….
è¿™å¥è¯çš„æ„æ€æ˜¯(èƒ½æ¸²æŸ“çš„æ”¾åœ¨Updateä¸­,å†³ç­–æ¸²æŸ“çš„é€»è¾‘æ”¾åœ¨FixedUpdateä¸­).</p>
<p>ä¸‹åˆ—åœºæ™¯å› è¯¥ä½¿ç”¨Update:</p>
<ul>
<li>Cameraçš„ç§»åŠ¨å’Œæ§åˆ¶</li>
<li>åŠ¨ç”»</li>
<li>UI</li>
<li>æ˜¾ç¤ºæ•ˆæœ</li>
<li>å›¾å½¢/è§†è§‰æ•ˆæœ/äº¤äº’</li>
<li>appçŠ¶æ€è½¬æ¢</li>
</ul>
<h3 id="bridging-the-gap"><a class="header" href="#bridging-the-gap">Bridging the Gap</a></h3>
<p>Sometimes there is a logical conflict:</p>
<p>For something like player movement, you want it to be computed reliably as part
of your gameplay/physics simulation, but you also want it to look smooth on-screen.</p>
<p>For input handling, you want it to be responsive and handled every frame, but
you also have game mechanics that need to respond to it.</p>
<p>The most elegant solution to both of these problems is to handle synchonization
yourself using custom types.</p>
<p>å¹¶ä¸æ˜¯æ‰€æœ‰çš„systeméƒ½æœ‰ä¸ªæ˜æ˜¾çš„åˆ’åˆ†,ç»å¸¸ä¼šå‡ºç°é€»è¾‘å†²çª,å¸¸è§çš„æœ‰:</p>
<p>è§’è‰²ç§»åŠ¨,å¯ä»¥ä½œä¸ºæ¸¸æˆç‰©ç†æ¨¡æ‹Ÿçš„çš„å¯é è®¡ç®—é€»è¾‘,ä¹Ÿå¸Œæœ›åœ¨å±å¹•ä¸Šçœ‹èµ·æ¥ä¸æ»‘.
è¾“å…¥å¤„ç†,æ—¢éœ€è¦æ¯å¸§éƒ½å¤„ç†,ä¹Ÿå¸Œæœ›æ¸¸æˆæœºåˆ¶èƒ½å“åº”.</p>
<p>ç±»ä¼¼çš„é—®é¢˜,æœ€ä¼˜é›…çš„æ–¹å¼æ˜¯ä½¿ç”¨è‡ªå®šä¹‰çš„ç±»å‹æ¥å®ŒæˆåŒæ­¥.</p>
<h4 id="movement"><a class="header" href="#movement">Movement</a></h4>
<p>For player (and other) movement, you could create your own custom component type
to use instead of <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>. Implement your player movement using your own
types. Then have a system in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> to sync/update <a href="https://docs.rs/bevy/0.13.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> from that,
with some interpolation to make it look smooth.</p>
<pre><code class="language-rust no_run noplayground">// TODO show how to do this</code></pre>
<p>Transformç»„ä»¶è´Ÿè´£ç§»åŠ¨,ä¼˜é›…çš„æ–¹å¼æ˜¯åˆ›å»ºä¸€ä¸ªç±»ä¼¼çš„ç»„ä»¶æ¥è´Ÿè´£ç§»åŠ¨,
FixedUpdateè´Ÿè´£å†³ç­–,ä¸­é—´çš„å¡é¡¿é€šè¿‡åœ¨Updateä¸­è¿›è¡Œ<code>æ’å€¼</code>æ¥æ›´æ–°Transform,
é€šè¿‡è¿™ç§æ–¹å¼æ¥è¾¾åˆ°ç•Œé¢é¡ºæ»‘ä¸å¡é¡¿çš„ç›®çš„.</p>
<h4 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h4>
<p>If you use <a href="https://docs.rs/bevy/0.13.0/bevy/input/struct.ButtonInput.html"><code>Res&lt;ButtonInput&lt;...&gt;&gt;</code></a> and
<code>.just_pressed</code>/<code>.just_released</code> to check for key/button presses, beware that
the state is updated once per frame. This API is not reliable inside
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>. Use <a href="fundamentals//programming/events.html">events</a> for input handling instead, or roll
your own abstractions.</p>
<p>One way to do this is to put your input handling systems in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>, order
them after Bevy's <a href="https://docs.rs/bevy/0.13.0/bevy/input/struct.InputSystem.html"><code>InputSystem</code></a> <a href="fundamentals//programming/system-sets.html">set</a>, and do your input
handling there. Convert it into your own custom <a href="fundamentals//programming/events.html">event</a> types or some
other useful representation, which you can then handle from your gameplay code
in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">// TODO show how to do this</code></pre>
<p>æŒ‰é’®çš„æŒ‰é”®æ£€æµ‹æ˜¯æ¯å¸§æ£€æµ‹,æ”¾åœ¨è°ƒç”¨æ¬¡æ•°ä¸ç¡®å®šçš„FixedUpdateä¸­,ä¹Ÿä¸èƒ½ç¡®ä¿é€»è¾‘å·²ç»èƒ½æ‰§è¡Œ,
æ‰€ä»¥æ”¾åœ¨FixedUpdateå¹¶ä¸å¯é .è¯¥ä½¿ç”¨äº‹ä»¶ä»£æ›¿,æˆ–è‡ªå·±æ‰‹æ“æŠ½è±¡å±‚æ¥å®Œæˆ.</p>
<p>æœ‰ç§å®ç°æ–¹å¼æ˜¯è¿™æ ·çš„:åœ¨PreUpdate(æ¯å¸§è°ƒåº¦ä¸­,ä»…åœ¨Firstä¹‹å,åœ¨æŒ‚èµ·çŠ¶æ€å¤„ç†ä¹‹å)å¤„ç†è¾“å…¥,
é€šè¿‡bevyçš„InputSystem setä¸­è¿›è¡Œæ’åº,å°†è¾“å…¥å˜ä¸ºè‡ªå®šä¹‰äº‹ä»¶,ç„¶ååœ¨FixedUpdateä¸­å¤„ç†.</p>
<h2 id="timing-caveats"><a class="header" href="#timing-caveats">Timing Caveats</a></h2>
<p>Fixed timestep does not run in real-world time! You cannot rely on it for timing!</p>
<p>For example, if you try to play audio from it, or send network packets, you will
notice that they don't actually occur at the fixed timestep interval. They will
not be evenly spaced!</p>
<p>Your <a href="fundamentals//programming/systems.html">systems</a> are still called as part of the regular frame-update
cycle. Every frame update, Bevy will run the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> as many times as needed to catch up.</p>
<p>This means if you specify, for example, a 60 Hz fixed timestep interval, your
systems will not actually run in 1/60 second intervals in real time.</p>
<p>What will happen is the following:</p>
<ul>
<li>If the display frame rate is faster than the timestep, some frame update cycles
will skip the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> schedule entirely.</li>
<li>If the display frame rate is slower than the timestep, some frame update cycles
will run the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> multiple times.</li>
</ul>
<p>In any case, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> will run right before
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>, where your per-frame systems live.</p>
<p>å›ºå®šæ—¶é—´æˆ³ä¸æ˜¯çœŸå®æ—¶é—´,è®¡æ—¶ä¸èƒ½ä¾èµ–è¿™ä¸ª.</p>
<p>éŸ³é¢‘æ’­æ”¾/ç½‘ç»œå‘åŒ…,è¿™äº›éƒ½ä¸èƒ½ä»¥æ¥å›ºå®šæ—¶é—´æˆ³,è¿™ä¸ªè¿è¡Œé—´éš”å¹¶ä¸æ˜¯å›ºå®šæ­¥é•¿,
åªæ˜¯å¹³å‡èµ·æ¥æ˜¯å›ºå®šæ­¥é•¿.</p>
<p>å®é™…ä¸Šçš„è¿è¡Œå¯èƒ½æ˜¯ä»¥ä¸‹å‡ ç±»:</p>
<ul>
<li>å¸§ç‡æ¯”å›ºå®šæ—¶é—´æˆ³å¿«,FixedUpdateå¯èƒ½ä¼šå¿½ç•¥</li>
<li>å¸§ç‡æ¯”å›ºå®šæ—¶é—´æˆ³æ…¢,FixedUpdateå¯èƒ½ä¼šæ‰§è¡Œå¤šæ¬¡</li>
</ul>
<h2 id="additional-schedules"><a class="header" href="#additional-schedules">Additional Schedules</a></h2>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> is actually part of a larger <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a>, which also contains other <a href="fundamentals//programming/schedules.html">schedules</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedFirst.html"><code>FixedFirst</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPreUpdate.html"><code>FixedPreUpdate</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPostUpdate.html"><code>FixedPostUpdate</code></a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedLast.html"><code>FixedLast</code></a></li>
</ul>
<p>They are analogous to the <a href="fundamentals//programming/schedules.html">schedules</a> in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>, that run every
frame update. They can be used for analogous purposes (to contain "engine
systems" from Bevy and plugins).</p>
<p>ä¸Šé¢æ˜¯ä¸»è°ƒåº¦(Main)åœ¨æ¯å¸§çš„è°ƒåº¦é¡ºåº(ä¸æ˜¯é¦–å¸§çš„).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="gizmos"><a class="header" href="#gizmos">Gizmos</a></h1>
<p>// TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="general-graphics-features"><a class="header" href="#general-graphics-features">General Graphics Features</a></h1>
<p>This chapter covers general graphics-related features in Bevy, that are
relevant to both 2D and 3D games.</p>
<p>Bevy's rendering is driven by / configured via <a href="/graphics/camera.html">cameras</a>. Each
camera <a href="/programming/ec.html#entities">entity</a> will cause Bevy to render your game world,
as configured via the various <a href="/programming/ec.html#components">components</a> on the
<a href="/graphics/camera.html">camera</a>. You can enable all kinds of different workflows, as
well as optional effects, by adding the relevant components to your camera
and configuring them.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="cameras"><a class="header" href="#cameras">Cameras</a></h1>
<p>Cameras drive all rendering in Bevy. They are responsible for configuring what
to draw, how to draw it, and where to draw it.</p>
<p>Camerasé©±åŠ¨ç€Bevyå†…çš„å…¨éƒ¨æ¸²æŸ“. è¿™äº›ç›¸æœºè´Ÿè´£é…ç½®: ç»˜åˆ¶ä»€ä¹ˆ, å¦‚ä½•ç»˜åˆ¶, ä»¥åŠåœ¨å“ªé‡Œç»˜åˆ¶.</p>
<p>You must have at least one camera entity, in order for anything to be displayed
at all! If you forget to spawn a camera, you will get an empty black screen.</p>
<p>ä½ è‡³å°‘éœ€è¦ä¸€ä¸ªç›¸æœºå®ä½“, ä¸ºäº†æ˜¾ç¤ºä»»ä½•ä¸œè¥¿! å¦‚æœä½ å¿˜è®°spawnä¸€ä¸ªç›¸æœº, é‚£ä¹ˆä½ å°†ä¼šå¾—åˆ°ä¸€ä¸ªç©ºç©ºçš„é»‘è‰²å±å¹•.</p>
<p>In the simplest case, you can create a camera with the default settings. Just
spawn an entity using <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a> or
<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_3d/struct.Camera3dBundle.html"><code>Camera3dBundle</code></a>. It will simply draw all renderable
entities that are <a href="graphics//fundamentals/visibility.html">visible</a>.</p>
<p>æœ€ç®€å•çš„ä¾‹å­æ˜¯, ä½ èƒ½ç”¨é»˜è®¤çš„é…ç½®åˆ›å»ºä¸€ä¸ªç›¸æœº. æ¯”å¦‚ä½¿ç”¨Camera2dBundleæˆ–Camera3dBundle,
å®ƒå°†ä¼šç»˜åˆ¶ä»»ä½•å¯è§çš„å®ä½“.</p>
<p>This page gives a general overview of cameras in Bevy. Also see the dedicated
pages for <a href="graphics//2d/camera.html">2D cameras</a> and <a href="graphics//3d/camera.html">3D cameras</a>.</p>
<p>Practical advice: always create <a href="graphics//programming/ec.html#marker-components">marker components</a> for
your camera entities, so that you can <a href="graphics//programming/queries.html">query</a> your cameras easily!</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyGameCamera;

fn setup(mut commands: Commands) {
    commands.spawn((
        Camera3dBundle::default(),
        MyGameCamera,
    ));
}</code></pre>
<p>ç›¸æœºé©±åŠ¨ Bevy ä¸­çš„æ‰€æœ‰æ¸²æŸ“.ä»–ä»¬è´Ÿè´£é…ç½®ç»˜åˆ¶ä»€ä¹ˆã€å¦‚ä½•ç»˜åˆ¶ä»¥åŠåœ¨å“ªé‡Œç»˜åˆ¶.</p>
<blockquote>
<p>æˆ‘ç†è§£çš„æ¸¸æˆæ˜¯ä¸€ä¸ªä¸–ç•Œ,ç›¸æœºæ˜¯è§‚çœ‹ä¸–ç•Œçš„ä¸€ä¸ªè§†è§’,æˆ–ä¸€åŒçœ¼ç›.æ•´ä¸ªä¸–ç•Œéƒ½åœ¨è¿è¡Œç€,
ä½†æˆ‘ä»¬çš„è§†è§’åªèƒ½çœ‹åˆ°ä¸€éƒ¨åˆ†,bossçš„åˆ·æ–°ä¸åœ¨æˆ‘ä»¬è§†è§’ä¸­,ä½†åœ¨ä¸–ç•Œä¸­ç¡®å®å‘ç”Ÿäº†,
ä¸€ä¸ªç©å®¶åœ¨æ‰“æ€ª,ä¸åœ¨æˆ‘ä»¬è§†è§’ä¸­,æˆ‘ä»¬çš„ç”µè„‘ä¸Šçš„ç¨‹åºä¸ä¼šå¤„ç†è¿™ä¸ª,
ä½†å½“æˆ‘ä»¬èµ°è¿‘æ—¶,æœåŠ¡ç«¯ä¼šå°†è¿™éƒ¨åˆ†æ•°æ®åŒæ­¥è¿‡æ¥,æˆ‘ä¹Ÿçœ‹åˆ°äº†ä¸€ä¸ªç©å®¶åœ¨æ‰“æ€ª.</p>
</blockquote>
<p>è¦çœ‹åˆ°æ¸²æŸ“çš„ä¸œè¥¿,è‡³å°‘éœ€è¦ä¸€ä¸ªcameraå®ä½“,å¦‚æœå¿˜äº†åˆ›å»ºcameraå®ä½“,å•¥éƒ½çœ‹ä¸åˆ°.</p>
<p>åœ¨ä¸€äº›ç®€å•çš„ä¾‹å­ä¸­,cameraå¯ä»¥ä½¿ç”¨é»˜è®¤é…ç½®,bevyä¼šç®€å•ç»˜åˆ¶æ‰€æœ‰å¯è§†ä¸”èƒ½æ¸²æŸ“çš„å®ä½“.</p>
<p>æœ‰ä¸ªå»ºè®®:ç»™åˆ›å»ºçš„Cameraè´´ä¸€ä¸ªæ ‡ç­¾,è¿™æ ·æ–¹ä¾¿Query.è¿™æ ·çš„æ ‡ç­¾è¿˜æœ‰ä¸ªåè¯:<code>æ ‡ç­¾ç»„ä»¶</code>.</p>
<h2 id="the-camera-transform"><a class="header" href="#the-camera-transform">The Camera Transform</a></h2>
<p>Cameras have <a href="graphics//fundamentals/transforms.html">transforms</a>, which can be used to position or
rotate the camera. This is how you move the camera around.</p>
<p>For examples, see these <a href="graphics//cookbook.html">cookbook</a> pages:</p>
<ul>
<li><a href="graphics//cookbook/pan-orbit-camera.html">3D pan-orbit camera</a>, like in 3D editor apps</li>
</ul>
<p>If you are making a game, you should implement your own custom camera controls
that feel appropriate to your game's genre and gameplay.</p>
<p>cameraä¹Ÿæœ‰å˜æ¢,ä¹Ÿèƒ½ç§»åŠ¨ä½ç½®å’Œæ—‹è½¬ç›¸æœº,ä¹Ÿå°±æ˜¯ç›¸æœºç§»åŠ¨çš„æ–¹å¼.
åˆ¶ä½œbevyæ¸¸æˆ,åº”è¯¥è‡ªå®šä¹‰ç›¸æœºæ§åˆ¶ä½¿å…¶æ›´åŠ æœåŠ¡å’Œè‡ªå·±çš„æ¸¸æˆå’Œç©æ³•.</p>
<h3 id="zooming-the-camera"><a class="header" href="#zooming-the-camera">Zooming the camera</a></h3>
<p>Do not use the transform scale to "zoom" a camera! It just stretches the image,
which is not "zooming". It might also cause other issues and incompatibilities.
Use the <a href="graphics//graphics/camera.html#projection">projection</a> to zoom.</p>
<p>For an orthographic projection, change the scale. For a perspective projection,
change the FOV. The FOV mimics the effect of zooming with a lens.</p>
<p>Learn more about how to do this in <a href="graphics//2d/camera.html#projection">2D</a> or
<a href="graphics//3d/camera.html#projection">3D</a>.</p>
<p>ç›¸æœºçš„èšç„¦(zoom)ä¸æ˜¯ç¼©æ”¾,ç¼©æ”¾æ˜¯æ‹‰ä¼¸,ä¸æ˜¯èšç„¦,ä½¿ç”¨ç¼©æ”¾æ¥å®ç°èšç„¦ä¼šæœ‰å„ç§é—®é¢˜,
æ­£ç¡®çš„æ–¹å¼åº”è¯¥æ˜¯<code>æŠ•å½±</code>.</p>
<p>å¯¹äº<code>æ­£äº¤æŠ•å½±</code>,åº”è¯¥æ”¹ä¸ºç¼©æ”¾;å¯¹äº<code>é€è§†æŠ•å½±</code>,æ”¹ä¸º<code>FOV</code>,FOVæ¨¡ä»¿äº†é•œå¤´å˜ç„¦çš„æ•ˆæœ.</p>
<ul>
<li>æ­£äº¤æŠ•å½±çš„ç‰¹ç‚¹æ˜¯éšç€è¿œè¿‘,æŠ•å½±ç‰©ä½“æ²¡æœ‰å¤§å°å˜åŒ–</li>
<li>é€è§†æŠ•å½±åˆ™æœ‰è¿œå°è¿‘å¤§çš„ç‰¹ç‚¹</li>
</ul>
<h2 id="projection"><a class="header" href="#projection">Projection</a></h2>
<p>The camera projection is responsible for mapping the coordinate system to the
viewport (commonly, the screen/window). It is what configures the coordinate
space, as well as any scaling/stretching of the image.</p>
<p>Bevy provides two kinds of projections:
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> and
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>. They are configurable,
to be able to serve a variety of different use cases.</p>
<p>Orthographic means that everything always appears the same size, regardless of
how far away it is from the camera.</p>
<p>Perspective means that things appear smaller the further away they are from
the camera. This is the effect that gives 3D graphics a sense of depth and
distance.</p>
<p><a href="graphics//2d/camera.html">2D cameras</a> are always orthographic.</p>
<p><a href="graphics//3d/camera.html">3D cameras</a> can use either kind of projection. Perspective is
the most common (and default) choice. Orthographic is useful for applications
such as CAD and engineering, where you want to accurately represent the
dimensions of an object, instead of creating a realistic sense of 3D space. Some
games (notably simulation games) use orthographic as an artistic choice.</p>
<p>It is possible to implement your own <a href="graphics//cookbook/custom-projection.html">custom camera
projections</a>. This can give you full control over
the coordinate system. However, beware that things might behave in unexpected
ways if you violate Bevy's <a href="graphics//fundamentals/coords.html">coordinate system conventions</a>!</p>
<p>ç›¸æœºæŠ•å½±è´Ÿè´£å°†åæ ‡ç³»æ˜ å°„åˆ°çª—å£è§†è§’(é€šå¸¸æ˜¯å±å¹•æˆ–çª—å£),è¿™é‡Œçš„ç›¸æœºæŠ•å½±å°±æ˜¯é…ç½®åæ ‡ç³»,
ä»¥åŠå›¾åƒçš„ç¼©æ”¾å’Œæ‹‰ä¼¸.
bevyæä¾›äº†<code>OrthographicProjection</code>æ­£äº¤æŠ•å½±å’Œ<code>PerspectiveProjection</code>é€è§†æŠ•å½±ä¸¤ç§,
ä¸¤è€…å‡å¯é…ç½®,é€‚ç”¨äºä¸åŒåœºæ™¯.</p>
<p>æ­£äº¤æ„å‘³ç€æ‰€æœ‰ç‰©ä½“å§‹ç»ˆæ˜¾ç¤ºç›¸åŒçš„å°ºå¯¸,æ— è®ºè·ç›¸æœºæœ‰å¤šè¿œ.<br />
é€è§†æ„å‘³ç€ç‰©ä½“è·ç¦»ç›¸æœºè¶Šè¿œ,çœ‹èµ·æ¥å°±è¶Šå°.è¿™ç§æ•ˆæœèµ‹äºˆ 3D å›¾å½¢æ·±åº¦æ„Ÿå’Œè·ç¦»æ„Ÿ.</p>
<p>2dæ¸¸æˆä½¿ç”¨æ­£äº¤,3dæ¸¸æˆä¸¤ç§éƒ½å¯ä»¥ä½¿ç”¨,ä½†é€è§†æ›´åŠ å¸¸ç”¨.</p>
<p>æ­£äº¤å¯¹äº CAD å’Œå·¥ç¨‹ç­‰åº”ç”¨ç¨‹åºéå¸¸æœ‰ç”¨,åœ¨è¿™äº›åº”ç”¨ç¨‹åºä¸­,æ‚¨å¸Œæœ›å‡†ç¡®è¡¨ç¤ºå¯¹è±¡çš„å°ºå¯¸,
è€Œä¸æ˜¯åˆ›å»ºé€¼çœŸçš„ 3D ç©ºé—´æ„Ÿ.ä¸€äº›æ¸¸æˆï¼ˆå°¤å…¶æ˜¯æ¨¡æ‹Ÿæ¸¸æˆï¼‰ä½¿ç”¨æ­£äº¤æ–‡å­—ä½œä¸ºè‰ºæœ¯é€‰æ‹©.</p>
<p>ä¹Ÿå¯ä»¥è‡ªå®šä¹‰ç›¸æœºå±æ€§,è¿™æ ·å°±å¯ä»¥å®Œå…¨æ§åˆ¶åæ ‡ä½“ç³»,ä½†éœ€è¦æ³¨æ„:éµå¾ªbevyçš„åæ ‡ä½“ç³»è§„åˆ™.</p>
<h2 id="hdr-and-tonemapping"><a class="header" href="#hdr-and-tonemapping">HDR and Tonemapping</a></h2>
<p><a href="graphics//graphics/hdr-tonemap.html">See here!</a></p>
<p>é«˜åŠ¨æ€èŒƒå›´å›¾ç‰‡å’Œè‰²è°ƒæ˜ å°„,è§ä¸‹ä¸€ç« .</p>
<h2 id="render-target"><a class="header" href="#render-target">Render Target</a></h2>
<p>The render target of a camera determines where the GPU will draw things to. It
could be a window (for outputting directly to the screen) or an
<a href="https://docs.rs/bevy/0.12.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> <a href="graphics//assets.html">asset</a> (render-to-texture).</p>
<p>By default, cameras output to the primary window.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::RenderTarget;

fn debug_render_targets(
    q: Query&lt;&amp;Camera&gt;,
) {
    for camera in &amp;q {
        match &amp;camera.target {
            RenderTarget::Window(wid) =&gt; {
                eprintln!("Camera renders to window with id: {:?}", wid);
            }
            RenderTarget::Image(handle) =&gt; {
                eprintln!("Camera renders to image asset with id: {:?}", handle);
            }
            RenderTarget::TextureView(_) =&gt; {
                eprintln!("This is a special camera that outputs to something outside of Bevy.");
            }
        }
    }
}</code></pre>
<p>ç›¸æœºçš„æ¸²æŸ“ç›®æ ‡å†³å®šäº†GPUä¼šç»˜åˆ¶é‚£äº›å¯¹è±¡,å¯èƒ½æ˜¯çª—å£(ç›´æ¥æ¸²æŸ“åˆ°å±å¹•),å¯èƒ½æ˜¯å›¾ç‰‡èµ„äº§(æ¸²æŸ“åˆ°çº¹ç†).
é»˜è®¤,ç›¸æœºè¾“å‡ºåˆ°ä¸»çª—å£.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RenderTarget {
    Window(WindowRef),
    Image(Handle&lt;Image&gt;),
    TextureView(ManualTextureViewHandle),
}
<span class="boring">}</span></code></pre></pre>
<p>è¿™3ç§å¯¹è±¡ä¾æ¬¡æ˜¯:</p>
<ul>
<li>ç›¸æœºæ¸²æŸ“åˆ°çª—å£</li>
<li>ç›¸æœºæ¸²æŸ“åˆ°Image</li>
<li>ç›¸æœºæ¸²æŸ“åˆ°çº¹ç†è§†å›¾,ç‰¹åˆ«é€‚åˆåœ¨bevyä¹‹å¤–äº§ç”Ÿçº¹ç†è¯•å›¾çš„åœºæ™¯(eg:å¤–éƒ¨XRä¸­åˆ›å»ºå’Œç®¡ç†çº¹ç†è¯•å›¾,ä¼ ç»™bevyåšæ¸²æŸ“)</li>
</ul>
<h2 id="viewport"><a class="header" href="#viewport">Viewport</a></h2>
<p>The viewport is an (optional) way to restrict a camera to a sub-area of its
render target, defined as a rectangle. That rectangle is effectively treated as
the "window" to draw in.</p>
<p>An obvious use-case are split-screen games, where you want a camera to only draw
to one half of the screen.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::Viewport;

fn setup_minimap(mut commands: Commands) {
    commands.spawn((
        Camera2dBundle {
            camera: Camera {
                // renders after / on top of other cameras
                order: 2,
                // set the viewport to a 256x256 square in the top left corner
                viewport: Some(Viewport {
                    physical_position: UVec2::new(0, 0),
                    physical_size: UVec2::new(256, 256),
                    ..default()
                }),
                ..default()
            },
            ..default()
        },
        MyMinimapCamera,
    ));
}</code></pre>
<p>If you need to find out the area a camera renders to (the viewport, if
configured, or the entire window, if not):</p>
<pre><code class="language-rust no_run noplayground">fn debug_viewports(
    q: Query&lt;&amp;Camera, With&lt;MyExtraCamera&gt;&gt;,
) {
    let camera = q.single();

    // the size of the area being rendered to
    let view_dimensions = camera.logical_viewport_size().unwrap();

    // the coordinates of the rectangle covered by the viewport
    let rect = camera.logical_viewport_rect().unwrap();
}</code></pre>
<p>è§†çª—æ˜¯ä¸€ç§å°†å–éƒ¨åˆ†ç›¸æœºè§†è§’çš„æ–¹æ¡ˆä¹‹ä¸€.è§†çª—é€šå¸¸æ˜¯çŸ©å½¢,æ˜¯çŸ©å½¢æ‰€ä»¥ä½œä¸ºçª—å£ç»˜åˆ¶æ—¶å°±å¾ˆé«˜æ•ˆ.
ä¸€ä¸ªå¸¸è§çš„åº”ç”¨åœºæ™¯æ˜¯åˆ†å±æ¸¸æˆ,ä¸€ä¸ªç›¸æœºåªç»˜åˆ¶åˆ°åŠä¸ªå±å¹•.</p>
<p>ä¸Šé¢çš„ä¾‹å­æ˜¾ç¤ºäº†ç›¸æœºåˆ¶å®šè§†çª—å±æ€§çš„ä¾‹å­,å¹¶å–ç›¸æœºè§†çª—çš„çš„çŸ©å½¢åæ ‡å¤§å°å’Œæ¸²æŸ“åŒºåŸŸå¤§å°.</p>
<h2 id="coordinate-conversion"><a class="header" href="#coordinate-conversion">Coordinate Conversion</a></h2>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a> provides methods to help with coordinate conversion
between on-screen coordinates and world-space coordinates. For an example, see
the <a href="graphics//cookbook/cursor2world.html">"cursor to world"</a> cookbook page.</p>
<p>ç›¸æœºæä¾›äº†ä¸å°‘æ–¹æ³•æ¥è¿›è¡Œå±å¹•åæ ‡å’Œä¸–ç•Œåæ ‡çš„è½¬æ¢.</p>
<h2 id="clear-color"><a class="header" href="#clear-color">Clear Color</a></h2>
<p>This is the "background color" that the whole viewport will be cleared to,
before a camera renders anything.</p>
<p>You can also disable clearing on a camera, if you want to preserve all the
pixels as they were before.</p>
<p><a href="graphics//window/clear-color.html">See this page for more info.</a></p>
<p>èƒŒæ™¯è‰²å…¶å®æ˜¯æ•´ä¸ªè§†çª—åˆ·ä¸Šçš„é¢œè‰²,åœ¨ç›¸æœºæ¸²æŸ“ä¹‹å‰å°±å®Œæˆäº†.</p>
<p>ç›¸æœºå¯ä»¥disableé¢œè‰²æ“¦é™¤,åšå±€éƒ¨æ›´æ–°æ—¶å¯ä»¥ç”¨åˆ°.</p>
<h2 id="render-layers"><a class="header" href="#render-layers">Render Layers</a></h2>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/struct.RenderLayers.html"><code>RenderLayers</code></a> is a way to filter what entities should be
drawn by what cameras. Insert this <a href="graphics//programming/ec.html#components">component</a> onto your entities
to place them in specific "layers". The layers are integers from 0 to 31 (32
total available).</p>
<p>Inserting this component onto a camera entity selects what layers that camera
should render. Inserting this component onto renderable entities selects what
cameras should render those entities. An entity will be rendered if there is any
overlap between the camera's layers and the entity's layers (they have at least
one layer in common).</p>
<p>If an entity does not have the <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/struct.RenderLayers.html"><code>RenderLayers</code></a> component,
it is assumed to belong to layer 0 (only).</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::visibility::RenderLayers;
// This camera renders everything in layers 0, 1
commands.spawn((
    Camera2dBundle::default(),
    RenderLayers::from_layers(&amp;[0, 1])
));
// This camera renders everything in layers 1, 2
commands.spawn((
    Camera2dBundle::default(),
    RenderLayers::from_layers(&amp;[1, 2])
));
// This sprite will only be seen by the first camera
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(0),
));
// This sprite will be seen by both cameras
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(1),
));
// This sprite will only be seen by the second camera
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(2),
));
// This sprite will also be seen by both cameras
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::from_layers(&amp;[0, 2]),
));</code></pre>
<p>You can also modify the render layers of entities after they are spawned.</p>
<p>é€šè¿‡æ¸²æŸ“åˆ†å±‚è¿™ä¸ªç»„ä»¶,ç›¸æœºå¯ä»¥è¿‡æ»¤æ‰ä¸€äº›å®ä½“.
åˆ†å±‚æœ‰32ä¸ª,æ„å»ºç›¸æœºæ—¶é€šè¿‡RenderLayersç»„ä»¶è®¾ç½®åˆ†å±‚,å°±é…ç½®ç›¸æœºå…³å¿ƒçš„åˆ†å±‚åˆ—è¡¨.
åŒç†,æ„å»ºå®ä½“æ—¶ä¹Ÿéœ€è¦æŒ‡å®šåˆ†å±‚åˆ—è¡¨.å¦‚æœç›¸æœºå’Œå¯æ¸²æŸ“å®ä½“çš„åˆ†å±‚åˆ—è¡¨æœ‰é‡å ,
åˆ™è¿›è¡Œæ¸²æŸ“.</p>
<p>åœ¨å®ä½“æ„å»ºåæ˜¯å¯ä»¥ä¿®æ”¹è¿™ä¸ªåˆ†å±‚å±æ€§çš„.</p>
<blockquote>
<p>æ¸²æŸ“åˆ†å±‚æè¿°äº†ä¸€ä¸ªå®ä½“å±äºå“ªäº›æ¸²æŸ“å±‚.ç›¸æœºå¯ä»¥å¯ä»¥åˆ©ç”¨åˆ†å±‚æ¥è¿‡æ»¤å…¶ä»–å±‚çš„å®ä½“,
å…³äºæ¸²æŸ“åˆ†å±‚æœ‰ä»¥ä¸‹å‡ æ¡è§„åˆ™:</p>
</blockquote>
<ol>
<li>å®ä½“å¯ä»¥å±äºå¤šä¸ªå±‚,ä¹Ÿå¯ä»¥ä¸€ä¸ªå±‚éƒ½ä¸æŒ‡å®š</li>
<li>ç¬¬ä¸€å±‚ä¸º layer 0, å¸¦RenderLayersç»„ä»¶çš„å®ä½“,å…¶é»˜è®¤åˆ†å±‚å°±æ˜¯0</li>
<li>ä¸å¸¦RenderLayersç»„ä»¶çš„å®ä½“,bevyä¼šç»™ä¸ªé»˜è®¤åˆ†å±‚:0</li>
<li>å¸¦RenderLayersç»„ä»¶çš„å®ä½“,å¦‚æœä¸å¸¦ä»»ä½•åˆ†å±‚,åˆ™ä¸å¯è§</li>
</ol>
<h2 id="camera-ordering"><a class="header" href="#camera-ordering">Camera Ordering</a></h2>
<p>A camera's <code>order</code> is a simple integer value that controls the order relative
to any other cameras with the same render target.</p>
<p>For example, if you have multiple cameras that all render to the primary window,
they will behave as multiple "layers". Cameras with a higher order value will render
"on top of" cameras with a lower value. <code>0</code> is the default.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::clear_color::ClearColorConfig;

commands.spawn((
    Camera2dBundle {
        camera_2d: Camera2d {
            // no "background color", we need to see the main camera's output
            clear_color: ClearColorConfig::None,
            ..default()
        },
        camera: Camera {
            // renders after / on top of the main camera
            order: 1,
            ..default()
        },
        ..default()
    },
    MyOverlayCamera,
));</code></pre>
<p>ç›¸æœºé¡ºåº.</p>
<p>å¯èƒ½æœ‰è¿™æ ·çš„éœ€æ±‚: å¤šä¸ªç›¸æœºéƒ½æ¸²æŸ“åˆ°ä¸»çª—å£,è¿™æ ·å¤šä¸ªç›¸æœºå°±ç›¸å½“äºå¤šå±‚,
åœ¨æ¸²æŸ“æ—¶é€šè¿‡ç›¸æœºå±æ€§order(ä¸€ä¸ªæ•´æ•°,é»˜è®¤ä¸º0)æ¥å†³å®šé¡ºåº,
orderè¶Šå¤§,æ¸²æŸ“åœ¨æœ€å‰é¢.</p>
<hr />
<p>å¤šç›¸æœºå°±æ˜¯å¤šè§†è§’,æœ‰ä»¥ä¸‹åœºæ™¯éƒ½ä¼šåŒ…å«å¤šç›¸æœº,å¯ä»¥è¯´æœ€æœ€å¸¸è§äº†:</p>
<ul>
<li>é™¤äº†ä¸Šé¢æåˆ°çš„åˆ†å±æ¸¸æˆ,è¿˜æœ‰é©¾é©¶æ¸¸æˆ(é©¾é©¶å‘˜è§†è§’å’Œåè§†é•œè§†è§’)</li>
<li>UI å±‚å’Œæ¸¸æˆä¸–ç•Œå±‚åˆ†ç¦»(uiæ˜¯ç”¨æˆ·ç•Œé¢,ä¹Ÿå°±æ˜¯æ¸¸æˆè®¾ç½®ç•Œé¢,å¦‚æœè¦æ˜¾ç¤º,ä¸€å®šæ˜¯åœ¨æ¸¸æˆä¸–ç•Œä¹‹ä¸Š)</li>
<li>åå¤„ç†æ•ˆæœ(ä¸€ä¸ªç›¸æœºæ¸²æŸ“åœºæ™¯,å¦ä¸€ä¸ªç›¸æœºå°†æ¸²æŸ“ç»“æœåº”ç”¨åˆ°å±å¹•ä¸Š,å¹¶æ·»åŠ åå¤„ç†æ•ˆæœ,å¦‚æ¨¡ç³Šã€è‰²å½©æ ¡æ­£,ç›®çš„æ˜¯å®ç°å¤æ‚çš„æ•ˆæœ)</li>
<li>æ·±åº¦å›¾å’Œé˜´å½±å›¾ç”Ÿæˆ(ä¸€ä¸ªç›¸æœºæ­£å¸¸æ¸²æŸ“,å¦ä¸€ä¸ªç›¸æœºæ¸²æŸ“æ·±åº¦å›¾å’Œé˜´å½±å›¾,å®ç°å…‰ç…§å’Œé˜´å½±æ•ˆæœ)</li>
<li>å°åœ°å›¾æˆ–é•œåƒ</li>
</ul>
<p>å¤šç›¸æœºå¯ä»¥åˆ›å»ºæ›´åŠ ä¸°å¯Œå’Œå¤æ‚çš„æ¸¸æˆä½“éªŒ.</p>
<h2 id="ui-rendering"><a class="header" href="#ui-rendering">UI Rendering</a></h2>
<p>Bevy UI rendering is integrated into the cameras! Every camera will, by default,
also draw UI.</p>
<p>However, if you are working with multiple cameras, you probably only want your
UI to be drawn once (probably by the main camera). You can disable UI rendering
on your other cameras.</p>
<p>Also, UI on multiple cameras is currently broken in Bevy. Even if you want
multiple UI cameras (say, to display UI in an app with multiple windows), it
does not work correctly.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle::default(),
    // UI config is a separate component
    UiCameraConfig {
        show_ui: false,
    },
    MyExtraCamera,
));</code></pre>
<p>uiæ¸²æŸ“å·²ç»é›†æˆåˆ°ç›¸æœºä¸­äº†,æ‰€ä»¥åœ¨ç›¸æœºä¸­å°±èƒ½ä½¿ç”¨ui.
å¦‚æœæ˜¯å¤šç›¸æœºæ¨¡å¼,å¤§éƒ¨åˆ†åœºæ™¯ä¸‹,æˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªuiæ˜¾ç¤ºåœ¨ä¸»ç›¸æœºä¸­.</p>
<p>å¦å¤–bevyç°åœ¨åœ¨å¤šç›¸æœºä¸­æ˜¾ç¤ºuiçš„åŠŸèƒ½æœ‰åæŸ,å³ä½¿æƒ³è¿™ä¹ˆå¹²,ä¹Ÿä¼šè¿è¡Œå¼‚å¸¸.</p>
<hr />
<p>bevyçš„uiæ˜¯ä¸€ä¸ªæ¡†æ¶,uiä¸­åŒ…å«æŒ‰é’®/å›¾ç‰‡/æ–‡æœ¬/å¸ƒå±€,åŸºäºECSå®ç°çš„.ä¸»è¦åŒ…å«ä»¥ä¸‹å…ƒç´ .</p>
<ul>
<li>èŠ‚ç‚¹(Node):å®šä¹‰ UI å…ƒç´ çš„å¤§å°å’Œä½ç½®.èŠ‚ç‚¹æ˜¯æ‰€æœ‰ UI å…ƒç´ çš„åŸºç¡€ç»„ä»¶.</li>
<li>æ ·å¼(Style):å®šä¹‰ UI å…ƒç´ çš„å¸ƒå±€å’Œå¯¹é½æ–¹å¼,åŒ…æ‹¬å¤§å°ã€ä½ç½®ã€è¾¹è·ã€å¡«å……ç­‰.</li>
<li>é¢œè‰²(Color):å®šä¹‰ UI å…ƒç´ çš„èƒŒæ™¯é¢œè‰².</li>
<li>æ–‡æœ¬(Text):æ˜¾ç¤ºæ–‡å­—å†…å®¹,å¯ä»¥è®¾ç½®å­—ä½“ã€å¤§å°ã€é¢œè‰²ç­‰å±æ€§.</li>
<li>å›¾ç‰‡(Image):æ˜¾ç¤ºå›¾ç‰‡å†…å®¹.</li>
<li>äº¤äº’(Interaction):ç”¨äºå¤„ç†ç”¨æˆ·äº¤äº’,å¦‚ç‚¹å‡»å’Œæ‚¬åœ.</li>
</ul>
<p>uiå¸¸ç”¨äºä»¥ä¸‹åœºæ™¯:</p>
<ul>
<li>ä¸»èœå•å’Œè®¾ç½®ç•Œé¢ï¼šåˆ›å»ºæ¸¸æˆçš„ä¸»èœå•ã€é€‰é¡¹èœå•å’Œè®¾ç½®ç•Œé¢,å…è®¸ç©å®¶é€‰æ‹©æ¸¸æˆæ¨¡å¼ã€è°ƒæ•´éŸ³é‡ã€è®¾ç½®å›¾åƒè´¨é‡ç­‰.</li>
<li>HUDï¼ˆHeads-Up Displayï¼‰ï¼šæ˜¾ç¤ºæ¸¸æˆä¸­çš„å®æ—¶ä¿¡æ¯,ä¾‹å¦‚ç©å®¶çš„ç”Ÿå‘½å€¼ã€åˆ†æ•°ã€å‰©ä½™æ—¶é—´ã€å¼¹è¯æ•°é‡ç­‰.</li>
<li>å¯¹è¯æ¡†å’Œæç¤ºï¼šå±•ç¤ºæ¸¸æˆä¸­çš„å¯¹è¯ã€ä»»åŠ¡æç¤ºã€æç¤ºä¿¡æ¯ç­‰.</li>
<li>äº¤äº’ç•Œé¢ï¼šåˆ›å»ºæŒ‰é’®ã€æ»‘å—ã€å¤é€‰æ¡†ç­‰äº¤äº’å…ƒç´ ,å…è®¸ç©å®¶ä¸æ¸¸æˆè¿›è¡Œäº’åŠ¨.</li>
<li>ä¿¡æ¯é¢æ¿å’Œç»Ÿè®¡æ•°æ®ï¼šæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯å’Œç»Ÿè®¡æ•°æ®,ä¾‹å¦‚è§’è‰²å±æ€§ã€ç‰©å“æè¿°ã€æˆ˜æ–—ç»“æœç­‰.</li>
<li>æš‚åœèœå•ï¼šåœ¨æ¸¸æˆè¿‡ç¨‹ä¸­å…è®¸ç©å®¶æš‚åœæ¸¸æˆ,å¹¶æ˜¾ç¤ºæš‚åœèœå•,æä¾›ç»§ç»­æ¸¸æˆã€é€€å‡ºæ¸¸æˆç­‰é€‰é¡¹.</li>
</ul>
<p>ä¹Ÿå¯ä»¥åŸºäºuiåšæ¸¸æˆ:</p>
<ul>
<li>å¡ç‰Œæ¸¸æˆï¼šä¾‹å¦‚æ‰‘å…‹ç‰Œã€çº¸ç‰Œæ¸¸æˆç­‰,å¯ä»¥é€šè¿‡ UI ç³»ç»Ÿåˆ›å»ºå¡ç‰Œã€ç‰Œå †ã€æŒ‰é’®ç­‰å…ƒç´ ,å®ç°æ‹–æ‹½ã€ç‚¹å‡»ç­‰äº¤äº’.</li>
<li>æ£‹ç›˜æ¸¸æˆï¼šä¾‹å¦‚å›½é™…è±¡æ£‹ã€å›´æ£‹ç­‰,å¯ä»¥é€šè¿‡ UI ç³»ç»Ÿåˆ›å»ºæ£‹ç›˜ã€æ£‹å­,å¹¶å¤„ç†ç©å®¶çš„ç‚¹å‡»å’Œç§»åŠ¨æ“ä½œ.</li>
<li>æ–‡å­—å†’é™©æ¸¸æˆï¼šé€šè¿‡ UI ç³»ç»Ÿåˆ›å»ºæ–‡æœ¬å¯¹è¯æ¡†ã€é€‰æ‹©æŒ‰é’®ç­‰,ç©å®¶å¯ä»¥é€šè¿‡é€‰æ‹©ä¸åŒçš„é€‰é¡¹æ¨åŠ¨æ•…äº‹å‘å±•.</li>
<li>ç‚¹å‡»æ¸¸æˆï¼šä¾‹å¦‚ç‚¹å‡»æ¨¡æ‹Ÿå™¨,é€šè¿‡ UI ç³»ç»Ÿåˆ›å»ºæŒ‰é’®ã€è®¡åˆ†æ¿ç­‰å…ƒç´ ,ç©å®¶é€šè¿‡ç‚¹å‡»æŒ‰é’®è¿›è¡Œæ¸¸æˆ.</li>
</ul>
<h2 id="disabling-cameras"><a class="header" href="#disabling-cameras">Disabling Cameras</a></h2>
<p>You can deactivate a camera without despawning it. This is useful when you want
to preserve the camera entity and all the configuration it carries, so you can
easily re-enable it later.</p>
<p>Some example use cases: toggling an overlay, switching between a 2D and 3D view.</p>
<pre><code class="language-rust no_run noplayground">fn toggle_overlay(
    mut q: Query&lt;&amp;mut Camera, With&lt;MyOverlayCamera&gt;&gt;,
) {
    let mut camera = q.single_mut();
    camera.is_active = !camera.is_active;
}</code></pre>
<p>å¯ä»¥åœ¨ä¸é”€æ¯ç›¸æœºå®ä½“çš„æƒ…å†µä¸‹,<code>åœç”¨</code>.ä¿ç•™ç›¸æœºå®ä½“ä»¥åŠé…ç½®,æ–¹ä¾¿åé¢é‡ç”¨.</p>
<p>æœ‰äº›ä¾‹å­æ˜¯é€šè¿‡å¼€å…³æ§åˆ¶2d/3dçš„åˆ‡æ¢,åå¤åˆ‡æ¢ä¸­,<code>åœç”¨</code>å°±å¾ˆå¥½ç”¨.</p>
<h2 id="multiple-cameras"><a class="header" href="#multiple-cameras">Multiple Cameras</a></h2>
<p>This is an overview of different scenarios where you would need more than one
camera entity.</p>
<p>ä¸‹é¢æ˜¯éœ€è¦ä½¿ç”¨å¤šç›¸æœºçš„åœºæ™¯.</p>
<h3 id="multiple-windows"><a class="header" href="#multiple-windows">Multiple Windows</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/window/multiple_windows.rs"><code>multiple_windows</code></a>.</p>
<p>If you want to create a Bevy app with multiple windows, you need to spawn
multiple cameras, one for each window, and set their render targets
respectively. Then, you can use your cameras to control what to display in each
window.</p>
<p>å¤šçª—å£å¿…é¡»è¦è¦å¤šç›¸æœº.</p>
<h3 id="split-screen"><a class="header" href="#split-screen">Split-Screen</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/3d/split_screen.rs"><code>split_screen</code></a>.</p>
<p>You can set the camera <a href="graphics/camera.html#viewport">viewport</a> to only render to a part of the
render target. This way, a camera can be made to render one half of the screen
(or any other area). Use a separate camera for each view in a split-screen game.</p>
<p>åˆ†å±.ç›¸æœºåªæ¸²æŸ“åˆ°æ¸²æŸ“å¯¹è±¡çš„ä¸€éƒ¨åˆ†åŒºåŸŸ.</p>
<h3 id="overlays"><a class="header" href="#overlays">Overlays</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/3d/two_passes.rs"><code>two_passes</code></a>.</p>
<p>You might want to render multiple "layers" (passes) to the same render target.
An example of this might be an overlay/HUD to be displayed on top of the
main game.</p>
<p>The overlay camera could be completely different from the main camera. For
example, the main camera might draw a 3D scene, and the overlay camera might
draw 2D shapes. Such use cases are possible!</p>
<p>Use a separate camera to create the overlay. Set the <a href="graphics/camera.html#priority">priority</a>
higher, to tell Bevy to render it after (on top of) the main camera. Make sure
to disable <a href="graphics/camera.html#clear-color">clearing</a>!</p>
<p>Think about which camera you want to be responsible for <a href="graphics/camera.html#ui-rendering">rendering the
UI</a>. Use the overlay camera if you want it to be unaffected,
or use the main camera if you want the overlay to be on top of the UI. Disable
it on the other camera.</p>
<p>Use <a href="graphics/camera.html#render-layers">Render Layers</a> to control what entities should be rendered
by each camera.</p>
<p>è¦†ç›–.æ¸¸æˆé¡¶éƒ¨çš„è¦†ç›–å±‚,æ˜¯å¦ä¸€ä¸ªç›¸æœºåšçš„æ¸²æŸ“,å› ä¸ºåœ¨é¡¶éƒ¨,è¿˜æœ‰ä¸ªåè¯HUD(æŠ¬å¤´æ˜¾).</p>
<p>è¦†ç›–ç›¸æœºå’Œä¸»ç›¸æœºå¾ˆä¸ä¸€æ ·,ä¸»ç›¸æœºå¯èƒ½æ˜¯3dæ¸¸æˆ,è¦†ç›–ç›¸æœºå¤§å¤šæ˜¯2dçš„.</p>
<p>å¤šä¸ªç›¸æœºè¦†ç›–æ—¶,è¦ç¡®ä¿é¡ºåºæ›´é«˜çš„ç›¸æœºè¦ç¦æ­¢æ¸…ç†èƒŒæ™¯è‰².</p>
<p>æ€è€ƒä¸€ä¸‹,uiåº”è¯¥é€šè¿‡é‚£ä¸ªç›¸æœºæ˜¾ç¤º:</p>
<ul>
<li>å¦‚æœæƒ³ä¸å—å½±å“,ä½¿ç”¨è¦†ç›–ç›¸æœº</li>
<li>å¦‚æœæƒ³åšæˆhud,ä½¿ç”¨ä¸»ç›¸æœº,å¹¶åœ¨å…¶ä»–ç›¸æœºä¸­disabe ui</li>
</ul>
<p>ç”¨æ¸²æŸ“åˆ†å±‚æ¥æ§åˆ¶æ¯ä¸ªç›¸æœºè¦æ¸²æŸ“çš„å®ä½“.</p>
<h3 id="render-to-image"><a class="header" href="#render-to-image">Render to Image</a></h3>
<p>(aka Render to Texture)</p>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/3d/render_to_texture.rs"><code>render_to_texture</code></a>.</p>
<p>If you want to generate an image in memory, you can output to an <code>Image</code> asset.</p>
<p>This is useful for intermediate steps in games, such as rendering a minimap or
the gun in a shooter game. You can then use that image as part of the final
scene to render to the screen. Item previews are a similar use case.</p>
<p>Another use case is window-less applications that want to generate image files.
For example, you could use Bevy to render something, and then export it to a PNG
file.</p>
<p>æ¸²æŸ“åˆ°Image,ä¹Ÿç§°ä½œæ¸²æŸ“åˆ°çº¹ç†.</p>
<p>å¦‚æœåœ¨å†…å­˜ä¸­ç”Ÿæˆäº†ä¸€å¼ å›¾,å¯ä»¥è¾“å‡ºåˆ°Imageçš„èµ„äº§ä¸­.
è¿™å¯¹äºæ¸¸æˆä¸­çš„ä¸­é—´æ­¥éª¤éå¸¸æœ‰ç”¨,ä¾‹å¦‚åœ¨å°„å‡»æ¸¸æˆä¸­æ¸²æŸ“å°åœ°å›¾æˆ–æª.
ç„¶å,æ‚¨å¯ä»¥ä½¿ç”¨è¯¥å›¾åƒä½œä¸ºæœ€ç»ˆåœºæ™¯çš„ä¸€éƒ¨åˆ†æ¸²æŸ“åˆ°å±å¹•ä¸Š.ç‰©å“é¢„è§ˆæ˜¯ä¸€ä¸ªç±»ä¼¼çš„ç”¨ä¾‹.</p>
<p>å¦ä¸€ä¸ªåœºæ™¯æ˜¯ç”Ÿæˆå›¾ç‰‡,eg:åˆ°å¤„ä¸€å¼ pngå›¾ç‰‡.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="hdr"><a class="header" href="#hdr">HDR</a></h1>
<p>HDR (High Dynamic Range) refers to the ability of the game engine to handle
very bright lights or colors. Bevy's rendering is HDR internally. This means
you can have objects with colors that go above <code>1.0</code>, very bright lights,
or bright emissive materials. All of this is supported for both 3D and 2D.</p>
<p>This is not to be confused with HDR display output, which is the ability to
produce a HDR image to be displayed by a modern monitor or TV with HDR
capabilities. Bevy has no support for this yet.</p>
<p>The internal HDR image has to be converted down to SDR (Standard Dynamic
Range) before it can be displayed on the screen. This process is called
<a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a>. Bevy supports different algorithms that can
result in a different look. It is an artistic choice what tonemapping
algorithm to use for your game.</p>
<p>HDR(é«˜åŠ¨æ€èŒƒå›´)æ˜¯æŒ‡æ¸¸æˆå¼•æ“å¤„ç†éå¸¸æ˜äº®çš„ç¯å…‰æˆ–é¢œè‰²çš„èƒ½åŠ›.
bevyå†…éƒ¨æ¸²æŸ“æ”¯æŒhdr,ä¹Ÿå°±æ˜¯è¯´å¯¹è±¡çš„é¢œè‰²å¯è°ƒèŠ‚åˆ°1.0ä¹‹ä¸Š,éå¸¸äº®çš„é‚£ç§,
ç¯å…‰/å‘å…‰æè´¨å‡å¦‚æ­¤.2d/3då‡æ”¯æŒ.</p>
<p>è¿™é‡Œçš„hdrä¸æ˜¯hdræ˜¾ç¤ºè¾“å‡º(ç”Ÿæˆ HDR å›¾åƒå¹¶ç”±å…·æœ‰ HDR åŠŸèƒ½çš„ç°ä»£æ˜¾ç¤ºå™¨æˆ–ç”µè§†æ˜¾ç¤ºçš„èƒ½åŠ›),
bevyè¿˜ä¸æ”¯æŒhdræ˜¾ç¤ºè¾“å‡º.</p>
<p>åœ¨å±å¹•æ˜¾ç¤ºä¹‹å‰,å†…éƒ¨çš„hdrä¼šè½¬æ¢ç§°æ ‡å‡†åŠ¨æ€èŒƒå›´(sdr)è¿™ä¸ªå¤„ç†è¿‡ç¨‹æˆä¸º<code>è‰²è°ƒæ˜ å°„</code>.
bevyæ”¯æŒå¤šç§<code>è‰²è°ƒæ˜ å°„</code>ç®—æ³•,çœ‹èµ·æ¥éƒ½ä¸ä¸€æ ·,é€‰å“ªä¸€ç§éœ€è¦å°è¯•ä¸€äºŒ.</p>
<h2 id="camera-hdr-configuration"><a class="header" href="#camera-hdr-configuration">Camera HDR configuration</a></h2>
<p>There is a per-camera toggle that lets you decide whether you want Bevy to
preserve the HDR data internally, to make it possible for subsequent passes
(such as postprocessing effects) to use it.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle {
        camera: Camera {
            hdr: true,
            ..default()
        },
        ..default()
    },
));</code></pre>
<p>If it is enabled, Bevy's intermediate textures will be in HDR format. The
shaders output HDR values and Bevy will store them, so they can be used in later
rendering passes. This allows you to enable effects like <a href="graphics//graphics/bloom.html">Bloom</a>,
that make use of the HDR data. <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> will happen as a
post-processing step, after the HDR data is no longer needed for anything.</p>
<p>If it is disabled, the shaders are expected to output standard RGB colors in
the 0.0 to 1.0 range. <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> happens in the shader. The
HDR information is not preserved. Effects that require HDR data, like Bloom,
will not work.</p>
<p>It is disabled by default, because this results in better performance and
reduced VRAM usage for applications with simple graphics that do not need it.</p>
<p>If you have both HDR and MSAA enabled, it is possible you might encounter
issues. There might be visual artifacts in some cases. It is also unsupported on
Web/WASM, crashing at runtime. Disable MSAA if you experience any such issues.</p>
<p>ç›¸æœºçš„hdré…ç½®.å¦‚æœå¯ç”¨,ä¸­é—´çš„çº¹ç†å°†å¯ç”¨hdræ ¼å¼,ç€è‰²å™¨è¾“å‡ºdhrå€¼,ç”±bevyå­˜å‚¨,
å¹¶è¿›è¡Œåç»­çš„æ¸²æŸ“æ“ä½œ.bloomç‰¹æ•ˆå°±ä½¿ç”¨åˆ°äº†è¿™äº›hdræ•°æ®.
å½“åç»­æ“ä½œä¸å†ä½¿ç”¨hdræ•°æ®æ—¶,è‰²è°ƒæ˜ å°„å°±ä¼šå°†hdrè½¬æ¢ä¸ºsdr,ä½œä¸ºåå¤„ç†çš„ä¸€éƒ¨åˆ†.</p>
<p>å¦‚æœä¸å¯ç”¨hdr,ç€è‰²å™¨è¾“å‡ºçš„é¢œè‰²å°±æ˜¯[0.0,1.0],è‰²è°ƒæ˜ å°„åœ¨ç€è‰²å™¨å°±å®Œæˆäº†.
bevyä¹Ÿä¸ä¼šå­˜å‚¨hdræ•°æ®,ä¾èµ–hdræ•°æ®çš„ç‰¹æ•ˆ(eg:bloomç››å¼€çš„æ•ˆæœ)å°±ä¸èµ·ä½œç”¨.</p>
<p>hdré»˜è®¤æ˜¯disabledçš„.å› ä¸ºç®€å•ä¸€ç‚¹çš„ç¨‹åºå¹¶ä¸éœ€è¦,ä¸”å¯ä»¥å‡å°‘å†…å­˜ä½¿ç”¨,æ€§èƒ½ä¹Ÿé«˜ä¸€ç‚¹.
è¿½æ±‚é«˜è´¨é‡æ•ˆæœçš„,å¯ä»¥æ·»åŠ ä¸Šdhr.</p>
<p>hdrå’Œmsaa(å¤šé‡æŠ—é”¯é½¿)åŒæ—¶ä½¿ç”¨ä¼šå¯¼è‡´é—®é¢˜(è§†è§‰æ®‹å½±);
hdr+msaaè¿˜ä¸æ”¯æŒwasm/web(è¿™ä¸¤ä¸ªå¹³å°ä¼šå¯¼è‡´panic),
å¦‚æœå‡ºç°å¼‚å¸¸,å»ºè®®disable msaa.</p>
<h2 id="tonemapping"><a class="header" href="#tonemapping">Tonemapping</a></h2>
<p>Tonemapping is the step of the rendering process where the colors of pixels are
converted from their in-engine intermediate repesentation into the final values
as they should be displayed on-screen.</p>
<p>This is very important with HDR applications, as in that case the image can
contain very bright pixels (above 1.0) which need to be remapped into a range
that can be displayed.</p>
<p>Tonemapping is enabled by default. Bevy allows you to configure it via the
(<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/tonemapping/enum.Tonemapping.html"><code>Tonemapping</code></a>) component, per-camera. Disabling it is not
recommended, unless you know you only have very simple graphics that don't need
it. It can make your graphics look incorrect.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::Tonemapping;

commands.spawn((
    Camera3dBundle {
        // no tonemapping
        tonemapping: Tonemapping::None,
        ..default()
    },
));
commands.spawn((
    Camera3dBundle {
        // this is the default:
        tonemapping: Tonemapping::TonyMcMapface,
        ..default()
    },
));
commands.spawn((
    Camera3dBundle {
        // another common choice:
        tonemapping: Tonemapping::ReinhardLuminance,
        ..default()
    },
));</code></pre>
<p>Bevy supports many different tonemapping algorithms. Each of them results in a
different look, affecting colors and brightness. It can be an artistic choice. You
can decide what algorithm looks best for your game. Bevy's default is TonyMcMapface,
which, despite the silly name, provides very good results for a wide variety of
graphics styles. See the (<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/tonemapping/enum.Tonemapping.html"><code>Tonemapping</code></a>) documentation for
an explanation of each of the available choices.</p>
<p>Some tonemapping algorithms (incl. the default TonyMcMapface) require the
<code>tonemapping_luts</code> <a href="graphics//setup/bevy-config.html">cargo feature</a>. It is enabled by default. Be
sure to re-enable it if you disable default features and you need it. Enabling
it also enables the <code>ktx2</code> and <code>zstd</code> features, because it works by embedding
special data in KTX2 format into your game, which is used during tonemapping.</p>
<p>The following tonemapping algorithms <em>DO NOT</em> require the special data from
<code>tonemapping_luts</code>:</p>
<ul>
<li>Reinhard</li>
<li>ReinhardLuminance</li>
<li>AcesFitted</li>
<li>SomewhatBoringDisplayTransform</li>
</ul>
<p>The following tonemapping algorithms <em>require</em> the special data from <code>tonemapping_luts</code>:</p>
<ul>
<li>AgX</li>
<li>TonyMcMapface</li>
<li>BlenderFilmic</li>
</ul>
<p>If you want to make a smaller game binary (might be important for Web games),
you could reduce bloat by changing the default tonemapping to something
simpler and disabling the <a href="graphics//setup/bevy-config.html">cargo features</a>.</p>
<p>è‰²è°ƒæ˜ å°„æ˜¯æ¸²æŸ“è¿‡ç¨‹ä¸­å…¶ä¸­ä¸€ä¸ªæ­¥éª¤,
è´Ÿè´£å°†bevyå¼•æ“çš„åƒç´ é¢œè‰²(ä¸­é—´è¡¨ç¤ºå½¢å¼)è½¬æ¢ä¸ºå±å¹•æœ€ç»ˆæ¸²æŸ“çš„çŠ¶æ€.</p>
<p>å¯¹äºhdræ¥è¯´,è‰²è°ƒæ˜ å°„å°¤ä¸ºé‡è¦,å› ä¸ºhdrçš„é¢œè‰²éƒ½å¤ªäº®äº†,å¿…é¡»é‡æ–°æ˜ å°„ä¸ºsdræ‰èƒ½æ˜¾ç¤º.
è‰²è°ƒæ˜ å°„é»˜è®¤å·²ç»å¼€å¯äº†,bevyé€šè¿‡Tonemappingç»„ä»¶æ¥é…ç½®è‰²è°ƒæ˜ å°„,
æ¯ä¸ªç›¸æœºéƒ½å¯ä»¥é…ç½®,ä¸æ¨èdisable,é™¤éæˆ‘ä»¬çš„å›¾å½¢éå¸¸ç®€å•.</p>
<p>bevyæ”¯æŒå¤šé‡è‰²è°ƒæ˜ å°„ç®—æ³•,ä¸åŒçš„ç®—æ³•å¯¹é¢œè‰²å’Œäº®åº¦çš„å½±å“ä¸åŒ.æŒ‰éœ€é€‰æ‹©.
é»˜è®¤æ˜¯<code>TonyMcMapface</code>. éƒ¨åˆ†ç®—æ³•ä¾èµ–<code>tonemapping_luts</code>åŠŸèƒ½,è¿™ä¸ªåŠŸèƒ½æ˜¯é»˜è®¤å¼€å¯çš„.
å¦‚æœç¦ç”¨äº†DefaultPlugins,è®°å¾—re-enableè¿™ä¸ªåŠŸèƒ½.è¿™ä¸ªåŠŸèƒ½è¿˜å¯ç”¨äº†ktx2/zstdçš„æ”¯æŒ,
å› ä¸ºå®ƒçš„å·¥ä½œåŸç†æ˜¯å°†KTX2æ ¼å¼çš„ç‰¹æ®Šæ•°æ®åµŒå…¥åˆ°æ¸¸æˆä¸­,åœ¨è‰²è°ƒæ˜ å°„è¿‡ç¨‹ä¸­ä½¿ç”¨.</p>
<p>ä¾èµ–<code>tonemapping_luts</code>çš„ç®—æ³•åŒ…æ‹¬:é»˜è®¤çš„<code>TonyMcMapface</code>,ä»¥åŠ<code>Agx</code>å’Œ<code>BlenderFilmic</code>.
å¦‚æœå¯¹ç¨‹åºå¤§å°ç‰¹åˆ«æ•æ„Ÿçš„,å¯ä»¥æ¢æˆå…¶ä»–ç®—æ³•,ç„¶åç¦ç”¨<code>tonemapping_luts</code>åŠŸèƒ½.</p>
<hr />
<p>è‰²è°ƒæ˜ å°„æ˜¯ä¸€ä¸ªç€è‰²å™¨,å°è¯•å°†çº¿æ€§è¾“å…¥åˆºæ¿€æ˜ å°„åˆ°ç»™å®šç›¸æœºå®ä½“çš„æ„ŸçŸ¥å‡åŒ€çš„å›¾åƒä¸­.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Tonemapping {
    None,
    Reinhard,
    ReinhardLuminance,
    AcesFitted,
    AgX,
    SomewhatBoringDisplayTransform,
    TonyMcMapface,
    BlenderFilmic,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="color-grading"><a class="header" href="#color-grading">Color Grading</a></h2>
<p>Color Grading is a manipulation of the overall look of the image.</p>
<p>Together with tonemapping, this affects the "tone"/"mood" of the final image.</p>
<p>This is also how you can implement a "retina" effect, where the camera
dynamically adapts to very dark (such as inside a cave) and very bright
(such as in daylight) scenes, by adjusting exposure/gamma.</p>
<p>You can also adjust color saturation. Heavily desaturating the image can
result in a greyscale or muted appearance, which can be a great artistic
choice for apocalyptic or horror games.</p>
<p>You can configure these parameters via the <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.ColorGrading.html"><code>ColorGrading</code></a>
component:</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::ColorGrading;

commands.spawn((
    Camera3dBundle {
        color_grading: ColorGrading {
            exposure: 0.0,
            gamma: 1.0,
            pre_saturation: 1.0,
            post_saturation: 1.0,
        },
        ..default()
    },
));</code></pre>
<p>é¢œè‰²åˆ†çº§æ˜¯å¯¹å›¾åƒæ•´ä½“å¤–è§‚çš„å¤„ç†,å¸¸é…åˆè‰²è°ƒæ˜ å°„ä¸€èµ·ä½¿ç”¨.</p>
<p>è¿™ä¹Ÿæ˜¯å®ç°â€œè§†ç½‘è†œâ€æ•ˆæœçš„æ–¹æ³•,
å…¶ä¸­ç›¸æœºé€šè¿‡è°ƒæ•´æ›å…‰/ä¼½ç›åŠ¨æ€é€‚åº”éå¸¸é»‘æš—(ä¾‹å¦‚åœ¨æ´ç©´å†…)å’Œéå¸¸æ˜äº®(ä¾‹å¦‚åœ¨æ—¥å…‰ä¸‹)çš„åœºæ™¯.</p>
<p>è¿˜å¯ä»¥è°ƒæ•´é¢œè‰²é¥±å’Œåº¦.ä¸¥é‡é™ä½å›¾åƒçš„é¥±å’Œåº¦å¯èƒ½ä¼šå¯¼è‡´ç°åº¦æˆ–æŸ”å’Œçš„å¤–è§‚,
è¿™å¯¹äºä¸–ç•Œæœ«æ—¥æˆ–ææ€–æ¸¸æˆæ¥è¯´æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è‰ºæœ¯é€‰æ‹©.</p>
<p>é€šè¿‡ColorGradingç»„ä»¶æ¥é…ç½®é¢œè‰²åˆ†çº§çš„å‚æ•°.</p>
<hr />
<p>Retina æ•ˆæœæŒ‡çš„æ˜¯è‹¹æœå…¬å¸åœ¨å…¶è®¾å¤‡ä¸Šä½¿ç”¨çš„ä¸€ç§é«˜åˆ†è¾¨ç‡æ˜¾ç¤ºæŠ€æœ¯,
ç›®çš„æ˜¯ä½¿å±å¹•ä¸Šçš„åƒç´ å¯†åº¦è¾¾åˆ°æˆ–è¶…è¿‡äººçœ¼åœ¨æ­£å¸¸è§†è·ä¸‹æ— æ³•åˆ†è¾¨çš„ç¨‹åº¦,
ä»è€Œæä¾›æ›´æ¸…æ™°/æ›´ç»†è…»çš„æ˜¾ç¤ºæ•ˆæœ.</p>
<p>Retina æ˜¾ç¤ºæŠ€æœ¯æœ¬èº«å¹¶ä¸ç›´æ¥æ¶‰åŠè‡ªåŠ¨è°ƒèŠ‚æ›å…‰(exposure)æˆ–ä¼½é©¬(gamma)å€¼.
True Tone æ˜¾ç¤º:è¿™ç§æŠ€æœ¯ä½¿ç”¨å¤šä¸ªä¼ æ„Ÿå™¨æ¥ç›‘æµ‹å‘¨å›´ç¯å¢ƒå…‰çº¿çš„é¢œè‰²å’Œäº®åº¦,
ç„¶åè‡ªåŠ¨è°ƒæ•´æ˜¾ç¤ºå±çš„ç™½å¹³è¡¡å’Œè‰²æ¸©,ä½¿å±å¹•é¢œè‰²çœ‹èµ·æ¥æ›´è‡ªç„¶.</p>
<h2 id="deband-dithering"><a class="header" href="#deband-dithering">Deband Dithering</a></h2>
<p>Deband dithering helps color gradients or other areas with subtle changes in
color to appear higher-quality, without a "color banding" effect.</p>
<p>It is enabled by default, and can be disabled per-camera.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::DebandDither;

commands.spawn((
    Camera3dBundle {
        dither: DebandDither::Disabled,
        ..default()
    },
));</code></pre>
<p>Here is an example image without dithering (top) and with dithering (bottom).
Pay attention to the quality/smoothness of the green color gradient on the
ground plane. In games with photorealistic graphics, similar situations can
arise in the sky, in dark rooms, or lights glowing with a bloom effect.</p>
<p><img src="graphics/../img/dithering.png" alt="Visual comparison of a scene simple cube on a flat green plane, with dithering disabled/enabled." /></p>
<p>å»è‰²å¸¦æŠ–åŠ¨æœ‰åŠ©äºé¢œè‰²æ¸å˜æˆ–å…¶ä»–é¢œè‰²å‘ç”Ÿç»†å¾®å˜åŒ–çš„åŒºåŸŸæ˜¾å¾—æ›´é«˜è´¨é‡,è€Œä¸ä¼šå‡ºç°â€œè‰²å¸¦â€æ•ˆæœ.</p>
<p>å»è‰²å¸¦æŠ–åŠ¨æ˜¯é€šè¿‡ç»„ä»¶DebandDitheræ¥é…ç½®çš„.</p>
<p>ä¸Šå›¾æ˜¯è¿™æ˜¯æ²¡æœ‰æŠ–åŠ¨ï¼ˆé¡¶éƒ¨ï¼‰å’Œæœ‰æŠ–åŠ¨ï¼ˆåº•éƒ¨ï¼‰çš„ç¤ºä¾‹å›¾åƒ.
è¯·æ³¨æ„åœ°é¢ä¸Šçš„ç»¿è‰²æ¸å˜çš„è´¨é‡/å¹³æ»‘åº¦.
åœ¨å…·æœ‰é€¼çœŸå›¾å½¢çš„æ¸¸æˆä¸­,å¤©ç©º/é»‘æš—çš„æˆ¿é—´æˆ–å…·æœ‰ç»½æ”¾æ•ˆæœçš„ç¯å…‰ä¸­ä¹Ÿä¼šå‡ºç°ç±»ä¼¼çš„æƒ…å†µ.</p>
<hr />
<p>Deband å’Œ Dithering æ˜¯å›¾åƒå¤„ç†ä¸­çš„ä¸¤ä¸ªæŠ€æœ¯,ç”¨äºä¸åŒçš„ç›®çš„.</p>
<p>Debanding æ˜¯ä¸€ç§å‡å°‘æˆ–æ¶ˆé™¤å›¾åƒä¸­é¢œè‰²æ¡çº¹ï¼ˆbandingï¼‰ç°è±¡çš„æŠ€æœ¯.
é¢œè‰²æ¡çº¹æ˜¯æŒ‡åœ¨é¢œè‰²æ¸å˜åŒºåŸŸä¸­,ç”±äºé¢œè‰²æ·±åº¦ä¸è¶³è€Œäº§ç”Ÿçš„æ˜æ˜¾è‰²å¸¦.
è¿™ç§ç°è±¡é€šå¸¸å‡ºç°åœ¨å…·æœ‰å¹³æ»‘æ¸å˜çš„åŒºåŸŸ,å¦‚å¤©ç©º/é˜´å½±æˆ–æ¸å˜èƒŒæ™¯ä¸­.</p>
<p>Debanding æŠ€æœ¯é€šè¿‡åœ¨å›¾åƒä¸­å¼•å…¥å¾®å°çš„é¢œè‰²å˜åŒ–,æ‰“ç ´è¿™äº›æ˜æ˜¾çš„è‰²å¸¦,
ä»è€Œä½¿é¢œè‰²è¿‡æ¸¡çœ‹èµ·æ¥æ›´åŠ å¹³æ»‘å’Œè‡ªç„¶.</p>
<p>Dithering æ˜¯ä¸€ç§é€šè¿‡å¼•å…¥ä¼ªéšæœºå™ªå£°æ¥æ¨¡æ‹Ÿæ›´å¤šé¢œè‰²å’Œç°åº¦çº§åˆ«çš„æŠ€æœ¯,
ç‰¹åˆ«æ˜¯åœ¨é¢œè‰²æ·±åº¦è¾ƒä½çš„æƒ…å†µä¸‹.
Dithering çš„ç›®çš„æ˜¯é€šè¿‡åœ¨ç›¸é‚»åƒç´ é—´å¼•å…¥ç»†å¾®çš„é¢œè‰²å˜åŒ–,
ä½¿å¾—æ•´ä½“æ•ˆæœçœ‹èµ·æ¥æ›´åŠ å¹³æ»‘,å‡å°‘é¢œè‰²é‡åŒ–å¼•èµ·çš„è§†è§‰ä¼ªå½±.</p>
<p>åœ¨ä¸€äº›åœºæ™¯ä¸­,debanding å’Œ dithering å¯ä»¥ç»“åˆä½¿ç”¨.
é¦–å…ˆ,åº”ç”¨ debanding æŠ€æœ¯æ¶ˆé™¤æ˜æ˜¾çš„é¢œè‰²æ¡çº¹,
ç„¶åé€šè¿‡ dithering æŠ€æœ¯è¿›ä¸€æ­¥å¹³æ»‘é¢œè‰²è¿‡æ¸¡,æ¨¡æ‹Ÿæ›´å¤šçš„é¢œè‰²å’Œç°åº¦çº§åˆ«.</p>
<p>æ€»ç»“</p>
<p>Debanding:ç”¨äºå‡å°‘æˆ–æ¶ˆé™¤å›¾åƒä¸­çš„é¢œè‰²æ¡çº¹ç°è±¡,ä½¿é¢œè‰²è¿‡æ¸¡æ›´åŠ å¹³æ»‘.<br />
Dithering:é€šè¿‡å¼•å…¥ä¼ªéšæœºå™ªå£°æ¨¡æ‹Ÿæ›´å¤šé¢œè‰²å’Œç°åº¦çº§åˆ«,å‡å°‘é¢œè‰²é‡åŒ–å¼•èµ·çš„ä¼ªå½±.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bloom"><a class="header" href="#bloom">Bloom</a></h1>
<p>The "Bloom" effect creates a glow around bright lights. It is not a
physically-accurate effect, though it is inspired by how light looks through
a dirty or imperfect lens.</p>
<p>Bloom does a good job of helping the perception of very bright light,
especially when outputting HDR to the display hardware is not supported.
Your monitor can only display a certain maximum brightness, so Bloom is a
common artistic choice to try to convey light intensity brighter than can
be displayed.</p>
<p>Bloom looks best with a <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> algorithm that desaturates
very bright colors. Bevy's default is a good choice.</p>
<p>Bloom requires <a href="graphics//graphics/hdr-tonemap.html">HDR mode</a> to be enabled on your camera. Add the
<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/bloom/struct.BloomSettings.html"><code>BloomSettings</code></a> component to the camera to enable
bloom and configure the effect.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::bloom::BloomSettings;

commands.spawn((
    Camera3dBundle {
        camera: Camera {
            hdr: true,
            ..default()
        },
        ..default()
    },
    BloomSettings::NATURAL,
));</code></pre>
<p>bloom(ç»½æ”¾)æ•ˆæœä¼šåœ¨æ˜äº®çš„ç¯å…‰å‘¨å›´äº§ç”Ÿè¾‰å…‰.
å°½ç®¡å®ƒçš„çµæ„Ÿæ¥è‡ªå…‰çº¿é€è¿‡è‚®è„æˆ–ä¸å®Œç¾çš„é•œå¤´çš„æ ·å­,ä½†å®ƒå¹¶ä¸æ˜¯ç‰©ç†ä¸Šç²¾ç¡®çš„æ•ˆæœ.</p>
<p>bloom å¯ä»¥å¾ˆå¥½åœ°å¸®åŠ©äººä»¬æ„ŸçŸ¥éå¸¸æ˜äº®çš„å…‰çº¿,
å°¤å…¶æ˜¯åœ¨ä¸æ”¯æŒå°† HDR è¾“å‡ºåˆ°æ˜¾ç¤ºç¡¬ä»¶çš„æƒ…å†µä¸‹.
æ‚¨çš„æ˜¾ç¤ºå™¨åªèƒ½æ˜¾ç¤ºç‰¹å®šçš„æœ€å¤§äº®åº¦,å› æ­¤ Bloom æ˜¯ä¸€ç§å¸¸è§çš„è‰ºæœ¯é€‰æ‹©,
å¯ä»¥å°è¯•ä¼ è¾¾æ¯”å¯æ˜¾ç¤ºçš„æ›´äº®çš„å…‰å¼ºåº¦.</p>
<p>bloomä¸€èˆ¬é…åˆè‰²è°ƒæ˜ å°„ä¸€èµ·ä½¿ç”¨,èƒ½å¯¹éå¸¸æ˜äº®çš„å…‰çº¤<code>å»é¥±å’Œ</code>,
bevyé»˜è®¤çš„è‰²è°ƒæ˜ å°„ç®—æ³•å°±æ˜¯å¾ˆå¥½çš„é€‰æ‹©.</p>
<p>bloomæ˜¯é€šè¿‡BloomSettingsç»„ä»¶å¯ç”¨çš„,bloomæ˜¯ä¾èµ–hdrçš„.
hdré»˜è®¤æ˜¯disabledçš„,è¦ä½¿ç”¨bloomå°±éœ€è¦æ‰“å¼€hdr.</p>
<h2 id="bloom-settings"><a class="header" href="#bloom-settings">Bloom Settings</a></h2>
<p>Bevy offers many parameters to tweak the look of the bloom effect.</p>
<p>The default mode is "energy-conserving", which is closer to how real light
physics might behave. It tries to mimic the effect of light scattering,
without brightening the image artificially. The effect is more subtle and "natural".</p>
<p>There is also an "additive" mode, which will brighten everything and make it feel
like bright lights are "glowing" unnaturally. This sort of effect is quite common
in many games, especially older games from the 2000s.</p>
<p>Bevy offers three bloom "presets":</p>
<ul>
<li><code>NATURAL</code>: energy-conerving, subtle, natural look.</li>
<li><code>OLD_SCHOOL</code>: "glowy" effect, similar to how older games looked.</li>
<li><code>SCREEN_BLUR</code>: very intense bloom that makes everything look blurred.</li>
</ul>
<p>You can also create an entirely custom configuration by tweaking all the
parameters in <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/bloom/struct.BloomSettings.html"><code>BloomSettings</code></a> to your taste. Use the
presets for inspiration.</p>
<p>Here are the settings for the Bevy presets:</p>
<pre><code class="language-rust no_run noplayground">// NATURAL
BloomSettings {
    intensity: 0.15,
    low_frequency_boost: 0.7,
    low_frequency_boost_curvature: 0.95,
    high_pass_frequency: 1.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.0,
        threshold_softness: 0.0,
    },
    composite_mode: BloomCompositeMode::EnergyConserving,
};

// OLD_SCHOOL
BloomSettings {
    intensity: 0.05,
    low_frequency_boost: 0.7,
    low_frequency_boost_curvature: 0.95,
    high_pass_frequency: 1.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.6,
        threshold_softness: 0.2,
    },
    composite_mode: BloomCompositeMode::Additive,
};

// SCREEN_BLUR
BloomSettings {
    intensity: 1.0,
    low_frequency_boost: 0.0,
    low_frequency_boost_curvature: 0.0,
    high_pass_frequency: 1.0 / 3.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.0,
        threshold_softness: 0.0,
    },
    composite_mode: BloomCompositeMode::EnergyConserving,
};</code></pre>
<p>bevy æä¾›äº†è®¸å¤šå‚æ•°æ¥è°ƒæ•´å…‰æ™•æ•ˆæœçš„å¤–è§‚.
é»˜è®¤æ•ˆæœæ˜¯<code>energy-conserving</code>,è¿™æ›´æ¥è¿‘çœŸå®å…‰ç‰©ç†çš„è¡¨ç°.
å®ƒè¯•å›¾æ¨¡ä»¿å…‰æ•£å°„çš„æ•ˆæœ,è€Œä¸äººä¸ºåœ°ä½¿å›¾åƒå˜äº®.æ•ˆæœæ›´åŠ å¾®å¦™å’Œâ€œè‡ªç„¶â€.</p>
<p>å¦ä¸€ç§æ•ˆæœæ˜¯<code>additive</code>,è¿™ä¼šç…§äº®ä¸€åˆ‡,è®©äººæ„Ÿè§‰æ˜äº®çš„ç¯å…‰ä¸è‡ªç„¶åœ°å‘å…‰.
è¿™ç§æ•ˆæœåœ¨è®¸å¤šæ¸¸æˆä¸­éƒ½å¾ˆå¸¸è§,å°¤å…¶æ˜¯ 2000 å¹´ä»£çš„è€æ¸¸æˆ.</p>
<p>bevyæä¾›3ç§é»˜è®¤é…ç½®:</p>
<ul>
<li>NATURAL, çœ‹èµ·æ¥æ˜¯è‡ªç„¶çš„, <code>energy-conserving</code></li>
<li>OLD_SCHOOL, å‘å…‰æ•ˆæœ, å’Œä»¥å‰çš„è€æ¸¸æˆç±»ä¼¼</li>
<li>SCREEN_BLUR, éå¸¸å¼ºçƒˆçš„ç»½æ”¾,è®©ä¸€åˆ‡çœ‹èµ·æ¥éƒ½å¾ˆæ¨¡ç³Š.</li>
</ul>
<p>ä¸å–œæ¬¢é¢„è®¾çš„å¯ä»¥è‡ªå·±è°ƒèŠ‚.</p>
<hr />
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum BloomCompositeMode {
    EnergyConserving,
    Additive,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="visualization"><a class="header" href="#visualization">Visualization</a></h2>
<p>Here is an example of Bloom in 3D:</p>
<p><img src="graphics/../img/bloom_3d.png" alt="The Bloom effect on street lamps." /></p>
<p>And here is a 2D example:</p>
<p><img src="graphics/../img/bloom_2d.png" alt="The Bloom effect on a simple hexagon." /></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-2d"><a class="header" href="#bevy-2d">Bevy 2D</a></h1>
<p>This chapter covers topics relevant to making 2D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="2d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="2d-camera-setup"><a class="header" href="#2d-camera-setup">2D Camera Setup</a></h1>
<p><a href="2d//graphics/camera.html">Cameras</a> in Bevy are mandatory to see anything: they configure the
rendering.</p>
<p>This page will teach you about the specifics of 2D cameras. If you want to learn about
general non-2D specific functionality, see the <a href="2d//graphics/camera.html">general page on cameras</a>.</p>
<p>bevyä¸­, å¿…é¡»ä½¿ç”¨ç›¸æœºæ¥çœ‹ä¸€åˆ‡ä¸œè¥¿, å› ä¸ºç›¸æœºé…ç½®ç€æ¸²æŸ“</p>
<h2 id="creating-a-2d-camera"><a class="header" href="#creating-a-2d-camera">Creating a 2D Camera</a></h2>
<p>Bevy provides a <a href="2d//programming/bundle.html">bundle</a> (<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>)
that you can use to <a href="2d//programming/commands.html">spawn</a> a camera <a href="2d//programming/ec.html#entities">entity</a>. It
has reasonable defaults to set up everything correctly.</p>
<p>You might want to set the <a href="2d//fundamentals/transforms.html">transform</a>, to position the camera.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyCameraMarker;

fn setup_camera(mut commands: Commands) {
    commands.spawn((
        Camera2dBundle {
            transform: Transform::from_xyz(100.0, 200.0, 0.0),
            ..default()
        },
        MyCameraMarker,
    ));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup_camera)
        .run();
}</code></pre>
<p><code>Camera2dBundle</code>å°±æ˜¯ç”¨äºç”Ÿæˆ2dç›¸æœºå®ä½“çš„,æ„é€ æ—¶å°±èƒ½æŒ‡å®šç›¸æœºçš„ä½ç½®å’Œå˜æ¢.</p>
<h2 id="projection-1"><a class="header" href="#projection-1">Projection</a></h2>
<p>The <a href="2d//graphics/camera.html#projection">projection</a> is what determines how coordinates map to the
<a href="2d//graphics/camera.html#viewport">viewport</a> (commonly, the screen/window).</p>
<p>2D cameras always use an Orthographic projection.</p>
<p>When you spawn a 2D camera using <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>,
it adds the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a>
<a href="2d//programming/ec.html#components">component</a> to your <a href="2d//programming/ec.html#entities">entity</a>. When
you are working with 2D cameras and you want to access
the projection, you should <a href="2d//programming/queries.html">query</a> for
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn debug_projection(
    query_camera: Query&lt;&amp;OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let projection = query_camera.single();
    // ... do something with the projection
}</code></pre>
<p>Note that this is different from <a href="2d//3d/camera.html#projection">3D</a>. If you are
making a library or some other code that should be able to handle both 2D and
3D, you cannot make a single <a href="2d//programming/queries.html">query</a> to access both 2D and 3D
cameras. You should create separate <a href="2d//programming/systems.html">systems</a>, or at least two
separate queries, to handle each kind of camera. This makes sense, as you will
likely need different logic for 2D vs. 3D anyway.</p>
<p>æŠ•å½±å†³å®šäº†ä¸–ç•Œçš„åæ ‡ç³»ç»Ÿå¦‚ä½•æ˜ å°„åˆ°è§†çª—(é€šå¸¸æ˜¯å±å¹•æˆ–çª—å£).
2dæ¸¸æˆæ€»æ˜¯ä½¿ç”¨æ­£äº¤æŠ•å½±.Camera2dBundleä¸­è‡ªåŠ¨åŒ…å«äº†OrthographicProjection,
å¦‚æœè¦åœ¨è¿‡ç¨‹ä¸­è®¿é—®æ­£äº¤æŠ•å½±çš„å€¼,ç›´æ¥åœ¨queryä¸­è®¿é—®<code>OrthographicProjection</code>å³å¯.</p>
<p>3dä¸­çš„å¤„ç†æœ‰äº›å·®å¼‚.å…·ä½“è¯´å¦‚æœæˆ‘ä»¬å†™ä¸€ä¸ªlib,éœ€è¦å¤„ç†å¥½2d/3dçš„ä¸åŒ,
ä¸»è¦æ˜¯æ²¡æ³•é€šè¿‡å•ä¸ªqueryæŸ¥åˆ°2d/3dç›¸æœºä¸­çš„æ­£äº¤æŠ•å½±,
è¦ä¹ˆæ˜¯åˆ†æˆä¸åŒçš„system,è¦ä¹ˆæ˜¯ä½¿ç”¨ä¸¤ä¸ªå•ç‹¬çš„query.
è¿™æ˜¯æœ‰é“ç†çš„,å› ä¸ºæ— è®ºå¦‚ä½•æ‚¨å¯èƒ½éœ€è¦ä¸åŒçš„ 2D ä¸ 3D é€»è¾‘.</p>
<h3 id="caveat-nearfar-values"><a class="header" href="#caveat-nearfar-values">Caveat: near/far values</a></h3>
<p>The projection contains the <code>near</code> and <code>far</code> values, which indicate the minimum
and maximum Z coordinate (depth) that can be rendered, relative to the position
(<a href="2d//fundamentals/transforms.html">transform</a>) of the camera.</p>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a> sets them appropriately for 2D:
<code>-1000.0</code> to <code>1000.0</code>, allowing entities to be displayed on both positive and
negative Z coordinates. However, if you create the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> yourself, to change any
other settings, you need to set these values yourself. The default value of the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> struct is designed for
3D and has a <code>near</code> value of <code>0.0</code>, which means you might not be able to see
your 2D entities.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera2dBundle {
        projection: OrthographicProjection {
            // don't forget to set `near` and `far`
            near: -1000.0,
            far: 1000.0,
            // ... any other settings you want to change ...
            ..default()
        },
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p>A more foolproof way to go about this is to use a temporary variable, to let the
bundle do its thing, and then mutate whatever you want. This way, you don't have
to worry about the exact values or getting anything wrong:</p>
<pre><code class="language-rust no_run noplayground">let mut camera_bundle = Camera2dBundle::default();
// change the settings we want to change:
camera_bundle.projection.scale = 2.0;
camera_bundle.transform.rotate_z(30f32.to_radians());
// ...

commands.spawn((
    camera_bundle,
    MyCameraMarker,
));</code></pre>
<p>è¿œè¿‘.æ­£ä»·æŠ•å½±ä¸ä¼šåº”ä¸ºè¿œè¿‘æœ‰å¤§å°ä¹‹åˆ†.æŠ•å½±çš„near/farå€¼ä»…ä»…è¡¨ç¤ºzè½´çš„å€¼,
è¡¨ç¤ºç¦»ç›¸æœºçš„è·ç¦».Camera2dBundleå°†è¿™ä¸¤ä¸ªå€¼è®¾ç½®ä¸º-1000.0å’Œ1000.0,
åœ¨è¿™ä¸ªèŒƒå›´å†…çš„å®ä½“éƒ½å¯ä»¥å‚ä¸æ¸²æŸ“.
(ä¹‹å‰è¯´çš„æ¸²æŸ“è¿‡æ»¤è¶…è¿‡1000ä¸ªå•ä½å°±ä¸æ˜¾ç¤ºäº†,è¿™ä¸ªé˜ˆå€¼æ¥è‡³è¿™é‡Œ.)</p>
<p>å¦‚æœæ˜¯è‡ªå·±åˆ›å»ºæ­£äº¤æŠ•å½±ç»„ä»¶,å°±éœ€è¦æ³¨æ„è¿™äº›å€¼çš„è®¾ç½®,
æ­£äº¤æŠ•å½±æ˜¯ä¸º3dç›¸æœºè€Œè®¾è®¡çš„,è¿™ä¸ªç»“æ„ä½“çš„nearå­—æ®µé»˜è®¤å€¼æ˜¯0,
ä¹Ÿå°±æ˜¯è¯´å¦‚æœåœ¨2dç›¸æœºä¸­,å¦‚æœä¸è®¾ç½®near,å°±ä¸ä¼šçœ‹åˆ°ä»»ä½•å®ä½“.</p>
<p>å¦‚æœæ€•ä¸¢, å°±å°†æ­£äº¤æŠ•å½±ç»„ä»¶çš„å€¼æ”¾åœ¨ä¸€ä¸ªä¸´æ—¶å˜é‡ä¸­,æ‰€æœ‰çš„2dç›¸æœºéƒ½ä½¿ç”¨è¿™ä¸ª,
è¿™æ ·å°±ä¸ç”¨æ‹…å¿ƒåœ¨ç›¸æœºå†…éƒ¨è®¾ç½®æ—¶å°‘äº†è®¾ç½®.</p>
<h3 id="scaling-mode"><a class="header" href="#scaling-mode">Scaling Mode</a></h3>
<p>You can set the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> according to how you want to
handle window size / resolution.</p>
<p>The default for Bevy 2D cameras is to have 1 screen pixel correspond to 1 world
unit, thus allowing you to think of everything in "pixels". When the window is
resized, that causes more or less content to be seen.</p>
<p>If you want to keep this window resizing behavior, but change the mapping of screen
pixels to world units, use <code>ScalingMode::WindowSize(x)</code> with a value other than <code>1.0</code>.
The value represents the number of screen pixels for one world unit.</p>
<p>If, instead, you want to always fit the same amount of content
on-screen, regardless of resolution, you should use something like
<code>ScalingMode::FixedVertical</code> or <code>ScalingMode::AutoMax</code>. Then, you can directly
specify how many units you want to display on-screen, and your content will
be upscaled/downscaled as appropriate to fit the window size.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ScalingMode;

let mut my_2d_camera_bundle = Camera2dBundle::default();
// For this example, let's make the screen/window height correspond to
// 1600.0 world units. The width will depend on the aspect ratio.
my_2d_camera_bundle.projection.scaling_mode = ScalingMode::FixedVertical(1600.0);
my_2d_camera_bundle.transform = Transform::from_xyz(100.0, 200.0, 0.0);

commands.spawn((
    my_2d_camera_bundle,
    MyCameraMarker,
));</code></pre>
<p>æ ¹æ®å¯¹çª—å£å¤§å°/åˆ†è¾¨ç‡çš„å¤„ç†,å¯ä»¥è®¾ç½®<code>ScalingMode</code>ç¼©æ”¾æ¨¡å¼.
2dç›¸æœºé»˜è®¤1å±å¹•åƒç´ å¯¹åº”1ä¸ªä¸–ç•Œå•ä½,è¿™æ ·çª—å£å¤§å°çš„æ”¹å˜ä¼šç›´æ¥å½±å“çœ‹åˆ°ä¸–ç•Œçš„å¤§å°.</p>
<p>å¦‚æœæƒ³åœ¨æ”¹å˜çª—å£å¤§å°çš„åŒæ—¶è¿˜æ˜¯èƒ½çœ‹åˆ°åŒæ ·çš„ä¸–ç•Œ,
<code>ScalingMode::WindowSize(x)</code>ä¸­çš„xå°±ä¸èƒ½è®¾ç½®ä¸º1.0.
<code>ScalingMode::FixedVertical</code>æˆ–<code>ScalingMode::AutoMax</code>èƒ½ä¿æŒåŸçª—å£çœ‹åˆ°çš„ä¸–ç•Œ.
ä¹Ÿå¯ä»¥ç›´æ¥æŒ‡å®šè¦çœ‹åˆ°çš„ä¸–ç•Œçš„å°ºå¯¸,æˆ–è€…å°†å†…å®¹è¿›è¡Œç¼©æ”¾åˆ°æ—¶å’Œçª—å£å¤§å°.</p>
<hr />
<p>æ­£äº¤æŠ•å½±ä¸‹çš„ç¼©æ”¾æ¨¡å¼.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ScalingMode {
    // Fixed æ‰‹åŠ¨ç›´æ¥æŠ•å½±å¤§å°,å¿½ç•¥çª—å£resize,å›¾åƒæ‹‰ä¼¸,å‚æ•°ä¸ºä¸–ç•Œå•ä½.
    Fixed {
        width: f32,
        height: f32,
    },
    // æŒ‡å®šè§†çª—å¤§å°,å‚æ•°æ˜¯ä¸€ä¸ªä¸–ç•Œå•ä½ç­‰äºå¤šå°‘åƒç´ .
    WindowSize(f32),
    // ä¿æŒå®½é«˜æ¯”,è¦æ»¡è¶³æœ€å°é™åˆ¶,å•ä½æ˜¯ä¸–ç•Œå•ä½.
    AutoMin {
        min_width: f32,
        min_height: f32,
    },
    // å’ŒAutoMinç±»ä¼¼,è¦æ»¡è¶³æœ€å¤§é™åˆ¶.
    AutoMax {
        max_width: f32,
        max_height: f32,
    },
    // ä¿æŒå®½é«˜æ¯”,å®½åº¦è°ƒæ•´,é«˜åº¦ä¸å˜,å‚æ•°æ˜¯æŠ•å½±æ‰€éœ€çš„é«˜åº¦,ä¸–ç•Œå•ä½.
    FixedVertical(f32),
    // é«˜åº¦è°ƒæ•´.
    FixedHorizontal(f32),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="zooming"><a class="header" href="#zooming">Zooming</a></h3>
<p>To "zoom" in 2D, you can change the orthographic projection's <code>scale</code>. This
allows you to just scale everything by some factor, regardless of the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> behavior.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_scale(
    mut query_camera: Query&lt;&amp;mut OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let mut projection = query_camera.single_mut();
    // zoom in
    projection.scale /= 1.25;
    // zoom out
    projection.scale *= 1.25;
}</code></pre>
<p>Alternatively, you can reconfigure the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a>. This
way you can be confident about how exactly coordinates/units map to the
screen. This also helps avoid scaling artifacts with 2D assets, especially
pixel art.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_scalingmode(
    mut query_camera: Query&lt;&amp;mut OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    use bevy::render::camera::ScalingMode;

    let mut projection = query_camera.single_mut();
    // 4 screen pixels to world/game pixel
    projection.scaling_mode = ScalingMode::WindowSize(4.0);
    // 6 screen pixels to world/game pixel
    projection.scaling_mode = ScalingMode::WindowSize(6.0);
}</code></pre>
<p>Consider having a list of predefined "zoom levels" / scale values, so that you
can make sure your game always looks good.</p>
<p>If you are making a pixel-art game, you want to make sure the default texture
filtering mode is set to Nearest (and not Linear), if you want your pixels
to appear crisp instead of blurry:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(
            DefaultPlugins
                .set(ImagePlugin::default_nearest())
        )
        // ...
        .run();
}</code></pre>
<p>However, when <em>downscaling</em>, Linear (the default) filtering is preferred
for higher quality. So, for games with high-res assets, you want to leave
it unchanged.</p>
<p>èšç„¦,é€šè¿‡æ­£äº¤æŠ•å½±çš„scaleæ¥æ”¹å˜,åœ¨2dç›¸æœºä¸­,å¯ä»¥å°†æ‰€æœ‰äº‹ç‰©æŒ‰åŒæ ·çš„ç¼©æ”¾å› å­è¿›è¡Œç¼©æ”¾.
zoomå’ŒScalingModeäº’ä¸å½±å“.ä¸¤è€…éƒ½å¯¹ç¼©æ”¾æœ‰å½±å“,é€‰æ‹©å…¶ä¸­ä¸€ç§å³å¯.</p>
<p>ä½¿ç”¨zoomå¯ä»¥æœ‰æ•ˆé˜²æ­¢2dèµ„äº§åœ¨ç¼©æ”¾è¿‡ç¨‹äº§ç”Ÿæ®‹å½±.</p>
<p>åœ¨æ¸¸æˆä¸­è®¾ç½®ä¸€ä¸ªé¢„å®šä¹‰çš„ç¼©æ”¾è¡¨,æ¸¸æˆçœ‹èµ·æ¥ä¼šæ›´å¥½.</p>
<p>å¦‚æœæ‚¨æ­£åœ¨åˆ¶ä½œåƒç´ è‰ºæœ¯æ¸¸æˆ,å¹¶ä¸”å¸Œæœ›åƒç´ æ˜¾å¾—æ¸…æ™°è€Œä¸æ˜¯æ¨¡ç³Š,
åˆ™éœ€è¦ç¡®ä¿å°†é»˜è®¤çº¹ç†è¿‡æ»¤æ¨¡å¼è®¾ç½®ä¸º<code>æœ€è¿‘</code>(è€Œä¸æ˜¯<code>çº¿æ€§</code>).
ä½†æ˜¯,åœ¨ç¼©å°å°ºå¯¸æ—¶,é¦–é€‰çº¿æ€§(é»˜è®¤)è¿‡æ»¤ä»¥è·å¾—æ›´é«˜çš„è´¨é‡.
å› æ­¤,å¯¹äºå…·æœ‰é«˜åˆ†è¾¨ç‡èµ„æºçš„æ¸¸æˆ,æ‚¨å¸Œæœ›ä¿æŒå…¶ä¸å˜.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="2d//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="sprites-and-atlases"><a class="header" href="#sprites-and-atlases">Sprites and Atlases</a></h1>
<p>Page coming soonâ€¦</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<p>ç²¾çµå’Œåœ°å›¾é›†.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-3d"><a class="header" href="#bevy-3d">Bevy 3D</a></h1>
<p>This chapter covers topics relevant to making 3D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="3d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="3d-camera-setup"><a class="header" href="#3d-camera-setup">3D Camera Setup</a></h1>
<p><a href="3d//graphics/camera.html">Cameras</a> in Bevy are mandatory to see anything: they configure the
rendering.</p>
<p>This page will teach you about the specifics of 3D cameras. If you want to learn about
general non-3D specific functionality, see the <a href="3d//graphics/camera.html">general page on cameras</a>.</p>
<h2 id="creating-a-3d-camera"><a class="header" href="#creating-a-3d-camera">Creating a 3D Camera</a></h2>
<p>Bevy provides a <a href="3d//programming/bundle.html">bundle</a> that you can use to <a href="3d//programming/commands.html">spawn</a> a
camera <a href="3d//programming/ec.html#entities">entity</a>. It has reasonable defaults to set up everything
correctly.</p>
<p>You might want to set the <a href="3d//fundamentals/transforms.html">transform</a>, to position the camera.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyCameraMarker;

fn setup_camera(mut commands: Commands) {
    commands.spawn((
        Camera3dBundle {
            transform: Transform::from_xyz(10.0, 12.0, 16.0)
                .looking_at(Vec3::ZERO, Vec3::Y),
            ..default()
        },
        MyCameraMarker,
    ));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup_camera)
        .run();
}</code></pre>
<p>The "looking at" function is an easy way to orient a 3D camera. The second
parameter (which we provide as <code>Y</code>) is the "up" direction. If you want the camera
to be tilted sideways, you can use something else there. If you want to make a
top-down camera, looking straight down, you need to use something other than <code>Y</code>.</p>
<p>æ„é€ 3dç›¸æœºå’Œ2dç›¸æœºç±»ä¼¼,æ¨èä½¿ç”¨Camera3dBundleæ¥æ„é€ å®ä½“.
<code>looking_at()</code>çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯è§’åº¦.</p>
<h2 id="projection-2"><a class="header" href="#projection-2">Projection</a></h2>
<p>The <a href="3d//graphics/camera.html#projection">projection</a> is what determines how coordinates map to the
<a href="3d//graphics/camera.html#viewport">viewport</a> (commonly, the screen/window).</p>
<p>3D cameras can use either a Perspective or an Orthographic projection.
Perspective is the default, and most common, choice.</p>
<p>When you spawn a 3D camera using Bevy's <a href="3d//programming/bundle.html">bundle</a>
(<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera3dBundle</code></a>), it adds the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.Projection.html"><code>Projection</code></a> <a href="3d//programming/ec.html#components">component</a> to your
<a href="3d//programming/ec.html#entities">entity</a>, which is an <code>enum</code>, allowing either projection kind to be
used.</p>
<p>When you are working with 3D cameras and you want to access the projection, you
should <a href="3d//programming/queries.html">query</a> for the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>Projection</code></a>
<a href="3d//programming/ec.html#components">component</a> type. You can then match on the enum, to handle each
case appropriately.</p>
<pre><code class="language-rust no_run noplayground">fn debug_projection(
    query_camera: Query&lt;&amp;Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let projection = query_camera.single();
    match projection {
        Projection::Perspective(persp) =&gt; {
            // we have a perspective projection
        }
        Projection::Orthographic(ortho) =&gt; {
            // we have an orthographic projection
        }
    }
}</code></pre>
<p>Note that this is different from <a href="3d//2d/camera.html#projection">2D</a>. If you are
making a library or some other code that should be able to handle both 2D and
3D, you cannot make a single <a href="3d//programming/queries.html">query</a> to access both 2D and 3D
cameras. You should create separate <a href="3d//programming/systems.html">systems</a>, or at least two
separate queries, to handle each kind of camera. This makes sense, as you will
likely need different logic for 2D vs. 3D anyway.</p>
<p>æŠ•å½±å†³å®šäº†ä»çª—å£çœ‹åˆ°çš„ä¸œè¥¿,é»˜è®¤æ˜¯é€è§†æŠ•å½±,3dæ¸¸æˆå¤§éƒ¨åˆ†åœºåˆä¸‹éƒ½ä½¿ç”¨è¿™ä¸ª.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component, Debug, Clone, Reflect)]
#[reflect(Component, Default)]
pub enum Projection {
    Perspective(PerspectiveProjection),
    Orthographic(OrthographicProjection),
}

// é»˜è®¤æ˜¯é€è§†æŠ•å½±.
impl Default for Projection {
    fn default() -&gt; Self {
        Projection::Perspective(Default::default())
    }
}

impl Default for Camera3dBundle {
    fn default() -&gt; Self {
        Self {
            camera_render_graph: CameraRenderGraph::new(Core3d),
            camera: Default::default(),
            projection: Default::default(),  // Camera3dBundle çš„é»˜è®¤æŠ•å½±
            visible_entities: Default::default(),
            frustum: Default::default(),
            transform: Default::default(),
            global_transform: Default::default(),
            camera_3d: Default::default(),
            tonemapping: Default::default(),
            color_grading: Default::default(),
            exposure: Default::default(),
            main_texture_usages: Default::default(),
            deband_dither: DebandDither::Enabled,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>å¦‚æœè¦åœ¨systemä¸­è®¿é—®æŠ•å½±,queryä¸­æŸ¥Projectionå³å¯.
å’Œ2dç±»ä¼¼,å¦‚æœåŒæ—¶å­˜åœ¨2dç›¸æœºå’Œ3dç›¸æœº,ä¸€ä¸ªæŸ¥è¯¢æ˜¯æ— æ³•æŸ¥åˆ°ä¸¤ä¸ªç›¸æœºçš„,
éœ€è¦2ä¸ªquery.</p>
<h3 id="perspective-projections"><a class="header" href="#perspective-projections">Perspective Projections</a></h3>
<p>Perspective creates a realistic sense of 3D space. Things appear smaller the
further away they are from the camera. This is how things appear to the human
eye, and to real-life cameras.</p>
<p>The most important variable here is the FOV (Field-of-View). The FOV determines
the strength of the perspective effect. The FOV is the angle covered by the
height of the screen/image.</p>
<p>A larger FOV is like a wide-angle camera lens. It makes everything appear more
distant, stretched, "zoomed out". You can see more on-screen.</p>
<p>A smaller FOV is like a telephoto camera lens. It makes everything appear closer
and flatter, "zoomed in". You can see less on-screen.</p>
<p>For reference, a good neutral value is 45Â° (narrower, Bevy default) or 60Â°
(wider). 90Â° is very wide. 30Â° is very narrow.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle {
        projection: PerspectiveProjection {
            // We must specify the FOV in radians.
            // Rust can convert degrees to radians for us.
            fov: 60.0_f32.to_radians(),
            ..default()
        }.into(),
        transform: Transform::from_xyz(10.0, 12.0, 16.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p><img src="3d/../img/camera-3d-fov.png" alt="Side-by-side comparison of different FOV values." /></p>
<p>In the above image, we are halving/doubling the FOV and doubling/halving
how far away the camera is positioned, to compensate. Note how you can see
pretty much the same 3D content, but the higher FOV looks more stretched
and has a stronger 3D perspective effect.</p>
<p>Internally, Bevy's perspective projection uses an <a href="https://developer.nvidia.com/content/depth-precision-visualized">infinite reversed
Z</a> configuration. This allows for good numeric
precision for both nearby and far away objects, avoiding visual artifacts.</p>
<p>é€è§†æŠ•å½±,åœ¨3dæ¸¸æˆä¸­æ›´åŠ é€¼çœŸ:è¿œå°è¿‘å¤§.(å’Œäººçœ¼çœ‹åˆ°çš„ç±»ä¼¼).</p>
<p>é€è§†æŠ•å½±ä¸­é‡è¦çš„æ¦‚å¿µæ˜¯FOV(è§†é‡,åŒ…å«æ°´å¹³è§†é‡HFOV/å‚ç›´è§†é‡VFOV,å¸¸ç”¨VFOV),
FOV æ˜¯æ‘„åƒæœºè§†é”¥ä½“çš„ä¸€ä¸ªè§’åº¦,è¡¨ç¤ºåœ¨æ‘„åƒæœºé•œå¤´å‰æ–¹èƒ½å¤Ÿçœ‹åˆ°çš„æœ€å¤§è§†é‡èŒƒå›´.
FOVå®šä¹‰äº†ç›¸æœºèƒ½çœ‹åˆ°çš„ç©ºé—´èŒƒå›´.</p>
<p>bevyä¸­çš„FOVå°±æ˜¯æŒ‡å‚ç›´è§†é‡.</p>
<p>FOVè¶Šå¤§å°±è¶Šåƒå¹¿è§’é•œå¤´,è¿™è®©ä¸€åˆ‡æ˜¾å¾—æ›´åŠ é¥è¿œ/æ‹‰é•¿/ç¼©å°,è¿™æ ·å¯ä»¥çœ‹åˆ°æ›´å¤šä¸œè¥¿.<br />
FOVè¶Šå°å°±è¶Šåƒé•¿ç„¦é•œå¤´,è¿™æ ·ä¸€èµ·æ˜¾å¾—æ›´åŠ è¿‘/å¹³å¦/æ–¹æ³•,çœ‹åˆ°çš„ä¸œè¥¿ä¹Ÿè¶Šå°‘.</p>
<p>bevyé»˜è®¤æ˜¯45åº¦(è‰¯å¥½),60åº¦å±äºè¾ƒå®½,90åº¦å¾ˆå®½,30åº¦éå¸¸çª„.</p>
<p>ä¸Šå›¾ä¸€ä¸ªæ˜¯45åº¦+å•ä½è·ç¦»,ä¸€ä¸ªæ˜¯90åº¦(45åº¦çš„2å€)+åŠä¸ªå•ä½è·ç¦»,åè€…çš„3dæ•ˆæœæ›´åŠ æ˜æ˜¾.</p>
<p>åœ¨å†…éƒ¨,Bevy çš„é€è§†æŠ•å½±ä½¿ç”¨(æ— é™åå‘Zé…ç½®)(è¿™æ˜¯ä¸€ä¸ªæ˜¾å¡æŠ€æœ¯).
è¿™ä½¿å¾—é™„è¿‘å’Œè¿œå¤„çš„ç‰©ä½“éƒ½å…·æœ‰è‰¯å¥½çš„æ•°å€¼ç²¾åº¦,é¿å…äº†è§†è§‰ä¼ªå½±.</p>
<h4 id="zooming-1"><a class="header" href="#zooming-1">Zooming</a></h4>
<p>To "zoom", change the perspective projection's FOV.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_perspective(
    mut query_camera: Query&lt;&amp;mut Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    // assume perspective. do nothing if orthographic.
    let Projection::Perspective(persp) = query_camera.single_mut().into_inner() else {
        return;
    };
    // zoom in
    persp.fov /= 1.25;
    // zoom out
    persp.fov *= 1.25;
}</code></pre>
<p>If the camera does not move, decreasing the FOV makes everything appear closer
and increasing it makes everything appear more distant:</p>
<p><img src="3d/../img/camera-3d-fov-zoom.png" alt="Side-by-side comparison of a &quot;zoomed in&quot; (small FOV) and a &quot;zoomed out&quot; (large FOV) 3D scene" /></p>
<p>Contrast this with moving the camera itself (using the
<a href="3d//fundamentals/transforms.html">transform</a>) closer or further away, while keeping the FOV the
same:</p>
<p><img src="3d/../img/camera-3d-position.png" alt="Side-by-side comparison of a camera positioned nearer to vs. further away from a 3D scene" /></p>
<p>In some applications (such as 3D editors), moving the camera might be preferable,
instead of changing the FOV.</p>
<p>èšç„¦,å°±æ˜¯æ”¹å˜é€è§†æŠ•å½±çš„FOVå€¼.
å¦‚æœç›¸æœºä¸ç§»åŠ¨,åˆ™å‡å° FOV ä¼šä½¿ä¸€åˆ‡çœ‹èµ·æ¥æ›´è¿‘,è€Œå¢åŠ  FOV ä¼šä½¿ä¸€åˆ‡çœ‹èµ·æ¥æ›´è¿œ.
bevyçš„é€è§†èšç„¦å’ŒçœŸå®ç›¸æœºçš„ç„¦è·æ˜¯ä¸€ä¸ªæ•ˆæœ.</p>
<p>çœŸå®ç›¸æœºèšç„¦æ˜¯å› ä¸ºç°å®è·ç¦»é™åˆ¶,ä½†åœ¨è½¯ä»¶ä¸­,è·ç¦»ä¸å†æ˜¯é™åˆ¶,æœ‰æ—¶ç§»åŠ¨æ¯”èšç„¦çš„æ•ˆæœä¼šæ›´å¥½.</p>
<h3 id="orthographic-projections"><a class="header" href="#orthographic-projections">Orthographic Projections</a></h3>
<p>An Orthographic projection makes everything always look the same size,
regardless of the distance from the camera. It can feel like if 3D was squashed
down into 2D.</p>
<p>Orthographic is useful for applications such as CAD and engineering, where you
want to accurately represent the dimensions of an object. Some games (notably
simulation games) might use orthographic as an artistic choice.</p>
<p>Orthographic can feel confusing and unintuitive to some people, because it does
not create any sense of 3D space. You cannot tell how far away anything is. It
creates a perfectly "flat" look. When displayed from a top-down diagonal angle,
this artistic style is sometimes referred to as "isometric".</p>
<p>You should set the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> according to how you want
to handle window size / resolution.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ScalingMode;

commands.spawn((
    Camera3dBundle {
        projection: OrthographicProjection {
            // For this example, let's make the screen/window height
            // correspond to 16.0 world units.
            scaling_mode: ScalingMode::FixedVertical(16.0),
            ..default()
        }.into(),
        // the distance doesn't really matter for orthographic,
        // it should look the same (though it might affect
        // shadows and clipping / culling)
        transform: Transform::from_xyz(10.0, 12.0, 16.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p><img src="3d/../img/camera-3d-orthographic.png" alt="Visualization of a 3D scene with orthographic projection" /></p>
<h4 id="zooming-2"><a class="header" href="#zooming-2">Zooming</a></h4>
<p>To "zoom", change the orthographic projection's scale. The scale determines
how much of the scene is visible.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_orthographic(
    mut query_camera: Query&lt;&amp;mut Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    // assume orthographic. do nothing if perspective.
    let Projection::Orthographic(ortho) = query_camera.single_mut().into_inner() else {
        return;
    };
    // zoom in
    ortho.scale /= 1.25;
    // zoom out
    ortho.scale *= 1.25;
}</code></pre>
<p><img src="3d/../img/camera-3d-orthographic-zoom.png" alt="Side-by-side comparison of different orthographic projection scale in 3D" /></p>
<p>æ­£äº¤æŠ•å½±ä¸‹,ä¸ç®¡è·ç¦»å¦‚ä½•,ä¸œè¥¿çœ‹èµ·æ¥éƒ½æ˜¯ä¸€æ ·å¤§.å¯ä»¥å‡†å¤‡è¡¨ç¤ºå¯¹è±¡å°ºå¯¸.
éå¸¸é€‚åˆCADé¢†åŸŸ(ç²¾ç¡®æµ‹é‡/å·¥ç¨‹å›¾çº¸/é›¶ä»¶è®¾è®¡ç­‰).</p>
<p>æ­£äº¤æŠ•å½±å¯¹äºæŸäº›äººæ¥è¯´å¯èƒ½ä»¤äººå›°æƒ‘ä¸”ä¸ç›´è§‚,å› ä¸ºå®ƒä¸ä¼šäº§ç”Ÿä»»ä½• 3D ç©ºé—´æ„Ÿ.
æ‚¨æ— æ³•åˆ†è¾¨ä»»ä½•äº‹ç‰©çš„è·ç¦».å®ƒä¼šäº§ç”Ÿå®Œç¾çš„å¹³é¢å¤–è§‚.
å½“ä»ä¸Šåˆ°ä¸‹çš„å¯¹è§’çº¿è§’åº¦æ˜¾ç¤ºæ—¶,è¿™ç§è‰ºæœ¯é£æ ¼æœ‰æ—¶è¢«ç§°ä¸ºç­‰è·.</p>
<p>å’Œåœ¨2dç›¸æœºæ—¶ä¸€æ ·,éœ€è¦åˆ¶å®šç¼©æ”¾æ¨¡å¼ScalingMode,æˆ–é€šè¿‡scaleè¿›è¡Œç¼©æ”¾.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="3d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="3d-models-and-scenes-gltf"><a class="header" href="#3d-models-and-scenes-gltf">3D Models and Scenes (GLTF)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/load_gltf.rs"><code>load_gltf</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/update_gltf_scene.rs"><code>update_gltf_scene</code></a>.</p>
<hr />
<p>Bevy uses the GLTF 2.0 file format for 3D assets.</p>
<p>(other formats may be unofficially available via 3rd-party plugins)</p>
<p>bevyä½¿ç”¨gltf2.0æ–‡ä»¶æ ¼å¼æ¥è¡¨ç¤º3dèµ„äº§.</p>
<h2 id="quick-start-spawning-3d-models-into-your-world"><a class="header" href="#quick-start-spawning-3d-models-into-your-world">Quick-Start: Spawning 3D Models into your World</a></h2>
<p>The simplest use case is to just load a "3D model" and spawn it into the game world.</p>
<p>"3D models" can often be complex, consisting of multiple parts. Think of a
house: the windows, roof, doors, etc., are separate pieces, that are likely
made of multiple meshes, materials, and textures. Bevy would technically
need multiple ECS Entities to represent and render the whole thing.</p>
<p>This is why your GLTF "model" is represented by Bevy as a
[Scene][cb::scene]. This way, you can easily spawn it, and Bevy will create
all the relevant <a href="3d//fundamentals/hierarchy.html">child entities</a> and configure them correctly.</p>
<pre><code class="language-rust no_run noplayground">fn spawn_gltf(mut commands: Commands, ass: Res&lt;AssetServer&gt;) {
    // note that we have to include the `Scene0` label
    let my_gltf = ass.load("my.glb#Scene0");

    // to position our 3d model, simply use the Transform
    // in the SceneBundle
    commands.spawn(SceneBundle {
        scene: my_gltf,
        transform: Transform::from_xyz(2.0, 0.0, -5.0),
        ..Default::default()
    });
}</code></pre>
<p>You could also use GLTF files to load an entire map/level. It works the same way.</p>
<p>The above example assumes that you have a simple GLTF file containing only
one "default scene". GLTF is a very flexible file format. A single file can
contain many "models" or more complex "scenes". To get a better understanding
of GLTF and possible workflows, read the rest of this page. :)</p>
<p>3dæ¸¸æˆæœ‰ä¸ªå¸¸è§çš„æ“ä½œå°±æ˜¯åŠ è½½3dæ¨¡å‹.
ä¸€ä¸ª3dæ¨¡å‹å¯ä»¥åŒ…å«å¾ˆå¤šä¸œè¥¿,ä¸€ä¸ªæ¡Œå­æœ‰æ¡Œé¢å’Œæ¡ŒæŸ±,
bevyè¡¨ç¤ºæ¡Œå­æ˜¯éœ€è¦å¤šä¸ªECSå®ä½“æ‰èƒ½æ¸²æŸ“ä¸€ä¸ªæ¡Œå­.</p>
<p>é€šå¸¸ä¸€ä¸ª3dæ¨¡å‹å°±ç§°ä¸ºä¸€ä¸ªscene,bevyå¯ä»¥åŸºäºsceneæ„é€ å‡ºæ‰€æœ‰ä¾èµ–çš„å®ä½“.
å¯ä»¥é€šè¿‡ä¸€ä¸ªgltfæ–‡ä»¶åŠ è½½ä¸€ç³»åˆ—å®ä½“.</p>
<h2 id="introduction-to-gltf"><a class="header" href="#introduction-to-gltf">Introduction to GLTF</a></h2>
<p>GLTF is a modern open standard for exchanging 3D assets between different
3D software applications, like game engines and 3D modeling software.</p>
<p>The GLTF file format has two variants: human-readable ascii/text (<code>*.gltf</code>)
and binary (<code>*.glb</code>). The binary format is more compact and preferable
for packaging the assets with your game. The text format may be useful for
development, as it can be easier to manually inspect using a text editor.</p>
<p>A GLTF file can contain many objects (sub-assets): meshes, materials,
textures, scenes, animation clips. When loading a GLTF file, Bevy will load
all of the assets contained inside. They will be mapped to the <a href="3d//builtins.html#assets">appropriate
Bevy-internal asset types</a>.</p>
<p>GLTFæ˜¯ç°ä»£çš„ä¸€ä¸ªäº¤æ¢3dèµ„äº§çš„æ ‡å‡†,è®©ä¸åŒè½¯ä»¶çš„3dèµ„äº§å¯ä»¥è¿›è¡Œäº¤äº’,
eg:3då»ºæ¨¡è½¯ä»¶blenderå¯ä»¥è¾“å‡º3dèµ„äº§,æ¸¸æˆå¼•æ“å¯ä»¥åŠ è½½è¿™äº›å†…å®¹.</p>
<p>gltfæœ‰ä¸¤ç§æ ¼å¼:äººç±»é˜…è¯»å‹å¥½çš„(<em>.gltf),å’ŒäºŒè¿›åˆ¶(</em>.glb).</p>
<p>ä¸€ä¸ªgltfæ–‡ä»¶å¯ä»¥æœ‰å¾ˆå¤šå­èµ„äº§:ç½‘æ ¼/æè´¨/çº¹ç†/scene/åŠ¨ç”».</p>
<h2 id="the-gltf-sub-assets"><a class="header" href="#the-gltf-sub-assets">The GLTF sub-assets</a></h2>
<p>GLTF terminology can be confusing, as it sometimes uses the same words to
refer to different things, compared to Bevy. This section will try explain
the various GLTF terms.</p>
<p>To understand everything, it helps to mentally consider how these concepts are
represented in different places: in your 3D modeling software (like Blender),
in the GLTF file itself, and in Bevy.</p>
<p>GLTF <strong>Scenes</strong> are what you spawn into your game world. This is typically
what you see on the screen in your 3D modeling software. Scenes combine
all of the data needed for the game engine to create all the needed
entities to represent what you want. Conceptually, think of a scene as one
"unit". Depending on your use case, this could be one "3d model",
or even a whole map or game level. In Bevy, these are represented as Bevy
Scenes with all the child ECS entities.</p>
<p>GLTF Scenes are composed of GLTF <strong>Nodes</strong>. These describe the "objects"
in the scene, typically GLTF Meshes, but can also be other things like
Cameras and Lights. Each GLTF Node has a transform for positioning it in
the scene. GLTF Nodes do not have a core Bevy equivalent; Bevy just uses
this data to create the ECS Entities inside of a Scene. Bevy has a special
<a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> asset type, if you need access to this data.</p>
<p>GLTF <strong>Meshes</strong> represent one conceptual "3D object". These correspond
to the "objects" in your 3D modeling software. GLTF Meshes may be complex
and composed of multiple smaller pieces, called GLTF Primitives, each of
which may use a different Material. GLTF Meshes do not have a core Bevy
equivalent, but there is a special <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a> asset type,
which describes the primitives.</p>
<p>GLTF <strong>Primitives</strong> are individual "units of 3D geometry", for the purposes of
rendering. They contain the actual geometry / vertex data, and reference the
Material to be used when drawing. In Bevy, each GLTF Primitive is represented
as a Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> asset, and must be spawned as a separate ECS
Entity to be rendered.</p>
<p>GLTF <strong>Materials</strong> describe the shading parameters for the surfaces of
your 3D models. They have full support for Physically-Based Rendering
(PBR). They also reference the textures to use. In Bevy, they are represented
as <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a> assets, as used by the Bevy
PBR 3D renderer.</p>
<p>GLTF <strong>Textures</strong> (images) can be embedded inside the GLTF file, or stored
externally in separate image files alongside it. For example, you can have
your textures as separate PNG/JPEG/KTX2 files for ease of development, or
package them all inside the GLTF file for ease of distribution. In Bevy,
GLTF textures are loaded as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets.</p>
<p>GLTF <strong>Samplers</strong> describe the settings for how the GPU should use a
given Texture. Bevy does not keep these separate; this data is stored
inside the Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset (the <code>sampler</code> field of type
<a href="https://docs.rs/bevy/0.9.1/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a>).</p>
<p>GLTF <strong>Animations</strong> describe animations that interpolate various values,
such as transforms or mesh skeletons, over time. In Bevy, these are loaded
as <a href="https://docs.rs/bevy/0.9.1/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a> assets.</p>
<p>gltfèµ„äº§æ˜¯æœ‰æ ‡å‡†åç§°çš„,è¿™ä¸ªæ˜¯ç»Ÿä¸€çš„.ä½†bevyå¹¶æ²¡æœ‰å®Œå…¨æŒ‰gltfæ ‡å‡†æ¥.</p>
<p>GLTFåœºæ™¯æ˜¯æ‚¨åœ¨æ¸¸æˆä¸–ç•Œä¸­ç”Ÿæˆçš„å†…å®¹.
è¿™é€šå¸¸æ˜¯æ‚¨åœ¨3Då»ºæ¨¡è½¯ä»¶çš„å±å¹•ä¸Šçœ‹åˆ°çš„å†…å®¹.
åœºæ™¯ç»“åˆäº†æ¸¸æˆå¼•æ“æ‰€éœ€çš„æ‰€æœ‰æ•°æ®,ä»¥åˆ›å»ºæ‰€æœ‰å¿…è¦çš„å®ä½“æ¥è¡¨ç¤ºæ‚¨æƒ³è¦çš„å†…å®¹.
ä»æ¦‚å¿µä¸Šè®²,å°†åœºæ™¯è§†ä¸ºä¸€ä¸ªâ€œå•å…ƒâ€.
æ ¹æ®æ‚¨çš„ç”¨ä¾‹,è¿™å¯èƒ½æ˜¯ä¸€ä¸ªâ€œ3Dæ¨¡å‹â€,ç”šè‡³æ˜¯æ•´ä¸ªåœ°å›¾æˆ–æ¸¸æˆçº§åˆ«.
åœ¨Bevyä¸­,è¿™äº›è¡¨ç¤ºä¸ºåŒ…å«æ‰€æœ‰å­ECSå®ä½“çš„Bevyåœºæ™¯.</p>
<p>GLTFåœºæ™¯ç”±GLTFèŠ‚ç‚¹ç»„æˆ.è¿™äº›èŠ‚ç‚¹æè¿°äº†åœºæ™¯ä¸­çš„â€œå¯¹è±¡â€,é€šå¸¸æ˜¯GLTFç½‘æ ¼,
ä½†ä¹Ÿå¯ä»¥æ˜¯å…¶ä»–ä¸œè¥¿,å¦‚ç›¸æœºå’Œç¯å…‰.æ¯ä¸ªGLTFèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå˜æ¢æ¥å°†å…¶å®šä½åœ¨åœºæ™¯ä¸­.
GLTFèŠ‚ç‚¹æ²¡æœ‰æ ¸å¿ƒBevyç­‰æ•ˆé¡¹ï¼›Bevyä»…ä½¿ç”¨æ­¤æ•°æ®åœ¨åœºæ™¯å†…åˆ›å»ºECSå®ä½“.
å¦‚æœæ‚¨éœ€è¦è®¿é—®æ­¤æ•°æ®,Bevyæœ‰ä¸€ä¸ªç‰¹æ®Šçš„GltfNodeèµ„æºç±»å‹.</p>
<p>GLTFç½‘æ ¼ä»£è¡¨ä¸€ä¸ªæ¦‚å¿µä¸Šçš„â€œ3Då¯¹è±¡â€.å®ƒä»¬å¯¹åº”äº3Då»ºæ¨¡è½¯ä»¶ä¸­çš„â€œå¯¹è±¡â€.
GLTFç½‘æ ¼å¯èƒ½å¾ˆå¤æ‚,ç”±å¤šä¸ªè¾ƒå°çš„éƒ¨åˆ†ç»„æˆ,ç§°ä¸ºGLTFåŸºå…ƒ,
æ¯ä¸ªåŸºå…ƒå¯èƒ½ä½¿ç”¨ä¸åŒçš„æè´¨.GLTFç½‘æ ¼æ²¡æœ‰æ ¸å¿ƒBevyç­‰æ•ˆé¡¹,
ä½†æœ‰ä¸€ä¸ªç‰¹æ®Šçš„GltfMeshèµ„æºç±»å‹,ç”¨äºæè¿°åŸºå…ƒ.</p>
<p>GLTFåŸºå…ƒæ˜¯å•ç‹¬çš„â€œ3Då‡ ä½•å•å…ƒâ€,ç”¨äºæ¸²æŸ“.
å®ƒä»¬åŒ…å«å®é™…çš„å‡ ä½•/é¡¶ç‚¹æ•°æ®,å¹¶å¼•ç”¨ç»˜åˆ¶æ—¶è¦ä½¿ç”¨çš„æè´¨.
åœ¨Bevyä¸­,æ¯ä¸ªGLTFPrimitiveéƒ½è¡¨ç¤ºä¸ºBevyMeshèµ„æº,
å¹¶ä¸”å¿…é¡»ç”Ÿæˆä¸ºå•ç‹¬çš„ECSå®ä½“æ‰èƒ½è¿›è¡Œæ¸²æŸ“.</p>
<p>GLTFæè´¨æè¿°3Dæ¨¡å‹è¡¨é¢çš„ç€è‰²å‚æ•°.å®ƒä»¬å®Œå…¨æ”¯æŒåŸºäºç‰©ç†çš„æ¸²æŸ“(PBR).
å®ƒä»¬è¿˜å¼•ç”¨è¦ä½¿ç”¨çš„çº¹ç†.åœ¨Bevyä¸­,å®ƒä»¬è¡¨ç¤ºä¸ºStandardMaterialèµ„æº,
ç”±BevyPBR3Dæ¸²æŸ“å™¨ä½¿ç”¨.</p>
<p>GLTFçº¹ç†(å›¾åƒ)å¯ä»¥åµŒå…¥GLTFæ–‡ä»¶ä¸­,ä¹Ÿå¯ä»¥å­˜å‚¨åœ¨å¤–éƒ¨å•ç‹¬çš„å›¾åƒæ–‡ä»¶ä¸­.
ä¾‹å¦‚,æ‚¨å¯ä»¥å°†çº¹ç†ä½œä¸ºå•ç‹¬çš„PNG/JPEG/KTX2æ–‡ä»¶ä»¥æ–¹ä¾¿å¼€å‘,
æˆ–è€…å°†å®ƒä»¬å…¨éƒ¨æ‰“åŒ…åˆ°GLTFæ–‡ä»¶ä¸­ä»¥æ–¹ä¾¿åˆ†å‘.
åœ¨Bevyä¸­,GLTFçº¹ç†ä½œä¸ºBevyå›¾åƒèµ„æºåŠ è½½.</p>
<p>GLTFé‡‡æ ·å™¨æè¿°äº†GPUåº”å¦‚ä½•ä½¿ç”¨ç»™å®šçº¹ç†çš„è®¾ç½®.Bevyä¸ä¼šå°†è¿™äº›åˆ†å¼€ä¿å­˜ï¼›
è¿™äº›æ•°æ®å­˜å‚¨åœ¨Bevyå›¾åƒèµ„äº§(SamplerDescriptorç±»å‹çš„é‡‡æ ·å™¨å­—æ®µ)ä¸­.</p>
<p>GLTFåŠ¨ç”»æè¿°äº†éšæ—¶é—´æ’å…¥å„ç§å€¼(ä¾‹å¦‚å˜æ¢æˆ–ç½‘æ ¼éª¨æ¶)çš„åŠ¨ç”».
åœ¨Bevyä¸­,è¿™äº›è¢«åŠ è½½ä¸ºAnimationClipèµ„äº§.</p>
<h2 id="gltf-usage-patterns"><a class="header" href="#gltf-usage-patterns">GLTF Usage Patterns</a></h2>
<p>A single GLTF file can contain any number of sub-assets of any of the above
types, referring to each other however they like.</p>
<p>Because GLTF is so flexible, it is up to you how to structure your assets.</p>
<p>A single GLTF file might be used:</p>
<ul>
<li>To represent a single "3D model", containing a single
GLTF Scene with the model, so you can spawn it into your game.</li>
<li>To represent a whole level, as a GLTF Scene, possibly also including
the camera. This lets you load and spawn a whole level/map at once.</li>
<li>To represent sections of a level/map, such as a rooms, as separate GLTF Scenes.
They can share meshes and textures if needed.</li>
<li>To contain a set of many different "3D models", each as a separate GLTF Scene.
This lets you load and manage the whole collection at once and spawn them individually as needed.</li>
<li>â€¦ others?</li>
</ul>
<p>å•ä¸ª GLTF æ–‡ä»¶å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„ä¸Šè¿°ä»»ä½•ç±»å‹çš„å­èµ„æº, å¹¶ä»¥ä»»æ„æ–¹å¼ç›¸äº’å¼•ç”¨.</p>
<p>gltfå¯ä»¥ç”¨åœ¨ä»¥ä¸‹åœºæ™¯:</p>
<ul>
<li>è¡¨ç¤ºå•ä¸ª3D æ¨¡å‹</li>
<li>å°†æ•´ä¸ªå…³å¡è¡¨ç¤ºä¸º GLTF åœºæ™¯,å¯èƒ½è¿˜åŒ…æ‹¬ç›¸æœº.è¿™è®©æ‚¨å¯ä»¥ä¸€æ¬¡åŠ è½½å’Œç”Ÿæˆæ•´ä¸ªå…³å¡/åœ°å›¾.</li>
<li>å°†å…³å¡/åœ°å›¾çš„å„ä¸ªéƒ¨åˆ†(ä¾‹å¦‚æˆ¿é—´)è¡¨ç¤ºä¸ºå•ç‹¬çš„ GLTF åœºæ™¯.å¦‚æœéœ€è¦,å®ƒä»¬å¯ä»¥å…±äº«ç½‘æ ¼å’Œçº¹ç†.</li>
<li>åŒ…å«ä¸€ç»„è®¸å¤šä¸åŒçš„3D æ¨¡å‹,æ¯ä¸ªæ¨¡å‹éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„ GLTF åœºæ™¯.è¿™è®©æ‚¨å¯ä»¥ä¸€æ¬¡åŠ è½½å’Œç®¡ç†æ•´ä¸ªé›†åˆ,å¹¶æ ¹æ®éœ€è¦å•ç‹¬ç”Ÿæˆå®ƒä»¬.</li>
<li>â€¦å…¶ä»–ï¼Ÿ</li>
</ul>
<h2 id="tools-for-creating-gltf-assets"><a class="header" href="#tools-for-creating-gltf-assets">Tools for Creating GLTF Assets</a></h2>
<p>If you are using a recent version of Blender (2.8+) for 3D modeling, GLTF
is supported out of the box. Just export and choose GLTF as the format.</p>
<p>For other tools, you can try these exporter plugins:</p>
<ul>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Blender_to_glTF">Old Blender (2.79)</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/3DSMax_to_glTF">3DSMax</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Maya_to_glTF">Autodesk Maya</a>
<ul>
<li>(or this <a href="https://kashika.co.jp/product/gltfexporter/">alternative</a>)</li>
</ul>
</li>
</ul>
<p>Be sure to check your export settings to make sure the GLTF file contains
everything you expect.</p>
<p>If you need Tangents for normal maps, it is recommended that you include them
in your GLTF files. This avoids Bevy having to autogenerate them at runtime.
Many 3D editors do not enable this option by default.</p>
<p>åˆ›å»ºgltfèµ„äº§çš„å·¥å…·,æ¨èä½¿ç”¨å¼€æºçš„blender.</p>
<p>å¦‚æœæ‚¨éœ€è¦æ³•çº¿è´´å›¾çš„åˆ‡çº¿,å»ºè®®æ‚¨å°†å®ƒä»¬åŒ…å«åœ¨ GLTF æ–‡ä»¶ä¸­.
è¿™é¿å…äº† Bevy å¿…é¡»åœ¨è¿è¡Œæ—¶è‡ªåŠ¨ç”Ÿæˆå®ƒä»¬.è®¸å¤š 3D ç¼–è¾‘å™¨é»˜è®¤ä¸å¯ç”¨æ­¤é€‰é¡¹.</p>
<h3 id="textures"><a class="header" href="#textures">Textures</a></h3>
<p>For your Textures / image data, the GLTF format specification officially
limits the supported formats to just PNG, JPEG, or Basis. However, Bevy does
not enforce such "artificial limitations". You can use any <a href="3d//builtins.html#file-formats">image format
supported by Bevy</a>.</p>
<p>Your 3D editor will likely export your GLTF with PNG textures. This will
"just work" and is nice for simple use cases.</p>
<p>However, mipmaps and compressed textures are very important to get good GPU
performance, memory (VRAM) usage, and visual quality. You will only get these
benefits if you use a format like KTX2 or DDS, that supports these features.</p>
<p>We recommend that you use KTX2, which natively supports all GPU texture
functionality + additional <code>zstd</code> compression on top, to reduce file size.
If you do this, don't forget to enable the <code>ktx2</code> and <code>zstd</code> <a href="3d//setup/bevy-config.html">cargo
features</a> for Bevy.</p>
<p>You can use the <a href="https://github.com/superdump/klafsa"><code>klafsa</code></a> tool to convert all the textures
used in your GLTF files from PNG/JPEG into KTX2, with mipmaps and GPU texture
compression of your choice.</p>
<pre><code>TODO: show an example workflow for converting textures into the "optimal" format
</code></pre>
<p>å¯¹äºæ‚¨çš„çº¹ç†/å›¾åƒæ•°æ®,GLTFæ ¼å¼è§„èŒƒæ­£å¼å°†æ”¯æŒçš„æ ¼å¼é™åˆ¶ä¸ºPNGã€JPEGæˆ–Basis.
ä½†æ˜¯,Bevyä¸ä¼šå¼ºåˆ¶æ‰§è¡Œè¿™ç§â€œäººä¸ºé™åˆ¶â€.æ‚¨å¯ä»¥ä½¿ç”¨Bevyæ”¯æŒçš„ä»»ä½•å›¾åƒæ ¼å¼.</p>
<p>æ‚¨çš„3Dç¼–è¾‘å™¨å¯èƒ½ä¼šä½¿ç”¨PNGçº¹ç†å¯¼å‡ºæ‚¨çš„GLTF.è¿™å°†â€œæ­£å¸¸å·¥ä½œâ€,å¹¶ä¸”éå¸¸é€‚åˆç®€å•çš„ç”¨ä¾‹.</p>
<p>ä½†æ˜¯,mipmapå’Œå‹ç¼©çº¹ç†å¯¹äºè·å¾—è‰¯å¥½çš„GPUæ€§èƒ½ã€å†…å­˜(VRAM)ä½¿ç”¨ç‡å’Œè§†è§‰è´¨é‡éå¸¸é‡è¦.
åªæœ‰ä½¿ç”¨æ”¯æŒè¿™äº›åŠŸèƒ½çš„KTX2æˆ–DDSç­‰æ ¼å¼,æ‚¨æ‰èƒ½è·å¾—è¿™äº›å¥½å¤„.</p>
<p>æˆ‘ä»¬å»ºè®®æ‚¨ä½¿ç”¨KTX2,å®ƒåŸç”Ÿæ”¯æŒæ‰€æœ‰GPUçº¹ç†åŠŸèƒ½+é¡¶éƒ¨çš„é¢å¤–zstdå‹ç¼©,ä»¥å‡å°æ–‡ä»¶å¤§å°.
å¦‚æœæ‚¨è¿™æ ·åš,è¯·ä¸è¦å¿˜è®°ä¸ºBevyå¯ç”¨ktx2å’Œzstdè´§ç‰©åŠŸèƒ½.</p>
<p>æ‚¨å¯ä»¥ä½¿ç”¨klafsaå·¥å…·å°†GLTFæ–‡ä»¶ä¸­ä½¿ç”¨çš„æ‰€æœ‰çº¹ç†ä»PNG/JPEGè½¬æ¢ä¸ºKTX2,
å¹¶é€‰æ‹©mipmapå’ŒGPUçº¹ç†å‹ç¼©.</p>
<h2 id="using-gltf-sub-assets-in-bevy"><a class="header" href="#using-gltf-sub-assets-in-bevy">Using GLTF Sub-Assets in Bevy</a></h2>
<p>The various sub-assets contained in a GLTF file can be addressed in two ways:</p>
<ul>
<li>by index (integer id, in the order they appear in the file)</li>
<li>by name (text string, the names you set in your 3D modeling software
when creating the asset, which can be exported into the GLTF)</li>
</ul>
<p>To get handles to the respective assets in Bevy, you can use the
<a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="3d/gltf.html#gltf-master-asset">"master asset"</a>, or alternatively,
<a href="3d/gltf.html#assetpath-with-labels">AssetPath with Labels</a>.</p>
<p>åœ¨bevyä¸­è®¿é—®è¿™äº›èµ„äº§æœ‰ä¸¤ç§æ–¹å¼:ç´¢å¼•æˆ–åç§°.</p>
<h3 id="gltf-master-asset"><a class="header" href="#gltf-master-asset"><code>Gltf</code> master asset</a></h3>
<p>If you have a complex GLTF file, this is likely the most flexible and useful
way of navigating its contents and using the different things inside.</p>
<p>You have to wait for the GLTF file to load, and then use the <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> asset.</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::Gltf;

/// Helper resource for tracking our asset
#[derive(Resource)]
struct MyAssetPack(Handle&lt;Gltf&gt;);

fn load_gltf(mut commands: Commands, ass: Res&lt;AssetServer&gt;) {
    let gltf = ass.load("my_asset_pack.glb");
    commands.insert_resource(MyAssetPack(gltf));
}

fn spawn_gltf_objects(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
) {
    // if the GLTF has loaded, we can navigate its contents
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // spawn the first scene in the file
        commands.spawn(SceneBundle {
            scene: gltf.scenes[0].clone(),
            ..Default::default()
        });

        // spawn the scene named "YellowCar"
        commands.spawn(SceneBundle {
            scene: gltf.named_scenes["YellowCar"].clone(),
            transform: Transform::from_xyz(1.0, 2.0, 3.0),
            ..Default::default()
        });

        // PERF: the `.clone()`s are just for asset handles, don't worry :)
    }
}</code></pre>
<p>For a more convoluted example, say we want to directly create a 3D PBR
entity, for whatever reason. (This is not recommended; you should probably
just use scenes)</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::GltfMesh;

fn gltf_manual_entity(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
    assets_gltfmesh: Res&lt;Assets&lt;GltfMesh&gt;&gt;,
) {
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // Get the GLTF Mesh named "CarWheel"
        // (unwrap safety: we know the GLTF has loaded already)
        let carwheel = assets_gltfmesh.get(&amp;gltf.named_meshes["CarWheel"]).unwrap();

        // Spawn a PBR entity with the mesh and material of the first GLTF Primitive
        commands.spawn(PbrBundle {
            mesh: carwheel.primitives[0].mesh.clone(),
            // (unwrap: material is optional, we assume this primitive has one)
            material: carwheel.primitives[0].material.clone().unwrap(),
            ..Default::default()
        });
    }
}</code></pre>
<h3 id="assetpath-with-labels"><a class="header" href="#assetpath-with-labels">AssetPath with Labels</a></h3>
<p>This is another way to access specific sub-assets. It is less reliable,
but may be easier to use in some cases.</p>
<p>Use the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a> to convert a path string into a
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Handle.html"><code>Handle</code></a>.</p>
<p>The advantage is that you can get handles to your sub-assets immediately,
even if your GLTF file hasn't loaded yet.</p>
<p>The disadvantage is that it is more error-prone. If you specify a sub-asset
that doesn't actually exist in the file, or mis-type the label, or use the
wrong label, it will just silently not work. Also, currently only using a
numerial index is supported. You cannot address sub-assets by name.</p>
<pre><code class="language-rust no_run noplayground">fn use_gltf_things(mut commands: Commands, ass: Res&lt;AssetServer&gt;) {
    // spawn the first scene in the file
    let scene0 = ass.load("my_asset_pack.glb#Scene0");
    commands.spawn(SceneBundle {
        scene: scene0,
        ..Default::default()
    });

    // spawn the second scene
    let scene1 = ass.load("my_asset_pack.glb#Scene1");
    commands.spawn(SceneBundle {
        scene: scene1,
        transform: Transform::from_xyz(1.0, 2.0, 3.0),
        ..Default::default()
    });
}</code></pre>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Mesh{}/Primitive{}/MorphTargets</code>: Morph target animation data for a GLTF Primitive</li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<p>GLTF (Graphics Library Transmission Format)èµ„æºä¸­ä½¿ç”¨çš„æ ‡ç­¾ä¸»è¦æ¶‰åŠä»¥ä¸‹å‡ æ–¹é¢:
æè¿°3Dæ¨¡å‹ã€åœºæ™¯ç»“æ„ã€æè´¨ã€çº¹ç†ç­‰å…ƒç´ çš„å…ƒæ•°æ®ã€‚
è¿™äº›æ ‡ç­¾å¸®åŠ©ç»„ç»‡å’Œå®šä¹‰äº†GLTFæ–‡ä»¶ä¸­çš„ä¸åŒç»„ä»¶ï¼Œ
ä½¿å¾—å®ƒä»¬èƒ½å¤Ÿåœ¨ä¸åŒçš„å¹³å°å’Œåº”ç”¨ç¨‹åºé—´æœ‰æ•ˆä¼ è¾“å’Œæ¸²æŸ“ã€‚
ä»¥ä¸‹æ˜¯ä¸€äº›å…³é”®çš„GLTFèµ„æºæ ‡ç­¾åŠå…¶ç”¨é€”æ¦‚è¿°ï¼š</p>
<ul>
<li>asset: åŒ…å«äº†GLTFæ–‡ä»¶çš„åŸºæœ¬å…ƒæ•°æ®ï¼Œå¦‚ç‰ˆæœ¬å·ã€ç‰ˆæƒä¿¡æ¯ã€ç”Ÿæˆå·¥å…·ç­‰ã€‚</li>
<li>scene: å®šä¹‰åœºæ™¯çš„åŸºæœ¬æ„æˆï¼Œä¸€ä¸ªGLTFæ–‡ä»¶å¯ä»¥åŒ…å«å¤šä¸ªåœºæ™¯ï¼Œæ¯ä¸ªåœºæ™¯å¯ä»¥å¼•ç”¨ä¸åŒçš„èŠ‚ç‚¹é›†åˆã€‚</li>
<li>scenes: åœºæ™¯åˆ—è¡¨ï¼Œæ¯ä¸ªåœºæ™¯å®šä¹‰äº†åœºæ™¯çš„æ ¹èŠ‚ç‚¹ï¼Œä»¥åŠåˆå§‹é»˜è®¤åœºæ™¯ã€‚</li>
<li>nodes: èŠ‚ç‚¹åˆ—è¡¨ï¼Œå®šä¹‰äº†3Dç©ºé—´ä¸­çš„å¯¹è±¡ï¼ˆå¦‚æ¨¡å‹ã€ç¯å…‰ã€ç›¸æœºç­‰ï¼‰åŠå…¶å˜æ¢ï¼ˆä½ç½®ã€æ—‹è½¬ã€ç¼©æ”¾ï¼‰ã€‚</li>
<li>meshes: ç½‘æ ¼åˆ—è¡¨ï¼Œæè¿°äº†3Då¯¹è±¡çš„å‡ ä½•å½¢çŠ¶ï¼ŒåŒ…æ‹¬é¡¶ç‚¹ã€ç´¢å¼•å’Œé¡¶ç‚¹å±æ€§ï¼ˆå¦‚æ³•çº¿ã€UVåæ ‡ï¼‰ã€‚</li>
<li>materials: æè´¨åˆ—è¡¨ï¼Œå®šä¹‰äº†å¦‚ä½•æ¸²æŸ“ç½‘æ ¼è¡¨é¢ï¼ŒåŒ…æ‹¬é¢œè‰²ã€çº¹ç†ã€å…‰ç…§æ¨¡å‹ç­‰å±æ€§ã€‚</li>
<li>textures: çº¹ç†åˆ—è¡¨ï¼Œå­˜å‚¨å›¾åƒæ•°æ®ï¼Œç”¨äºæè´¨è´´å›¾ã€ç¯å¢ƒæ˜ å°„ç­‰ã€‚</li>
<li>images: å›¾åƒæ•°æ®åˆ—è¡¨ï¼Œå¯ä»¥æ˜¯å›¾ç‰‡æ–‡ä»¶çš„å¼•ç”¨æˆ–ç›´æ¥åµŒå…¥çš„å›¾åƒæ•°æ®ã€‚</li>
<li>samplers: å®šä¹‰äº†å¦‚ä½•é‡‡æ ·çº¹ç†ï¼Œå¦‚è¿‡æ»¤å’Œç¯ç»•æ–¹å¼ã€‚</li>
<li>accessors: æ•°æ®è®¿é—®å™¨ï¼Œæè¿°å¦‚ä½•ä»ç¼“å†²åŒºè§†å›¾ä¸­è¯»å–å’Œè§£é‡Šæ•°ç»„æ•°æ®ï¼ˆå¦‚é¡¶ç‚¹åæ ‡ã€é¢œè‰²æ•°æ®ç­‰ï¼‰ã€‚</li>
<li>bufferViews: ç¼“å†²åŒºè§†å›¾ï¼ŒæŒ‡å®šç¼“å†²åŒºä¸­æ•°æ®çš„åç§»é‡å’Œé•¿åº¦ï¼Œä»¥åŠæ•°æ®çš„å­—èŠ‚æ’åˆ—æ–¹å¼ã€‚</li>
<li>buffers: ç¼“å†²åŒºï¼Œå­˜å‚¨å¤§é‡çš„åŸå§‹äºŒè¿›åˆ¶æ•°æ®ï¼Œå¦‚é¡¶ç‚¹åæ ‡ã€ç´¢å¼•ç­‰ã€‚</li>
<li>cameras: ç›¸æœºå®šä¹‰ï¼Œæè¿°äº†å¦‚ä½•ä»3Dåœºæ™¯æ¸²æŸ“åˆ°2Då›¾åƒï¼ŒåŒ…æ‹¬é€è§†ç›¸æœºå’Œæ­£äº¤ç›¸æœºã€‚</li>
<li>animations: åŠ¨ç”»åˆ—è¡¨ï¼Œå®šä¹‰äº†åœºæ™¯ä¸­èŠ‚ç‚¹æˆ–æè´¨éšæ—¶é—´å˜åŒ–çš„åŠ¨ç”»åºåˆ—ã€‚</li>
<li>skins: çš®è‚¤ä¿¡æ¯ï¼Œç”¨äºç»‘å®šç½‘æ ¼é¡¶ç‚¹åˆ°éª¨éª¼ï¼Œå®ç°è’™çš®åŠ¨ç”»ã€‚</li>
<li>extensions: æ‰©å±•ï¼Œå…è®¸åœ¨GLTFè§„èŒƒåŸºç¡€ä¸Šæ·»åŠ é¢å¤–çš„åŠŸèƒ½æˆ–ç‰¹å®šå¹³å°çš„æ”¯æŒã€‚</li>
<li>extras: é™„åŠ æ•°æ®ï¼Œç”¨äºå­˜å‚¨ä¸è¢«GLTFè§„èŒƒç›´æ¥å®šä¹‰çš„ä¿¡æ¯ï¼Œé€šå¸¸ä¾›ç‰¹å®šåº”ç”¨ç¨‹åºæˆ–å·¥å…·ä½¿ç”¨ã€‚</li>
</ul>
<p>bevyä¸­ä½¿ç”¨åˆ°äº†: scene/node/mesh/meshåŸè¯­/å˜å½¢åŠ¨ç”»æ•°æ®/çº¹ç†/æè´¨/é»˜è®¤æè´¨/åŠ¨ç”»/çš®è‚¤.</p>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>
asset types are only useful to help you navigate the contents of
your GLTF file. They are not core Bevy renderer types, and not used
by Bevy in any other way. The Bevy renderer expects Entities with
<a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>; for that you need the
<a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>.</p>
<h2 id="bevy-limitations"><a class="header" href="#bevy-limitations">Bevy Limitations</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this yet. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<p>bevyåªæ”¯æŒgltfçš„éƒ¨åˆ†åŠŸèƒ½,å¹¶ä¸æ˜¯æ‰€æœ‰çš„gltfæ–‡ä»¶éƒ½èƒ½åŠ è½½è¿›bevy.
åœ¨éƒ¨åˆ†åœºæ™¯ä¸‹,è¿˜å¾—ä¸åˆ°ä»»ä½•é”™è¯¯çš„è¯Šæ–­ä¿¡æ¯:</p>
<ul>
<li>gltfæ–‡ä»¶ä¸­,çº¹ç†ç»è¿‡äº†base64ç¼–ç ,è¿™ç§æ–‡ä»¶æ— æ³•åŠ è½½</li>
<li>mipè´´å›¾ä¹‹åœ¨ktx2/ddsçº¹ç†æ–‡ä»¶ä¸­æ”¯æŒ</li>
</ul>
<p>è¿™ä¸ªåˆ—è¡¨å¹¶ä¸å…¨,è¿˜æœ‰äº›é”™è¯¯æœªåŒ…å«è¿›æ¥.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="input-handling-1"><a class="header" href="#input-handling-1">Input Handling</a></h1>
<p>Bevy supports the following inputs:</p>
<ul>
<li><a href="/input/keyboard.html">Keyboard</a> (detect when keys are pressed or released, or for text input)</li>
<li><a href="/input/mouse.html">Mouse</a>:
<ul>
<li><a href="/input/mouse.html#mouse-motion">Motion</a> (moving the mouse, not tied to OS cursor)</li>
<li><a href="/input/mouse.html#mouse-cursor-position">Cursor</a> (absolute pointer position)</li>
<li><a href="/input/mouse.html#mouse-buttons">Buttons</a></li>
<li><a href="/input/mouse.html#mouse-scrolling--wheel">Scrolling</a> (mouse wheel or touchpad gesture)</li>
<li><a href="/input/mouse.html#touchpad-gestures">Touchpad Gestures</a> (only macOS/iOS supported)</li>
</ul>
</li>
<li><a href="/input/touch.html">Touchscreen</a> (with multi-touch)</li>
<li><a href="/input/gamepad.html">Gamepad (Controller, Joystick)</a> (via the <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> library)</li>
<li><a href="/input/dnd.html">Drag-and-Drop</a> (only for files)</li>
<li><a href="/input/ime.html">IME</a> (for advanced text input, to support multilingual users)</li>
</ul>
<p>The following notable input devices are <em><strong>not</strong></em> supported:</p>
<ul>
<li>Accelerometers and gyroscopes for device tilt</li>
<li>Other sensors, like temperature sensors</li>
<li>Tracking individual fingers on a multi-touch trackpad, like on a touchscreen</li>
<li>Microphones and other audio input devices</li>
<li>MIDI (musical instruments), but there is an unofficial plugin: <a href="https://github.com/BlackPhlox/bevy_midi"><code>bevy_midi</code></a>.</li>
</ul>
<p>bevyæ”¯æŒä»¥ä¸‹è¾“å…¥:</p>
<ul>
<li>é”®ç›˜æŒ‰é”®çš„æŒ‰ä¸‹å’Œé‡Šæ”¾,æ–‡æœ¬è¾“å…¥</li>
<li>é¼ æ ‡ç§»åŠ¨,å…‰æ ‡ä½ç½®,é¼ æ ‡æŒ‰é”®,é¼ æ ‡æ»šè½®</li>
<li>å¤šæŒ‡è§¦æ‘¸,è§¦æ‘¸æ¿æ‰‹åŠ¿(ä»…é™ä¸macç³»åˆ—),è§¦æ‘¸æ»šåŠ¨</li>
<li>æ‰‹æŸ„</li>
<li>æ–‡ä»¶æ‹–æ‹½</li>
<li>IME é«˜çº§æ–‡æœ¬è¾“å…¥</li>
</ul>
<p>bevyè¿˜ä¸æ”¯æŒä»¥ä¸‹è®¾å¤‡:</p>
<ul>
<li>åŠ é€Ÿè®¡å’Œé™€èºä»ª</li>
<li>ä¼ æ„Ÿå™¨(eg:æ¸©åº¦è®¡)</li>
<li>å¤šç‚¹è§¦æ§æ¿è·Ÿè¸ªæ‰‹æŒ‡</li>
<li>éº¦å…‹é£å’Œå…¶ä»–éŸ³é¢‘è¾“å…¥è®¾å¤‡</li>
<li>ä¹å™¨MIDI, (æœ‰ä¸ªéå®˜æ–¹çš„bevy_midi)</li>
</ul>
<hr />
<p>For most input types (where it makes sense), Bevy provides two ways of
dealing with them:</p>
<ul>
<li>by checking the current state via <a href="/programming/res.html">resources</a> (<a href="/builtins.html#input-handling-resources">input resources</a>),</li>
<li>or via <a href="/programming/events.html">events</a> (<a href="/builtins.html#input-events">input events</a>).</li>
</ul>
<p>Some inputs are only provided as events.</p>
<p>Checking state is done using <a href="/programming/res.html">resources</a> such as <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a> (for
binary inputs like keys or buttons), <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.Axis.html"><code>Axis</code></a> (for analog inputs), <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>
(for fingers on a touchscreen), etc. This way of handling input is very
convenient for implementing game logic. In these scenarios, you typically
only care about the specific inputs mapped to actions in your game. You can
check specific buttons/keys to see when they get pressed/released, or what
their current state is.</p>
<p><a href="/programming/events.html">Events</a> (<a href="/builtins.html#input-events">input events</a>) are a lower-level,
more all-encompassing approach. Use them if you want to get all activity
from that class of input device, rather than only checking for specific inputs.</p>
<p>å¯¹äºå¤§å¤šæ•°è¾“å…¥,bevyæä¾›äº†ä¸¤ç§å¤„ç†æ–¹å¼:èµ„æºå’Œäº‹ä»¶.
éƒ¨åˆ†è¾“å…¥åªæœ‰äº‹ä»¶.</p>
<p>æ£€æŸ¥èµ„æºçš„çŠ¶æ€(ButtonInputçš„æŒ‰é”®;Axisçš„é¥æ„Ÿæ–¹å‘;Touchesçš„è§¦æ‘¸)ç­‰.
è¿™ç§å¤„ç†è¾“å…¥çš„æ–¹å¼å¯¹å®ç°æ¸¸æˆé€»è¾‘æ¥è¯´éå¸¸æ–¹ä¾¿.</p>
<p>äº‹ä»¶è¾“å…¥æ˜¯ä¸€ä¸ªä½çº§åˆ«çš„å¤„ç†æ–¹å¼,å¤„ç†ä¹Ÿæ›´åŠ å…¨é¢.
å¦‚æœæƒ³ä»è¯¥ç±»è¾“å…¥è®¾å¤‡è·å–æ‰€æœ‰æ´»åŠ¨,è€Œä¸æ˜¯ä»…æ£€æŸ¥ç‰¹å®šè¾“å…¥,è¯·ä½¿ç”¨å®ƒä»¬.</p>
<h2 id="input-mapping"><a class="header" href="#input-mapping">Input Mapping</a></h2>
<p>Bevy does not yet offer a built-in way to do input mapping (configure key
bindings, etc). You need to come up with your own way of translating the
inputs into logical actions in your game/app.</p>
<p>There are some community-made plugins that may help with that: <a href="https://bevyengine.org/assets/#input">see the
input-section on bevy-assets</a>. My personal recommendation:
<a href="https://github.com/leafwing-studios/leafwing-input-manager">Input Manager plugin by Leafwing Studios</a>. It is opinionated
and unlikely to suit all games, but if it works for you, it is very high quality.</p>
<p>It may be a good idea to build your own abstractions specific to your
game. For example, if you need to handle player movement, you might want to
have a system for reading inputs and converting them to your own internal
"movement intent/action events", and then another system acting on those
custom events, to actually move the player. Make sure to use <a href="/programming/system-order.html">explicit
system ordering</a> to avoid lag / frame delays.</p>
<p>bevyæ²¡æœ‰å†…ç½®è¾“å…¥æ˜ å°„(eg:ç»‘å®šç»„åˆé”®),è¿™ä¸ªåº”è¯¥ç”±æ¸¸æˆé€»è¾‘æ¥è‡ªå®šä¹‰.
ç¤¾åŒºæœ‰äº›æ’ä»¶å¯ä»¥å®ç°è¿™äº›åŠŸèƒ½,æœ¬ä¹¦ä½œè€…æ¨èä½¿ç”¨<a href="https://github.com/leafwing-studios/leafwing-input-manager">è¿™ä¸ªæ’ä»¶</a>,
è¿™ä¸ªæ’ä»¶åœ¨æŸäº›åœºæ™¯ä¸‹éå¸¸æœ‰ç”¨(æ½œåœ¨æ„æ€æ˜¯,æ²¡æœ‰é“¶å¼¹,æ²¡æœ‰ä¸‡çµä¸¹).</p>
<p>åœ¨æ¸¸æˆä¸­ç»´æŠ¤ä¸€ä¸ªæŠ½è±¡å±‚éå¸¸æœ‰å¿…è¦.
å¦‚æœéœ€è¦å¤„ç†è§’è‰²ç§»åŠ¨,éœ€è¦åœ¨systemä¸­è¯»å–è¾“å…¥,å¹¶è½¬æ¢æˆè‡ªå·±å†…éƒ¨çš„äº‹ä»¶,
å…¶ä»–systemå°±èƒ½åŸºäºå†…éƒ¨äº‹ä»¶ç»§ç»­æ­ç§¯æœ¨å®Œå–„æ¸¸æˆé€»è¾‘.</p>
<h2 id="run-conditions-1"><a class="header" href="#run-conditions-1">Run Conditions</a></h2>
<p>Bevy also provides <a href="/programming/run-criteria.html">run conditions</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/common_conditions/index.html">see all of them
here</a>) that you can attach to your systems, if
you want a specific system to only run when a specific key or button is pressed.</p>
<p>This way, you can do input handling as part of the
<a href="/programming/intro-code.html">scheduling/configuration</a> of your <a href="/programming/systems.html">systems</a>, and
avoid running unnecessary code on the CPU.</p>
<p>Using these in real games is not recommended, because you have to hard-code the
keys, which makes it impossible to make user-configurable keybindings.</p>
<p>To support configurable keybindings, you can implement your own run conditions
that check your keybindings from your user preferences.</p>
<p>If you are using the <a href="https://github.com/leafwing-studios/leafwing-input-manager">LWIM plugin</a>, it also provides support for
<a href="https://docs.rs/leafwing-input-manager/latest/leafwing_input_manager/common_conditions/index.html">a similar run-condition-based workflow</a>.</p>
<p>bevyä¸ºsystemæä¾›äº†è¿è¡Œæ¡ä»¶,å¯ä»¥åˆ©ç”¨è¿™ä¸ªæœºåˆ¶è®©systemåªåœ¨æŸäº›é”®è¢«æŒ‰ä¸‹æ—¶è¿è¡Œ.</p>
<p>å¯ä»¥é€šè¿‡"è°ƒåº¦/é…ç½®"(åé¢ç« èŠ‚ä¸­æåˆ°)æ¥é¿å…éå¿…è¦çš„ä»£ç å ç”¨cpuèµ„æº.</p>
<p>è¿™ç§æ–¹å¼æ˜¯å°†ç¡¬ç¼–ç keyå†™åœ¨ä»£ç ä¸­äº†,ç”¨æˆ·æ— æ³•é‡æ–°ç»‘å®š,æ‰€ä»¥ä¸æ¨èåœ¨çœŸå®æ¸¸æˆä¸­ä½¿ç”¨.</p>
<p>æ’ä»¶(LWIM,å°±æ˜¯ä¸Šé¢æ¨èçš„inputç®¡ç†æ’ä»¶)åŒæ ·æä¾›äº†ä¸€ä¸ªå°å‹çš„åŸºäºè¿è¡Œæ¡ä»¶çš„å·¥ä½œæµ.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard Input</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/keyboard_input.rs"><code>keyboard_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/keyboard_input_events.rs"><code>keyboard_input_events</code></a>.</p>
<hr />
<p>This page shows how to handle keyboard keys being pressed and released.</p>
<p>Note: Command Key on Mac corresponds to the Super/Windows Key on PC.</p>
<p>Similar to <a href="input//input/mouse.html#mouse-buttons">mouse buttons</a>, keyboard input is available
as a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a> <a href="input//programming/res.html">resource</a>, <a href="input//programming/events.html">events</a>, and <a href="input//programming/run-criteria.html">run
conditions</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/common_conditions/index.html">see list</a>). Use
whichever pattern feels most appropriate to your use case.</p>
<p>å’Œé¼ æ ‡æŒ‰é”®ä¸€æ ·,é”®ç›˜æŒ‰é”®ä¹Ÿå¯ä½œä¸ºButtonInputèµ„æº/äº‹ä»¶/è¿è¡Œæ¡ä»¶, é€‰æ‹©ä¸€ç§åˆé€‚çš„å³å¯.</p>
<h2 id="checking-key-state"><a class="header" href="#checking-key-state">Checking Key State</a></h2>
<p>Most commonly for games, you might be interested in specific known keys and
detecting when they are pressed or released. You can check specific keys
using the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput&lt;KeyCode&gt;</code></a> <a href="input//programming/res.html">resource</a>.</p>
<ul>
<li>Use <code>.pressed(â€¦)</code>/<code>.released(â€¦)</code> to check if a key is being held down
<ul>
<li>These return <code>true</code> every frame, for as long as the key is in the respective state.</li>
</ul>
</li>
<li>Use <code>.just_pressed(â€¦)</code>/<code>.just_released(â€¦)</code> to detect the actual press/release
<ul>
<li>These return <code>true</code> only on the frame update when the press/release happened.</li>
</ul>
</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn keyboard_input(
    keys: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Space) {
        // Space was pressed
    }
    if keys.just_released(KeyCode::ControlLeft) {
        // Left Ctrl was released
    }
    if keys.pressed(KeyCode::KeyW) {
        // W is being held down
    }
    // we can check multiple at once with `.any_*`
    if keys.any_pressed([KeyCode::ShiftLeft, KeyCode::ShiftRight]) {
        // Either the left or right shift are being held down
    }
    if keys.any_just_pressed([KeyCode::Delete, KeyCode::Backspace]) {
        // Either delete or backspace was just pressed
    }
}</code></pre>
<p>To iterate over any keys that are currently held, or that have been pressed/released:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_iter(
    keys: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    for key in keys.get_pressed() {
        println!("{:?} is currently held down", key);
    }
    for key in keys.get_just_pressed() {
        println!("{:?} was pressed", key);
    }
    for key in keys.get_just_released() {
        println!("{:?} was released", key);
    }
}</code></pre>
<p>å¤§å¤šæ•°æ¸¸æˆéƒ½ä¼šé€‰æ‹©æ£€æŸ¥èµ„æº,ç›´æ¥æŸ¥èµ„æºä¿å­˜çš„æŒ‰é”®çŠ¶æ€.<br />
<code>.pressed()/.released()</code>,æ£€æŸ¥æŸä¸ªé”®æ˜¯å¦å·²ç»è¢«æŒ‰ä¸‹æˆ–é‡Šæ”¾.åªè¦çŠ¶æ€å¯¹,æ¯å¸§éƒ½è¿”å›true.<br />
<code>.just_pressed()/.just_released()</code>,åªè¦çŠ¶æ€å¯¹,åªåœ¨å½“å‰å¸§è¿”å›true.</p>
<h2 id="run-conditions-2"><a class="header" href="#run-conditions-2">Run Conditions</a></h2>
<p>Another workflow is to add <a href="input//programming/run-criteria.html">run conditions</a> to your systems,
so that they only run when the appropriate inputs happen.</p>
<p>It is highly recommended you write your own <a href="input//programming/run-criteria.html">run conditions</a>,
so that you can check for whatever you want, support configurable bindings, etcâ€¦</p>
<p>For prototyping, Bevy offers some <a href="input//input.html#run-conditions">built-in run conditions</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::common_conditions::*;

app.add_systems(Update, (
    handle_jump
        .run_if(input_just_pressed(KeyCode::Space)),
    handle_shooting
        .run_if(input_pressed(KeyCode::Enter)),
));</code></pre>
<p>æ¡ä»¶è¿è¡Œ,ä»…åœ¨æŸäº›äº‹å‘ç”Ÿæ—¶æ‰æ‰§è¡Œsystem.</p>
<p>å¼ºçƒˆæ¨èè‡ªå·±ç¼–å†™è‡ªå·±çš„è¿è¡Œæ¡ä»¶,è¿™æ ·å¯ä»¥è¿½æ±‚æ›´å¤§çš„çµæ´»æ€§,ä¹Ÿæ”¯æŒé…ç½®æŒ‰é”®ç»‘å®šç­‰.</p>
<p>ä¸Šé¢çš„ä¾‹å­æ˜¯bevyå†…ç½®çš„è¿è¡Œæ¡ä»¶.</p>
<h2 id="keyboard-events"><a class="header" href="#keyboard-events">Keyboard Events</a></h2>
<p>To get all keyboard activity, you can use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_events(
    mut evr_kbd: EventReader&lt;KeyboardInput&gt;,
) {
    for ev in evr_kbd.read() {
        match ev.state {
            ButtonState::Pressed =&gt; {
                println!("Key press: {:?} ({:?})", ev.key_code, ev.logical_key);
            }
            ButtonState::Released =&gt; {
                println!("Key release: {:?} ({:?})", ev.key_code, ev.logical_key);
            }
        }
    }
}</code></pre>
<p>æ•è·æ‰€æœ‰é”®ç›˜äº‹ä»¶,ä½¿ç”¨äº‹ä»¶.</p>
<h3 id="physical-keycode-vs-logical-key"><a class="header" href="#physical-keycode-vs-logical-key">Physical <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a> vs. Logical <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a></a></h3>
<p>When a key is pressed, the <a href="input//programming/events.html">event</a> contains two important pieces of information:</p>
<ul>
<li>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a>, which always represents a specific key on the keyboard,
regardless of the OS layout or language settings.</li>
<li>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a>, which contains the logical meaning of the key as interpreted by the OS.</li>
</ul>
<p>When you want to implement gameplay mechanics, you want to use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a>.
This will give you reliable keybindings that always work, including for multilingual
users with multiple keyboard layouts configured in their OS.</p>
<p>When you want to implement text/character input, you want to use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a>.
This can give you Unicode characters that you can append to your text string and
will allow your users to type just like they do in other applications.</p>
<p>If you'd like to handle special function keys or media keys on keyboards that
have them, that can also be done via the logical <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/enum.Key.html"><code>Key</code></a>.</p>
<p>å½“ä¸€ä¸ªé”®æŒ‰ä¸‹æ—¶,äº‹ä»¶ä¼šåŒ…å«ä¸¤éƒ¨åˆ†ä¿¡æ¯:</p>
<ul>
<li>KeyCode,é”®ç›˜ä¸Šå“ªä¸ªé”®è¢«æŒ‰ä¸‹äº†,å’ŒOSä¸ºä¸åŒè¯­è¨€çš„å¸ƒå±€æ— å…³</li>
<li>Key,OSå¯¹æŒ‰é”®çš„è§£é‡Š</li>
</ul>
<p>å½“å®ç°æ¸¸æˆé€»è¾‘æ—¶,éœ€è¦ä½¿ç”¨Keycode,è¿™æ ·ä½ å¯ä»¥å§‹ç»ˆæä¾›å¯é çš„ç»‘å®š.<br />
å½“å®ç°æ–‡æœ¬/å­—ç¬¦è¾“å…¥æ—¶,ä½¿ç”¨Key,è¿™å¯ä»¥ä¸ºæ‚¨æä¾›Unicodeå­—ç¬¦,æ‚¨å¯ä»¥å°†å…¶é™„åŠ åˆ°æ–‡æœ¬å­—ç¬¦ä¸²ä¸­,
å¹¶å…è®¸æ‚¨çš„ç”¨æˆ·åƒåœ¨å…¶ä»–åº”ç”¨ç¨‹åºä¸­ä¸€æ ·è¿›è¡Œé”®å…¥ã€‚</p>
<p>å¦‚æœæ‚¨æƒ³å¤„ç†å…·æœ‰ç‰¹æ®ŠåŠŸèƒ½é”®æˆ–åª’ä½“é”®çš„é”®ç›˜,ä¹Ÿå¯ä»¥é€šè¿‡é€»è¾‘é”®æ¥å®Œæˆ.</p>
<h2 id="text-input"><a class="header" href="#text-input">Text Input</a></h2>
<p>Here is a simple example of how to implement text input into a string (here
stored as a <a href="input//programming/local.html">local</a>).</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::ButtonState;
use bevy::input::keyboard::{Key, KeyboardInput};

fn text_input(
    mut evr_kbd: EventReader&lt;KeyboardInput&gt;,
    mut string: Local&lt;String&gt;,
) {
    for ev in evr_kbd.read() {
        // We don't care about key releases, only key presses
        if ev.state == ButtonState::Released {
            continue;
        }
        match &amp;ev.logical_key {
            // Handle pressing Enter to finish the input
            Key::Enter =&gt; {
                println!("Text input: {}", &amp;*string);
                string.clear();
            }
            // Handle pressing Backspace to delete last char
            Key::Backspace =&gt; {
                string.pop();
            }
            // Handle key presses that produce text characters
            Key::Character(input) =&gt; {
                // Ignore any input that contains control (special) characters
                if input.chars().any(|c| c.is_control()) {
                    continue;
                }
                string.push_str(&amp;input);
            }
            _ =&gt; {}
        }
    }
}</code></pre>
<p>Note how we implement special handling for keys like <code>Backspace</code> and <code>Enter</code>.
You can easily add special handling for other keys that make sense in your
application, like arrow keys or the <code>Escape</code> key.</p>
<p>Keys that produce useful characters for our text come in as small Unicode
strings. It is possible that there might be more than one <code>char</code> per keypress
in some languages.</p>
<p>Note: To support text input for international users who use languages
with complex scripts (such as East Asian languages), or users who use
assistive methods like handwriting recognition, you also need to support
<a href="input//input/ime.html">IME input</a>, in addition to keyboard input.</p>
<p>æ–‡æœ¬è¾“å…¥,ä¸Šé¢çš„ä¾‹å­ä¸­å¯¹å›é€€å’Œenteré”®åšäº†ç‰¹æ®Šå¤„ç†,å¸¸è§çš„ç‰¹æ®Šå¤„ç†è¿˜æœ‰Esc/æ–¹å‘é”®.</p>
<p>æ³¨æ„:ä¸ºäº†æ”¯æŒä½¿ç”¨å¤æ‚è„šæœ¬çš„è¯­è¨€(CJK)çš„å›½é™…ç”¨æˆ·æˆ–ä½¿ç”¨æ‰‹å†™è¯†åˆ«ç­‰è¾…åŠ©æ–¹æ³•çš„ç”¨æˆ·çš„æ–‡æœ¬è¾“å…¥,
é™¤äº†é”®ç›˜è¾“å…¥ä¹‹å¤–,æ‚¨è¿˜éœ€è¦æ”¯æŒ IME è¾“å…¥.</p>
<h2 id="keyboard-focus"><a class="header" href="#keyboard-focus">Keyboard Focus</a></h2>
<p>If you are doing advanced things like caching state to detect multi-key
sequences or combinations of keys, you might end up in an inconsistent
state if the Bevy OS window loses focus in the middle of keyboard input,
such as with Alt-Tab or similar OS window switching mechanisms.</p>
<p>If you are doing such things and you think your algorithm might be getting
stuck, Bevy offers a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/struct.KeyboardFocusLost.html"><code>KeyboardFocusLost</code></a> <a href="input//programming/events.html">event</a> to let you
know when you should reset your state.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::keyboard::KeyboardFocusLost;

fn detect_special_sequence(
    mut evr_focus_lost: EventReader&lt;KeyboardFocusLost&gt;,
    mut remembered_keys: Local&lt;Vec&lt;KeyCode&gt;&gt;,
) {
    // Imagine we need to remeber a sequence of keypresses
    // for some special gameplay reason.
    // TODO: implement that; store state in `remembered_keys`

    // But it might go wrong if the user Alt-Tabs, we need to reset
    if !evr_focus_lost.is_empty() {
        remembered_keys.clear();
        evr_focus_lost.clear();
    }
}</code></pre>
<p>å¦‚æœæ‚¨æ­£åœ¨æ‰§è¡Œé«˜çº§æ“ä½œ,ä¾‹å¦‚ç¼“å­˜çŠ¶æ€ä»¥æ£€æµ‹å¤šé”®åºåˆ—æˆ–é”®ç»„åˆ,
å¦‚æœ Bevy OS çª—å£åœ¨é”®ç›˜è¾“å…¥è¿‡ç¨‹ä¸­å¤±å»ç„¦ç‚¹(ä¾‹å¦‚ä½¿ç”¨ Alt-Tab æˆ–ç±»ä¼¼çš„ OS çª—å£åˆ‡æ¢æœºåˆ¶),
æ‚¨å¯èƒ½ä¼šé™·å…¥ä¸ä¸€è‡´çš„çŠ¶æ€.</p>
<p><code>KeyboardFocusLost</code>äº‹ä»¶ä¼šä¸Šæ¸…é™¤ä¸€äº›æŒ‰é”®ç¼“å­˜.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/mouse_input.rs"><code>mouse_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/mouse_input_events.rs"><code>mouse_input_events</code></a>.</p>
<hr />
<h2 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h2>
<p>Similar to <a href="input//input/keyboard.html">keyboard input</a>, mouse buttons are available as a
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a> <a href="input//programming/res.html">resource</a>, <a href="input//programming/events.html">events</a>, and <a href="input//programming/run-criteria.html">run
conditions</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/common_conditions/index.html">see list</a>). Use whichever
pattern feels most appropriate to your use case.</p>
<h3 id="checking-button-state"><a class="header" href="#checking-button-state">Checking Button State</a></h3>
<p>You can check the state of specific mouse buttons using the
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/enum.MouseButton.html"><code>ButtonInput&lt;MouseButton&gt;</code></a> <a href="input//programming/res.html">resource</a>:</p>
<ul>
<li>Use <code>.pressed(â€¦)</code>/<code>.released(â€¦)</code> to check if a button is being held down
<ul>
<li>These return <code>true</code> every frame, for as long as the button is in the respective state.</li>
</ul>
</li>
<li>Use <code>.just_pressed(â€¦)</code>/<code>.just_released(â€¦)</code> to detect the actual press/release
<ul>
<li>These return <code>true</code> only on the frame update when the press/release happened.</li>
</ul>
</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn mouse_button_input(
    buttons: Res&lt;ButtonInput&lt;MouseButton&gt;&gt;,
) {
    if buttons.just_pressed(MouseButton::Left) {
        // Left button was pressed
    }
    if buttons.just_released(MouseButton::Left) {
        // Left Button was released
    }
    if buttons.pressed(MouseButton::Right) {
        // Right Button is being held down
    }
    // we can check multiple at once with `.any_*`
    if buttons.any_just_pressed([MouseButton::Left, MouseButton::Middle]) {
        // Either the left or the middle (wheel) button was just pressed
    }
}</code></pre>
<p>You can also iterate over any buttons that have been pressed or released:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_iter(
    buttons: Res&lt;ButtonInput&lt;MouseButton&gt;&gt;,
) {
    for button in buttons.get_pressed() {
        println!("{:?} is currently held down", button);
    }
    for button in buttons.get_just_pressed() {
        println!("{:?} was pressed", button);
    }
    for button in buttons.get_just_released() {
        println!("{:?} was released", button);
    }
}</code></pre>
<p>é€šè¿‡ButtonInput<MourseButton>èµ„æºè·å–é¼ æ ‡æŒ‰é”®çŠ¶æ€.</p>
<h3 id="run-conditions-3"><a class="header" href="#run-conditions-3">Run Conditions</a></h3>
<p>Another workflow is to add <a href="input//programming/run-criteria.html">run conditions</a> to your systems,
so that they only run when the appropriate inputs happen.</p>
<p>It is highly recommended you write your own <a href="input//programming/run-criteria.html">run conditions</a>,
so that you can check for whatever you want, support configurable bindings, etcâ€¦</p>
<p>For prototyping, Bevy offers some <a href="input//input.html#run-conditions">built-in run conditions</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::common_conditions::*;

app.add_systems(Update, (
    handle_middleclick
        .run_if(input_just_pressed(MouseButton::Middle)),
    handle_drag
        .run_if(input_pressed(MouseButton::Left)),
));</code></pre>
<p>è¿è¡Œæ¡ä»¶,ä¸Šé¢çš„ä¾‹å­ä¸­æ¼”ç¤ºäº†é¼ æ ‡ä¸­é”®æŒ‰ä¸‹å’Œå·¦é”®æ‹–æ‹½.</p>
<h3 id="mouse-button-events"><a class="header" href="#mouse-button-events">Mouse Button Events</a></h3>
<p>Alternatively, you can use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a> <a href="input//programming/events.html">events</a> to get
all activity:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseButtonInput;

fn mouse_button_events(
    mut mousebtn_evr: EventReader&lt;MouseButtonInput&gt;,
) {
    use bevy::input::ButtonState;

    for ev in mousebtn_evr.read() {
        match ev.state {
            ButtonState::Pressed =&gt; {
                println!("Mouse button press: {:?}", ev.button);
            }
            ButtonState::Released =&gt; {
                println!("Mouse button release: {:?}", ev.button);
            }
        }
    }
}</code></pre>
<p>é¼ æ ‡äº‹ä»¶.</p>
<h2 id="mouse-scrolling--wheel"><a class="header" href="#mouse-scrolling--wheel">Mouse Scrolling / Wheel</a></h2>
<p>To detect scrolling input, use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseWheel;

fn scroll_events(
    mut evr_scroll: EventReader&lt;MouseWheel&gt;,
) {
    use bevy::input::mouse::MouseScrollUnit;
    for ev in evr_scroll.read() {
        match ev.unit {
            MouseScrollUnit::Line =&gt; {
                println!("Scroll (line units): vertical: {}, horizontal: {}", ev.y, ev.x);
            }
            MouseScrollUnit::Pixel =&gt; {
                println!("Scroll (pixel units): vertical: {}, horizontal: {}", ev.y, ev.x);
            }
        }
    }
}</code></pre>
<p>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a> enum is important: it tells you the type of scroll
input. <code>Line</code> is for hardware with fixed steps, like the wheel on desktop
mice. <code>Pixel</code> is for hardware with smooth (fine-grained) scrolling, like
laptop touchpads.</p>
<p>You should probably handle each of these differently (with different
sensitivity settings), to provide a good experience on both types of hardware.</p>
<p><strong>Note:</strong> the <code>Line</code> unit is not guaranteed to have whole number values/steps!
At least <a href="input//platforms/macos.html">macOS</a> does non-linear scaling / acceleration of
scrolling at the OS level, meaning your app will get weird values for the number
of lines, even when using a regular PC mouse with a fixed-stepping scroll wheel.</p>
<p>é¼ æ ‡æ»šè½®äº‹ä»¶.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MouseScrollUnit {
    Line, // æŒ‰è¡Œæ»šåŠ¨, é€‚åˆé¼ æ ‡ç¡¬ä»¶
    Pixel, // æŒ‰åƒç´ æ»šåŠ¨, é€‚åˆç¬”è®°æœ¬è§¦æ‘¸æ¿
}
<span class="boring">}</span></code></pre></pre>
<p>macç³»ç»Ÿå¯¹äºLineæ»šåŠ¨æ—¶,æ»šåŠ¨çš„è¡Œæ•°ä¸æ˜¯çº¿æ€§å˜åŒ–çš„,éœ€è¦æ³¨æ„è¿™ä¸ªå¹³å°å¯èƒ½å‡ºç°é—®é¢˜.</p>
<h2 id="mouse-motion"><a class="header" href="#mouse-motion">Mouse Motion</a></h2>
<p>Use this if you don't care about the exact position of the mouse cursor,
but rather you just want to see how much the mouse moved from frame to
frame. This is useful for things like controlling a 3D camera.</p>
<p>Use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a> <a href="input//programming/events.html">events</a>. Whenever the mouse is moved, you
will get an event with the delta.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseMotion;

fn mouse_motion(
    mut evr_motion: EventReader&lt;MouseMotion&gt;,
) {
    for ev in evr_motion.read() {
        println!("Mouse moved: X: {} px, Y: {} px", ev.delta.x, ev.delta.y);
    }
}</code></pre>
<p>You might want to <a href="input//window/mouse-grab.html">grab/lock the mouse inside the game
window</a>.</p>
<p>ä¸å…³å¿ƒé¼ æ ‡å…·ä½“ç§»åŠ¨äº†å¤šå°‘,è€Œå…³å¿ƒå¸§é—´ç§»åŠ¨çš„å·®å€¼,è¿™ç§éœ€æ±‚åœ¨3dç›¸æœºä¸­è¿˜æ˜¯æœ‰å¾ˆå¤šçš„.
ä½¿ç”¨<code>MouseMotion</code>äº‹ä»¶æ¥å®ç°.</p>
<h2 id="mouse-cursor-position"><a class="header" href="#mouse-cursor-position">Mouse Cursor Position</a></h2>
<p>Use this if you want to accurately track the position of the pointer /
cursor. This is useful for things like clicking and hovering over objects
in your game or UI.</p>
<p>You can get the current coordinates of the mouse pointer, from the respective
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.Window.html"><code>Window</code></a> (if the mouse is currently inside that window):</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::PrimaryWindow;

fn cursor_position(
    q_windows: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    // Games typically only have one window (the primary window)
    if let Some(position) = q_windows.single().cursor_position() {
        println!("Cursor is inside the primary window, at {:?}", position);
    } else {
        println!("Cursor is not in the game window.");
    }
}</code></pre>
<p>To detect when the pointer is moved, use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a> <a href="input//programming/events.html">events</a>
to get the updated coordinates:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_events(
    mut evr_cursor: EventReader&lt;CursorMoved&gt;,
) {
    for ev in evr_cursor.read() {
        println!(
            "New cursor position: X: {}, Y: {}, in Window ID: {:?}",
            ev.position.x, ev.position.y, ev.window
        );
    }
}</code></pre>
<p>Note that you can only get the position of the mouse inside a window;
you cannot get the global position of the mouse in the whole OS Desktop /
on the screen as a whole.</p>
<p>The coordinates you get are in "window space". They represent window
pixels, and the origin is the <strong>top left</strong> corner of the window.</p>
<p>They do not relate to your camera or in-game coordinates in any way. <a href="input//cookbook/cursor2world.html">See
this cookbook example</a> for converting these window
cursor coordinates into world-space coordinates.</p>
<p>To track when the mouse cursor enters and leaves your window(s), use
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a> and <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>å¦‚æœæ‚¨æƒ³å‡†ç¡®è·Ÿè¸ªæŒ‡é’ˆ/å…‰æ ‡çš„ä½ç½®,è¯·ä½¿ç”¨æ­¤é€‰é¡¹.
è¿™å¯¹äºåœ¨æ¸¸æˆæˆ– UI ä¸­å•å‡»æˆ–æ‚¬åœåœ¨å¯¹è±¡ä¸Šç­‰æ“ä½œéå¸¸æœ‰ç”¨.</p>
<p><code>cursor_position()</code>å¯ä»¥ä»å½“å‰çª—å£è·å–å…‰æ ‡å½“å‰åæ ‡.
<code>EventReader&lt;CursorMoved&gt;</code>è·å–å…‰æ ‡ç§»åŠ¨äº‹ä»¶.</p>
<p>å…‰æ ‡åœ¨çª—å£ä¸­å°±èƒ½è·å–åˆ°åæ ‡,å‡ºäº†çª—å£å°±è·å–ä¸åˆ°äº†.
èƒ½è·å–åˆ°çš„åæ ‡éƒ½æ˜¯åŸºäºçª—å£çš„,çª—å£çš„åŸç‚¹åœ¨åä¸Šè§’.
è¿™ä¸ªåæ ‡å’Œç›¸æœº/æ¸¸æˆä¸­çš„åæ ‡ä¸æ˜¯åŒä¸€å¥—,ä¸¤è€…çš„åæ ‡è½¬æ¢å¯ä»¥ç¿»ä¸€ä¸‹å‰é¢çš„"åæ ‡"ä¸€èŠ‚.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="gamepad-controller-joystick"><a class="header" href="#gamepad-controller-joystick">Gamepad (Controller, Joystick)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/gamepad_input.rs"><code>gamepad_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/input/gamepad_input_events.rs"><code>gamepad_input_events</code></a>.</p>
<hr />
<p>Bevy has support for gamepad input hardware, using <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a>:
console controllers, joysticks, etc. Many different kinds of hardware should
work, but if your device is not supported, you should file an issue with the
<a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> project.</p>
<p>bevyåˆ©ç”¨gilrsåº“æ¥å®ç°æ‰‹æŸ„çš„è¾“å…¥.</p>
<h2 id="gamepad-ids"><a class="header" href="#gamepad-ids">Gamepad IDs</a></h2>
<p>Bevy assigns a unique ID (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.Gamepad.html"><code>Gamepad</code></a>) to each connected gamepad. For local
multiplayer, this lets you associate each device with a specific player and
distinguish which one your inputs are coming from.</p>
<p>You can use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a> <a href="input//programming/res.html">resource</a> to list the IDs of all the
currently connected gamepad devices, or to check the status of a specific one.</p>
<pre><code class="language-rust no_run noplayground">fn list_gamepads(gamepads: Res&lt;Gamepads&gt;) {
    println!("Currently connected gamepads:");
    for gamepad in gamepads.iter() {
        println!(
            "ID: {:?}; Name: {}",
            gamepad,
            gamepads.name(gamepad).unwrap_or("unknown")
        );
    }
}</code></pre>
<p>bevyç»™æ¯ä¸ªè¿æ¥çš„æ‰‹æŸ„éƒ½åˆ†é…äº†å”¯ä¸€id,è¿™ä¸ªidæ˜¯ç”¨äºåŒºåˆ†è¾“å…¥æºçš„.</p>
<p>ä¸Šé¢çš„ä¾‹å­æ˜¯é€šè¿‡Gamepadsèµ„æºæ˜¾ç¤ºæ‰€æœ‰å·²è¿æ¥çš„æ‰‹æŸ„.</p>
<h3 id="handling-connections--disconnections"><a class="header" href="#handling-connections--disconnections">Handling Connections / Disconnections</a></h3>
<p>To detect when gamepads are connected or disconnected, you can use
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/enum.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>Example showing how to remember the first connected gamepad ID:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::gamepad::{GamepadConnection, GamepadEvent};

/// Simple resource to store the ID of the first connected gamepad.
/// We can use it to know which gamepad to use for player input.
#[derive(Resource)]
struct MyGamepad(Gamepad);

fn gamepad_connections(
    mut commands: Commands,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut evr_gamepad: EventReader&lt;GamepadEvent&gt;,
) {
    for ev in evr_gamepad.read() {
        // we only care about connection events
        let GamepadEvent::Connection(ev_conn) = ev else {
            continue;
        };
        match &amp;ev_conn.connection {
            GamepadConnection::Connected(info) =&gt; {
                debug!(
                    "New gamepad connected: {:?}, name: {}",
                    ev_conn.gamepad, info.name,
                );
                // if we don't have any gamepad yet, use this one
                if my_gamepad.is_none() {
                    commands.insert_resource(MyGamepad(ev_conn.gamepad));
                }
            }
            GamepadConnection::Disconnected =&gt; {
                debug!("Lost connection with gamepad: {:?}", ev_conn.gamepad);
                // if it's the one we previously used for the player, remove it:
                if let Some(MyGamepad(old_id)) = my_gamepad.as_deref() {
                    if *old_id == ev_conn.gamepad {
                        commands.remove_resource::&lt;MyGamepad&gt;();
                    }
                }
            }
        }
    }
}</code></pre>
<p>ä½¿ç”¨<code>GamepadEvent</code>äº‹ä»¶æ¥æ£€æµ‹æ‰‹æŸ„çš„è¿æ¥çŠ¶æ€.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum GamepadEvent {
    Connection(GamepadConnectionEvent),
    Button(GamepadButtonChangedEvent),
    Axis(GamepadAxisChangedEvent),
}
<span class="boring">}</span></code></pre></pre>
<p>ä¸Šé¢ç»´æŠ¤æ‰‹æŸ„è¿æ¥çŠ¶æ€çš„ä¾‹å­,ç”¨èµ„æºä¿å­˜äº†ä¸€ä¸ªæ‰‹æŸ„ä¿¡æ¯,å¹¶æœªæ”¯æŒå¤šæ‰‹æŸ„.</p>
<h2 id="handling-gamepad-inputs"><a class="header" href="#handling-gamepad-inputs">Handling Gamepad Inputs</a></h2>
<p>The <code>Axis&lt;GamepadAxis&gt;</code> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.Axis.html"><code>Axis</code></a>, <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadAxis.html"><code>GamepadAxis</code></a>) <a href="input//programming/res.html">resource</a>
keeps track of the current value of the different axes: X/Y for each thumb
stick, and the Z axes (the analog triggers).</p>
<p>Buttons can be handled with the <code>ButtonInput&lt;GamepadButton&gt;</code>
(<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/struct.ButtonInput.html"><code>ButtonInput</code></a>, <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>) <a href="input//programming/res.html">resource</a>, similar to <a href="input//input/mouse.html#mouse-buttons">mouse
buttons</a> or <a href="input//input/keyboard.html">keyboard keys</a>.</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input(
    axes: Res&lt;Axis&lt;GamepadAxis&gt;&gt;, // æ‰‹æŸ„è¾“å…¥å¯ä»¥é€šè¿‡äº‹ä»¶æˆ–èµ„æºè·å–,è¿™é‡Œæ˜¯é€šè¿‡èµ„æº
    buttons: Res&lt;ButtonInput&lt;GamepadButton&gt;&gt;,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
) {
    // æ‰‹æŸ„è¾“å…¥çš„å¤„ç†æµç¨‹æ˜¯æ ‡å‡†çš„: å…ˆå¤„ç†è¿æ¥,å†å¤„ç†è¾“å…¥,ä¸¤è€…ç‹¬ç«‹å¤„ç†.
    let Some(&amp;MyGamepad(gamepad)) = my_gamepad.as_deref() else {
        // no gamepad is connected
        // è¿™é‡Œå¯ä»¥åªå¤„ç†æ„Ÿå…´è¶£çš„æ‰‹æŸ„,åœ¨å¤šæ‰‹æŸ„è¿æ¥çš„åœºæ™¯éå¸¸å¿…è¦.
        // nsä¸»ç•Œé¢,çº¢è“æ‰‹æŸ„éƒ½èƒ½æ§åˆ¶,å°±æ˜¯æ²¡æœ‰å¤„ç†è¿‡æ»¤.
        return;
    };

    // The joysticks are represented using a separate axis for X and Y
    let axis_lx = GamepadAxis {
        gamepad,
        axis_type: GamepadAxisType::LeftStickX,
    };
    let axis_ly = GamepadAxis {
        gamepad,
        axis_type: GamepadAxisType::LeftStickY,
    };

    // pub struct Axis&lt;T&gt;, Tä¸ºè¾“å…¥è®¾å¤‡ç±»å‹,structå­˜å‚¨çš„æ˜¯ä½ç½®ä¿¡æ¯.
    // Axis.get()è·å–æœ‰é™åˆ¶èŒƒå›´,ä½¿ç”¨get_unclamped()è·å–æ— é™åˆ¶èŒƒå›´.

    if let (Some(x), Some(y)) = (axes.get(axis_lx), axes.get(axis_ly)) {
        // combine X and Y into one vector
        let left_stick = Vec2::new(x, y);

        // Example: check if the stick is pushed up
        if left_stick.length() &gt; 0.9 &amp;&amp; left_stick.y &gt; 0.5 {
            // do something
            // è‡ªå®šä¹‰é¥æ„Ÿé€»è¾‘.
        }
    }

    // In a real game, the buttons would be configurable, but here we hardcode them
    // é¥æ„ŸæŒ‰é’®,å’Œæ™®é€šæŒ‰é’®çš„å¤„ç†æ–¹å¼ä¸€è‡´.
    let jump_button = GamepadButton {
        gamepad,
        button_type: GamepadButtonType::South,
    };
    let heal_button = GamepadButton {
        gamepad,
        button_type: GamepadButtonType::East,
    };

    if buttons.just_pressed(jump_button) {
        // button just pressed: make the player jump
    }

    if buttons.pressed(heal_button) {
        // button being held down: heal the player
    }
}</code></pre>
<p>Notice that the names of buttons in the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a> <code>enum</code> are
vendor-neutral (like <code>South</code> and <code>East</code> instead of X/O or A/B).</p>
<p>Some game controllers have additional buttons and axes beyond what is available
on a standard controller, for example:</p>
<ul>
<li>HOTAS (stick for flight sim)</li>
<li>steering wheel + pedals (for car driving games)</li>
</ul>
<p>These are represented by the <code>Other(u8)</code> variant in <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadAxis.html"><code>GamepadAxis</code></a>.
The <code>u8</code> value is hardware-specific, so if you want to support such devices,
your game needs to have a way for your users to configure their input bindings.</p>
<p>æ‰‹æŸ„è¾“å…¥çš„ç¬¬ä¸€ç±»å°±æ˜¯é¥æ„Ÿ.
é€šè¿‡<code>Axis</code>å’Œ<code>GamepadAxis</code>å¯è·å–é¥æ„Ÿçš„æ–¹å‘å’Œæ¨¡æ‹Ÿçš„Zè½´.
é¥æ„ŸæŒ‰é’®æ˜¯é€šè¿‡<code>ButtonInput&lt;GamepadButton&gt;</code>è·å–çš„.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Resource)]
pub struct Axis&lt;T&gt; {
    /// The position data of the input devices.
    axis_data: HashMap&lt;T, f32&gt;,
}

// å¦‚ä½•ä»èµ„æºä¸­è·å–è¾“å…¥,ä¸‹é¢åˆ†æä¸€ä¸‹.èµ·ç‚¹å°±æ˜¯systemçš„èµ„æºå‚æ•°`Res&lt;Axis&lt;GamepadAxis&gt;&gt;`.
// Axisç”¨hashmapæ¥ç»´æŠ¤è¾“å…¥çš„å€¼,keyä¸ºè¾“å…¥ç±»å‹,valueä¸ºè¾“å…¥çš„å€¼;è·å–å€¼å°±ä½¿ç”¨get().
// ä»ä½¿ç”¨çš„æµç¨‹ä¸Šè®²,åªéœ€è¦æ„é€ ä¸€ä¸ªGamepadAxisæ¥èƒ½è·å–åˆ°å¯¹åº”æ‰‹æŸ„å¯¹åº”çš„è¾“å…¥äº‹ä»¶çš„å€¼äº†.

// GamepadAxisè®¾è®¡çš„å¦‚æ­¤æš´åŠ›(ç®€å•æœ‰æ•ˆ)
pub struct GamepadAxis {
    pub gamepad: Gamepad, // å“ªä¸ªæ‰‹æŸ„çš„
    pub axis_type: GamepadAxisType, // å“ªä¸ªç±»å‹çš„è¾“å…¥
}

// å·¦å³æ‰‹æŸ„çš„xyzæ˜¯åœ¨è¿™å„¿åŒºåˆ†çš„.
pub enum GamepadAxisType {
    LeftStickX,
    LeftStickY,
    LeftZ,
    RightStickX,
    RightStickY,
    RightZ,
    Other(u8),
}

// é¥æ„ŸæŒ‰é’®.
// GamepadButtonTypeæšä¸¾, åœ¨bevyä¸­é‡æ–°å–äº†åå­—,æŒ‰é”®çš„æ•°é‡å’Œw3cçš„æ ‡å‡†æ‰‹æŸ„æŒ‰é’®æ˜¯èƒ½å¯¹ä¸Šçš„.
pub struct GamepadButton {
    pub gamepad: Gamepad,
    pub button_type: GamepadButtonType,
}
<span class="boring">}</span></code></pre></pre>
<p>bevyä¸­çš„æ‰‹æŸ„æŒ‰é’®æ˜¯è´´è¿‘æŸäº›æ‰‹æŸ„å‚å•†çš„,ä¸æ˜¯è´´è¿‘w3cæ ‡å‡†çš„.
éƒ¨åˆ†è®¾å¤‡è¿˜æ”¯æŒéæ ‡è¾“å…¥,eg:å¼€è½¦æ¸¸æˆä¸­çš„æ–¹å‘ç›˜å’Œè¸æ¿,é£è¡Œæ¸¸æˆä¸­çš„é£è¡Œæ£’,
è¿™äº›éƒ½ç”¨<code>Other(u8)</code>æ¥å¤„ç†.æ¸¸æˆéœ€è¦æä¾›ä¸€ç§æ–¹æ³•è®©ç”¨æˆ·æ¥ç»‘å®šæŒ‰é”®.</p>
<h3 id="events-1"><a class="header" href="#events-1">Events</a></h3>
<p>Alternatively, if you want to detect all activity as it comes in, you
can also handle gamepad inputs using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/enum.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input_events(mut evr_gamepad: EventReader&lt;GamepadEvent&gt;) {
    for ev in evr_gamepad.read() {
        match ev {
            GamepadEvent::Axis(ev_axis) =&gt; {
                println!(
                    "Axis {:?} on gamepad {:?} is now at {:?}",
                    ev_axis.axis_type, ev_axis.gamepad, ev_axis.value
                );
            }
            GamepadEvent::Button(ev_button) =&gt; {
                // The "value" of a button is typically `0.0` or `1.0`, but it
                // is a `f32` because some gamepads may have buttons that are
                // pressure-sensitive or otherwise analog somehow.
                println!(
                    "Button {:?} on gamepad {:?} is now at {:?}",
                    ev_button.button_type, ev_button.gamepad, ev_button.value
                );
            }
            _ =&gt; {
                // we don't care about other events here (connect/disconnect)
            }
        }
    }
}</code></pre>
<p>å¦‚æœè¦æ•è·æ‰‹æŸ„çš„æ‰€æœ‰äº‹ä»¶,ç”¨<code>GamepadEvent</code>.</p>
<h2 id="gamepad-settings"><a class="header" href="#gamepad-settings">Gamepad Settings</a></h2>
<p>You can use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a> <a href="input//programming/res.html">resource</a> to configure dead-zones
and other parameters of the various axes and buttons. You can set the global
defaults, as well as individually per-axis/button.</p>
<p>Here is an example showing how to configure gamepads with custom settings
(not necessarily <em>good</em> settings, please don't copy these blindly):</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::gamepad::{AxisSettings, ButtonSettings, GamepadSettings};

fn configure_gamepads(my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;, mut settings: ResMut&lt;GamepadSettings&gt;) {
    let Some(&amp;MyGamepad(gamepad)) = my_gamepad.as_deref() else {
        // no gamepad is connected
        return;
    };

    // add a larger default dead-zone to all axes (ignore small inputs, round to zero)
    settings.default_axis_settings.set_deadzone_lowerbound(-0.1);
    settings.default_axis_settings.set_deadzone_upperbound(0.1);

    // make the right stick "binary", squash higher values to 1.0 and lower values to 0.0
    let mut right_stick_settings = AxisSettings::default();
    right_stick_settings.set_deadzone_lowerbound(-0.5);
    right_stick_settings.set_deadzone_upperbound(0.5);
    right_stick_settings.set_livezone_lowerbound(-0.5);
    right_stick_settings.set_livezone_upperbound(0.5);
    // the raw value should change by at least this much,
    // for Bevy to register an input event:
    right_stick_settings.set_threshold(0.01);

    // make the triggers work in big/coarse steps, to get fewer events
    // reduces noise and precision
    let mut trigger_settings = AxisSettings::default();
    trigger_settings.set_threshold(0.25);

    // set these settings for the gamepad we use for our player
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::RightStickX,
        },
        right_stick_settings.clone(),
    );
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::RightStickY,
        },
        right_stick_settings.clone(),
    );
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::LeftZ,
        },
        trigger_settings.clone(),
    );
    settings.axis_settings.insert(
        GamepadAxis {
            gamepad,
            axis_type: GamepadAxisType::RightZ,
        },
        trigger_settings.clone(),
    );

    // for buttons (or axes treated as buttons):
    let mut button_settings = ButtonSettings::default();
    // require them to be pressed almost all the way, to count
    button_settings.set_press_threshold(0.9);
    // require them to be released almost all the way, to count
    button_settings.set_release_threshold(0.1);

    settings.default_button_settings = button_settings;
}</code></pre>
<p>To tie the examples together: if you have the <a href="input//programming/systems.html">system</a> from the
<a href="input/gamepad.html#handling-connections--disconnections">connect/disconnect example</a> earlier
above on this page, to update our <code>MyGamepad</code> resource, we can configure
the system from the above example with a <a href="input//programming/run-criteria.html">run condition</a>, so that
the gamepad settings are updated whenever a new gamepad is connected and
selected to be used:</p>
<pre><code class="language-rust no_run noplayground">    app.add_systems(
        Update,
        configure_gamepads.run_if(resource_exists_and_changed::&lt;MyGamepad&gt;),
    );</code></pre>
<p>æ¯ä¸ªé¥æ„Ÿéƒ½å¯ä»¥è®¾ç½®<code>æ­»åŒº</code>,ä¹Ÿå¯ä»¥å…¨å±€é…ç½®.</p>
<h2 id="gamepad-rumble"><a class="header" href="#gamepad-rumble">Gamepad Rumble</a></h2>
<p>To cause rumble/vibration, use the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gamepad/enum.GamepadRumbleRequest.html"><code>GamepadRumbleRequest</code></a> event. Every
event you send will add a "rumble" with a given intensity that lasts for
a given duration of time. As you send multiple events, each requested rumble
will be tracked independently, and the actual hardware vibration intensity
will be the sum of all the rumbles currently in progress.</p>
<p>You can also send a <code>Stop</code> event to immediately cancel any ongoing rumbling.</p>
<p>The intensity of each rumble is represented as two values: the "strong"
motor and the "weak" motor. These might produce different-feeling vibrations
on different hardware.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::gamepad::{GamepadRumbleIntensity, GamepadRumbleRequest};

fn gamepad_rumble(
    mut evw_rumble: EventWriter&lt;GamepadRumbleRequest&gt;,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
) {
    let Some(&amp;MyGamepad(gamepad)) = my_gamepad.as_deref() else {
        // no gamepad is connected
        return;
    };

    // add a short 100ms rumble at max intensity
    evw_rumble.send(GamepadRumbleRequest::Add {
        gamepad,
        duration: Duration::from_millis(100),
        intensity: GamepadRumbleIntensity::MAX,
    });

    // also rumble for a little longer (500 ms)
    // with the weak motor at half intensity
    // and the strong motor at quarter intensity
    evw_rumble.send(GamepadRumbleRequest::Add {
        gamepad,
        duration: Duration::from_millis(500),
        intensity: GamepadRumbleIntensity {
            strong_motor: 0.25,
            weak_motor: 0.5,
        },
    });
}</code></pre>
<p>æ‰‹æŸ„æŒ¯åŠ¨.<code>GamepadRumbleRequest</code>äº‹ä»¶.
æ‚¨å‘é€çš„æ¯ä¸ªäº‹ä»¶éƒ½ä¼šæ·»åŠ å…·æœ‰ç»™å®šå¼ºåº¦å¹¶æŒç»­ç»™å®šæ—¶é—´çš„éœ‡åŠ¨.
å½“æ‚¨å‘é€å¤šä¸ªäº‹ä»¶æ—¶,æ¯ä¸ªè¯·æ±‚çš„éœ‡åŠ¨éƒ½ä¼šè¢«å•ç‹¬è·Ÿè¸ª,
å®é™…çš„ç¡¬ä»¶æŒ¯åŠ¨å¼ºåº¦å°†æ˜¯å½“å‰æ­£åœ¨è¿›è¡Œçš„æ‰€æœ‰éœ‡åŠ¨çš„æ€»å’Œ.</p>
<p><code>Stop</code>äº‹ä»¶ä¼šç«‹é©¬ç»ˆæ­¢æŒ¯åŠ¨.
æŒ¯åŠ¨æœ‰æ—¶é•¿,æœ‰å¼ºå¼±.</p>
<p>å¼ºå¼±èƒ½è®¾ç½®ä¸ºæ¸è¿›çš„.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="touchscreen"><a class="header" href="#touchscreen">Touchscreen</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/touch_input.rs"><code>touch_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/touch_input_events.rs"><code>touch_input_events</code></a>.</p>
<hr />
<p>Multi-touch touchscreens are supported. You can track multiple fingers on
the screen, with position and pressure/force information. Bevy does not
offer gesture recognition.</p>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/input/touch/struct.Touches.html"><code>Touches</code></a> <a href="input//programming/res.html">resource</a> allows you to track any
fingers currently on the screen:</p>
<pre><code class="language-rust no_run noplayground">fn touches(
    touches: Res&lt;Touches&gt;,
) {
    // There is a lot more information available, see the API docs.
    // This example only shows some very basic things.

    for finger in touches.iter() {
        if touches.just_pressed(finger.id()) {
            println!("A new touch with ID {} just began.", finger.id());
        }
        println!(
            "Finger {} is at position ({},{}), started from ({},{}).",
            finger.id(),
            finger.position().x,
            finger.position().y,
            finger.start_position().x,
            finger.start_position().y,
        );
    }
}</code></pre>
<p>Alternatively, you can use <a href="https://docs.rs/bevy/0.9.1/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn touch_events(
    mut touch_evr: EventReader&lt;TouchInput&gt;,
) {
    use bevy::input::touch::TouchPhase;
    for ev in touch_evr.iter() {
        // in real apps you probably want to store and track touch ids somewhere
        match ev.phase {
            TouchPhase::Started =&gt; {
                println!("Touch {} started at: {:?}", ev.id, ev.position);
            }
            TouchPhase::Moved =&gt; {
                println!("Touch {} moved to: {:?}", ev.id, ev.position);
            }
            TouchPhase::Ended =&gt; {
                println!("Touch {} ended at: {:?}", ev.id, ev.position);
            }
            TouchPhase::Cancelled =&gt; {
                println!("Touch {} cancelled at: {:?}", ev.id, ev.position);
            }
        }
    }
}</code></pre>
<p>è§¦æ‘¸æ”¯æŒ<code>å¤šæŒ‡</code>,åœ¨å±å¹•ä¸Šå¯è·Ÿè¸ªå¤šæŒ‡çš„æŒ‰ä¸‹å’Œå‹åŠ›ä¿¡æ¯,bevyåŸç”Ÿæ²¡æœ‰æä¾›æ‰‹åŠ¿è¯†åˆ«,
å¦‚æœæœ‰éœ€è¦,æ¸¸æˆä¸­éœ€è¦è‡ªå·±å®ç°.</p>
<p><code>Touches</code>èµ„æºå¯ä»¥è·Ÿè¸ªæ‰‹æŒ‡ä¿¡æ¯;<code>TouchInput</code>äº‹ä»¶ä¹Ÿèƒ½è¾¾åˆ°åŒæ ·çš„æ•ˆæœ.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="gestures"><a class="header" href="#gestures">Gestures</a></h1>
<p>Multi-finger gestures on a Touchpad or Touchscreen are a very common
way to implement various operations, like panning, zooming, and rotating.</p>
<p>è§¦æ‘¸å±ä¸Šçš„å¤šæŒ‡æ‰‹åŠ¿è¯†åˆ«å¯è¿›è¡Œå¹³ç§»/ç¼©æ”¾/æ—‹è½¬ç­‰å¸¸è§æ“ä½œ,
è€Œæ‰‹åŠ¿è¯†åˆ«çš„å®ç°è¿˜æ˜¯æœ‰å¥—è·¯çš„.</p>
<h2 id="platform-gesture-events"><a class="header" href="#platform-gesture-events">Platform Gesture Events</a></h2>
<p>Bevy offers <a href="input//programming/events.html">events</a> that allow you to handle gestures as they
are detected / implemented by the OS.</p>
<p>Currently, only macOS and iOS are supported. Other platforms may be supported
in the future.</p>
<p>The supported gestures are:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.RotationGesture.html"><code>RotationGesture</code></a>: rotating with two fingers</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.PinchGesture.html"><code>PinchGesture</code></a>: pinch-to-zoom with two fingers</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.PanGesture.html"><code>PanGesture</code></a>: panning gesture</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/gestures/struct.DoubleTapGesture.html"><code>DoubleTapGesture</code></a>: double-tap gesture</li>
</ul>
<pre><code class="language-rust no_run noplayground">use bevy::input::gestures::{
    DoubleTapGesture, PanGesture, PinchGesture, RotationGesture
};

// these only work on macOS and iOS
fn builtin_gestures(
    mut evr_gesture_pinch: EventReader&lt;PinchGesture&gt;,
    mut evr_gesture_rotate: EventReader&lt;RotationGesture&gt;,
    mut evr_gesture_pan: EventReader&lt;PanGesture&gt;,
    mut evr_gesture_doubletap: EventReader&lt;PanGesture&gt;,
) {
    for ev_pinch in evr_gesture_pinch.read() {
        // Positive numbers are zooming in
        // Negative numbers are zooming out
        println!("Two-finger zoom by {}", ev_pinch.0);
    }
    for ev_rotate in evr_gesture_rotate.read() {
        // Positive numbers are anticlockwise
        // Negative numbers are clockwise
        println!("Two-finger rotate by {}", ev_rotate.0);
    }
    for ev_pan in evr_gesture_pan.read() {
        // Each event is a Vec2 giving you the X/Y pan amount
        println!("Two-finger pan by X: {}, Y: {}", ev_pan.0.x, ev_pan.0.y);
    }
    for ev_doubletap in evr_gesture_doubletap.read() {
        // This one has no data
        println!("Double-Tap gesture!");
    }
}</code></pre>
<p>ä¾èµ–å¹³å°çš„æ‰‹åŠ¿è¯†åˆ«äº‹ä»¶,macç³»åˆ—æ˜¯æ”¯æŒçš„.</p>
<h2 id="custom-touchpad-gestures"><a class="header" href="#custom-touchpad-gestures">Custom Touchpad Gestures</a></h2>
<p>It is not currently possible to implement your own gestures on a touchpad,
because there is no API to detect the individual fingers that are touching
the touchpad.</p>
<p>padä¸Šçš„è‡ªå®šä¹‰æ‰‹åŠ¿è¯†åˆ«è¿˜ä¸æ”¯æŒ,å› ä¸ºæ²¡æœ‰apiæ¥è·Ÿè¸ªå•ä¸ªæ‰‹æŒ‡.</p>
<h2 id="custom-touchscreen-gestures"><a class="header" href="#custom-touchscreen-gestures">Custom Touchscreen Gestures</a></h2>
<p>You can (and probably should) implement your own touchscreen gestures. Bevy
offers multi-touch detection, tracking each finger that is currently on the
screen. Implementing your own gestures is be a good way to make touchscreen
input behave appropriately to your application.</p>
<p><a href="input//input/touch.html">See here for more info on touchscreen input in Bevy.</a></p>
<p>è§¦æ‘¸å±ä¸Šçš„æ‰‹åŠ¿è¯†åˆ«å¯ä»¥å°è¯•ä¸€ä¸‹.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="drag-and-drop-files"><a class="header" href="#drag-and-drop-files">Drag-and-Drop (Files)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/app/drag_and_drop.rs"><code>drag_and_drop</code></a>.</p>
<hr />
<p>Bevy supports the Drag-and-Drop gesture common on most desktop operating
systems, but only for files, not arbitrary data / objects.</p>
<p>If you drag a file (say, from the file manager app) into a Bevy app, Bevy
will produce a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a> <a href="input//programming/events.html">event</a>, containing the path
of the file that was dropped in.</p>
<pre><code class="language-rust no_run noplayground">fn file_drop(
    mut evr_dnd: EventReader&lt;FileDragAndDrop&gt;,
) {
    for ev in evr_dnd.read() {
        if let FileDragAndDrop::DroppedFile { id, path_buf } = ev {
            println!("Dropped file with path: {:?}, in window id: {:?}", path_buf, id);
        }
    }
}</code></pre>
<p>æ‹–æ‹½,åœ¨æ¡Œé¢å¹³å°,ä¸”åªæ”¯æŒæ–‡ä»¶.é€šè¿‡<code>FileDragAndDrop</code>äº‹ä»¶æ•è·.</p>
<h2 id="detecting-the-position-of-the-drop"><a class="header" href="#detecting-the-position-of-the-drop">Detecting the Position of the Drop</a></h2>
<p>You may want to do different things depending on where the cursor was when the
drop gesture ended. For example, add the file to some collection, if it was
dropped over a specific UI element/panel.</p>
<p>Unfortunately, this is currently somewhat tricky to implement, due to <a href="https://github.com/rust-windowing/winit/issues/1550"><code>winit</code>
bug #1550</a>. Bevy does not get <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a> <a href="input//programming/events.html">events</a>
while the drag gesture is ongoing, and therefore does not respond to the
mouse cursor. Bevy completely loses track of the cursor position.</p>
<p>Checking the cursor position from the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.Window.html"><code>Window</code></a> will also not work.</p>
<p>Systems that use cursor events to respond to cursor movements will not work
during a drag gesture. This includes Bevy UI's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ui/enum.Interaction.html"><code>Interaction</code></a> detection,
which is the usual way of detecting when a UI element is hovered over.</p>
<p>æ‚¨å¯èƒ½æƒ³è¦æ ¹æ®æ”¾ä¸‹æ‰‹åŠ¿ç»“æŸæ—¶å…‰æ ‡æ‰€åœ¨çš„ä½ç½®æ‰§è¡Œä¸åŒçš„æ“ä½œ.
ä¾‹å¦‚,å¦‚æœå°†æ–‡ä»¶æ‹–æ”¾åˆ°ç‰¹å®šçš„ UI å…ƒç´ /é¢æ¿ä¸Š,åˆ™å°†æ–‡ä»¶æ·»åŠ åˆ°æŸä¸ªé›†åˆ.
å› ä¸ºwinitåŠŸèƒ½ç¼ºå¤±,è¿™ä¸ªåŠŸèƒ½è¿˜æœªå®ç°.</p>
<h3 id="workaround"><a class="header" href="#workaround">Workaround</a></h3>
<p>The only way to workaround this issue is to store the file path somewhere
temporarily after receiving the drop event. Then, wait until the next
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a> event, and then process the file.</p>
<p>Note that this might not even be on the next frame update. The next cursor
update will happen whenever the user moves the cursor. If the user does not
immediately move the mouse after dropping the file and leaves the cursor in the
same place for a while, there will be no events and your app will have no way of
knowing the cursor position.</p>
<p>è§£å†³æ­¤é—®é¢˜çš„å”¯ä¸€æ–¹æ³•æ˜¯åœ¨æ”¶åˆ°æ”¾ç½®äº‹ä»¶åå°†æ–‡ä»¶è·¯å¾„ä¸´æ—¶å­˜å‚¨åœ¨æŸå¤„.
ç„¶å,ç­‰å¾…ä¸‹ä¸€ä¸ª CursorMoved äº‹ä»¶,ç„¶åå¤„ç†è¯¥æ–‡ä»¶.
è¯·æ³¨æ„,è¿™ç”šè‡³å¯èƒ½ä¸æ˜¯åœ¨ä¸‹ä¸€å¸§æ›´æ–°æ—¶.
åªè¦ç”¨æˆ·ç§»åŠ¨å…‰æ ‡,å°±ä¼šå‘ç”Ÿä¸‹ä¸€æ¬¡å…‰æ ‡æ›´æ–°.
å¦‚æœç”¨æˆ·åœ¨æ”¾ä¸‹æ–‡ä»¶åæ²¡æœ‰ç«‹å³ç§»åŠ¨é¼ æ ‡,è€Œæ˜¯å°†å…‰æ ‡åœç•™åœ¨åŒä¸€ä½ç½®ä¸€æ®µæ—¶é—´,
åˆ™ä¸ä¼šå‘ç”Ÿä»»ä½•äº‹ä»¶,æ‚¨çš„åº”ç”¨ä¹Ÿæ— æ³•çŸ¥é“å…‰æ ‡çš„ä½ç½®.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="ime-input"><a class="header" href="#ime-input">IME Input</a></h1>
<p>Bevy has support for IMEs (Input Method Editors), which is how people perform
text input in languages with more complex scripts, like East Asian languages, and
how non-keyboard text input methods (such as handwriting recognition) work. It
requires some special handling from you, however.</p>
<p>If you'd like all international users to be able to input text in their
language, the way they usually do in other GUI apps on their OS, you should
support IMEs. If you want good accessibility for disabled users or users
who prefer alternative text input methods like handwriting recognition, you
should support IMEs. This should be in addition to supporting <a href="input//input/keyboard.html#text-input">text input via
the keyboard</a>, which is how most users will input text.</p>
<p>å¤æ‚çš„è¾“å…¥éœ€è¦ä½¿ç”¨IMEæ”¯æŒ,å…¶ä¸­å°±åŒ…æ‹¬æ±‰å­—è¾“å…¥.
æ”¯æŒIMEå°±å¯ä»¥æ”¯æŒä¸åŒè¯­è¨€çš„ç©å®¶.</p>
<h2 id="how-imes-work"><a class="header" href="#how-imes-work">How IMEs Work</a></h2>
<p>IMEs work by using a special "buffer", which shows the current in-progress
text suggestions and allows users to preview and compose the next part of
their text before confirming it. The text suggestions are provided by the OS,
but your app needs to display them for the user.</p>
<p>For example, imagine you have a text input box in your UI. You show the text
that the user has already inputted, with a cursor at the end.</p>
<p>If IME is enabled, you will get <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Preedit</code></a> <a href="input//programming/events.html">events</a>
for "pending" text.  You should show that "unconfirmed" text in the text
input box, but with different formatting to be visually distinct.</p>
<p>When the user confirms their desired input, you will get an
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Commit</code></a> <a href="input//programming/events.html">event</a> with the final text. You should
then discard any previous "uncofirmed" text and append the new text to your
actual text input string.</p>
<p>IMEçš„å·¥ä½œåŸç†æ˜¯åˆ©ç”¨ä¸€ä¸ªç‰¹æ®Šçš„ç¼“å†²,é€šè¿‡è¿™ä¸ªç¼“å†²å¯ä»¥å¾—åˆ°å€™é€‰å­—,
ä¹Ÿå¯ä»¥å°†åæ¥è¾“å…¥çš„å’Œå‰é¢çš„åˆå¹¶å½¢æˆæ–°çš„å€™é€‰å­—,ç”¨æˆ·åœ¨ç¡®è®¤ä¹‹å‰è¿˜å¯ä»¥é¢„è§ˆ.
ç”Ÿæˆå€™é€‰å­—æ˜¯å…¶ä»–OSæä¾›çš„,ä½†appéœ€è¦æ˜¾ç¤ºç”¨æˆ·è¾“å…¥.</p>
<p>åœ¨æ•´ä¸ªç”¨æˆ·è¾“å…¥çš„è¿‡ç¨‹ä¸­,appéœ€è¦æ˜¾ç¤ºç”¨æˆ·å·²ç¡®è®¤çš„æ–‡æœ¬,å¹¶åœ¨æœ€åæ˜¾ç¤ºå…‰æ ‡.</p>
<p>å¦‚æœå¯ç”¨äº†IME,é€šè¿‡<code>Ime::Preedit</code>äº‹ä»¶å¾—åˆ°é˜»å¡çš„æ–‡æœ¬.
é€šè¿‡<code>Ime::Commit</code>äº‹ä»¶å¾—åˆ°ç”¨æˆ·ç¡®è®¤çš„æ–‡æœ¬,åŠ ä¸Šä¹‹å‰ç¡®è®¤çš„æ–‡æœ¬å°±æ˜¯æ‰€æœ‰è¾“å…¥çš„æ–‡æœ¬.</p>
<h2 id="how-to-support-imes-in-your-bevy-app"><a class="header" href="#how-to-support-imes-in-your-bevy-app">How to support IMEs in your Bevy app</a></h2>
<p>First, you need to inform the OS when your application is expecting text input.
You don't want the IME to accidentally activate during gameplay, etc.</p>
<p>Whenever you want the user to input text, you enable "IME mode" on the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/struct.Window.html"><code>Window</code></a>.
When you are done, disable it.</p>
<p>If the user is not using an IME, nothing happens when you enable "IME mode". You
will still get <a href="input//input/keyboard.html">keyboard</a> <a href="input//programming/events.html">events</a> as usual and you
can <a href="input//input/keyboard.html#text-input">accept text input that way</a>.</p>
<p>If the user has an IME, you will get an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Enabled</code></a> event. At that point,
your application will no longer receive any <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>You can then handle <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Preedit</code></a> <a href="input//programming/events.html">events</a> for pending/unconfirmed
text, and <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/window/enum.Ime.html"><code>Ime::Commit</code></a> for final/confirmed text.</p>
<pre><code class="language-rust no_run noplayground">// for this simple example, we will just enable/disable IME mode on mouse click
fn ime_toggle(
    mousebtn: Res&lt;ButtonInput&lt;MouseButton&gt;&gt;,
    mut q_window: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    // è¿™é‡Œéå¸¸äººæ€§åŒ–çš„æ˜¾ç¤ºäº†é¼ æ ‡å·¦é”®å•å‡»å°±å¼€å§‹è¾“å…¥(å¯ä»¥æ¢æˆenterè¾“å…¥,enterç»“æŸè¾“å…¥)
    if mousebtn.just_pressed(MouseButton::Left) {
        let mut window = q_window.single_mut();

        // toggle "IME mode"
        window.ime_enabled = !window.ime_enabled;

        // We need to tell the OS the on-screen coordinates where the text will
        // be displayed; for this simple example, let's just use the mouse cursor.
        // In a real app, this might be the position of a UI text field, etc.
        window.ime_position = window.cursor_position().unwrap();
    }
}

fn ime_input(mut evr_ime: EventReader&lt;Ime&gt;) {
    for ev in evr_ime.read() {
        match ev {
            Ime::Commit { value, .. } =&gt; {
                println!("IME confirmed text: {}", value);
            }
            Ime::Preedit { value, cursor, .. } =&gt; {
                println!("IME buffer: {:?}, cursor: {:?}", value, cursor);
            }
            Ime::Enabled { .. } =&gt; {
                println!("IME mode enabled!");
            }
            Ime::Disabled { .. } =&gt; {
                println!("IME mode disabled!");
            }
        }
    }
}</code></pre>
<p>For the sake of brevity, this example just prints the events to the console.</p>
<p>In a real app, you will want to display the "pre-edit" text on-screen, and use
different formatting to show the cursor. On "commit", you can append the
provided text to the actual string where you normally accept text input.</p>
<p>è¦åœ¨appä¸­å¯ç”¨ime,æŒ‰å¦‚ä¸‹é¡ºåºæ“ä½œ:</p>
<ul>
<li>ç³»ç»Ÿå®‰è£…éœ€è¦çš„è¾“å…¥æ³•</li>
<li>åœ¨çª—å£å¯ç”¨IMEåŠŸèƒ½</li>
</ul>
<p>å½“appçš„IMEå¼€å§‹ç”Ÿæ•ˆæ—¶(æ¥æ”¶Ime::Enabledäº‹ä»¶å),å°±ä¸ä¼šåœ¨æ¥æ”¶åˆ°çš„KeyboardInputäº‹ä»¶äº†.
æ­¤æ—¶éœ€è¦å°†pre-editçš„æ–‡æœ¬æ˜¾ç¤ºåœ¨å±å¹•ä¸Š,å°†å·²ç¡®è®¤çš„æ–‡æœ¬æ˜¾ç¤ºåœ¨æ­£ç¡®çš„ä½ç½®,å¹¶åœ¨æœ€åæ˜¾ç¤ºå…‰æ ‡,
åœ¨<code>Commit</code>ä¹‹åæ„å‘³ç€è¾“å…¥ç»“æŸ,æ¥ç€èµ°åç»­é€»è¾‘.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="window-management"><a class="header" href="#window-management">Window Management</a></h1>
<p>This chapter covers topics related to working with the application's OS window.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="window-properties"><a class="header" href="#window-properties">Window Properties</a></h1>
<p>Page coming soonâ€¦</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<p>See the <a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/window/window_settings.rs"><code>window_settings</code></a> example.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="changing-the-background-color"><a class="header" href="#changing-the-background-color">Changing the Background Color</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/window/clear_color.rs"><code>clear_color</code></a>.</p>
<hr />
<p>Use the <a href="https://docs.rs/bevy/0.13.0/bevy/render/camera/struct.ClearColor.html"><code>ClearColor</code></a> <a href="window//programming/res.html">resource</a> to choose the default background
color. This color will be used as the default for all <a href="window//graphics/camera.html">cameras</a>,
unless overriden.</p>
<p>Note that the window will be black if no cameras exist. You must spawn at
least one camera.</p>
<pre><code class="language-rust no_run noplayground">fn setup(
    mut commands: Commands,
) {
    // this camera will use the default color
    commands.spawn(Camera2dBundle::default());
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // set the global default clear color
        .insert_resource(ClearColor(Color::rgb(0.9, 0.3, 0.6)))
        .add_systems(Startup, setup)
        .run();
}</code></pre>
<p>To override the default and use a different color for a specific camera, you can
set it using the <a href="https://docs.rs/bevy/0.13.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a> <a href="window//programming/ec.html#components">component</a>.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ClearColorConfig;

// configure the background color (if any), for a specific camera (3D)
commands.spawn(Camera3dBundle {
    camera: Camera {
        // clear the whole viewport with the given color
        clear_color: ClearColorConfig::Custom(Color::rgb(0.8, 0.4, 0.2)),
        ..Default::default()
    },
    ..Default::default()
});

// configure the background color (if any), for a specific camera (2D)
commands.spawn(Camera2dBundle {
    camera: Camera {
        // disable clearing completely (pixels stay as they are)
        // (preserves output from previous frame or camera/pass)
        clear_color: ClearColorConfig::None,
        ..Default::default()
    },
    ..Default::default()
});</code></pre>
<p>All of these locations (the components on specific cameras, the global default
resource) can be mutated at runtime, and bevy will use your new color. Changing
the default color using the resource will apply the new color to all existing
cameras that do not specify a custom color, not just newly-spawned cameras.</p>
<p><code>ClearColor</code>èµ„æºå¯ç”¨äºè®¾ç½®ç›¸æœºé»˜è®¤èƒŒæ™¯è‰²,é»˜è®¤å¯¹æ‰€æœ‰ç›¸æœºéƒ½ç”Ÿæ•ˆ.
å¦‚æœæ²¡æœ‰ç›¸æœº,çª—å£é»˜è®¤æ˜¯é»‘è‰²çš„.</p>
<p>æ›´æ”¹è¿™ä¸ªèµ„æº,ä¼šå½±å“åˆ°æ‰€æœ‰ç›¸æœº,å·²æœ‰å®ä½“å’Œå³å°†æ–°å»ºçš„å®ä½“.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="grabbing-the-mouse"><a class="header" href="#grabbing-the-mouse">Grabbing the Mouse</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/input/mouse_grab.rs"><code>mouse_grab</code></a>.</p>
<hr />
<p>For some genres of games, you want to the mouse to be restricted to the window,
to prevent it from leaving the window during gameplay.</p>
<p>There are two variations on this behavior (<a href="https://docs.rs/bevy/0.13.0/bevy/window/enum.CursorGrabMode.html"><code>CursorGrabMode</code></a>):</p>
<ul>
<li><code>Confined</code> allows the cursor to be moved, but only within the bounds of the window.</li>
<li><code>Locked</code> fixes the cursor in place and does not allow it to move.
<ul>
<li>Relative <a href="window//input/mouse.html#mouse-motion">mouse motion</a> <a href="window//programming/events.html">events</a> still work.</li>
</ul>
</li>
</ul>
<p>To grab the cursor:</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::{CursorGrabMode, PrimaryWindow};

fn cursor_grab(
    mut q_windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    let mut primary_window = q_windows.single_mut();

    // if you want to use the cursor, but not let it leave the window,
    // use `Confined` mode:
    primary_window.cursor.grab_mode = CursorGrabMode::Confined;

    // for a game that doesn't use the cursor (like a shooter):
    // use `Locked` mode to keep the cursor in one place
    primary_window.cursor.grab_mode = CursorGrabMode::Locked;

    // also hide the cursor
    primary_window.cursor.visible = false;
}</code></pre>
<p>To release the cursor:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_ungrab(
    mut q_windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    let mut primary_window = q_windows.single_mut();

    primary_window.cursor.grab_mode = CursorGrabMode::None;
    primary_window.cursor.visible = true;
}</code></pre>
<p>You should grab the cursor during active gameplay and release it when
the player pauses the game / exits to menu / etc.</p>
<p>For relative mouse movement, you should use <a href="window//input/mouse.html#mouse-motion">mouse motion</a>
instead of <a href="window//input/mouse.html#mouse-cursor-position">cursor input</a> to implement your gameplay.</p>
<p>é¼ æ ‡æ•è·,éƒ¨åˆ†åœºæ™¯ä¸‹éœ€è¦å…‰æ ‡ä¸èƒ½ç¦»å¼€çª—å£,å…·ä½“åœºæ™¯æœ‰ä¸¤ç§:</p>
<ul>
<li><code>Confined</code>: å…‰æ ‡ç§»ä¸å‡ºçª—å£</li>
<li><code>Locked</code>: å›ºå®šåœ¨ä¸€ä¸ªåŒºåŸŸ,é€‚åˆå°„å‡»æ¸¸æˆ,è¿™æ ·å…‰æ ‡è¢«å›ºå®šåœ¨æŸä¸ªä½ç½®</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CursorGrabMode {
    None,
    Confined, // macOSä¸æ”¯æŒè¿™ä¸ª
    Locked, // windowsä¸æ”¯æŒè¿™ä¸ª
}
<span class="boring">}</span></code></pre></pre>
<p>ios/androidä¸æ”¯æŒå…‰æ ‡.</p>
<p>ä»ä¸Šé¢ä¾‹å­çœ‹,æ•è·é¼ æ ‡å’Œimeè¾“å…¥ä¸€æ ·,éƒ½æ˜¯å¯ä»¥åœ¨systemä¸­å¯ç”¨/å…³é—­çš„.
åœ¨æ¸¸æˆæš‚åœæˆ–é€€å‡ºæ—¶,å¯ä»¥é‡Šæ”¾é¼ æ ‡.</p>
<h2 id="platform-differences"><a class="header" href="#platform-differences">Platform Differences</a></h2>
<p>macOS does not natively support <code>Confined</code> mode. Bevy will fallback to <code>Locked</code>.
If you want to support macOS and you want to use <a href="window//input/mouse.html#mouse-cursor-position">cursor input</a>,
you might want to implement a "virtual cursor" instead.</p>
<p>Windows does not natively support <code>Locked</code> mode. Bevy will fallback to <code>Confined</code>.
You could emulate the locked behavior by re-centering the cursor every frame:</p>
<pre><code class="language-rust no_run noplayground">#[cfg(target_os = "windows")]
fn cursor_recenter(
    mut q_windows: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    let mut primary_window = q_windows.single_mut();
    let center = Vec2::new(
        primary_window.width() / 2.0,
        primary_window.height() / 2.0,
    );
    primary_window.set_cursor_position(Some(center));
}</code></pre>
<pre><code class="language-rust no_run noplayground">#[cfg(target_os = "windows")]
app.add_systems(Update, cursor_recenter);</code></pre>
<p>å¹³å°å·®å¼‚.åœ¨macOSä¸­æ²¡æœ‰<code>Confined</code>,è¦å®ç°ç±»ä¼¼æ•ˆæœåªèƒ½å®ç°ä¸€ä¸ªè™šæ‹Ÿå…‰æ ‡;
windowsæ²¡æœ‰<code>Locked</code>æ¨¡å¼,åªèƒ½åœ¨æ¯å¸§ä¸­é‡æ–°å°†å…‰æ ‡æ”¾åœ¨ä¸­å¿ƒæ¥å®ç°.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="setting-the-window-icon"><a class="header" href="#setting-the-window-icon">Setting the Window Icon</a></h1>
<p>You might want to set a custom Window Icon. On Windows and Linux, this is
the icon image shown in the window title bar (if any) and task bar (if any).</p>
<p>Unfortunately, Bevy does not yet provide an easy and ergonomic built-in way
to do this. However, it can be done via the <code>winit</code> APIs.</p>
<p>The way shown here is quite hacky. To save on code complexity, instead of
using Bevy's asset system to load the image in the background, we bypass
the assets system and directly load the file using the <code>image</code> library.</p>
<p>There is some WIP on adding a proper API for this to Bevy; see PRs
<a href="https://github.com/bevyengine/bevy/issues/1163">#1163</a>, <a href="https://github.com/bevyengine/bevy/pull/2268">#2268</a>, <a href="https://github.com/bevyengine/bevy/issues/5488">#5488</a>,
<a href="https://github.com/bevyengine/bevy/issues/8130">#8130</a>, and <a href="https://github.com/bevyengine/bevy/issues/1031">Issue #1031</a>.</p>
<p>This example shows how to set the icon for the primary/main window, from
a Bevy startup system.</p>
<pre><code class="language-rust no_run noplayground">use bevy::winit::WinitWindows;
use winit::window::Icon;

fn set_window_icon(
    // we have to use `NonSend` here
    windows: NonSend&lt;WinitWindows&gt;,
) {
    // here we use the `image` crate to load our icon data from a png file
    // this is not a very bevy-native solution, but it will do
    let (icon_rgba, icon_width, icon_height) = {
        let image = image::open("my_icon.png")
            .expect("Failed to open icon path")
            .into_rgba8();
        let (width, height) = image.dimensions();
        let rgba = image.into_raw();
        (rgba, width, height)
    };
    let icon = Icon::from_rgba(icon_rgba, icon_width, icon_height).unwrap();

    // do it for all windows
    for window in windows.windows.values() {
        window.set_window_icon(Some(icon.clone()));
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, set_window_icon)
        .run();
}</code></pre>
<p>Note: that <a href="https://docs.rs/bevy/0.13.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> is a <a href="window//programming/non-send.html">non-send resource</a>.</p>
<p>Note: you need to add <code>winit</code> and <code>image</code> to your project's dependencies,
and they must be the same versions as used by Bevy. As of Bevy 0.13, that
should be <code>winit = "0.29"</code> and <code>image = "0.24"</code>. If you don't know which
version to use, you can use <code>cargo tree</code> or check <code>Cargo.lock</code> to see which
is the correct version.</p>
<p>çª—å£è®¾ç½®çš„å›¾æ ‡ä¼šæ˜¾ç¤ºåœ¨æ ‡é¢˜æ å’Œä»»åŠ¡æ .
åœ¨bevyä¸­åªèƒ½é€šè¿‡winit APIæ¥å®ç°.</p>
<p>ä¸ºäº†ç®€åŒ–å¤æ‚åº¦,ä¸æ˜¯é€šè¿‡èµ„äº§æ¥åŠ è½½å›¾ç‰‡,è€Œæ˜¯ç›´æ¥ä½¿ç”¨imageåº“æ¥åŠ è½½.</p>
<p>åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­æœ‰å‡ ç‚¹éœ€è¦æ³¨æ„:</p>
<ul>
<li><code>WinitWindows</code>èµ„æºè¦æŒ‡å®šä¸ºNonSend(åªåœ¨ä¸»çº¿ç¨‹ä¸Šè¿è¡Œ)</li>
<li>éœ€è¦ä¾èµ–<code>winit</code>å’Œ<code>image</code>,ä¸”ç‰ˆæœ¬è¿˜è¦å’Œbevyæœ€æ–°ç‰ˆä¿æŒä¸€è‡´</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-asset-management"><a class="header" href="#bevy-asset-management">Bevy Asset Management</a></h1>
<p>Assets are the data that the game engine is working with: all of your images,
3D models, sounds, scenes, game-specific things like item descriptions,
and more!</p>
<p>Bevy has a flexible system for loading and managing your game assets
asynchronously (in the background, without causing lag spikes in your game).</p>
<p>In your code, you refer to individual assets using <a href="/assets/handles.html">handles</a>.</p>
<p>Asset data can be <a href="/assets/assetserver.html">loaded from files</a> and also <a href="/assets/data.html">accessed from
code</a>. <a href="/assets/hot-reload.html">Hot-reloading</a> is supported to
help you during development, by reloading asset files if they change while the
game is running.</p>
<p>If you want to write some code to do something when assets finish loading, get
modified, or are unloaded, you can use <a href="/assets/assetevent.html">asset events</a>.</p>
<p>æ¸¸æˆå¼•æ“ä¼šç”¨åˆ°çš„ä¸œè¥¿,å¦‚æ‰€æœ‰çš„å›¾ç‰‡,3dæ¨¡å‹,å£°éŸ³,åœºæ™¯,æ¸¸æˆç‰¹å®šæ•°æ®(ç‰©å“æè¿°)ç­‰ç­‰,
è¿™äº›éƒ½æ˜¯èµ„äº§.</p>
<p>bevyåŠ è½½ç®¡ç†èµ„äº§éå¸¸çµæ´»,æ”¯æŒå¼‚æ­¥.
bevyä½¿ç”¨<code>handles</code>æ¥å¼•ç”¨ä¸åŒçš„èµ„æº,æœ¯è¯­æ˜¯<code>å¥æŸ„</code>,ä¸€ä¸ªè½»é‡çº§çš„ID.</p>
<p>èµ„äº§æ˜¯ä»æ–‡ä»¶ä¸­åŠ è½½,åœ¨ä»£ç ä¸­è®¿é—®,å¼€å‘é˜¶æ®µè¿˜æ”¯æŒ<code>çƒ­åŠ è½½</code>,
æ¸¸æˆè¿è¡Œè¿‡ç¨‹ä¸­,å¦‚æœèµ„äº§å‘ç”Ÿäº†å˜åŒ–,è¿˜å¯ä»¥è¿›è¡Œ<code>reload</code>.</p>
<p>é€šè¿‡èµ„äº§äº‹ä»¶,åœ¨èµ„äº§åŠ è½½å®Œæ¯•åå¯è¿›è¡Œä¿®æ”¹å’Œå¸è½½.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="handles"><a class="header" href="#handles">Handles</a></h1>
<p>Handles are lightweight IDs that refer to a specific asset. You need them
to use your assets, for example to <a href="assets//programming/commands.html">spawn entities</a> like
<a href="assets//2d/sprites.html">2D sprites</a> or <a href="assets//3d/gltf.html">3D models</a>, or to <a href="assets//assets/data.html">access the data
of the assets</a>.</p>
<p>Handles have the Rust type <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Handle.html"><code>Handle&lt;T&gt;</code></a>, where <code>T</code> is the
<a href="assets//builtins.html#assets">asset type</a>.</p>
<p>You can store handles in your <a href="assets//programming/ec.html#components">entity components</a> or
<a href="assets//programming/res.html">resources</a>.</p>
<p>Handles can refer to not-yet-loaded assets, meaning you can just spawn your
entities anyway, using the handles, and the assets will just "pop in" when
they become ready.</p>
<p>èµ„äº§çš„å¥æŸ„æ˜¯ä¸€ä¸ªè½»é‡çº§ID,è¿™ä¸ªIDä¼šæŒ‡å‘çœŸæ­£çš„èµ„äº§æ•°æ®,
åœ¨å®ä½“æ„é€ ä¸­ä¼šä½¿ç”¨åˆ°å¥æŸ„(eg:2dç²¾çµ/3dæ¨¡å‹).</p>
<p><code>Handle&lt;T&gt;</code>æ˜¯å¥æŸ„,Tä¸ºèµ„äº§ç±»å‹.
ç»„ä»¶/èµ„æºéƒ½å¯ä»¥å­˜å‚¨å¥æŸ„.</p>
<p>æœ‰äº†å¥æŸ„å,å®ä½“æ„é€ æ—¶å°±å¯ä»¥ä½¿ç”¨å¥æŸ„,å®é™…çš„èµ„äº§å¯ä»¥åœ¨åé¢åŠ è½½.</p>
<h2 id="obtaining-handles"><a class="header" href="#obtaining-handles">Obtaining Handles</a></h2>
<p>If you are <a href="assets//assets/assetserver.html">loading an asset from a file</a>, the
<code>asset_server.load(â€¦)</code> call will give you the handle. The loading of the
data happens in the background, meaning that the handle will initially refer
to an unavailable asset, and the actual data will become available later.</p>
<p>If you are <a href="assets//assets/data.html">creating your own asset data from code</a>,
the <code>assets.add(â€¦)</code> call will give you the handle.</p>
<p>å¦‚ä½•è·å–å¥æŸ„:<code>asset_server.load(â€¦)</code>ä»æ–‡ä»¶åŠ è½½èµ„äº§æ—¶ä¼šå¾—åˆ°å¥æŸ„,
å®é™…çš„åŠ è½½è¿‡ç¨‹æ˜¯å¼‚æ­¥çš„.</p>
<p>è¿˜æœ‰ä¸€ç§æ–¹å¼æ˜¯ä»ä»£ç ä¸­åˆ›å»ºèµ„äº§,<code>assets.add()</code>.</p>
<h2 id="reference-counting-strong-and-weak-handles"><a class="header" href="#reference-counting-strong-and-weak-handles">Reference Counting; Strong and Weak Handles</a></h2>
<p>Bevy keeps track of how many handles to a given asset exist at any time. Bevy
will automatically unload unused assets, after the last handle is dropped.</p>
<p>For this reason, creating additional handles to the same asset requires you
to call <code>handle.clone()</code>. This makes the operation explicit, to ensure you are
aware of all the places in your code where you create additional handles. The
<code>.clone()</code> operation is cheap, so don't worry about performance (in most cases).</p>
<p>There are two kinds of handles: "strong" and "weak". Strong assets are
counted, weak handles are not. By default, handles are strong. If you want
to create a weak handle, use <code>.clone_weak()</code> (instead of <code>.clone()</code>) on an
existing handle. Bevy can unload the asset after all strong handles are gone,
even if you are still holding some weak handles.</p>
<p>å¥æŸ„å¯ä»¥clone,æ‰€ä»¥å°±æœ‰äº†å¼•ç”¨è®¡æ•°å™¨,å½“æ‰€æœ‰çš„å¼•ç”¨éƒ½é‡Šæ”¾å,bevyä¼šè‡ªåŠ¨å¸è½½ä¸ä½¿ç”¨çš„èµ„äº§,
<code>clone</code>å…‹éš†çš„æ˜¯å¼ºå¥æŸ„,<code>clone_weak</code>å…‹éš†çš„æ˜¯å¼±å¥æŸ„,å·®åˆ«åœ¨ä¸å¼±å¥æŸ„æ²¡æœ‰å¼•ç”¨è®¡æ•°å™¨,
ä¹Ÿä¸å…³å¿ƒèµ„äº§æ˜¯å¦æ˜¯å·²åŠ è½½çš„.</p>
<h2 id="untyped-handles"><a class="header" href="#untyped-handles">Untyped Handles</a></h2>
<p>Bevy also has a <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.HandleUntyped.html"><code>HandleUntyped</code></a> type. Use this type
of handle if you need to be able to refer to any asset, regardless of the
asset type.</p>
<p>This allows you to store a collection (such as <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> or <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>HashMap</code></a>)
containing assets of mixed types.</p>
<p>You can create an untyped handle using <code>.clone_untyped()</code> on an existing
handle.</p>
<p>Just like regular handles, untyped handles can be strong or weak.</p>
<p>You need to do this to <a href="assets//assets/data.html">access the asset data</a>.</p>
<p>You can convert an untyped handle into a typed handle with <code>.typed::&lt;T&gt;()</code>,
specifying the type to use. You need to do this to <a href="assets//assets/data.html">access the asset
data</a>.</p>
<p>å¦‚æœè¦å¼•ç”¨ä»»æ„ç±»å‹çš„èµ„äº§,å¯ä»¥ä½¿ç”¨æ— ç±»å‹å¥æŸ„<code>HandleUntyped</code>,
<code>clone_untyped</code>å°±èƒ½åˆ›å»ºæ— ç±»å‹å¥æŸ„,<code>type::&lt;T&gt;</code>è½¬æ¢æˆæœ‰ç±»å‹çš„.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="load-assets-from-files-with-assetserver"><a class="header" href="#load-assets-from-files-with-assetserver">Load Assets from Files with AssetServer</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/asset/asset_loading.rs"><code>asset_loading</code></a>.</p>
<hr />
<p>To load assets from files, use the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>
<a href="assets//programming/res.html">resource</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct UiFont(Handle&lt;Font&gt;);

fn load_ui_font(mut commands: Commands, server: Res&lt;AssetServer&gt;) {
    let handle: Handle&lt;Font&gt; = server.load("font.ttf");

    // we can store the handle in a resource:
    //  - to prevent the asset from being unloaded
    //  - if we want to use it to access the asset later
    commands.insert_resource(UiFont(handle));
}</code></pre>
<p>This queues the asset loading to happen in the background, and return a
<a href="assets//assets/handles.html">handle</a>. The asset will take some time to become available. You
cannot access the actual data immediately in the same <a href="assets//programming/systems.html">system</a>,
but you can use the handle.</p>
<p>You can spawn entities like your 2D sprites, 3D models, and UI, using the
handle, even before the asset has loaded. They will just "pop in" later,
when the asset becomes ready.</p>
<p>Note that it is OK to call <code>asset_server.load(â€¦)</code> as many times as you want,
even if the asset is currently loading, or already loaded. It will just
provide you with the same handle. Every time you call it, it will just check
the status of the asset, begin loading it if needed, and give you a handle.</p>
<p>Bevy supports loading <a href="assets//builtins.html#file-formats">a variety of asset file formats</a>,
and can be extended to support more. The asset loader implementation to use
is selected based on the file extension.</p>
<p>ä»æ–‡ä»¶åŠ è½½èµ„äº§ä½¿ç”¨<code>AssetServer</code>èµ„æº,è¿™æ ·å¯ä»¥å°†èµ„äº§å­˜åˆ°èµ„æºä¸­.
æ–‡ä»¶,å›¾ç‰‡éƒ½å¯ä»¥è¿™ä¹ˆç©.</p>
<p>åŠ è½½èµ„äº§çš„é˜Ÿåˆ—,æ˜¯åœ¨åå°æ‰§è¡Œçš„,å¯¹åŒä¸€ä¸ªèµ„äº§å¤šæ¬¡è°ƒç”¨<code>asset_server.load()</code>,
ä¼šå¾—åˆ°åŒä¸€ä¸ªå¥æŸ„.</p>
<h2 id="untyped-loading"><a class="header" href="#untyped-loading">Untyped Loading</a></h2>
<p>If you want an <a href="assets//assets/handles.html#untyped-handles">untyped handle</a>, you can use
<code>asset_server.load_untyped(â€¦)</code> instead.</p>
<p>Untyped loading is possible, because Bevy always detects the file type from
the file extension anyway.</p>
<h3 id="loading-folders"><a class="header" href="#loading-folders">Loading Folders</a></h3>
<p>You can also load an entire folder of assets, regardless of how many
files are inside, using <code>asset_server.load_folder(â€¦)</code>. This gives you a
<code>Vec&lt;HandleUntyped&gt;</code> with all the <a href="assets//assets/handles.html#untyped-handles">untyped handles</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct ExtraAssets(Vec&lt;HandleUntyped&gt;);

fn load_extra_assets(mut commands: Commands, server: Res&lt;AssetServer&gt;) {
    if let Ok(handles) = server.load_folder("extra") {
        commands.insert_resource(ExtraAssets(handles));
    }
}</code></pre>
<p>Loading folders is not supported by all I/O backends. Notably, it does not
work on WASM/Web.</p>
<p><code>load_folder</code>åŠ è½½æ•´ä¸ªæ–‡ä»¶å¤¹,å¾—åˆ°çš„æ˜¯ä¸€ä¸ª<code>Vec&lt;HandleUntyped&gt;</code>,wasm/webä¸æ”¯æŒè¿™ç§.</p>
<h2 id="assetpath-and-labels"><a class="header" href="#assetpath-and-labels">AssetPath and Labels</a></h2>
<p>The asset path you use to identify an asset from the filesystem is actually
a special <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetPath.html"><code>AssetPath</code></a>, which consists of the file path +
a label. Labels are used in situations where multiple assets are contained
in the same file. An example of this are <a href="assets//3d/gltf.html">GLTF files</a>, which can
contain meshes, scenes, textures, materials, etc.</p>
<p>Asset paths can be created from a string, with the label (if any) attached
after a <code>#</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">fn load_gltf_things(mut commands: Commands, server: Res&lt;AssetServer&gt;) {
    // get a specific mesh
    let my_mesh: Handle&lt;Mesh&gt; = server.load("my_scene.gltf#Mesh0/Primitive0");

    // spawn a whole scene
    let my_scene: Handle&lt;Scene&gt; = server.load("my_scene.gltf#Scene0");
    commands.spawn(SceneBundle {
        scene: my_scene,
        ..Default::default()
    });
}</code></pre>
<p>See the <a href="assets//3d/gltf.html">GLTF page</a> for more info about working with 3D models.</p>
<p>èµ„äº§è·¯å¾„ç”¨äºæ ‡è®°æ–‡ä»¶ç³»ç»Ÿä¸­çš„èµ„äº§æ–‡ä»¶çš„å…·ä½“è·¯å¾„,
<code>èµ„äº§è·¯å¾„ = æ–‡ä»¶è·¯å¾„ + æ ‡ç­¾</code>,å¦‚æœä¸€ä¸ªæ–‡ä»¶ä¸­åŒ…å«å¤šä¸ªèµ„äº§,æ ‡ç­¾å°±æ˜¯ç”¨æ¥è¿›è¡ŒåŒºåˆ†çš„.
åŒ…å«3dæ¨¡å‹çš„gltfæ–‡ä»¶,ä¸€ä¸ªæ–‡ä»¶å°±åŒ…å«å¤šç§èµ„äº§.æ ‡ç­¾æ˜¯å¯é€‰çš„.</p>
<p>"my_scene.gltf#Mesh0/Primitive0", ç”¨<code>#</code>åˆ†å‰²æ–‡ä»¶è·¯å¾„å’Œæ ‡ç­¾.</p>
<h2 id="where-are-assets-loaded-from"><a class="header" href="#where-are-assets-loaded-from">Where are assets loaded from?</a></h2>
<p>The asset server internally relies on an implementation of the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/trait.AssetIo.html"><code>AssetIo</code></a> Rust trait, which is Bevy's way of providing
"backends" for fetching data from different types of storage.</p>
<p>Bevy provides its own default built-in I/O backends for each <a href="assets//platforms.html">supported
platform</a>.</p>
<p>On desktop platforms, it treats asset paths as relative to a folder called
<code>assets</code>, that must be placed at one of the following locations:</p>
<ul>
<li>Alongside the game's executable file, for distribution</li>
<li>In your Cargo project folder, when running your game using <code>cargo</code> during development
<ul>
<li>This is identified by the <code>CARGO_MANIFEST_DIR</code> environment variable</li>
</ul>
</li>
</ul>
<p>On the web, it fetches assets using HTTP URLs pointing within an <code>assets</code>
folder located alongside the game's <code>.wasm</code> file.</p>
<p>There are <a href="assets//setup/unofficial-plugins.html">unofficial plugins</a> available that provide alternative
I/O backend implementations, such as for loading assets from inside archive
files (<code>.zip</code>), embedded inside the game executable, using a network protocol,
â€¦ many other possibilities.</p>
<p>æœ¬æ–‡ä¸­æè¿°çš„asset serverèµ„æºç±»å‹æ˜¯å®ç°äº†<code>AssetIo</code>çš„.(è¿™ç‚¹åœ¨0.14ç‰ˆæœ¬ä¸­å·²ç»è°ƒæ•´äº†).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="access-the-asset-data"><a class="header" href="#access-the-asset-data">Access the Asset Data</a></h1>
<p>To access the actual asset data from systems, use the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> <a href="assets//programming/res.html">resource</a>.</p>
<p>You can identify your desired asset using the <a href="assets//assets/handles.html">handle</a>.</p>
<p><a href="assets//assets/handles.html#untyped-handles">untyped handles</a> need to be "upgraded" into typed handles.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct SpriteSheets {
    map_tiles: Handle&lt;TextureAtlas&gt;,
}

fn use_sprites(
    handles: Res&lt;SpriteSheets&gt;,
    atlases: Res&lt;Assets&lt;TextureAtlas&gt;&gt;,
    images: Res&lt;Assets&lt;Image&gt;&gt;,
) {
    // Could be `None` if the asset isn't loaded yet
    if let Some(atlas) = atlases.get(&amp;handles.map_tiles) {
        // do something with the texture atlas
    }
}</code></pre>
<p>åœ¨systemä¸­è®¿é—®å®é™…çš„èµ„äº§æ•°æ®,ä½¿ç”¨<code>Assets&lt;T&gt;</code>èµ„æº,é…åˆå¥æŸ„å°±èƒ½é”šå®šå…·ä½“çš„èµ„äº§.
ä½¿ç”¨æ— ç±»å‹å¥æŸ„æ—¶,éœ€è¦å…ˆå‡çº§åˆ°å…·ä½“æŸä¸ªç±»å‹çš„å¥æŸ„.</p>
<p>ä½¿ç”¨Optionæ¥å¤„ç†èµ„äº§æ²¡æœ‰åŠ è½½å®Œæ¯•çš„é—®é¢˜.</p>
<h2 id="creating-assets-from-code"><a class="header" href="#creating-assets-from-code">Creating Assets from Code</a></h2>
<p>You can also add assets to <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> manually.</p>
<p>Sometimes you need to create assets from code, rather than <a href="assets//assets/assetserver.html">loading them
from files</a>. Some common examples of such use-cases are:</p>
<ul>
<li>creating texture atlases</li>
<li>creating 3D or 2D materials</li>
<li>procedurally-generating assets like images or 3D meshes</li>
</ul>
<p>To do this, first create the data for the asset (an instance of the
<a href="assets//builtins.html#assets">asset type</a>), and then add it <code>.add(â€¦)</code> it to the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> resource, for it to be stored and tracked by
Bevy. You will get a <a href="assets//assets/handles.html">handle</a> to use to refer to it, just like
any other asset.</p>
<pre><code class="language-rust no_run noplayground">fn add_material(mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;) {
    let new_mat = StandardMaterial {
        base_color: Color::rgba(0.25, 0.50, 0.75, 1.0),
        unlit: true,
        ..Default::default()
    };

    let handle = materials.add(new_mat);

    // do something with the handle
}</code></pre>
<p>ä»£ç ä¸­åˆ›å»ºèµ„äº§.å¸¸ç”¨åœºæ™¯æœ‰:</p>
<ul>
<li>åˆ›å»ºçº¹ç†</li>
<li>åˆ›å»º2d/3dæè´¨</li>
<li>ç”Ÿæˆå›¾ç‰‡æˆ–3dç½‘æ ¼</li>
</ul>
<p>ç”Ÿæˆä¸€ä¸ªèµ„äº§å®ä¾‹,å¹¶è°ƒç”¨ <code>Assets&lt;T&gt;.add()</code>,ä¹‹åbevyå°±èƒ½è·Ÿè¸ªæ¬¡èµ„äº§äº†.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="react-to-changes-with-asset-events"><a class="header" href="#react-to-changes-with-asset-events">React to Changes with Asset Events</a></h1>
<p>If you need to perform specific actions when an asset is created,
modified, or removed, you can make a <a href="assets//programming/systems.html">system</a> that reacts to
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> <a href="assets//programming/events.html">events</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct MyMapImage {
    handle: Handle&lt;Image&gt;,
}

fn fixup_images(
    mut ev_asset: EventReader&lt;AssetEvent&lt;Image&gt;&gt;,
    mut assets: ResMut&lt;Assets&lt;Image&gt;&gt;,
    map_img: Res&lt;MyMapImage&gt;,
) {
    for ev in ev_asset.iter() {
        match ev {
            AssetEvent::Created { handle } =&gt; {
                // a texture was just loaded or changed!

                // WARNING: this mutable access will cause another
                // AssetEvent (Modified) to be emitted!
                let texture = assets.get_mut(handle).unwrap();
                // ^ unwrap is OK, because we know it is loaded now

                if *handle == map_img.handle {
                    // it is our special map image!
                } else {
                    // it is some other image
                }
            }
            AssetEvent::Modified { handle } =&gt; {
                // an image was modified
            }
            AssetEvent::Removed { handle } =&gt; {
                // an image was unloaded
            }
        }
    }
}</code></pre>
<p><strong>Note:</strong> If you are handling <code>Modified</code> events and doing a mutable access to
the data, the <code>.get_mut</code> will trigger another <code>Modified</code> event for the same
asset. If you are not careful, this could result in an infinite loop! (from
events caused by your own system)</p>
<p>è¿˜å¯ä»¥ä½¿ç”¨äº‹ä»¶æ¥ç›‘å¬èµ„äº§çš„åˆ›å»º/ä¿®æ”¹/åˆ é™¤.<code>AssetEvent&lt;T&gt;</code>.</p>
<p>å¦‚æœåœ¨ä¿®æ”¹äº‹ä»¶çš„å¤„ç†ä¸­åšäº†ä¸€ä¸ªä¿®æ”¹æ“ä½œ,ä¼šè§¦å‘ä¸€ä¸ªæ–°çš„ä¿®æ”¹äº‹ä»¶,
æ­¤å¤„éœ€è¦ç‰¹åˆ«æ³¨æ„:åˆ«æ•´å‡ºä¸ªæ— é™å¾ªç¯æ¥.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="track-loading-progress"><a class="header" href="#track-loading-progress">Track Loading Progress</a></h1>
<p>There are good community plugins that can help with this. Otherwise, this page
shows you how to do it yourself.</p>
<hr />
<p>If you want to check the status of various <a href="assets//assets/assetserver.html">asset files</a>,
you can poll it from the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>. It will tell you
whether the asset(s) are loaded, still loading, not loaded, or encountered
an error.</p>
<p>To check an individual asset, you can use <code>asset_server.get_load_state(â€¦)</code> with
a handle or path to refer to the asset.</p>
<p>To check a group of many assets, you can add them to a single collection
(such as a <code>Vec&lt;HandleUntyped&gt;</code>; <a href="assets//assets/handles.html#untyped-handles">untyped handles</a> are very
useful for this) and use <code>asset_server.get_group_load_state(â€¦)</code>.</p>
<hr />
<p>Here is a more complete code example:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct AssetsLoading(Vec&lt;HandleUntyped&gt;);

// åœ¨æ„é€ æ—¶å°†å¥æŸ„å…¨éƒ¨æ”¶é›†èµ·æ¥.
fn setup(server: Res&lt;AssetServer&gt;, mut loading: ResMut&lt;AssetsLoading&gt;) {
    // we can have different asset types
    let font: Handle&lt;Font&gt; = server.load("my_font.ttf");
    let menu_bg: Handle&lt;Image&gt; = server.load("menu.png");
    let scene: Handle&lt;Scene&gt; = server.load("level01.gltf#Scene0");

    // add them all to our collection for tracking
    loading.0.push(font.clone_untyped());
    loading.0.push(menu_bg.clone_untyped());
    loading.0.push(scene.clone_untyped());
}

fn check_assets_ready(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
    loading: Res&lt;AssetsLoading&gt;,
) {
    use bevy::asset::LoadState;

    // ç›‘æ§ä¸€ç»„èµ„äº§çš„çŠ¶æ€å˜æ›´.
    match server.get_group_load_state(loading.0.iter().map(|h| h.id)) {
        LoadState::Failed =&gt; {
            // one of our assets had an error
        }
        LoadState::Loaded =&gt; {
            // all assets are now ready

            // this might be a good place to transition into your in-game state

            // remove the resource to drop the tracking handles
            commands.remove_resource::&lt;AssetsLoading&gt;();
            // (note: if you don't have any other handles to the assets
            // elsewhere, they will get unloaded after this)
        }
        _ =&gt; {
            // NotLoaded/Loading: not fully ready yet
        }
    }
}</code></pre>
<p>æœ¬ç« ä»‹ç»çš„è‡ªå·±å®ç°èµ„äº§åŠ è½½è¿›åº¦,ç¤¾åŒºå·²ç»æœ‰äº†å¾ˆå¤šæ’ä»¶å®ç°äº†è¿™ä¸€åŠŸèƒ½.</p>
<p>å¦‚æœæƒ³æ£€æŸ¥å¤šä¸ªèµ„äº§æ–‡ä»¶çš„åŠ è½½è¿›åº¦,ä»asset serveræ‹‰å–,
çŠ¶æ€å¤§æ¦‚æœ‰:å·²åŠ è½½;åŠ è½½ä¸­;æœªåŠ è½½;å‡ºç°é”™è¯¯.</p>
<p>å¦‚æœæƒ³æ£€æŸ¥å•ä¸ªèµ„äº§æ–‡ä»¶çš„åŠ è½½è¿›åº¦,ä½¿ç”¨<code>get_load_state()</code>,å…¥å‚æ˜¯å¥æŸ„æˆ–èµ„äº§è·¯å¾„.</p>
<p>å¦‚æœæƒ³è¦æ£€æŸ¥ä¸€ç»„èµ„äº§çš„çŠ¶æ€(å¾ˆå¤šæ–‡ä»¶),å°†æ‰€æœ‰å¥æŸ„æ”¾åœ¨<code>Vec&lt;HandleUntyped&gt;</code>ä¸­,
ç„¶åä¼ ç»™<code>get_group_load_state()</code>. æ— ç±»å‹å¥æŸ„åœ¨æ­¤å¤„ä¹Ÿèµ·äº†å¾ˆå¤§çš„ä½œç”¨.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="hot-reloading-assets"><a class="header" href="#hot-reloading-assets">Hot-Reloading Assets</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/asset/hot_asset_reloading.rs"><code>hot_asset_reloading</code></a>.</p>
<hr />
<p>At runtime, if you modify the file of an <a href="assets//assets.html">asset</a>
that is <a href="assets//assets/assetserver.html">loaded</a> into the game (via the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>), Bevy can detect that and reload the
asset automatically. This is very useful for quick iteration. You can edit
your assets while the game is running and see the changes instantly in-game.</p>
<p>Not all <a href="assets//builtins.html#file-formats">file formats</a> and use cases are supported
equally well. Typical asset types like textures / images should work without
issues, but complex GLTF or scene files, or assets involving custom logic,
might not.</p>
<p>If you need to run custom logic as part of your hot-reloading
workflow, you could implement it in a <a href="assets//programming/systems.html">system</a>, using
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> (<a href="assets//assets/assetevent.html">learn more</a>).</p>
<p>Hot reloading is opt-in and has to be enabled in order to work:</p>
<pre><code class="language-rust no_run noplayground">    fn main() {
        App::new()
            .add_plugins(DefaultPlugins.set(AssetPlugin {
                watch_for_changes: true,
                ..Default::default()
            }))
            .run();
    }</code></pre>
<p>Note that this requires the <code>filesystem_watcher</code> <a href="assets//setup/bevy-config.html">Bevy cargo
feature</a>. It is enabled by default, but if you have disabled
default features to customize Bevy, be sure to include it if you need it.</p>
<p>è¿è¡Œæ—¶ä¿®æ”¹äº†èµ„äº§,bevyä¼šæ£€æµ‹åˆ°å¹¶è‡ªåŠ¨è¿›è¡Œreload,å‰ææ—¶å¼€å¯èµ„æºå˜æ›´ç›‘å¬.</p>
<p>å¯¹äºçº¹ç†/å›¾ç‰‡æ¥è¯´,reloadå¹¶æ²¡æœ‰ä»€ä¹ˆé—®é¢˜,ä½†å…¶ä»–æ ¼å¼å¯èƒ½ä¼šå‡ºç°å¼‚å¸¸,
å¤æ‚çš„gltf/åœºæ™¯æ–‡ä»¶/è‡ªå®šä¹‰é€»è¾‘æ¶‰åŠçš„èµ„æº.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AssetPlugin {
    pub file_path: String,
    pub processed_file_path: String,
    pub watch_for_changes_override: Option&lt;bool&gt;, // 0.14è¯¥ä¸ºæ­¤å­—æ®µäº†
    pub mode: AssetMode,
}

impl Default for AssetPlugin {
    fn default() -&gt; Self {
        Self {
            mode: AssetMode::Unprocessed,
            file_path: Self::DEFAULT_UNPROCESSED_FILE_PATH.to_string(),
            processed_file_path: Self::DEFAULT_PROCESSED_FILE_PATH.to_string(),
            watch_for_changes_override: None, // é»˜è®¤æ²¡æœ‰å¼€å¯ç›‘å¬,éœ€è¦æ³¨å†Œæ’ä»¶æ—¶æŒ‡å®š.
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>ç°åœ¨æ˜¯v0.14,å¯¹åº”çš„å˜æ›´ç›‘å¬åŠŸèƒ½æ¶‰åŠä¸¤ä¸ª:<br />
embedded_watcher å†…å­˜èµ„äº§å˜æ›´ç›‘å¬;file_watcher æ–‡ä»¶èµ„äº§å˜æ›´ç›‘å¬.</p>
<hr />
<h2 id="shaders"><a class="header" href="#shaders">Shaders</a></h2>
<p>Bevy also supports hot-reloading for shaders. You can edit your custom shader
code and see the changes immediately.</p>
<p>This works for any shader loaded from a file path, such as shaders specified
in your Materials definitions, or shaders <a href="assets//assets/assetserver.html">loaded</a> via the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>.</p>
<p>Shader code that does not come from asset files, such as if you include it
as a static string in your source code, cannot be hot-reloaded (for obvious
reasons).</p>
<p>ç€è‰²å™¨ä¹Ÿæ”¯æŒçƒ­åŠ è½½,ä¸ç®¡æ˜¯é€šè¿‡æè´¨å®šä¹‰çš„ç€è‰²å™¨è¿˜æ˜¯asset serverå®šä¹‰çš„ç€è‰²å™¨éƒ½ä¸€æ ·.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="processing-assets"><a class="header" href="#processing-assets">Processing Assets</a></h1>
<p>TODO / WIP</p>
<p>Coming soon...</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="audio"><a class="header" href="#audio">Audio</a></h1>
<p>Bevy offers a (somewhat barebones, but still useful) ECS-based Audio framework.
This chapter will teach you how to use it.</p>
<p>You can <a href="/audio/basic.html">play sound effects and music</a> from your game, with
volume control. There is a rudimentary <a href="/audio/spatial.html">"spatial audio"</a>
implementation, which can pan sounds left/right in stereo, based on the
<a href="/fundamentals/transforms.html">transforms</a> of <a href="/programming/intro-data.html#entities--components">entities</a>. You can also implement your
own <a href="/audio/custom.html">custom sources of audio data</a>, if you want to synthesize
sound from code, stream data from somewhere, or any other custom use case.</p>
<p>There are also 3rd-party alternatives to Bevy's audio support:</p>
<ul>
<li><a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a>: uses <a href="https://github.com/tesselode/kira"><code>kira</code></a>; provides a richer set of features and playback controls</li>
<li><a href="https://github.com/harudagondi/bevy_oddio"><code>bevy_oddio</code></a>: uses <a href="https://github.com/Ralith/oddio"><code>oddio</code></a>; seems to offer more advanced 3D spatial sound</li>
<li><a href="https://github.com/harudagondi/bevy_fundsp"><code>bevy_fundsp</code></a>: uses <a href="https://github.com/SamiPerttu/fundsp"><code>fundsp</code></a>; for advanced sound synthesis and effects</li>
</ul>
<p>(Bevy's official audio is based on the <a href="https://github.com/RustAudio/rodio"><code>rodio</code></a> library.)</p>
<p>As you can see, the Rust audio ecosystem is quite fragmented. There are
many backend libraries, all offering a different mix of features, none of
them particularly exhaustive. All of them are somewhat immature. You have
to pick your poison.</p>
<p>Audio is an area sorely in need of improvement. If you are an enthusiastic
audio developer, consider joining <a href="https://discord.gg/bevy">Discord</a> and helping
with development!</p>
<p>bevyæä¾›äº†ä¸€ä¸ªåŸºäºecsçš„éŸ³é¢‘æ¡†æ¶(åŸºäºrodio),è™½ç„¶è¿˜ç¼ºä¹å¾ˆå¤šä¸œè¥¿,ä½†æ ¸å¿ƒåŠŸèƒ½è¿˜æ˜¯æœ‰çš„.</p>
<p>åŸºäºè¿™ä¸ªæ¡†æ¶,å¯ä»¥æ’­æ”¾éŸ³æ•ˆ/éŸ³ä¹,éŸ³é‡è°ƒèŠ‚,åˆçº§çš„ç©ºé—´éŸ³é¢‘,åŒå£°é“.
ç”šè‡³å¯ä»¥å®ç°è‡ªå®šä¹‰çš„éŸ³é¢‘æ•°æ®æº,ä»¥åŠéŸ³é¢‘æ•°æ®åˆå¹¶.</p>
<p>ä¸‹é¢æ˜¯å‡ ä¸ªä¼˜ç§€çš„ç¬¬ä¸‰æ–¹ä»£æ›¿:</p>
<ul>
<li><code>bevy_kira_audio</code>åŸºäºkira,æä¾›ä¸°å¯Œçš„åŠŸèƒ½å’Œå›æ”¾æ§åˆ¶</li>
<li><code>bevy_oddio</code>åŸºäºoddio,æä¾›é«˜çº§çš„3dç©ºé—´éŸ³é¢‘</li>
<li><code>bevy_fundsp</code>åŸºäºfundsp,æä¾›é«˜çº§çš„åˆå¹¶å’ŒéŸ³æ•ˆ</li>
</ul>
<p>bevyçš„éŸ³é¢‘ç”Ÿæ€å¾ˆå‰²è£‚,æ¯ç§æ–¹æ¡ˆéƒ½æ˜¯æ–‡æ¡£åŒ®ä¹,éƒ¨åˆ†åœºåˆæ›´æ˜¯æ™ºéšœ,æŒ‰éœ€é€‰æ‹©.
è¿™å—ç»§ç»­è¿›æ­¥.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="playing-sounds"><a class="header" href="#playing-sounds">Playing Sounds</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/audio.rs"><code>audio</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/audio_control.rs"><code>audio_control</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="spatial-audio"><a class="header" href="#spatial-audio">Spatial Audio</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/spatial_audio_2d.rs"><code>spatial_audio_2d</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/spatial_audio_3d.rs"><code>spatial_audio_3d</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="custom-audio-streams"><a class="header" href="#custom-audio-streams">Custom Audio Streams</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.12.1/examples/audio/decodable.rs"><code>decodable</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-ui-framework"><a class="header" href="#bevy-ui-framework">Bevy UI Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-programming-framework"><a class="header" href="#bevy-programming-framework">Bevy Programming Framework</a></h1>
<p>This chapter presents the features of the Bevy core programming framework. This
covers the ECS (Entity Component System), App and Scheduling.</p>
<p>All the knowledge of this chapter is useful even if you want to use Bevy as
something other than a game engine. For example: using just the ECS for a
scientific simulation.</p>
<p>Hence, this chapter does not cover the game-engine parts of Bevy. Those
features are covered in other chapters of the book. You can start with
<a href="/fundamentals.html">Game Engine Fundamentals</a> chapter.</p>
<p>For additional of programming patterns and idioms, see the <a href="/patterns.html">Programming
Patterns</a> chapter.</p>
<p>If you are also interested in GPU programming, see the <a href="/gpu.html">Bevy GPU
Framework</a> chapter.</p>
<p>è¿™éƒ¨åˆ†æ˜¯bevyæ ¸å¿ƒæ¡†æ¶,å¹¶ä¸ä»…ä»…èƒ½ç”¨æ¥åšæ¸¸æˆå¼•æ“,ECSä¹Ÿå¯ä»¥å•ç‹¬æ‹¿å‡ºæ¥ç”¨çš„,
æ¶‰åŠå¯¹è±¡è¾ƒå¤šçš„ç§‘å­¦æ¨¡æ‹Ÿå¤§å¤šä½¿ç”¨ECS.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="ecs-programming-introduction"><a class="header" href="#ecs-programming-introduction">ECS Programming Introduction</a></h1>
<p>This page will try to teach you the general ECS mindset/paradigm.</p>
<hr />
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<p>Also check out the complete game examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>ECS is a programming paradigm that separates data and behavior. Bevy will store
all of <a href="programming//programming/intro-data.html">your data</a> and manage all of <a href="programming//programming/intro-code.html">your individual pieces
of functionality</a> for you. The code will run when
appropriate. Your code can get access to whatever data it needs to do its thing.</p>
<p>This makes it easy to write game logic (<a href="programming//programming/systems.html">Systems</a>) in a way that
is flexible and reusable. For example, you can implement:</p>
<ul>
<li>health and damage that works the same way for anything in the game,
regardless of whether that's the player, an NPC, or a monster, or a vehicle</li>
<li>gravity and collisions for anything that should have physics</li>
<li>an animation or sound effect for all buttons in your UI</li>
</ul>
<p>Of course, when you need specialized behavior only for specific entities (say,
player movement, which only applies to the player), that is naturally easy to
express, too.</p>
<p>If you are familiar with database programming, you will feel right at home. ECS
is conceptually very similar to a lightweight in-memory database.</p>
<p><a href="programming//programming/intro-data.html">Read more about how to represent your data.</a></p>
<p><a href="programming//programming/intro-code.html">Read more about how to represent your functionality.</a></p>
<p>bevyæœ€æ ¸å¿ƒçš„æ˜¯ECS,ECSæ˜¯ä¸€ç§å°†æ•°æ®å’Œé€»è¾‘å®Œå…¨åˆ†ç¦»çš„ç¼–ç¨‹èŒƒå¼.
æœ‰å¾ˆå¤šç§°å·,å…¶ä¸­åooå’Œæ•°æ®é©±åŠ¨å¼€å‘ç”¨çš„æ¯”è¾ƒå¤š.</p>
<p>ECSçš„ä¼˜åŠ¿æ˜¯é€»è¾‘è§£è€¦,å°é¢—ç²’çš„ç»„åˆæé«˜äº†é‡ç”¨çš„å¯èƒ½.ä¸€å®šè§„æ¨¡çš„é¡¹ç›®æ¯”å…¶ä»–èŒƒå¼è¦ç®€å•å¾ˆå¤š.</p>
<ul>
<li>ç”Ÿå‘½å€¼å’Œä¼¤å®³çš„å·¥ä½œæ–¹å¼,åœ¨ä¸€ä¸ªæ¸¸æˆå†…å¯¹æ‰€æœ‰å¯¹è±¡éƒ½æ˜¯ä¸€æ ·çš„.ç©å®¶/npc/boss/è½¦è¾†ç­‰</li>
<li>ç‰©ç†ä¸­çš„å¼•åŠ›å’Œç¢°æ’å¯¹æ‰€æœ‰ç‰©å“,åŒ…æ‹¬ç©å®¶,éƒ½æ˜¯ä¸€æ ·çš„</li>
<li>ç•Œé¢ä¸­æŒ‰é’®çš„éŸ³æ•ˆå’ŒåŠ¨ç”»,è¿™äº›è¿è¡ŒåŸç†éƒ½æ˜¯ä¸€æ ·çš„</li>
</ul>
<p>åªè¦æ˜¯ä¸€æ ·çš„,å°±å¯ä»¥å•ç‹¬æˆsystem.å¦‚æœä¸€ä¸ªå®ä½“æœ‰å¤šä¸ªé€»è¾‘,ç»„åˆå³å¯.</p>
<p>æ€»ä¹‹,ECSç±»ä¼¼äºå†…å­˜ä¸­å­˜å‚¨çš„è½»é‡çº§æ•°æ®åº“.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="intro-your-data"><a class="header" href="#intro-your-data">Intro: Your Data</a></h1>
<p>This page is an overview, to give you an idea of the big picture of how Bevy
works. Click on the various links to be taken to dedicated pages where you can
learn more about each concept.</p>
<p>è¿™é‡Œåªæ˜¯ç®€ä»‹,è¯¦ç»†å†…å®¹è¿˜éœ€è¦ç‚¹å‡»é“¾æ¥è¿›ä¸€æ­¥æŸ¥çœ‹.</p>
<hr />
<p>As mentioned in <a href="programming//programming/ecs-intro.html">the ECS Intro</a>, Bevy stores all your data for
you and allows you easy and flexible access to whatever you need, wherever you
need it.</p>
<p>The ECS's data structure is called the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>. That is what
stores and manages all of the data. For advanced scenarios, is possible to
have <a href="programming//programming/sub-apps.html">multiple worlds</a>, and then each one will behave as
its own separate ECS instance. However, normally, you just work with the
main World that Bevy sets up for your <a href="programming//programming/app-builder.html">App</a>.</p>
<p>You can represent your data in two different ways:
<a href="programming/intro-data.html#entities--components">Entities/Components</a>, and <a href="programming/intro-data.html#resources">Resources</a>.</p>
<p>ECSçš„æ•°æ®å…¨éƒ¨å­˜åœ¨ä¸€ä¸ªå«worldçš„å®ä¾‹ä¸­,worldç®¡ç†å’Œç»´æŠ¤äº†æ‰€æœ‰çš„æ•°æ®,
å¯¹äºéƒ¨åˆ†é«˜çº§åœºæ™¯,å¯èƒ½ä¼šå­˜åœ¨å¤šä¸ªworld,æ¯ä¸ªworldéƒ½æ˜¯è‡ªå·±ç‹¬ç«‹çš„ECSå®ä¾‹,
é€šå¸¸appåªæœ‰ä¸€ä¸ªworld,å…³å¿ƒä¸»worldå³å¯.</p>
<p>æ•°æ®åªèƒ½ä¾é™„äºç»„ä»¶æˆ–èµ„æºå‡ºç°.èµ„æºå°±æ˜¯ä¸€ä¸ªä¸­ç‰¹æ®Šçš„ç»„ä»¶<code>å•ä¾‹ç»„ä»¶</code>,
ä¸€ä¸ªæ¸¸æˆä¸­50%ä»¥ä¸Šéƒ½æ˜¯<code>å•ä¾‹ç»„ä»¶</code>,è¿™ç§ç‰¹æ®Šçš„ç»„ä»¶åœ¨bevyä¸­æœ‰ä¸ªæ–°åè¯:èµ„æº.</p>
<h2 id="entities--components"><a class="header" href="#entities--components">Entities / Components</a></h2>
<p>Conceptually, you can think of it by analogy with tables, like in a database or
spreadsheet. Your different data types (<a href="programming//programming/ec.html#components">Components</a>) are like
the "columns" of a table, and there can be arbitrarily many "rows"
(<a href="programming//programming/ec.html#entities">Entities</a>) containing values / instances of various components.
The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID is like the row number. It's an integer index
that lets you find specific component values.</p>
<p>Component types that are empty <code>struct</code>s (contain no data) are called <a href="programming//programming/ec.html#marker-components">marker
components</a>. They are useful as "tags" to identify
specific entities, or enable certain behaviors. For example, you could use them
to identify the player entity, to mark enemies that are currently chasing the
player, to select entities to be despawned at the end of the level, etc.</p>
<p>Here is an illustration to help you visualize the logical structure. The
checkmarks show what component types are present on each entity. Empty cells
mean that the component is not present. In this example, we have a player,
a camera, and several enemies.</p>
<div class="table-wrapper"><table><thead><tr><th><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> (ID)</th><th><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/transform/components/struct.Transform.html"><code>Transform</code></a></th><th><code>Player</code></th><th><code>Enemy</code></th><th><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/render/camera/struct.Camera.html"><code>Camera</code></a></th><th><code>Health</code></th><th>...</th></tr></thead><tbody>
<tr><td>...</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>107</td><td>âœ“ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td>âœ“</td><td></td><td></td><td>âœ“ <code>50.0</code></td><td></td></tr>
<tr><td>108</td><td>âœ“ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>âœ“</td><td></td><td>âœ“ <code>25.0</code></td><td></td></tr>
<tr><td>109</td><td>âœ“ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td></td><td>âœ“ <code>&lt;camera data&gt;</code></td><td></td><td></td></tr>
<tr><td>110</td><td>âœ“ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>âœ“</td><td></td><td>âœ“ <code>10.0</code></td><td></td></tr>
<tr><td>111</td><td>âœ“ <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>âœ“</td><td></td><td>âœ“ <code>25.0</code></td><td></td></tr>
<tr><td>...</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Representing things this way gives you flexibility. For example, you could
create a <code>Health</code> component for your game. You could then have many entities
representing different things in your game, such as the player, NPCs, or
monsters, all of which can have a <code>Health</code> value (as well as other relevant
components).</p>
<p>The typical and obvious pattern is to use entities to represent "objects in the
game/scene", such as the camera, the player, enemies, lights, props, UI
elements, and other things. However, you are not limited to that. The ECS is a
general-purpose data structure. You can create entities and components to store
any data. For example, you could create an entity to store a bunch of settings
or configuration parameters, or other abstract things.</p>
<p>Data stored using Entities and Components is accessed using
<a href="programming//programming/queries.html">queries</a>. For example, if you want to implement a new game
mechanic, write a <a href="programming//programming/systems.html">system</a> (just a Rust function that takes
special parameters), specify what component types you want to access, and do
your thing. You can either iterate through all entities that match your query,
or access the data of a specific one (using the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID).</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Xp(u32);

#[derive(Component)]
struct Health {
    current: u32,
    max: u32,
}

fn level_up(
    // We want to access the Xp and Health data:
    mut query: Query&lt;(&amp;mut Xp, &amp;mut Health)&gt;,
) {
    // process all relevant entities
    for (mut xp, mut health) in query.iter_mut() {
        if xp.0 &gt; 1000 {
            xp.0 -= 1000;
            health.max += 25;
            health.current = health.max;
        }
    }
}</code></pre>
<p>Bevy can automatically keep track of what data your <a href="programming//programming/systems.html">systems</a> have
access to and <a href="programming//programming/system-order.html">run them in parallel</a> on multiple CPU
cores. This way, you get multithreading with no extra effort from you!</p>
<p>What if you want to create or remove entities and components, not just access
existing data? That requires special consideration. Bevy cannot change the
memory layout while other systems might be running. These operations can be
buffered/deferred using <a href="programming//programming/commands.html">Commands</a>. Bevy will apply them later
when it is safe to do so. You can also get <a href="programming//programming/world.html">direct World access</a>
using <a href="programming//programming/exclusive.html">exclusive systems</a>, if you want to perform such
operations immediately.</p>
<p><a href="programming//programming/bundle.html">Bundles</a> serve as "templates" for common sets of components, to
help you when you spawn new entities, so you don't accidentally forget anything.</p>
<pre><code class="language-rust no_run noplayground">/// Marker for the player
#[derive(Component)]
struct Player;

/// Bundle to make it easy to spawn the player entity
/// with all the correct components:
#[derive(Bundle)]
struct PlayerBundle {
    // éå¸¸ç»å…¸çš„è‡ªå·±å®šä¹‰Bundle
    marker: Player,
    health: Health,
    xp: Xp,
    // including all the components from another bundle
    sprite: SpriteBundle,
}

fn spawn_player(
    // needed for safely creating/removing data in the ECS World
    // (anything done via Commands will be applied later)
    mut commands: Commands,
    // needed for loading assets
    asset_server: Res&lt;AssetServer&gt;,
) {
    // create a new entity with whatever components we want
    commands.spawn(PlayerBundle {
        marker: Player,
        health: Health {
            current: 100,
            max: 125,
        },
        xp: Xp(0),
        sprite: SpriteBundle {
            texture: asset_server.load("player.png"),
            transform: Transform::from_xyz(25.0, 50.0, 0.0),
            // use the default values for all other components in the bundle
            ..Default::default()
        },
    });

    // Call .id() if you want to store the Entity ID of your new entity
    let my_entity = commands.spawn((/* ... */)).id();
}</code></pre>
<p>è¿™é‡Œæ²¡æœ‰å¤ªå¤šé«˜æ·±çš„ç†è®º,åªæ˜¯å½¢è±¡åŒ–æè¿°äº†å®ä½“å’Œç»„ä»¶çš„å…³ç³»,
å¦‚æœæƒ³è¦äº†è§£ä¸ºå•¥ECSæ€§èƒ½é«˜,ä¸ºå•¥è¦è¿™æ ·è®¾è®¡æ•°æ®ç»“æ„çš„,å¯ä»¥æŸ¥çœ‹ECSçš„å‡ ç§å®ç°.</p>
<p>æŠ›å¼€è®¾è®¡åªçœ‹è¡¨ç°å½¢å¼,å®ä½“/ç»„ä»¶å°±åƒä¸€ä¸ªè¡¨æ ¼(æˆ–æ•°æ®åº“çš„è¡¨),
ä¸åŒçš„åˆ—æ˜¯ä¸åŒç±»å‹çš„æ•°æ®(ç»„ä»¶),å¯ä»¥æœ‰ä»»æ„å¤šè¡Œ,æ¯ä¸€è¡Œå°±æ˜¯ä¸€ä¸ªå®ä½“,
å®ä½“çš„IDå°±æ˜¯è¡Œå·(è¿™æ˜¯ä¸€ä¸ªå½¢è±¡åŒ–çš„æ¯”å–»,å¾ˆå¤šECSçš„Entityè®¾è®¡å°±æ˜¯ä¸€ä¸ªå”¯ä¸€æ•´å½¢,
è‡ªå¢ä¸»é”®IDæ­£å¥½æ»¡è¶³è¿™ä¸ªæ¡ä»¶).</p>
<p>å¦‚æœç»„ä»¶ç±»å‹æ˜¯ç©ºç»“æ„ä½“(æ²¡æœ‰å…·ä½“çš„å€¼),é‚£ä¹ˆè¿™ç§ç»„ä»¶ç§°ä¸º<code>æ ‡è®°ç»„ä»¶</code>.
æ ‡è®°ç‰¹æ®Šå®ä½“,å¯ç”¨ç‰¹å®šçš„system,è¿™éå¸¸æœ‰ç”¨.</p>
<p>ä¸Šå›¾ä¸­åœ¨ä¸€ä¸ªè¡¨ä¸­è¡¨ç¤ºäº†ä¸åŒç±»å‹çš„å®ä½“(å…·ä½“bevyå®ç°æ˜¯ä¸æ˜¯è¿™æ ·,éœ€è¦åˆ†ææºç å†è¯´).</p>
<p>ä¸€èˆ¬æ˜¯ç”¨å®ä½“æ¥è¡¨ç¤ºæ¸¸æˆ/åœºæ™¯ä¸­å‡ºç°çš„å¯¹è±¡,eg:ç›¸æœº/æ•Œäºº/å…‰çº¿/ç•Œé¢,ä½†å¯ä»¥è¡¨ç¤ºæ›´å¤š,
ä½¿ç”¨ECSå¹¶æ²¡æœ‰ä»€ä¹ˆé™åˆ¶.</p>
<p>æ•°æ®å­˜å‚¨åœ¨å®ä½“/ç»„ä»¶ä¸­,è®¿é—®æ–¹å¼æ˜¯query,åœ¨å¢é‡å¼€å‘ä¸­,æ–°å¢ä¸€ä¸ªæ¸¸æˆæœºåˆ¶,
åœ¨å®ç°systemæ—¶åªéœ€è¦é€šè¿‡queryå°†ç¬¦åˆæ¡ä»¶çš„å®ä½“æ‰¾å‡ºæ¥,å¹¶åº”ç”¨æ–°æœºåˆ¶å³å¯,
è¿™ç‚¹å¯ä»¥è®©å¤šäººå¹¶è¡Œåä½œ,æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„çªç ´.
å‡ºäº†é€šè¿‡query-éå†å®ä½“,è¿˜å¯ä»¥ç›´æ¥é€šè¿‡å®ä½“IDæ¥è®¿é—®æ•°æ®.</p>
<p>bevyé€šè¿‡è°ƒåº¦æœºåˆ¶+systemçš„é¡ºåºæœºåˆ¶,å°½é‡ä¿è¯æ¯ä¸ªcpuæ ¸ä¸Šéƒ½è·‘ç€system,
è¿™æ ·çš„å¥½å¤„æ˜¯å¼€å‘è€…å‹å¥½,å¼€å‘è€…ä¸å¿…å†è‡ªå·±ç»´æŠ¤å¤šçº¿ç¨‹äº†.</p>
<p>systemè¿è¡Œæ—¶,bevyä¸èƒ½ä¿®æ”¹å†…å­˜å¸ƒå±€,å¦‚æœè¦å¢åˆ å®ä½“æˆ–ç»„ä»¶,è¯¥æ€ä¹ˆåŠ?
é€šè¿‡Commandsè¿›è¡Œå»¶æ—¶å¤„ç†,è¿™æ ·å°±å¯ä»¥ä¿è¯å®‰å…¨äº†.
å½“ç„¶å¦‚æœè¦ç«‹é©¬ç”Ÿæ•ˆ,ä¹Ÿå¯ä»¥ç›´æ¥é€šè¿‡worldç›´æ¥è®¿é—®æ•°æ®å’Œç‹¬å systemæ¥å®ç°.</p>
<p>bevyæä¾›äº†å¾ˆå¤šBundleæ¥è¾…åŠ©æ„é€ å®ä½“.</p>
<h3 id="comparison-with-object-oriented-programming"><a class="header" href="#comparison-with-object-oriented-programming">Comparison with Object-Oriented Programming</a></h3>
<p>Object-Oriented programming teaches you to think of everything as "objects",
where each object is an instance of a "class". The class specifies the data
and functionality for all objects of that type, in one place. Every object
of that class has the same data (with different values) and the same
associated functionality.</p>
<p>This is the opposite of the ECS mentality. In ECS, any <a href="programming//programming/ec.html#entities">entity</a> can
have any data (any combination of <a href="programming//programming/ec.html#components">components</a>). The purpose of
entities is to identify that data. Your <a href="programming//programming/systems.html">systems</a> are loose pieces
of functionality that can operate on any data. They can easily find what they
are looking for, and implement the desired behavior.</p>
<p>If you are an object-oriented programmer, you might be tempted to define a big
monolithic <code>struct Player</code> containing all the fields / properties of the player.
In Bevy, this is considered bad practice, because doing it that way can make it
more difficult to work with your data and limit performance. Instead, you should
make things granular, when different pieces of data may be accessed independently.</p>
<p>For example, represent the player in your game as an entity, composed of
separate component types (separate <code>struct</code>s) for things like the health, XP, or
whatever is relevant to your game. You can also attach standard Bevy components
like <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> (<a href="programming//fundamentals/transforms.html">transforms explained</a>) to it.</p>
<p>Then, each piece of functionality (each <a href="programming//programming/systems.html">system</a>) can just
<a href="programming//programming/queries.html">query</a> for the data it needs. Common functionality (like a
health/damage system) can be applied to any entity with the matching components,
regardless of whether that's the player or something else in the game.</p>
<p>If you have functionality that should only be applied to the player entity,
you can use a <a href="programming//programming/ec.html#marker-components">marker component</a> (like <code>struct Player;</code>)
to narrow down your query (using a <a href="programming//programming/queries.html#query-filters">query filter</a> like
<code>With&lt;Player&gt;</code>).</p>
<p>However, if some data always makes sense to be accessed together, then you
should put it in a single <code>struct</code>. For example, Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>.
With these types, the fields are not likely to be useful independently.</p>
<p>ooå’Œåooè™½ç„¶æ˜¯ä¸¤ç§æ€æƒ³,ä½†æœ€ç»ˆçš„ç›®çš„éƒ½æ˜¯ä¸€ä¸ª:è§£å†³é—®é¢˜,è¾¾æˆç›®æ ‡,é™ä½å¼€å‘å’Œç»´æŠ¤æˆæœ¬.
ooæ˜¯ç»§æ‰¿ä½“ç³»,ecsæ˜¯ç»„åˆæ€æƒ³.</p>
<p>ooæ˜¯å¯¹è±¡æ‹¥æœ‰æ•°æ®,å¹¶æ‹¥æœ‰æŸäº›è¡Œä¸º; ecsæ˜¯æ•°æ®å’Œè¡Œä¸ºåˆ†ç¦»,æ¯ä¸ªsysteméƒ½æ˜¯ä¸€ä¸ªå°çš„åŠŸèƒ½ç‚¹,
ç»„åˆä¸åŒçš„systemåŒæ ·å¯ä»¥å®ç°é€»è¾‘,å› ä¸ºsysteméƒ½æ˜¯ç¢ç‰‡åŒ–çš„å°åŠŸèƒ½ç‚¹,å¥¹åªå…³æ³¨è‡ªå·±çš„éœ€æ±‚,
å¦‚æœæ˜¯ooçš„è¡Œä¸º,ä¼šçœ‹åˆ°å¾ˆå¤šå½“å‰é€»è¾‘ä¸éœ€è¦çš„æ•°æ®,æ•´ä½“çš„å®ç°çœ‹è¦çœ‹æ•´ä¸ªç»§æ‰¿ä½“ç³»
(è¿™ç‚¹åœ¨å‰å‡ ä¸ªç‰ˆæœ¬ä¸æ˜¯é—®é¢˜), ä½†åœ¨åæœŸç»´æŠ¤çš„æˆæœ¬çœ‹,è¿™ä¼šæ˜¯ä¸ªå¤§é—®é¢˜.</p>
<p>ecsæ¨èå°é¢—ç²’åº¦çš„ç»„ä»¶,è¿™æ ·æ–¹ä¾¿å¤ç”¨.å…¶å®ç¼–æˆèŒƒå¼ä¸€ç›´åœ¨æ¼”å˜,
ooå¦‚æ—¥ä¸­å¤©æ—¶å‡ºç°äº†ecs,å¹¶ä¸”<code>ç»„åˆä¼˜äºç»§æ‰¿</code>åŸºæœ¬æ·±å…¥äººå¿ƒäº†,
è¿™æ˜¯ä»æ— æ•°ä¸ªå®Œæ•´çš„é¡¹ç›®ç”Ÿå‘½å‘¨æœŸå¾—åˆ°çš„æ•™è®­.</p>
<p>å¦‚æœåªæƒ³å¯¹æŸå‡ ä¸ªå®ä½“è¿›è¡Œå¤„ç†,ä¾¿æ·çš„æ–¹æ³•æ˜¯å¢åŠ ä¸€ä¸ªç©ºçš„ç»“æ„ä½“ç»„ä»¶å……å½“æ ‡è®°ç»„ä»¶,
åŒæ ·èµ°queryæœºåˆ¶.</p>
<p>å¦‚æœæŸäº›æ•°æ®ä¸€èµ·è®¿é—®æ—¶æ˜¯æœ‰æ„ä¹‰çš„,å¯ä»¥è€ƒè™‘æ”¾åœ¨åŒä¸€ä¸ªstructä¸­.</p>
<h3 id="additional-internal-details"><a class="header" href="#additional-internal-details">Additional Internal Details</a></h3>
<p>The set / combination of components that a given entity has is called the
entity's Archetype. Bevy keeps track of that internally, to organize the
data in RAM. Entities of the same Archetype have their data stored together
in contiguous arrays, which allows the CPU to access and cache it efficiently.</p>
<p>If you add/remove component types on existing entities, you are changing
the Archetype, which may require Bevy to move previously-existing data to
a different location.</p>
<p><a href="programming//patterns/component-storage.html">Learn more about Bevy's component storage.</a></p>
<p>Bevy will reuse Entity IDs. The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> type is actually
two integers: the ID and a "generation". After you despawn some entities,
their IDs can be reused for newly-spawned entities, but Bevy will increase
the generation value.</p>
<p>åœ¨bevyä¸­,å®ä½“æ‹¥æœ‰çš„ç»„ä»¶åˆ—è¡¨æˆä¸ºåŸå‹,bevyå†…éƒ¨ä¼šè·Ÿè¸ªæ‰€æœ‰åŸå‹,
åœ¨å†…å­˜ä¸­ç»„ç»‡è¿™äº›æ•°æ®.(è¿™æ˜¯å› ä¸ºECSä¸ºäº†è¿åˆCPUçš„ioç‰¹æ€§,è½¬æ¢è®¾è®¡çš„,
åªæœ‰è¦è®¿é—®çš„æ•°æ®æ˜¯è¿ç»­å­˜æ”¾çš„,é‚£ä¹ˆcpuåœ¨ioæ—¶ä¸€æ¬¡å°±å¯ä»¥è¯»åˆ°æœªæ¥å‡ æ¬¡éœ€è¦çš„æ•°æ®,
å‡å°‘cpuçš„ioæ¬¡æ•°,å°±æ˜¯æ€§èƒ½å·¨å¤§æå‡çš„å…³é”®),åŒä¸€ä¸ªåŸå‹çš„å®ä½“æ—¶è¿ç»­å­˜æ”¾çš„,
æ–¹ä¾¿cpuçš„ç¼“å­˜å¯ä»¥å¿«é€Ÿå‘½ä¸­.</p>
<p>å®ä½“å¯ä»¥è¢«é”€æ¯,ä½†å®ä½“çš„idæ—¶å¯ä»¥å¤ç”¨çš„,ä¸€ä¸ªå®ä½“å†…éƒ¨ç”±ä¸¤ä¸ªidè¡¨ç¤º:
ä¸€ä¸ªæ˜¯å®ä½“ID,ä¸€ä¸ªæ˜¯å¤ç”¨æ¬¡æ•°(ä¹Ÿå¯ä»¥æˆä¸ºç‰ˆæœ¬,ä»£æ•°,éƒ½æ˜¯ä¸€ä¸ªæ„æ€).
è¿™é‡Œé¢è¿˜éšè—äº†ä¸€ä¸ªå…³é”®æŠ€æœ¯:å®ä½“idå¤ç”¨æœºåˆ¶.goè¯­è¨€æœ‰ä¸ªarcheä¹Ÿæ˜¯ecsåº“,
å®ä½“çš„å®ç°å’Œbevyæ˜¯ä¸€æ ·çš„,åº•å±‚æœ‰ä¸ªé“¾è¡¨æ¥è·Ÿè¸ªæ‰€æœ‰å¯å¤ç”¨çš„å®ä½“id,
ä¸çŸ¥é“bevyæ˜¯ä¸æ˜¯åŒæ ·çš„å®ç°.</p>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>If there is only one global instance (singleton) of something, and it is
standalone (not associated with other data), create a <a href="programming//programming/res.html">Resource</a>.</p>
<p>For example, you could create a resource to store your game's graphics
settings, or an interface to a non-Bevy library.</p>
<p>This is a simple way of storing data, when you know you don't need the
flexibility of Entities/Components.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct GameSettings {
    current_level: u32,
    difficulty: u32,
    max_time_seconds: u32,
}

fn setup_game(mut commands: Commands) {
    // Add the GameSettings resource to the ECS
    // (if one already exists, it will be overwritten)
    commands.insert_resource(GameSettings {
        current_level: 1,
        difficulty: 100,
        max_time_seconds: 60,
    });
}

fn spawn_extra_enemies(
    mut commands: Commands,
    // we can easily access our resource from any system
    game_settings: Res&lt;GameSettings&gt;,
) {
    if game_settings.difficulty &gt; 50 {
        commands.spawn((
            // ...
        ));
    }
}
</code></pre>
<p>å•ä¾‹ç»„ä»¶:èµ„æº.ä¸€ä¸ªæ¸¸æˆ,å¤§éƒ¨åˆ†éƒ½æ˜¯èµ„æº,å°‘éƒ¨åˆ†çµæ´»çš„æ‰æ˜¯ç»„ä»¶.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="intro-your-code"><a class="header" href="#intro-your-code">Intro: Your Code</a></h1>
<p>This page is an overview, to give you an idea of the big picture of how Bevy
works. Click on the various links to be taken to dedicated pages where you can
learn more about each concept.</p>
<p>è¿™é‡Œåªæ˜¯æ¦‚è¿°,ç»†èŠ‚éœ€è¦ç‚¹å‡»é“¾æ¥è¿›ä¸€æ­¥æŸ¥çœ‹.</p>
<hr />
<p>As mentioned in <a href="programming//programming/ecs-intro.html">the ECS Intro</a>, Bevy manages all of your
functionality/behaviors for you, running them when appropriate and giving them
access to whatever parts of <a href="programming//programming/intro-data.html">your data</a> they need.</p>
<p>Individual pieces of functionality are called <a href="programming//programming/systems.html">systems</a>. Each system
is a Rust function (<code>fn</code>) you write, which accepts <a href="programming//builtins.html#systemparams">special parameter
types</a> to indicate what <a href="programming//programming/intro-data.html">data</a> it needs to
access. Think of the function signature as a "specification" for what to fetch
from the ECS <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>Here is what a <a href="programming//programming/systems.html">system</a> might look like. Note how, just by looking
at the function parameters, we know <em>exactly</em> what <a href="programming//programming/intro-data.html">data</a>
can be accessed.</p>
<pre><code class="language-rust no_run noplayground">fn enemy_detect_player(
    // access data from resources
    mut ai_settings: ResMut&lt;EnemyAiSettings&gt;,
    gamemode: Res&lt;GameModeData&gt;,
    // access data from entities/components
    query_player: Query&lt;&amp;Transform, With&lt;Player&gt;&gt;,
    query_enemies: Query&lt;&amp;mut Transform, (With&lt;Enemy&gt;, Without&lt;Player&gt;)&gt;,
    // in case we want to spawn/despawn entities, etc.
    mut commands: Commands,
) {
    // ... implement your behavior here ...
}</code></pre>
<p>(learn more about: <a href="programming//programming/systems.html">systems</a>, <a href="programming//programming/queries.html">queries</a>, <a href="programming//programming/commands.html">commands</a>, <a href="programming//programming/res.html">resources</a>, <a href="programming//programming/ec.html#entities">entities</a>, <a href="programming//programming/ec.html#components">components</a>)</p>
<p>ECSæ˜¯æ•°æ®å’Œé€»è¾‘åˆ†ç¦»çš„,è¿™äº›é€»è¾‘æˆä¸ºsystem,åœ¨bevyä¸­systemç”¨å‡½æ•°è¡¨ç¤º,
å‡½æ•°å‚æ•°æŒ‡å®šäº†è¦è®¿é—®å“ªäº›æ•°æ®.è€Œæ•°æ®æ˜¯å­˜åœ¨èµ„æº/å®ä½“çš„ç»„ä»¶ä¸­,
systemçš„å¦ä¸€ç§å‚æ•°æ˜¯Commands,è¿™æ˜¯å¯¹worldæ•°æ®çš„ä¿®æ”¹(å®ä½“/ç»„ä»¶çš„å¢åˆ ),
bevyä¼šå°†Commandsæ”¾åœ¨æ¯å¸§çš„åé¢æ‰§è¡Œ(é»˜è®¤æ˜¯PostUpdate),
åŒæ—¶è¿˜æä¾›äº†after/beforæ¥æ‰§è¡Œsystemæ‰§è¡Œé¡ºåº.</p>
<h2 id="parallel-systems"><a class="header" href="#parallel-systems">Parallel Systems</a></h2>
<p>Based on the <a href="programming//builtins.html#systemparams">parameter</a> types of the <a href="programming//programming/systems.html">systems</a>
you write, Bevy knows what data each system can access and whether it conflicts
with any other systems. Systems that do not conflict (don't access any of the
same data mutably) will automatically be <a href="programming//programming/system-order.html">run in parallel</a>
on different CPU threads. This way, you get multithreading, utilizing modern
multi-core CPU hardware effectively, with no extra effort from you!</p>
<p>For best parallelism, it is recommended that you keep your functionality and
<a href="programming//programming/intro-data.html">your data</a> granular. Split up your systems, so each
one has a narrowly-scoped purpose and access to only the data it needs. This
gives Bevy more opportunities for parallelism. Putting too much functionality
in one system, or too much data in a single <a href="programming//programming/ec.html#components">component</a> or
<a href="programming//programming/res.html">resource</a> <code>struct</code>, limits parallelism.</p>
<p>Bevy's parallelism is non-deterministic by default. Your systems might run in a
different and unpredictable order relative to one another, unless you add
<a href="programming//programming/system-order.html">ordering</a> dependencies to constrain it.</p>
<p>å¹¶è¡Œæ‰§è¡Œsystemæ˜¯bevyçš„æ ¸å¿ƒè®¾è®¡ä¹‹ä¸€,ä¹Ÿæ˜¯é«˜æ€§èƒ½çš„ä¿è¯.</p>
<p>bevyé€šè¿‡systemå‚æ•°å°±çŸ¥é“å“ªäº›systemæœ‰ç«äº‰,ä¸ç«äº‰çš„systemä¼šæ”¾åœ¨ä¸åŒçš„cpuæ ¸ä¸­æ‰§è¡Œ,
åœ¨åˆ©ç”¨ç°ä»£å¤šæ ¸CPUç¡¬ä»¶çš„åŸºç¡€ä¸Š,å¼€å‘è€…è¿˜ä¸ç”¨å…³å¿ƒè¿™äº›å¤šçº¿ç¨‹çš„ç»„ç»‡é€»è¾‘(bevyå¸®å¿™åšäº†).</p>
<p>è¦å‡å°‘ç«äº‰,æœ€å¥½çš„åŠæ³•æ˜¯æ§åˆ¶æ•°æ®çš„é¢—ç²’åº¦,æ‹†åˆ†systemè®©å…¶ç¬¦åˆå•ä¸€åŸåˆ™,
åªæœ‰è¿™æ ·æ‰èƒ½æ›´å¥½é…åˆbevyè¿›è¡Œå¹¶è¡Œæ‰§è¡Œ.
ä¸€ä¸ªsystemæ‰¿è½½å¤ªå¤šåŠŸèƒ½,æˆ–ä¸€ä¸ªç»„ä»¶/èµ„æºæ‰¿è½½å¤ªå¤šæ•°æ®,éƒ½ä¼šå¤§å¤§å½±å“å¹¶è¡Œ.</p>
<p>systemä¹‹é—´è¦ä¿è¯æ­£äº¤æ€§(ä¸ç®¡ä½•æ—¶ç”±å“ªä¸ªcpuæ‰§è¡Œ,ç»“æœéƒ½æ˜¯ä¸€æ ·çš„),
å¦‚æœä¸¤ä¸ªsystemç¡®å®æœ‰é¡ºåºä¾èµ–,å¯ä»¥ç”¨systemçš„é¡ºåºè§„åˆ™æ¥æŒ‡å®šå…ˆå.</p>
<h2 id="exclusive-systems"><a class="header" href="#exclusive-systems">Exclusive Systems</a></h2>
<p><a href="programming//programming/exclusive.html">Exclusive</a> systems provide you with a way to get <a href="programming//programming/world.html">full direct
access</a> to the ECS <a href="programming//programming/world.html"><code>World</code></a>. They cannot run in parallel
with other systems, because they can access anything and do anything. Sometimes,
you might need this additonal power.</p>
<pre><code class="language-rust no_run noplayground">fn save_game(
    // get full access to the World, so we can access all data and do anything
    world: &amp;mut World,
) {
    // ... save game data to disk, or something ...
}</code></pre>
<p>ç‹¬å systemæ˜¯ç›´æ¥ä¿®æ”¹worldæ•°æ®çš„,æå°‘æƒ…å†µä¸‹ä¼šç”¨åˆ°,ç±»ä¼¼äºæ ¸æ­¦å™¨.
è¿™ç±»systemå¹¶ä¸èƒ½å¹¶è¡Œæ‰§è¡Œ.</p>
<h2 id="schedules-1"><a class="header" href="#schedules-1">Schedules</a></h2>
<p>Bevy stores systems inside of <a href="programming//programming/schedules.html">schedules</a>
(<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/schedule/struct.Schedule.html"><code>Schedule</code></a>). The schedule contains the systems and all
relevant metadata to organize them, telling Bevy when and how to run them. Bevy
<a href="programming//programming/app-builder.html">Apps</a> typically contain many schedules. Each one is a collection of
systems to be invoked in different scenarios (every frame update, <a href="programming//fundamentals/fixed-timestep.html">fixed
timestep</a> update, at app startup, on <a href="programming//programming/states.html">state</a>
transitions, etc.).</p>
<p>The metadata stored in schedules allows you to control how systems run:</p>
<ul>
<li>Add <a href="programming//programming/run-criteria.html">run conditions</a> to control if systems should run during an
invocation of the schedule. You can disable systems if you only need them
to run sometimes.</li>
<li>Add <a href="programming//programming/system-order.html">ordering</a> constraints, if one system depends on
another system completing before it.</li>
</ul>
<p>Within schedules, systems can be grouped into <a href="programming//programming/system-sets.html">sets</a>. Sets
allow multiple systems to share common configuration/metadata. Systems
inherit configuration from all sets they belong to. Sets can also inherit
configuration from other sets.</p>
<p>Here is an illustration to help you visualize the logical structure of a
schedule. Let's look at how a hypothetical "Update" (run every frame) schedule of a
game might be organized.</p>
<p>List of <a href="programming//programming/systems.html">systems</a>:</p>
<div class="table-wrapper"><table><thead><tr><th><a href="programming//programming/systems.html">System</a> name</th><th><a href="programming//programming/system-sets.html">Sets</a> it belongs to</th><th><a href="programming//programming/run-criteria.html">Run conditions</a></th><th><a href="programming//programming/system-order.html">Ordering constraints</a></th></tr></thead><tbody>
<tr><td><code>footstep_sound</code></td><td><code>AudioSet</code> <code>GameplaySet</code></td><td></td><td><code>after(player_movement)</code> <code>after(enemy_movement)</code></td></tr>
<tr><td><code>player_movement</code></td><td><code>GameplaySet</code></td><td><code>player_alive</code> <code>not(cutscene)</code></td><td><code>after(InputSet)</code></td></tr>
<tr><td><code>camera_movement</code></td><td><code>GameplaySet</code></td><td></td><td><code>after(InputSet)</code></td></tr>
<tr><td><code>enemy_movement</code></td><td><code>EnemyAiSet</code></td><td></td><td></td></tr>
<tr><td><code>enemy_spawn</code></td><td><code>EnemyAiSet</code></td><td></td><td></td></tr>
<tr><td><code>enemy_despawn</code></td><td><code>EnemyAiSet</code></td><td></td><td><code>before(enemy_spawn)</code></td></tr>
<tr><td><code>mouse_input</code></td><td><code>InputSet</code></td><td><code>mouse_enabled</code></td><td></td></tr>
<tr><td><code>controller_input</code></td><td><code>InputSet</code></td><td><code>gamepad_enabled</code></td><td></td></tr>
<tr><td><code>background_music</code></td><td><code>AudioSet</code></td><td></td><td></td></tr>
<tr><td><code>ui_button_animate</code></td><td></td><td></td><td></td></tr>
<tr><td><code>menu_logo_animate</code></td><td><code>MainMenuSet</code></td><td></td><td></td></tr>
<tr><td><code>menu_button_sound</code></td><td><code>MainMenuSet</code> <code>AudioSet</code></td><td></td><td></td></tr>
<tr><td>...</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>List of <a href="programming//programming/system-sets.html">sets</a>:</p>
<div class="table-wrapper"><table><thead><tr><th><a href="programming//programming/system-sets.html">Set</a> name</th><th>Parent Sets</th><th><a href="programming//programming/run-criteria.html">Run conditions</a></th><th><a href="programming//programming/system-order.html">Ordering constraints</a></th></tr></thead><tbody>
<tr><td><code>MainMenuSet</code></td><td></td><td><code>in_state(MainMenu)</code></td><td></td></tr>
<tr><td><code>GameplaySet</code></td><td></td><td><code>in_state(InGame)</code></td><td></td></tr>
<tr><td><code>InputSet</code></td><td><code>GameplaySet</code></td><td></td><td></td></tr>
<tr><td><code>EnemyAiSet</code></td><td><code>GameplaySet</code></td><td><code>not(cutscene)</code></td><td><code>after(player_movement)</code></td></tr>
<tr><td><code>AudioSet</code></td><td></td><td><code>not(audio_muted)</code></td><td></td></tr>
</tbody></table>
</div>
<p>Note that it doesn't matter in what order systems are listed in the schedule.
Their <a href="programming//programming/system-order.html">order</a> of execution is determined by the metadata. Bevy
will respect those constraints, but otherwise run systems in parallel as much as
it can, depending on what CPU threads are available.</p>
<p>Also note how our hypothetical game is implemented using many individually-small
systems. For example, instead of playing audio inside of the <code>player_movement</code>
system, we made a separate <code>play_footstep_sounds</code> system. These two pieces of
functionality probably need to access different <a href="programming//programming/intro-data.html">data</a>, so
putting them in separate systems allows Bevy more opportunities for parallelism.
By being separate systems, they can also have different configuration. The
<code>play_footstep_sounds</code> system can be added to an <code>AudioSet</code>
<a href="programming//programming/system-sets.html">set</a>, from which it inherits a <code>not(audio_muted)</code> <a href="programming//programming/run-criteria.html">run
condition</a>.</p>
<p>Similarly, we put mouse and controller input in separate systems. The <code>InputSet</code>
set allows systems like <code>player_movement</code> to share an ordering dependency
on all of them at once.</p>
<p>You can see how Bevy's scheduling APIs give you a lot of flexibility to organize
all the functionality in your game. What will you do with all this power? ;)</p>
<hr />
<p>Here is how <a href="programming//programming/schedules.html">schedule</a> that was illustrated above could be
created in code:</p>
<pre><code class="language-rust no_run noplayground">// Set configuration is per-schedule. Here we do it for `Update`
app.configure_sets(Update, (
    MainMenuSet
        .run_if(in_state(MainMenu)),
    GameplaySet
        .run_if(in_state(InGame)),
    InputSet
        .in_set(GameplaySet),
    EnemyAiSet
        .in_set(GameplaySet)
        .run_if(not(cutscene))
        .after(player_movement),
    AudioSet
        .run_if(not(audio_muted)),
));
app.add_systems(Update, (
    (
        ui_button_animate,
        menu_logo_animate.in_set(MainMenuSet),
    ),
    (
        enemy_movement,
        enemy_spawn,
        enemy_despawn.before(enemy_spawn),
    ).in_set(EnemyAiSet),
    (
        mouse_input.run_if(mouse_enabled),
        controller_input.run_if(gamepad_enabled),
    ).in_set(InputSet),
    (
        footstep_sound.in_set(GameplaySet),
        menu_button_sound.in_set(MainMenuSet),
        background_music,
    ).in_set(AudioSet),
    (
        player_movement
            .run_if(player_alive)
            .run_if(not(cutscene)),
        camera_movement,
    ).in_set(GameplaySet).after(InputSet),
));</code></pre>
<p>(learn more about: <a href="programming//programming/schedules.html">schedules</a>, <a href="programming//programming/system-sets.html">system sets</a>, <a href="programming//programming/states.html">states</a>, <a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-order.html">system ordering</a>)</p>
<p>bevyçš„è°ƒåº¦ç³»ç»Ÿæ˜¯ä¿è¯å¹¶è¡Œæ‰§è¡Œçš„å…³é”®,ä¹Ÿæ˜¯ä¿è¯systemçµæ´»çš„åŸºçŸ³.
bevyå°†systemåˆ—è¡¨å­˜åœ¨ä¸€ä¸ªå®¹å™¨,å«<code>è°ƒåº¦</code>,bevyçŸ¥é“è°ƒåº¦ä½•æ—¶æ‰§è¡Œ.</p>
<p>systemçš„è¿è¡Œæ¡ä»¶å’Œé¡ºåºæ‰§è¡Œä¿¡æ¯éƒ½å­˜åœ¨è°ƒåº¦ä¸­,è¿™äº›ä¿¡æ¯è¢«æˆä¸ºsystemçš„å…ƒæ•°æ®</p>
<ul>
<li>è¿è¡Œæ¡ä»¶,æ§åˆ¶äº†è°ƒåº¦ä¸­çš„systemè¦ä¸è¦æ‰§è¡Œ</li>
<li>é¡ºåºçº¦æŸ,æ§åˆ¶äº†è°ƒåº¦ä¸­å…³è”systemçš„æ‰§è¡Œé¡ºåº</li>
</ul>
<p>bevyå¯¹è°ƒåº¦çš„è®¾è®¡å¹¶ä¸ä»…ä»…å¦‚è¡¨é¢çœ‹åˆ°çš„è¿™ä¹ˆç®€å•,è®¾è®¡çš„è¶³å¤Ÿçµæ´»,æœªæ¥æ‰©å±•å°±å®¹æ˜“å¾ˆå¤§.
è°ƒåº¦ä¸­çš„éƒ¨åˆ†systemåˆ—è¡¨å¯ä»¥ç»§ç»­æ”¾åœ¨ä¸€ä¸ªå®¹å™¨é›†åˆä¸­,ä¹Ÿå«<code>è°ƒåº¦</code>,ç®—æ˜¯ä¹‹å‰è°ƒåº¦çš„å­è°ƒåº¦,
é»˜è®¤æ˜¯å…±äº«çˆ¶è°ƒåº¦çš„é…ç½®å’Œå…ƒæ•°æ®,åœ¨bevyçš„è®¾è®¡ä¸­ä¹Ÿå¯ä»¥ä»å…¶ä»–è°ƒåº¦ä¸­ç»§æ‰¿,è¿™æ˜¯åè¯,
ç›®å‰bevyä¸­å¯¹å¼•æ“çš„å®ç°æ˜¯: bevyç®¡ç†äº†å‡ ä¸ªå†…ç½®è°ƒåº¦,æ¯ä¸ªè°ƒåº¦éƒ½æœ‰å¤šä¸ªå­è°ƒåº¦,
å¯¹äºæˆ‘ä»¬è‡ªå·±æ¸¸æˆçš„system,bevyæä¾›äº†é¡ºåºçº¦æŸ,åœ¨æ­¤åŸºç¡€ä¸Š,bevyæ€»æ˜¯å°½é‡åšåˆ°å¹¶è¡Œ.</p>
<p>systemè¶³å¤Ÿå°(åŠŸèƒ½å†…èš),bevyå°±èƒ½æ‰¾åˆ°æ›´å¤§çš„å¹¶è¡Œæœºä¼š.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="the-app"><a class="header" href="#the-app">The App</a></h1>
<p>Relevant official examples: All of them ;)</p>
<p>In particular, check out the complete game examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>To enter the Bevy runtime, you need to configure an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a>. The app is how you
define the structure of all the things that make up your project:
<a href="programming//programming/plugins.html">plugins</a>, <a href="programming//programming/systems.html">systems</a> (and their configuration/metadata:
<a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-order.html">ordering</a>, <a href="programming//programming/system-sets.html">sets</a>),
<a href="programming//programming/events.html">event</a> types, <a href="programming//programming/states.html">states</a>, <a href="programming//programming/schedules.html">schedules</a>â€¦</p>
<p>You typically create your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> in your project's <code>main</code> function.  However,
you don't have to add everything from there. If you want to add things to your
app from multiple places (like other Rust files or crates), use
<a href="programming//programming/plugins.html">plugins</a>. As your project grows, you will need to do that to keep
everything organized.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // Bevy itself:
        .add_plugins(DefaultPlugins)

        // Plugins from our game/project:
        .add_plugins(ui::MyUiPlugin)

        // events:
        .add_event::&lt;LevelUpEvent&gt;()

        // systems to run once at startup:
        .add_systems(Startup, spawn_things)

        // systems to run each frame:
        .add_systems(Update, (
            camera_follow_player,
            debug_levelups,
            debug_stats_change,
        ))
        // ...

        // launch the app!
        .run();
}</code></pre>
<p>Note: use tuples with <code>add_systems</code>/<code>add_plugins</code>/<code>configure_sets</code> to add
multiple things at once.</p>
<p><a href="programming//programming/ec.html#components">Component</a> types do not need to be registered.</p>
<p>Schedules cannot (yet) be modified at runtime; all <a href="programming//programming/systems.html">systems</a> you
want to run must be added/configured in the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> ahead of time. You can
control individual systems using <a href="programming//programming/run-criteria.html">run conditions</a>. You can also
dynamically enable/disable entire schedules using the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a>
<a href="programming//programming/res.html">resource</a>.</p>
<p>appæ˜¯ç»„ç»‡é¡¹ç›®çš„èµ·ç‚¹,é€šè¿‡appå¯ä»¥é…ç½®<code>æ’ä»¶</code>/<code>system(åŒ…æ‹¬å…¶è¿è¡Œæ¡ä»¶/é¡ºåº/é›†åˆ)</code>/
<code>äº‹ä»¶</code>/<code>çŠ¶æ€</code>/<code>è°ƒåº¦</code>ç­‰ç­‰.</p>
<p>åˆ©ç”¨appå¯ä»¥æŒ‰éœ€æ·»åŠ åŠŸèƒ½,å½“é¡¹ç›®å¢é•¿æ—¶éœ€è¦è€ƒè™‘å¦‚ä½•ç»„ç»‡ä»£ç ,<code>æ’ä»¶</code>æ˜¯æœ€å¥½çš„é€‰æ‹©.</p>
<p>appçš„å‡ ä¸ª<code>add_å‡½æ•°</code>éƒ½æ˜¯æ”¯æŒå…ƒç»„ç±»å‹çš„,ä¹Ÿå°±æ˜¯è¯´ä¸€æ¬¡å¯ä»¥æ·»åŠ å¤šä¸ªå¯¹è±¡.
appä¸éœ€è¦æ³¨å†Œç»„ä»¶ç±»å‹.</p>
<p>è°ƒåº¦åœ¨è¿è¡ŒæœŸé—´ä¸èƒ½ä¿®æ”¹,æ‰€ä»¥éœ€è¦é€šè¿‡appæ˜ç¡®é…ç½®å®Œ.
å•ä¸ªsystemæ˜¯å¯ä»¥é…ç½®è¿è¡Œæ¡ä»¶çš„;
åˆ©ç”¨<code>MainScheduleOrder</code>èµ„æºå¯ä»¥åŠ¨æ€å¼€å¯/å…³é—­æŸä¸ªè°ƒåº¦(è¿™ä¸ªæ˜¯ä¸ªé«˜çº§ç”¨æ³•,å¾ˆå°‘ç”¨åˆ°).</p>
<h2 id="builtin-bevy-functionality"><a class="header" href="#builtin-bevy-functionality">Builtin Bevy Functionality</a></h2>
<p>The Bevy game engine's own functionality is represented as a <a href="programming//programming/plugins.html#plugin-groups">plugin group</a>.
Every typical Bevy app must first add it, using either:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> if you are making a full game/app.</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> for something like a headless server.</li>
</ul>
<p>bevyæ¸¸æˆå¼•æ“è‡ªå·±çš„é€»è¾‘ä½¿ç”¨<code>æ’ä»¶ç»„</code>æ¥è¡¨ç¤º,bevyæä¾›äº†ä¸¤ä¸ªé»˜è®¤çš„åŠŸèƒ½ç»„:</p>
<ul>
<li>DefaultPlugins,é»˜è®¤æ’ä»¶åˆ—è¡¨</li>
<li>MinimalPlugins,æœ€å°æ’ä»¶åˆ—è¡¨</li>
</ul>
<h2 id="setting-up-data"><a class="header" href="#setting-up-data">Setting up data</a></h2>
<p>Normally, you can set up <a href="programming//programming/intro-data.html">your data</a> from
<a href="programming//programming/systems.html">systems</a>. Use <a href="programming//programming/commands.html">Commands</a> from regular systems, or
use <a href="programming//programming/exclusive.html">exclusive systems</a> to get <a href="programming//programming/world.html">full World access</a>.</p>
<p>Add your setup systems to the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Startup.html"><code>Startup</code></a> <a href="programming//programming/schedules.html">schedule</a> for
things you want to initialize at launch, or use <a href="programming//programming/states.html">state</a> enter/exit
systems to do things when transitioning between menus, game modes, levels, etc.</p>
<p>However, you can also initialize data directly from the app builder. This
is common for <a href="programming//programming/res.html">resources</a>, if they need to be present at all
times. You can also get <a href="programming//programming/world.html">direct World access</a>.</p>
<pre><code class="language-rust no_run noplayground">// Create (or overwrite) resource with specific value
app.insert_resource(StartingLevel(3));

// Ensure resource exists; if not, create it
// (using `Default` or `FromWorld`)
app.init_resource::&lt;MyFancyResource&gt;();

// We can also access/manipulate the World directly
// (in this example, to spawn an entity, but you can do anything)
app.world_mut().spawn(SomeBundle::default());</code></pre>
<p>æ„é€ å®ä½“æœ‰ä»¥ä¸‹å‡ ç§æ–¹å¼:</p>
<ul>
<li>åœ¨æ™®é€šsystemä¸­åˆ©ç”¨Commandså®ç°</li>
<li>ä½¿ç”¨ç‹¬å systemæ¥è®¿é—®worldçš„æ‰€æœ‰æ•°æ®</li>
<li>åœ¨Startupè°ƒåº¦ä¸­ä½¿ç”¨æ„é€ systemæ¥å®ç°</li>
<li>åœ¨ç¿»è¯‘èœå•/æ¸¸æˆæ¨¡å‹/ç­‰çº§æ—¶åˆ©ç”¨stateåœ¨systemå¼€å¤´æˆ–é€€å‡ºæ—¶å®ç°</li>
<li>åœ¨appä¸­ç›´æ¥ä½¿ç”¨worldæ¥æ„é€ </li>
</ul>
<p>é€šå¸¸åˆ©ç”¨appæ¥ç›´æ¥åˆå§‹åŒ–æ•°æ®(èµ„æº,åœ¨å‰©ä¸‹çš„æ¸¸æˆæ—¶é—´ä¸­éƒ½èƒ½è¢«è®¿é—®).</p>
<h2 id="quitting-the-app"><a class="header" href="#quitting-the-app">Quitting the App</a></h2>
<p>To cleanly shut down bevy, send an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/enum.AppExit.html"><code>AppExit</code></a> <a href="programming//programming/events.html">event</a> from any
<a href="programming//programming/systems.html">system</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::AppExit;

fn exit_system(mut exit: EventWriter&lt;AppExit&gt;) {
    exit.send(AppExit::Success);
}</code></pre>
<p>You can specify the exit code to return to the OS. If Bevy receives
multiple <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/enum.AppExit.html"><code>AppExit</code></a> events, success will only be returned if all
of them report success. If some report an error, the last event will
determine the actual exit code of the process.</p>
<p>é€€å‡ºbevyä½¿ç”¨,åœ¨ä»»æ„systemä¸­å‘å‡º<code>AppExit</code>äº‹ä»¶å³å¯,
åŒæ—¶å¯ä»¥å¸¦ä¸Šè¿”å›ç .</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/startup_system.rs"><code>startup_system</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/system_param.rs"><code>system_param</code></a>.</p>
<hr />
<p>Systems are pieces of functionality to be run by Bevy. They are typically
implemented using regular Rust functions. This is how you implement all
your game logic.</p>
<p>These functions can only take <a href="programming//builtins.html#systemparams">special parameter types</a>,
to specify what <a href="programming//programming/intro-data.html">data</a> you need access to. If you use
unsupported parameter types in your function, <a href="programming//pitfalls/into-system.html">you will get confusing compiler
errors!</a></p>
<p>Some of the possibilities are:</p>
<ul>
<li>accessing <a href="programming//programming/res.html">resources</a> using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a></li>
<li>accessing <a href="programming//programming/ec.html#components">components of entities</a> using <a href="programming//programming/queries.html">queries</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Query.html"><code>Query</code></a>)</li>
<li>creating/destroying entities, components, and resources using <a href="programming//programming/commands.html">Commands</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>)</li>
<li>sending/receiving <a href="programming//programming/events.html">events</a> using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader</code></a></li>
</ul>
<p><a href="programming//builtins.html#systemparams">See here for a full list!</a></p>
<pre><code class="language-rust no_run noplayground">fn debug_start(
    // access resource
    start: Res&lt;StartingLevel&gt;
) {
    eprintln!("Starting on level {:?}", *start);
}</code></pre>
<p>System parameters can be grouped into tuples (which can be nested). This is
useful for organization.</p>
<pre><code class="language-rust no_run noplayground">fn complex_system(
    (a, mut b): (
        Res&lt;ResourceA&gt;,
        ResMut&lt;ResourceB&gt;,
    ),
    (q0, q1, q2): (
        Query&lt;(/* â€¦ */)&gt;,
        Query&lt;(/* â€¦ */)&gt;,
        Query&lt;(/* â€¦ */)&gt;,
    ),
) {
    // â€¦
}</code></pre>
<p>ç‹¬å systemçš„å‚æ•°(æ­¤ç±»systemåœ¨æ‰§è¡Œæ—¶ä¼šç‹¬å world):</p>
<ul>
<li><code>&amp;mut world</code>: ç›´æ¥è®¿é—®worldçš„æ–¹å¼,ç‹¬å çš„</li>
<li><code>Local&lt;T&gt;</code>: systemè‡ªå·±çš„æ•°æ®,localä¸ä¿å­˜åœ¨worldä¸­,è€Œæ˜¯åœ¨systemä¸­,åœ¨systemåç»­è¿è¡Œä¸­ä¹Ÿå­˜åœ¨</li>
<li><code>&amp;mut SystemState&lt;P&gt;</code> <code>SystemState</code>: æ¨¡æ‹Ÿæ™®é€šsystem,å¯ä»¥ç®€å•ä»worldè®¿é—®æ•°æ®,På°±æ˜¯systemå‚æ•°</li>
<li><code>&amp;mut QueryState&lt;Q, F= ()&gt;</code> <code>QueryState</code>: ä»worldæ‰§è¡ŒæŸ¥è¯¢,ç±»ä¼¼æ™®é€šsystemçš„Query</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<p>å‡½æ•°æœ€å¤šæœ‰16ä¸ªå‚æ•°,å¦‚æœéœ€è¦æ›´å¤š,å°±ä½¿ç”¨å…ƒç»„æ¥çªç ´é™åˆ¶.
å…ƒç»„åŒæ ·æœ€å¤šåªèƒ½æœ‰16ä¸ªå‚æ•°,ä½†æ²¡æœ‰åµŒå¥—é™åˆ¶.</p>
<p>There is also a different kind of system: <a href="programming//programming/exclusive.html">exclusive systems</a>.
They have <a href="programming//programming/world.html">full direct access to the ECS World</a>, so you can access
any data you want and do anything, but cannot run in parallel. For most use
cases, you should use regular parallel systems.</p>
<pre><code class="language-rust no_run noplayground">fn reload_game(world: &amp;mut World) {
    // ... access whatever we want from the World
}</code></pre>
<p>systemæ˜¯bevyçš„åŠŸèƒ½ç‰‡æ®µ,é€šå¸¸æ˜¯rustå‡½æ•°å®ç°,æ¸¸æˆçš„é€»è¾‘éƒ½åœ¨è¿™é‡Œ.</p>
<p>systemçš„å…¥å‚æ˜¯æœ‰é™åˆ¶çš„(0),æ‰“ç ´é™åˆ¶ä¼šå¯¼è‡´ç¼–è¯‘æŠ¥é”™(4.3).
å¸¸ç”¨çš„å…¥å‚ç±»å‹æœ‰:èµ„æº/query/Commands/äº‹ä»¶æ”¶å‘å™¨.</p>
<p>ä¸ºäº†æ–¹ä¾¿ç»„ç»‡,å¯ä»¥å°†åŒç±»å‹çš„å…¥å‚ä½¿ç”¨å…ƒç»„ç»„ç»‡.</p>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>In order for your systems to actually be run by Bevy, you need to configure
them via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // run these only once at launch
        .add_systems(Startup, (setup_camera, debug_start))
        // run these every frame update
        .add_systems(Update, (move_player, enemies_ai))
        // ...
        .run();
}</code></pre>
<p>Be careful: writing a new system <code>fn</code> and forgetting to add it to your app is a
common mistake! If you run your project and your new code doesn't seem to be
running, make sure you added the system!</p>
<p>The above is enough for simple projects.</p>
<p>Systems are contained in <a href="programming//programming/schedules.html">schedules</a>. <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Update.html"><code>Update</code></a> is the schedule
where you typically add any systems you want to run every frame. <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Startup.html"><code>Startup</code></a> is
where you typically add systems that should run only once on app startup. There
are also <a href="programming//builtins.html#schedules">other possibilities</a>.</p>
<p>As your project grows more complex, you might want to make use of some of the
powerful tools that Bevy offers for managing when/how your systems run, such as:
<a href="programming//programming/system-order.html">explicit ordering</a>, <a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-sets.html">system
sets</a>, <a href="programming//programming/states.html">states</a>.</p>
<p>åœ¨appä¸­å¯ä»¥åˆ©ç”¨è°ƒåº¦å™¨é…ç½®systemçš„æ‰§è¡Œé¡ºåº,å¦‚æœsystemå‡½æ•°æ²¡æœ‰æ·»åŠ åˆ°appä¸­,
æ­¤æ˜¯ç¼–è¯‘å™¨ä¸ä¼šæŠ¥é”™,ä½†è¿è¡Œæ²¡æœ‰æ•ˆæœ,è¿™å¯èƒ½è¦ä¼šèŠ±å¾ˆå¤šæ—¶é—´æ’æŸ¥.</p>
<p>Startupæ˜¯appå¯åŠ¨æ—¶æ‰§è¡Œä¸€æ¬¡,Updateæ˜¯æ¯å¸§éƒ½ä¼šæ‰§è¡Œ,å…·ä½“è¯¦æƒ…å¯ä»¥æŸ¥çœ‹<code>è°ƒåº¦å™¨</code>ç« èŠ‚.</p>
<p>å½“systemæ•°é‡éå¸¸å¤šæ—¶,å¯ç”¨åˆ°ä¸‹åˆ—å·¥å…·:<code>æ˜¾ç¤ºé¡ºåºæŒ‡å®š</code>,<code>è¿è¡Œæ¡ä»¶</code>,<code>systemé›†åˆ</code>,<code>çŠ¶æ€</code>.</p>
<h3 id="one-shot-systems"><a class="header" href="#one-shot-systems">One-Shot Systems</a></h3>
<p>Sometimes you don't want Bevy to run your system for you. In that case,
don't add it to a schedule.</p>
<p>If you are a writing a system that you want to call yourself whenever
you want (such as on a button press), you can do that using <a href="programming//programming/one-shot-systems.html">one-shot
systems</a>.</p>
<p><code>å•å‡»</code>system,ä¸æ˜¯æ³¨å†Œåˆ°appç”±è°ƒåº¦æœºåˆ¶æ¥è§¦å‘æ‰§è¡Œ,è€Œæ˜¯æŒ‰éœ€æ‰§è¡Œ,
eg:æŒ‰é’®ç‚¹å‡»æ‰§è¡Œä¸€ä¸ªsystem.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="resources-2"><a class="header" href="#resources-2">Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Resources allow you to store a single global instance of some data type,
independently of <a href="programming//programming/intro-data.html#entities--components">entities</a>.</p>
<p>Use them for <a href="programming//programming/intro-data.html">data</a> that is truly global for your app, such
as configuration / settings. Resources make it easy for you to access such data
from anywhere.</p>
<p>To create a new resource type, simply define a Rust <code>struct</code> or <code>enum</code>, and
derive the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/trait.Resource.html"><code>Resource</code></a> trait, similar to
<a href="programming//programming/ec.html#components">components</a> and <a href="programming//programming/events.html">events</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct GoalsReached {
    main_goal: bool,
    bonus: u32,
}</code></pre>
<p>Types must be unique; there can only be at most one instance of a given type. If
you might need multiple, consider using <a href="programming//programming/intro-data.html#entities--components">entities and components</a> instead.</p>
<p>Bevy <a href="programming//builtins.html#resources">uses resources for many things</a>. You can use these builtin
resources to access various features of the engine. They work just like your own
custom types.</p>
<p>èµ„æºæ˜¯å¯ä»¥å­˜å‚¨æŸç±»å‹æ•°æ®çš„å…¨å±€å•ä¾‹,ç‹¬ç«‹äºå®ä½“.
å¯¹äºappæ¥è¯´,èµ„æºæ˜¯å…¨å±€çš„,(é…ç½®å’Œè®¾ç½®å°±æ˜¯èµ„æº),åœ¨ä»»ä½•åœ°æ–¹è®¿é—®èµ„æºéƒ½éå¸¸æ–¹ä¾¿.</p>
<p>åˆ›å»ºèµ„æºå¾ˆç®€å•,struct/enumæ·»åŠ <code>Resource</code>è‡ªåŠ¨å®ç°å³å¯(ç»„ä»¶/äº‹ä»¶éƒ½æ˜¯å¦‚æ­¤å£°æ˜çš„).</p>
<p>èµ„æºç±»å‹è¦å”¯ä¸€(è¿™ä¸ªæ˜¯è‚¯å®šçš„),åªèƒ½æœ‰ä¸€ä¸ªå®ä¾‹(å•ä¾‹,è¿™ä¸ªä¹Ÿæ˜¯æ­£å¸¸çš„).
å¦‚æœæœ‰å¤šä¸ªå®ä¾‹,ä½¿ç”¨ECSå³å¯.</p>
<p>èµ„æºå¯ä»¥ç”¨æ¥åšå¾ˆå¤šäº‹,bevyæä¾›äº†ä¸å°‘å†…ç½®èµ„æº,é€šè¿‡è¿™äº›å†…ç½®èµ„æºå¯ä»¥è®¿é—®å¾ˆå¤šbevyåŠŸèƒ½.</p>
<h2 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing Resources</a></h2>
<p>To access the value of a resource from <a href="programming//programming/systems.html">systems</a>, use
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(
    // these will panic if the resources don't exist
    mut goals: ResMut&lt;GoalsReached&gt;,
    other: Res&lt;MyOtherResource&gt;,
    // use Option if a resource might not exist
    mut fancy: Option&lt;ResMut&lt;MyFancyResource&gt;&gt;,
) {
    if let Some(fancy) = &amp;mut fancy {
        // TODO: do things with `fancy`
    }
    // TODO: do things with `goals` and `other`
}</code></pre>
<p>åœ¨systemä¸­è®¿é—®èµ„æº,åªéœ€è¦ä½¿ç”¨<code>Res&lt;T&gt;</code>æˆ–<code>ResMut&lt;T&gt;</code>.</p>
<h2 id="managing-resources"><a class="header" href="#managing-resources">Managing Resources</a></h2>
<p>If you need to create/remove resources at runtime, you can do so using
<a href="programming//programming/commands.html">commands</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>):</p>
<pre><code class="language-rust no_run noplayground">fn my_setup(mut commands: Commands /* ... */) {
    // add (or overwrite if existing) a resource, with the given value
    // å¯¹äºåŒä¸€ç±»å‹è°ƒç”¨insert_resource(),ä¼šè¦†ç›–èµ„æºçš„å€¼.
    commands.insert_resource(GoalsReached {
        main_goal: false,
        bonus: 100,
    });
    // ensure resource exists (create it with its default value if necessary)
    // å¦‚æœèµ„æºå·²å­˜åœ¨,ç›´æ¥è¿”å›;å¦‚æœèµ„æºä¸å­˜åœ¨,ä½¿ç”¨`FromWorld`ç‰¹å‹åˆå§‹åŒ–å€¼.
    // ä»»ä½•èµ„æº,åªè¦å®ç°äº†Defaultç‰¹å‹,å°±è‡ªåŠ¨å®ç°äº†FromWorldç‰¹å‹.
    // æ‰€ä»¥ä½¿ç”¨init_resource()çš„ç±»å‹,ä¸€èˆ¬è¦å®ç°Defaultç‰¹å‹.
    commands.init_resource::&lt;MyFancyResource&gt;();
    // remove a resource (if it exists)
    // å¦‚æœèµ„æºä¸å­˜åœ¨,ç›´æ¥è¿”å›.
    commands.remove_resource::&lt;MyOtherResource&gt;();
}</code></pre>
<p>Alternatively, using <a href="programming//programming/world.html">direct World access</a> from an <a href="programming//programming/exclusive.html">exclusive
system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn my_setup2(world: &amp;mut World) {
    // The same methods as with Commands are also available here,
    // but we can also do fancier things:

    // Check if resource exists
    if !world.contains_resource::&lt;MyFancyResource&gt;() {
        // Get access to a resource, inserting a custom value if unavailable
        let _bonus = world
            .get_resource_or_insert_with(|| GoalsReached {
                main_goal: false,
                bonus: 100,
            })
            .bonus;
    }
}</code></pre>
<p>Resources can also be set up from the <a href="programming//programming/app-builder.html">app builder</a>. Do this for
resources that are meant to always exist from the start.</p>
<pre><code class="language-rust no_run noplayground">    App::new()
        .add_plugins(DefaultPlugins)
        .insert_resource(StartingLevel(3))
        .init_resource::&lt;MyFancyResource&gt;()
        // ...</code></pre>
<p>è¿è¡Œè¿‡ç¨‹ä¸­å¢åˆ èµ„æºä½¿ç”¨Commandsè¿›è¡Œæ“ä½œ;
ä¹Ÿå¯ä»¥åœ¨ç‹¬å systemä¸­ç›´æ¥å¯¹worldè¿›è¡Œæ“ä½œ;
å¯¹äºä¸€å¼€å§‹å°±è¦å­˜åœ¨çš„èµ„æº,åœ¨app builderä¸­ä¹Ÿå¯ä»¥ç›´æ¥é€šè¿‡appå¢åŠ èµ„æº.</p>
<h2 id="resource-initialization"><a class="header" href="#resource-initialization">Resource Initialization</a></h2>
<p>If you want to be able to use <code>.init_resource</code> to create your resource,
here is how you can provide the default value.</p>
<p>Implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> for simple resources:</p>
<pre><code class="language-rust no_run noplayground">// simple derive, to set all fields to their defaults
#[derive(Resource, Default)]
struct GameProgress {
    game_completed: bool,
    secrets_unlocked: u32,
}

#[derive(Resource)]
struct StartingLevel(usize);

// custom implementation for unusual values
impl Default for StartingLevel {
    fn default() -&gt; Self {
        StartingLevel(1)
    }
}

// on enums, you can specify the default variant
#[derive(Resource, Default)]
enum GameMode {
    Tutorial,
    #[default] // è¿™ä¸ªdefaultæ ‡è¯†å¦‚æœGameMode::default()æ—¶,é»˜è®¤ä¼šè¿”å›SinglePlayer::default()
    Singleplayer,
    Multiplayer,
}</code></pre>
<p>For resources that need complex initialization, implement <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct MyFancyResource {/* stuff */}

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS World from here.

        // For example, you can access (and mutate!) other things:
        {
            let mut x = world.resource_mut::&lt;MyOtherResource&gt;();
            x.do_mut_stuff();
        }

        // You can load assets:
        let font: Handle&lt;Font&gt; = world.resource::&lt;AssetServer&gt;().load("myfont.ttf");

        MyFancyResource { /* stuff */ }
    }
}</code></pre>
<p>Beware: it can be easy to get yourself into a mess of unmaintainable code
if you overuse <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> to do complex things.</p>
<p>ä½¿ç”¨init_resource()æ—¶,å¯¹äºç‰¹åˆ«å¤æ‚çš„åˆå§‹åŒ–,å¯ä»¥ç›´æ¥ä½¿ç”¨<code>FroWorld</code>.
è¿™ç§çµæ´»æ€§çš„ä»£ä»·æ˜¯<code>è¿‡æ¸¡ä½¿ç”¨FromWorldå¾ˆæœ‰å¯èƒ½å†™å‡ºæ— æ³•ç»´æŠ¤çš„ä»£ç </code>.</p>
<h2 id="usage-advice"><a class="header" href="#usage-advice">Usage Advice</a></h2>
<p>The choice of when to use <a href="programming//programming/intro-data.html#entities--components">entities/components</a> vs. resources is
typically about how you want to access the <a href="programming//programming/intro-data.html">data</a>: globally
from anywhere (resources), or using ECS patterns (entities/components).</p>
<p>Even if there is only one of a certain thing in your game (such as the
player in a single-player game), it can be a good fit to use an entity
instead of resources, because entities are composed of multiple components,
some of which can be common with other entities. This can make your game
logic more flexible. For example, you could have a "health/damage system"
that works with both the player and enemies.</p>
<p>é€‰æ‹©ä½¿ç”¨ECSè¿˜æ˜¯èµ„æºå–å†³äºè®¿é—®æ–¹å¼,ä»ä»»ä½•åœ°æ–¹è®¿é—®å…¨å±€å˜é‡,ä½¿ç”¨èµ„æº,å…¶ä»–ä½¿ç”¨ECS.</p>
<p>å¹¶ä¸æ˜¯åªæœ‰ä¸€ä¸ªå®ä¾‹å°±åº”è¯¥è®¾è®¡ä¸ºèµ„æº,å¦‚æœå¾ˆå¤šå®ä½“éƒ½è¦ç”¨åˆ°æŸä¸ªæ•°æ®,è®¾è®¡ä¸ºç»„ä»¶.
è¿™æ ·çš„è€ƒè™‘ä¼šæ›´åŠ çµæ´».</p>
<h3 id="settings"><a class="header" href="#settings">Settings</a></h3>
<p>One common usage of resources is for storing settings and configuration.</p>
<p>However, if it is something that cannot be changed at runtime and only used when
initializing a <a href="programming//programming/plugins.html">plugin</a>, consider putting that inside the plugin's
<code>struct</code>, instead of a resource.</p>
<p>èµ„æºçš„å¦ä¸€ä¸ªå¸¸è§ä½¿ç”¨åœºæ™¯æ˜¯å­˜å‚¨è®¾ç½®/é…ç½®.</p>
<p>æ¸¸æˆå¯åŠ¨æ—¶åˆå§‹åŒ–,è¿è¡ŒæœŸé—´ä¸æ”¹å˜,æœ€å¥½è®¾è®¡ä¸ºæ’ä»¶,è€Œä¸æ˜¯èµ„æº.</p>
<h3 id="caches"><a class="header" href="#caches">Caches</a></h3>
<p>Resources are also useful if you want to store some data in a way that is easier
or more efficient for you to access. For example, keeping a collection of <a href="programming//assets/handles.html">asset
handles</a>, or using a custom datastructure for representing a game
map more efficiently than using entities and components, etc.</p>
<p><a href="programming//programming/intro-data.html#entities--components">Entities and Components</a>, as flexible as they are, are not necessarily
the best fit for all use cases. If you want to represent your data some other
way, feel free to do so. Simply create a resource and put it there.</p>
<p>åªè¦æ˜¯æƒ³å­˜å‚¨çš„ç®€å•ç‚¹,æˆ–æ˜¯è®¿é—®çš„ç®€å•ç‚¹,éƒ½å¯ä»¥ä½¿ç”¨èµ„æºæ¥å®ç°.
eg: assetèµ„æºçš„å¤„ç†handle;æ¸¸æˆåœ°å›¾(è¿™ä¸ªç”¨èµ„æºå®ç°æ¯”ECSç®€å•å¤šäº†).</p>
<p>ECSéå¸¸çµæ´»,ä½†å¹¶ä¸æ˜¯åœ¨å„ä¸ªéæ–¹é¢éƒ½é¢†å…ˆå…¶ä»–æ–¹æ¡ˆ.</p>
<h3 id="interfacing-with-external-libraries"><a class="header" href="#interfacing-with-external-libraries">Interfacing with external libraries</a></h3>
<p>If you want to integrate some external non-Bevy software into a Bevy app,
it can be very convenient to create a resource to hold onto its state/data.</p>
<p>For example, if you wanted to use an external physics or audio engine, you
could put all its data in a resource, and write some systems to call its
functions. That can give you an easy way to interface with it from Bevy code.</p>
<p>If the external code is not thread-safe (<code>!Send</code> in Rust parlance), which is
common for non-Rust (e.g C++ and OS-level) libraries, you should use a
<a href="programming//programming/non-send.html">Non-Send</a> Bevy resource instead. This will make sure any Bevy
system that touches it will run on the main thread.</p>
<p>bevyç¨‹åºä½¿ç”¨å¤–éƒ¨è½¯ä»¶æ—¶,èµ„æºé€‚åˆå­˜å‚¨çŠ¶æ€å’Œæ•°æ®.eg:ä½¿ç”¨å¤–éƒ¨çš„ç‰©ç†å¼•æ“æˆ–éŸ³é¢‘å¼•æ“.</p>
<p>å¦‚æœå¤–éƒ¨åº“ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„,å¯ä»¥ç”¨!Sendæ¥æŒ‡æ˜:åªåœ¨ä¸»çº¿ç¨‹ä¸­è¿è¡Œ.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p><a href="programming//programming/intro-data.html">See here for more explanation on how storing data in the ECS works.</a></p>
<p>Conceptually, an entity represents a set of values for different components.
Each component is a Rust type (<code>struct</code> or <code>enum</code>) and an entity can be used to
store a value of that type.</p>
<p>Technically, an entity is just a simple integer ID (imagine the "row number" in
a table/spreadsheet) that can be used to find related data values (in different
"columns" of that table).</p>
<p>In Bevy, <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> is this value. It consists of two integers:
the ID and the "generation" (allowing IDs to be reused, after you despawn old
entities).</p>
<p>You can create ("spawn") new entities and destroy ("despawn") entities using
<a href="programming//programming/commands.html"><code>Commands</code></a> or <a href="programming//programming/world.html">exclusive <code>World</code> access</a>.</p>
<pre><code class="language-rust no_run noplayground">fn setup(mut commands: Commands) {
    // create a new entity
    commands.spawn((
        // Initialize all your components and bundles here
        Enemy,
        Health {
            hp: 100.0,
            extra: 25.0,
        },
        AiMode::Passive,
        // ...
    ));

    // If you want to get the Entity ID, just call `.id()` after spawn
    let my_entity = commands.spawn((/* ... */)).id();

    // destroy an entity, removing all data associated with it
    commands.entity(my_entity).despawn();
}</code></pre>
<p>Many of your entities might need to have the same common components. You can use
<a href="programming//programming/bundle.html">Bundles</a> to make it easier to spawn your entities.</p>
<p>å®ä½“,å°±æ˜¯ç»„ä»¶é›†åˆ,ç»„ä»¶çš„rustç±»å‹æ˜¯struct/enum.</p>
<p>åœ¨ECSè®¾è®¡ä¸­,å®ä½“é€šå¸¸æ˜¯ä¸€ä¸ªç®€å•çš„æ•´æ•°ID,é€šè¿‡è¿™ä¸ªidå¯ä»¥æ‰¾åˆ°å®é™…çš„å®ä½“æ•°æ®.
bevyä¹Ÿæ˜¯è¿™ä¹ˆè®¾è®¡çš„.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug)]
#[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
#[cfg_attr(feature = "bevy_reflect", reflect_value(Hash, PartialEq))]
#[cfg_attr(
    all(feature = "bevy_reflect", feature = "serialize"),
    reflect_value(Serialize, Deserialize)
)]
#[repr(C, align(8))]
pub struct Entity {
    #[cfg(target_endian = "little")]
    index: u32, // å¯¹å¤–æš´éœ²çš„ID.
    generation: NonZeroU32, // ç‰ˆæœ¬,ä»£æ•°,é‡ç”¨ä¸€æ¬¡è‡ªå¢ä¸€æ¬¡.
    #[cfg(target_endian = "big")]
    index: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>å¾ˆå¤šå®ä½“å¯èƒ½éœ€è¦ç›¸åŒçš„ç»„ä»¶,bevyæä¾›äº†å¤šä¸ªæ¨¡æ¿Bundle,ç”¨äºç®€åŒ–å®ä½“çš„æ„é€ .</p>
<h1 id="components-1"><a class="header" href="#components-1">Components</a></h1>
<p>Components are the data associated with entities.</p>
<p>To create a new component type, simply define a Rust <code>struct</code> or <code>enum</code>, and
derive the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Health {
    hp: f32,
    extra: f32,
}

#[derive(Component)]
enum AiMode {
    Passive,
    ChasingPlayer,
}</code></pre>
<p>Types must be unique â€“ an entity can only have one component per Rust type.</p>
<p>å®ä½“ä¸èƒ½åŒ…å«å¤šä¸ªåŒä¸€ç±»å‹çš„ç»„ä»¶,å› ä¸ºå®ä½“æ˜¯æŒ‰ç±»å‹åŒºåˆ«ç»„ä»¶çš„,é‡å¤ä¼šå¯¼è‡´panic.</p>
<h2 id="newtype-components"><a class="header" href="#newtype-components">Newtype Components</a></h2>
<p>Use wrapper (newtype) structs to make unique components out of simpler types:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct PlayerXp(u32);

#[derive(Component)]
struct PlayerName(String);</code></pre>
<p>æ–°ç±»å‹ç»„ä»¶,å°±æ˜¯äº†é˜²æ­¢ä¸¤ä¸ªç»„ä»¶çš„ç±»å‹ä¸€è‡´è€Œæ·»åŠ äº†ä¸€å±‚å°è£….</p>
<h2 id="marker-components"><a class="header" href="#marker-components">Marker Components</a></h2>
<p>You can use empty structs to help you identify specific entities. These are
known as "marker components". Useful with <a href="programming//programming/queries.html#query-filters">query filters</a>.</p>
<pre><code class="language-rust no_run noplayground">/// Add this to all menu ui entities to help identify them
#[derive(Component)]
struct MainMenuUI;

/// Marker for hostile game units
#[derive(Component)]
struct Enemy;

/// This will be used to identify the main player entity
#[derive(Component)]
struct Player;

/// Tag all creatures that are currently friendly towards the player
#[derive(Component)]
struct Friendly;</code></pre>
<p>æ ‡è®°ç»„ä»¶,ç©ºç»“æ„ä½“,è¿™ä¸ªç”¨å¤„å¤ªå¤šäº†.eg:å‹å†›å’Œæ•Œå†›å¤§éƒ¨åˆ†ç»„ä»¶éƒ½æ˜¯ç±»ä¼¼çš„,
åˆ©ç”¨æ ‡è®°ç»„ä»¶æ¥åšåŒºåˆ†.</p>
<h2 id="accessing-components"><a class="header" href="#accessing-components">Accessing Components</a></h2>
<p>Components can be accessed from <a href="programming//programming/systems.html">systems</a>, using <a href="programming//programming/queries.html">queries</a>.</p>
<p>You can think of the query as the "specification" for the data you want
to access. It gives you access to specific component values from entities
that match the query's signature.</p>
<pre><code class="language-rust no_run noplayground">fn level_up_player(
    // get the relevant data. some components read-only, some mutable
    mut query_player: Query&lt;(&amp;PlayerName, &amp;mut PlayerXp, &amp;mut Health), With&lt;Player&gt;&gt;,
) {
    // `single` assumes only one entity exists that matches the query
    let (name, mut xp, mut health) = query_player.single_mut();
    if xp.0 &gt; 1000 {
        xp.0 = 0;
        health.hp = 100.0;
        health.extra += 25.0;
        info!("Player {} leveled up!", name.0);
    }
}

fn die(
    // `Entity` can be used to get the ID of things that match the query
    query_health: Query&lt;(Entity, &amp;Health)&gt;,
    // we also need Commands, so we can despawn entities if we have to
    mut commands: Commands,
) {
    // we can have many such entities (enemies, player, whatever)
    // so we loop to check all of them
    for (entity_id, health) in query_health.iter() {
        if health.hp &lt;= 0.0 {
            commands.entity(entity_id).despawn();
        }
    }
}</code></pre>
<p>è®¿é—®ç»„ä»¶ä¸€èˆ¬éƒ½æ˜¯é€šè¿‡queryæ¥åŒ¹é…å®ä½“,éå†å®ä½“åˆ—è¡¨,å†è®¿é—®ç»„ä»¶.</p>
<h2 id="addingremoving-components"><a class="header" href="#addingremoving-components">Adding/removing Components</a></h2>
<p>You can add/remove components on existing entities, using <a href="programming//programming/commands.html"><code>Commands</code></a> or
<a href="programming//programming/world.html">exclusive <code>World</code> access</a>.</p>
<pre><code class="language-rust no_run noplayground">fn make_enemies_friendly(
    query_enemy: Query&lt;Entity, With&lt;Enemy&gt;&gt;,
    mut commands: Commands,
) {
    for entity_id in query_enemy.iter() {
        commands.entity(entity_id)
            .remove::&lt;Enemy&gt;()
            .insert(Friendly);
    }
}</code></pre>
<p>å¢åˆ å®ä½“çš„ç»„ä»¶æœ‰ä¸¤ç§æ–¹å¼:</p>
<ul>
<li>Commands</li>
<li>ç‹¬å systemè®¿é—®world</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="bundles-1"><a class="header" href="#bundles-1">Bundles</a></h1>
<p>You can think of Bundles like "templates" for creating entities.
They make it easy to create <a href="programming//programming/ec.html#entities">entities</a> with a common set of
<a href="programming//programming/ec.html#components">components</a> types.</p>
<p>By creating a bundle type, instead of adding your components one by one, you
can make sure that you will never accidentally forget some important component
on your entities. The Rust compiler will give an error if you do not set all
the fields of a struct, thus helping you make sure your code is correct.</p>
<p>Bevy provides many <a href="programming//builtins.html#bundles">built-in bundle types</a> that you can use
to spawn common kinds of entities.</p>
<p>bundleå¯ç¿»è¯‘ä¸ºä¸€æ†ä¸€åŒ…,å°†å¤šä¸ªç»„ä»¶åˆ’åˆ†ä¸ºä¸€åŒ…,å†å‚ä¸å®ä½“çš„æ„é€ ,
ç®€å•ç‚¹è¯´å°±æ˜¯æ„é€ å®ä½“æ‰“é€ å‡ºçš„ç‰¹æ®Šç±»å‹,ä¸ºä»€ä¹ˆè¦bundle,è‡ªç„¶æ˜¯ä¸ºäº†apiçš„ç»Ÿä¸€.</p>
<p>bundleè¿˜æœ‰ä¸ªå¥½å¤„,å°†éƒ¨åˆ†ç»„ä»¶åˆ’åˆ†ä¸ºä¸€åŒ…,è¿™æ ·åœ¨æ„é€ å®ä½“æ—¶å°±ä¸ä¼šæ„å¤–å°‘äº†æŸä¸ªç»„ä»¶,
ecsæ¶æ„ä¸­å°‘ä¸€ä¸ªç»„ä»¶,è¿è¡Œç»“æœå°†å¤§å¤§ä¸åŒ.rustç¼–è¯‘å™¨ä¼šæ£€æŸ¥bundleçš„æ¯ä¸ªå­—æ®µ,
è¿™ä¹Ÿæ˜¯å˜ç›¸ä¿è¯äº†ä»£ç çš„æ­£ç¡®æ€§(è¿™æœ‰ç‚¹ç¡¬æ‰¯äº†).</p>
<p>bevyæä¾›äº†å¤šç§å†…ç½®çš„bundle,æ–¹ä¾¿ç”Ÿæˆä¸åŒç±»å‹çš„å®ä½“.</p>
<h2 id="creating-bundles"><a class="header" href="#creating-bundles">Creating Bundles</a></h2>
<p>To create your own bundle, derive <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/bundle/trait.Bundle.html"><code>Bundle</code></a> on a <code>struct</code>:</p>
<pre><code class="language-rust no_run noplayground">// ç»™è‡ªå®šä¹‰ç±»å‹æ·»åŠ Bundleçš„deriveä¹‹å,è‡ªå®šç±»å‹å°±å®ç°äº†Bundleç‰¹å‹.
// Bundleç‰¹æ€§çš„åŠŸèƒ½åœ¨äºå®ä½“å¯ä»¥å¢åˆ ç»„ä»¶,å®ç°æ–¹å¼æ˜¯ç”¨Bundleè¡¨ç¤ºä¸€ç»„å®ä½“çš„ç»„ä»¶.
// Bundleä¸­çš„ç»„ä»¶ä¸èƒ½é‡å¤,å¦åˆ™ä¼španic.
//
// Bundleä¸»è¦åŠŸèƒ½è¿˜æ˜¯å‘å®ä½“ä¸­æ–°å¢Bundle,
// å¦‚æœæŸä¸ªå®ä½“å·²ç»æœ‰äº†æ–°å¢çš„ç»„ä»¶,é‚£ä¹ˆå®ä½“ä¸­åŸå§‹ç»„ä»¶çš„å€¼ä¼šè¢«è¦†ç›–.
// (è¿™æ„å‘³ç€ä¸€ä¸ªå®ä½“å¯ä»¥åŒ…å«å¤šä¸ªBundle,å¤šä¸ªBundleå¯ä»¥åŒ…å«ç›¸åŒçš„ç»„ä»¶,
// ä½†å•ä¸ªBundleä¸­ä¸èƒ½åŒ…å«é‡å¤çš„ç»„ä»¶).
//
// Bundleä»…ä»…æ˜¯ç»„ä»¶çš„ç»„åˆ,ä¸å…³å¿ƒç»„ä»¶çš„è¡Œä¸º,ç»„ä»¶çš„è¡Œä¸ºç”±systemè€ƒè™‘.
// æ‰€ä»¥åœ¨è®¾è®¡ä¸Š`Query`çš„å¯¹è±¡æ˜¯ç»„ä»¶,è€Œä¸æ˜¯Bundle.
//
// å°‘éƒ¨åˆ†åœºæ™¯ä¸‹å®ä½“å¯ä»¥åˆ é™¤Bundle,æ­¤æ—¶ä¼šåˆ é™¤æ‰€æœ‰Bundleä¸­çš„ç»„ä»¶,
// å¦‚æœåˆ é™¤åå®ä½“å¹¶æ— å…¶ä»–ç»„ä»¶æ—¶,å®ä½“ä¼šè¢«åˆ é™¤.
#[derive(Bundle)]
struct PlayerBundle {
    xp: PlayerXp,
    name: PlayerName,
    health: Health,
    marker: Player,

    // We can nest/include another bundle.
    // Add the components for a standard Bevy Sprite:
    sprite: SpriteBundle,
}</code></pre>
<p>When you have nested bundles, everything gets flattened.
You end up with an entity that has all the included component
types. If a type appears more than once, that's an error.</p>
<p>ä¸ç®¡bundleåµŒå¥—å¤šå°‘,æœ€ç»ˆéƒ½æ˜¯æ‰å¹³åŒ–å¤„ç†,å®ä½“ä¼šæ‹¥æœ‰æ‰€æœ‰çš„ç»„ä»¶ç±»å‹,å¦‚æœé‡å¤ä¼šå‡ºé”™.</p>
<h3 id="using-bundles"><a class="header" href="#using-bundles">Using Bundles</a></h3>
<p>You can then use your bundle when you spawn your entities:</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn(PlayerBundle {
        xp: PlayerXp(0),
        name: PlayerName("Player 1".into()),
        health: Health {
            hp: 100.0,
            extra: 0.0,
        },
        marker: Player,
        sprite: SpriteBundle {
            // TODO
            ..Default::default()
        },
    });</code></pre>
<p>If you want to have default values (similar to Bevy's bundles):</p>
<pre><code class="language-rust no_run noplayground">impl Default for PlayerBundle {
    fn default() -&gt; Self {
        Self {
            xp: PlayerXp(0),
            name: PlayerName("Player".into()),
            health: Health {
                hp: 100.0,
                extra: 0.0,
            },
            marker: Player,
            sprite: Default::default(),
        }
    }
}</code></pre>
<p>Now you can do this:</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn(PlayerBundle {
        name: PlayerName("Player 1".into()),
        ..Default::default()
    });</code></pre>
<p>å…·ä½“å®ç°Bundleç‰¹å‹çš„ç±»å‹,åœ¨Commands.spawn()ä¸­å¯ä»¥ä¼ å…¥å…·ä½“çš„å®ä¾‹,
å…·ä½“ç±»å‹è¿˜å¯ä»¥å®ç°Defaultæ¥ç®€åŒ–å†™æ³•.</p>
<h3 id="bundles-for-removal"><a class="header" href="#bundles-for-removal">Bundles for Removal</a></h3>
<p>Bundles can also be useful to represent a set of components that you
want to be able to easily remove from an entity.</p>
<pre><code class="language-rust no_run noplayground">/// Contains all components to remove when
/// resetting the player between rooms/levels.
#[derive(Bundle)]
struct PlayerResetCleanupBundle {
    status_effect: StatusEffect,
    pending_action: PlayerPendingAction,
    modifier: CurrentModifier,
    low_hp_marker: LowHpMarker,
}</code></pre>
<pre><code class="language-rust no_run noplayground">    commands
        .entity(e_player)
        .remove::&lt;PlayerResetCleanupBundle&gt;();</code></pre>
<p>The component types included in the bundle will be removed from the
entity, if any of them exist on the entity.</p>
<p>å®ä½“åˆ é™¤Bundleçš„å¥—è·¯æ˜¯:
<code>commands.entity(å®ä½“id).remove::&lt;å…·ä½“çš„Bundleç±»å‹&gt;();</code></p>
<h2 id="loose-components-as-bundles"><a class="header" href="#loose-components-as-bundles">Loose components as bundles</a></h2>
<p>Technically, Bevy also considers arbitrary tuples of components as bundles:</p>
<pre><code>(ComponentA, ComponentB, ComponentC)
</code></pre>
<p>This allows you to easily spawn an entity using a loose bunch of components (or
bundles), or add more arbitrary components when you spawn entities. However,
this way you don't have the compile-time correctness advantages that a
well-defined <code>struct</code> gives you.</p>
<pre><code class="language-rust no_run noplayground">    commands.spawn((
        SpriteBundle {
            // ...
            ..default()
        },
        Health {
            hp: 50.0,
            extra: 0.0,
        },
        Enemy,
        // ...
    ));</code></pre>
<p>You should strongly consider creating proper <code>struct</code>s, especially if you are
likely to spawn many similar entities. It will make your code easier to maintain.</p>
<p>bevyè®¾è®¡çš„Bundleæ˜¯ä¸€ä¸ªéå¸¸çµæ´»çš„ç±»å‹,æ— é™åµŒå¥—è®©Bundleçš„è¡¨ç°åŠ›éå¸¸å¼ºå¤§,
ä¹Ÿå¤ç”¨rustç¼–è¯‘å™¨çš„æ­£ç¡®æ€§æ£€æŸ¥åŠŸèƒ½.ä»…å‡­è¿™ä¸€ç‚¹,
æœ€å¥½è¿˜æ˜¯ä½¿ç”¨ç»“æ„ä½“å°†æ¾æ•£çš„ç»„ä»¶åˆ—è¡¨ç»´æŠ¤èµ·æ¥, ç‰¹åˆ«æ˜¯è¦æ„é€ å¾ˆå¤šç›¸ä¼¼çš„å®ä½“æ—¶,ä»£ç æ›´å®¹æ˜“ç»´æŠ¤.</p>
<p>æ‰€ä»¥è¯´å°½é‡ä½¿ç”¨Bundleæ¥ç»„ç»‡ç»„ä»¶.</p>
<h2 id="querying"><a class="header" href="#querying">Querying</a></h2>
<p>Note that you cannot <a href="programming//programming/queries.html">query</a> for a whole bundle. Bundles are just a
convenience when creating the entities. Query for the individual component types
that your <a href="programming//programming/systems.html">system</a> needs to access.</p>
<p>This is <em>wrong</em>:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(query: Query&lt;&amp;SpriteBundle&gt;) {
  // ...
}</code></pre>
<p>Instead, do this:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(query: Query&lt;(&amp;Transform, &amp;Handle&lt;Image&gt;)&gt;) {
  // ...
}</code></pre>
<p>(or whatever specific components you need in that system)</p>
<p>ECSæŸ¥è¯¢æ—¶ä½¿ç”¨ç»„ä»¶,å› ä¸ºBundleè®¾è®¡çš„ä½¿ç”¨åœºæ™¯æ˜¯æ„é€ å®ä½“,ä¸æ˜¯è¿™å„¿çš„æŸ¥è¯¢.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Queries let you access <a href="programming//programming/ecs-intro.html">components of entities</a>.</p>
<p>Use the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> <a href="programming//programming/systems.html">system parameter</a>, where you can specify the data
you want to access, and optionally additional <a href="programming//programming/queries.html#query-filters">filters</a>.</p>
<p>Think of the types you put in your <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> as a "specification" for selecting
what entities you want to access. Queries will match only those entities in the
ECS World that fit your specification. You are then able to access the relevant
data from any such entities.</p>
<p>The first type parameter for a query is the data you want to access. Use <code>&amp;</code> for
shared/readonly access and <code>&amp;mut</code> for exclusive/mutable access. Use <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> if
the component is not required (you want to find entities with or without that
component. If you want multiple components, put them in a tuple.</p>
<p>é€šè¿‡queryå¯ä»¥è®¿é—®å®ä½“çš„ç»„ä»¶.</p>
<pre><code class="language-rsut">pub struct Query&lt;'world, 'state, D, F = ()&gt;
where
    D: QueryData, // ç‰¹å‹,ç”¨äºä»worldä¸­æŸ¥æ‰¾æ•°æ®.
    F: QueryFilter, // ç‰¹å‹,ç”¨äºè¿‡æ»¤æŸ¥è¯¢çš„ç»“æœ.
{ /* private fields */ }
</code></pre>
<p>Queryæ˜¯ä¸€ä¸ªæ³›å‹ç»“æ„ä½“,æœ‰ä¸¤ä¸ªå‚æ•°.å‰ä¸€ä¸ªå‚æ•°åªèƒ½æ˜¯å¼•ç”¨ç±»å‹(ä¸ç„¶æ‰€æœ‰æƒæ²¡äº†),
ä¸”å¦‚æœä¸ç¡®å®šæŸä¸ªç»„ä»¶æœ‰æ²¡æœ‰,ä½¿ç”¨Option,å¦‚æœå®ä½“åŒ…å«æ­¤ç»„ä»¶,å°±è¿”å›;å¦åˆ™è¿”å›ç©º.
å¦‚æœè¦è®¿é—®å¤šä¸ªç»„ä»¶,ä½¿ç”¨å…ƒç»„.</p>
<h3 id="iterating"><a class="header" href="#iterating">Iterating</a></h3>
<p>The most common operation is to simply iterate to access the component values of
every entity that matches the query:</p>
<pre><code class="language-rust no_run noplayground">fn check_zero_health(
    // access entities that have `Health` and `Transform` components
    // get read-only access to `Health` and mutable access to `Transform`
    // optional component: get access to `Player` if it exists
    mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
    // get all matching entities
    for (health, mut transform, player) in query.iter_mut() {
        eprintln!("Entity at {} has {} HP.", transform.translation, health.hp);

        // center if hp is zero
        if health.hp &lt;= 0.0 {
            transform.translation = Vec3::ZERO;
        }

        if let Some(player) = player {
            // the current entity is the player!
            // do something special!
        }
    }
}</code></pre>
<p>If you want to know the entity IDs of the entities you are accessing, you can
put the special <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> type in your query. This is useful if you need
to later perform specific operations on those entities.</p>
<pre><code class="language-rust no_run noplayground">// add `Entity` to `Query` to get Entity IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
    for (e, /* ... */) in q.iter() {
        // `e` is the Entity ID of the entity we are accessing
    }
}</code></pre>
<p>ä¸Šé¢æ˜¾ç¤ºäº†queryç»„ä»¶æœ€å¸¸è§çš„éå†æ–¹å¼.
ä¹Ÿå¯ä»¥queryå®ä½“,å¾—åˆ°çš„æ˜¯å®ä½“ID,å¦‚ä¸Šé¢çš„ä¾‹å­.</p>
<h3 id="accessing-specific-entities"><a class="header" href="#accessing-specific-entities">Accessing Specific Entities</a></h3>
<p>To access the <a href="programming//programming/ec.html#components">components</a> from one specific <a href="programming//programming/ec.html#entities">entity</a>
only, you need to know the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID:</p>
<pre><code class="language-rust no_run noplayground">if let Ok((health, mut transform)) = query.get_mut(entity) {
    // do something with the components
} else {
    // the entity does not have the components from the query
}</code></pre>
<p>If you want to access the data from several entities all at once, you can use
<code>many</code>/<code>many_mut</code> (panic on error) or <code>get_many</code>/<code>get_many_mut</code> (return
<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>).  These methods ensure that all the requested entities exist and
match the query, and will produce an error otherwise.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct UiHudIndicators {
    // say we have 3 special UI elements
    entities_ui: [Entity; 3],
    entities_text: [Entity; 3],
}

fn update_ui_hud_indicators(
    indicators: Res&lt;UiHudIndicators&gt;,
    query_text: Query&lt;&amp;Text&gt;,
    query_ui: Query&lt;(&amp;Style, &amp;BackgroundColor)&gt;,
) {
    // we can get everything as an array
    if let Ok(my_texts) = query_text.get_many(indicators.entities_text) {
        // the entities exist and match the query
        // TODO: something with `my_texts[0]`, `my_texts[1]`, `my_texts[2]`
    } else {
        // query unsuccessful
    };

    // we can use "destructuring syntax"
    // if we want to unpack everything into separate variables
    let [(style0, color0), (style1, color1), (style2, color2)] =
        query_ui.many(indicators.entities_ui);

    // TODO: something with all these variables
}</code></pre>
<p>è®¿é—®ç‰¹å®šçš„å®ä½“,æå‰ä¿å­˜å¥½å®ä½“idå³å¯.
å¦‚æœè¦åŒæ—¶è®¿é—®å¤šä¸ªå®ä½“,å¯ä»¥ä½¿ç”¨many/many_mutæˆ–get_many/get_many_mut.</p>
<h3 id="unique-entities"><a class="header" href="#unique-entities">Unique Entities</a></h3>
<p>If you know that only one matching entity is supposed to exist (the query is
expected to only ever match a single entity), you can use <code>single</code>/<code>single_mut</code>
(panic on error) or <code>get_single</code>/<code>get_single_mut</code> (return <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>). These
methods ensure that there exists exactly one candidate entity that can match
your query, and will produce an error otherwise.</p>
<p>You do not need to know the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID.</p>
<pre><code class="language-rust no_run noplayground">fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
    let (player, mut transform) = q.single_mut();

    // do something with the player and its transform
}</code></pre>
<p>å”¯ä¸€å®ä½“,eg:æˆ‘ä»¬æ“çºµçš„è§’è‰²åªæœ‰ä¸€ä¸ª,æ­¤æ—¶å¯ç”¨single/single_mutæˆ–get_single/get_many_mut.
æ­¤æ—¶ä¸éœ€è¦å®ä½“ID.</p>
<h3 id="combinations"><a class="header" href="#combinations">Combinations</a></h3>
<p>If you want to iterate over all possible combinations of N entities, Bevy
provides a method for that too. Be careful: with a lot of entities, this
can easily become very slow!</p>
<pre><code class="language-rust no_run noplayground">fn print_potential_friends(
    q_player_names: Query&lt;&amp;PlayerName&gt;,
) {
    // this will iterate over every possible pair of two entities
    // (that have the PlayerName component)

    for [player1, player2] in q_player_names.iter_combinations() {
        println!("Maybe {} could be friends with {}?", player1.0, player2.0);
    }
}

fn apply_gravity_to_planets(
    mut query: Query&lt;&amp;mut Transform, With&lt;Planet&gt;&gt;,
) {
    // this will iterate over every possible pair of two planets

    // For mutability, we need a different syntax
    let mut combinations = query.iter_combinations_mut();
    while let Some([planet1, planet2]) = combinations.fetch_next() {
        // TODO: calculate the gravity force between the planets
    }
}</code></pre>
<p>å°†queryç»“æœè¿›è¡Œç»„åˆ,ä½¿å…¶å˜ä¸ºæ•°ç»„.å½“å®ä½“æ•°é‡å¤§æ—¶,æ€§èƒ½ä¼šå¾ˆå·®.
è¿™ä¸ªçš„æ„ä¹‰åœ¨ä¸è¡¥å……æ ‡å‡†<code>query-for</code>çš„éå†æ–¹å¼.</p>
<h2 id="bundles-2"><a class="header" href="#bundles-2">Bundles</a></h2>
<p>Queries work with individual components. If you created an entity using a
<a href="programming//programming/bundle.html">bundle</a>, you need to query for the specific components from
that bundle that you care about.</p>
<p>A common beginner mistake is to query for the bundle type!</p>
<p>bundleåªåœ¨æ„é€ æ—¶æœ‰ç”¨,ä¸èƒ½ç”¨åœ¨queryå¤„.</p>
<h2 id="query-filters"><a class="header" href="#query-filters">Query Filters</a></h2>
<p>Add query filters to narrow down the entities you get from the query.</p>
<p>This is done using the second (optional) generic type parameter of the
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> type.</p>
<p>Note the syntax of the query: first you specify the data you want to access
(using a tuple to access multiple things), and then you add any additional
filters (can also be a tuple, to add multiple).</p>
<p>Use <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.With.html"><code>With</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Without.html"><code>Without</code></a> to only get entities that have specific components.</p>
<pre><code class="language-rust no_run noplayground">fn debug_player_hp(
    // access the health (and optionally the PlayerName, if present), only for friendly players
    query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
    // get all matching entities
    for (health, name) in query.iter() {
        if let Some(name) = name {
            eprintln!("Player {} has {} HP.", name.0, health.hp);
        } else {
            eprintln!("Unknown player has {} HP.", health.hp);
        }
    }
}</code></pre>
<p>This is useful if you don't actually care about the data stored inside these
components, but you want to make sure that your query only looks for entities
that have (or not have) them. If you want the data, then put the component in
the first part of the query (as shown previously), instead of using a filter.</p>
<p>Multiple filters can be combined:</p>
<ul>
<li>in a tuple to apply all of them (AND logic)</li>
<li>using the <code>Or&lt;(â€¦)&gt;</code> wrapper to detect any of them (OR logic).
<ul>
<li>(note the tuple inside)</li>
</ul>
</li>
</ul>
<p>queryçš„ç¬¬äºŒä¸ªæ³›å‹å‚æ•°æ˜¯è¿‡æ»¤,å¯çœç•¥,ä¹Ÿå¯ä»¥æ˜¯å…ƒç»„ç»„æˆ.
å¤šä¸ªè¿‡æ»¤å¯ä»¥è¿›è¡Œç»„åˆ:</p>
<ul>
<li>ç”¨å…ƒç»„,é‡Œé¢æ˜¯<code>é€»è¾‘ä¸</code>å…³ç³»</li>
<li>ç”¨<code>Or&lt;..&gt;</code>, <code>é€»è¾‘æˆ–</code>å…³ç³»</li>
</ul>
<h2 id="query-transmutation"><a class="header" href="#query-transmutation">Query Transmutation</a></h2>
<p>If you want one function with a <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> parameter to call another function
with a different (but compatible) <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> parameter, you can create the
needed <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> from the one you have using something called <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.QueryLens.html"><code>QueryLens</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn debug_positions(
    query: Query&lt;&amp;Transform&gt;,
) {
    for transform in query.iter() {
        eprintln!("{:?}", transform.translation);
    }
}

fn move_player(
    mut query_player: Query&lt;&amp;mut Transform, With&lt;Player&gt;&gt;,
) {
    // TODO: mutate the transform to move the player

    // say we want to call our debug_positions function

    // first, convert into a query for `&amp;Transform`
    let mut lens = query_player.transmute_lens::&lt;&amp;Transform&gt;();
    debug_positions(lens.query());
}

fn move_enemies(
    mut query_enemies: Query&lt;&amp;mut Transform, With&lt;Enemy&gt;&gt;,
) {
    // TODO: mutate the transform to move our enemies

    let mut lens = query_enemies.transmute_lens::&lt;&amp;Transform&gt;();
    debug_positions(lens.query());
}</code></pre>
<p>Note: when we call <code>debug_positions</code> from each function, it will access
different entities! Even though the <code>Query&lt;&amp;Transform&gt;</code> parameter type does not
have any additional <a href="programming//programming/queries.html#query-filters">filters</a>, it was created by transmuting
via <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.QueryLens.html"><code>QueryLens</code></a>, and therefore it can only access the entities and components
of the original <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a> that it was derived from. If we were to add
<code>debug_positions</code> to Bevy as a regular system, it would access the transforms of
all entities.</p>
<p>Also note: this has some performance overhead; the transmute operation is not
free. Bevy normally caches some query metadata across multiple runs of a
system. When you create the new query, it has to make a copy of it.</p>
<p>éƒ¨åˆ†åœºæ™¯ä¸‹,systemä¼šè°ƒç”¨å¦ä¸€ä¸ªå‡½æ•°,å¦ä¸€ä¸ªå‡½æ•°çš„å‚æ•°ä¹Ÿæ˜¯ä¸€ä¸ªquery,
åªä¸è¿‡è¿™ä¸ªqueryå‚æ•°æ˜¯è°ƒç”¨æ–¹system å…¥å‚queryçš„å…¼å®¹éƒ¨åˆ†(åªæ˜¯åŒ…å«éƒ¨åˆ†ç»„ä»¶),
å¦‚ä¸Šé¢çš„ä¾‹å­æ‰€ç¤º,å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå«<code>QueryLen</code>çš„æŠ€æœ¯æ¥å®ç°è½¬æ¢.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn transmute_lens&lt;NewD&gt;(&amp;mut self) -&gt; QueryLens&lt;'_, NewD&gt;
where
    NewD: QueryData,
<span class="boring">}</span></code></pre></pre>
<p>è¿™æ˜¯å¯¹QueryDataçš„å¤„ç†,å°†è¦æŸ¥è¯¢çš„ç»„ä»¶ç¼©å°äº†èŒƒå›´.ç»„ä»¶èŒƒå›´ç¼©å°äº†,
æ„å‘³ç€å°†systemå‡½æ•°æ‹†åˆ†ä¸ºå°å‡½æ•°çš„è¿‡ç¨‹ä¸­,éƒ¨åˆ†å°å‡½æ•°åªå…³å¿ƒè‡ªå·±éœ€è¦çš„é‚£éƒ¨åˆ†æ•°æ®,
å¥½å¤„æ˜¯å°å‡½æ•°ä¹Ÿå®¹æ˜“å¤ç”¨.</p>
<p>è¿™ä¹ˆåšä¹Ÿæ˜¯æœ‰ä»£ä»·çš„,æ€§èƒ½æ˜¯ä¸€ä¸ª,å†…å­˜ä¹Ÿæ˜¯ä¸€ä¸ª.
å› ä¸ºbevyé€šå¸¸ä¼šç¼“å­˜æŸ¥è¯¢çš„å…ƒæ•°æ®,æ–¹ä¾¿å¤šæ¬¡è°ƒç”¨systemæ—¶èƒ½æé«˜æ€§èƒ½,
ä½†æ–°å»ºä¸€ä¸ªqueryæ—¶,éœ€è¦æ‹·è´.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> to spawn/despawn entities, add/remove components on existing
entities, manage resources, from your <a href="programming//programming/systems.html">systems</a>.</p>
<p>Commandså¯ä»¥å¢åˆ å®ä½“;ä»å®ä½“ä¸­å¢åˆ ç»„ä»¶;ç®¡ç†èµ„æº.</p>
<pre><code class="language-rust no_run noplayground">// è¿™ä¸ªCommandsçš„ä¾‹å­å°†ä¸»è¦ä½¿ç”¨çš„åœºæ™¯éƒ½ç½—åˆ—å‡ºæ¥äº†.
fn spawn_things(mut commands: Commands) {
    // manage resources
    commands.insert_resource(MyResource::new());
    commands.remove_resource::&lt;MyResource&gt;();
    // å¢åˆ èµ„æº,åŒç±»å‹çš„èµ„æºéƒ½åªæœ‰ä¸€ä»½.(å¦‚æœè¦å¢åŠ å¤šä»½å°±ä½¿ç”¨ç»„ä»¶,èµ„æºéƒ½æ˜¯å•ä¾‹ç»„ä»¶).

    // create a new entity using `spawn`,
    // providing the data for the components it should have
    // (typically using a Bundle)
    commands.spawn(PlayerBundle {
        name: PlayerName("Henry".into()),
        xp: PlayerXp(1000),
        health: Health {
            hp: 100.0,
            extra: 20.0,
        },
        _p: Player,
        sprite: Default::default(),
    });
    // æ„é€ ä¸€ä¸ªå®ä½“,å•ç»„ä»¶.

    // you can use a tuple if you need additional components or bundles
    // (tuples of component and bundle types are considered bundles)
    // (note the extra parentheses)
    let my_entity_id = commands
        .spawn((
            // add some components
            ComponentA,
            ComponentB::default(),
            // add some bundles
            MyBundle::default(),
            TransformBundle::default(),
        ))
        .id(); // get the Entity (id) by calling `.id()` at the end

    // æ„é€ ä¸€ä¸ªå®ä½“,å¤šç»„ä»¶.
    // Bundleæ˜¯ç‰¹å¾,ä»å•å…ƒå…ƒç»„åˆ°14ä¸ªå…ƒç´ çš„å…ƒç»„,éƒ½å®ç°äº†Bundle.
    //
    // Commands::spawn()æ˜¯æ„é€ å®ä½“,è¿”å›çš„æ˜¯system::EntityCommands,
    // EntityCommandsæ˜¯ä¸€ä¸ªå‘½ä»¤åˆ—è¡¨,è¿™äº›å‘½ä»¤ä¼šä¿®æ”¹å®ä½“. id()ä¼šè¿”å›å®ä½“(ä¸€ä¸ªè½»é‡çº§çš„æ ‡è¯†:æ•°å€¼ç±»å‹).

    // add/remove components of an existing entity
    commands
        .entity(my_entity_id)
        .insert(ComponentC::default())
        .remove::&lt;ComponentA&gt;()
        .remove::&lt;(ComponentB, MyBundle)&gt;();
    // å¯¹å®ä½“è¿›è¡Œç»„ä»¶å¢åˆ æ“ä½œ.
    // Commands.entity()ä¼šæ ¹æ®EntityæŸ¥åˆ°å¯¹åº”çš„EntityCommands,
    // EntityCommandsçš„insert/removeå°±æ˜¯å¯¹å…·ä½“å®ä½“è¿›è¡Œç»„ä»¶å˜æ›´æ“ä½œ.

    // remove everything except the given components / bundles
    commands
        .entity(my_entity_id)
        .retain::&lt;(TransformBundle, ComponentC)&gt;();
    // åªä¿ç•™æŒ‡å®šçš„ç»„ä»¶,å…¶ä»–å…¨éƒ¨åˆ é™¤.
}

// æ”¹å˜æ•Œå¯¹å…³ç³»,å¢åŠ æ•Œäººç»„ä»¶,åˆ é™¤å‹å–„ç»„ä»¶.
fn make_all_players_hostile(
    mut commands: Commands,
    // we need the Entity id, to perform commands on specific entities
    query: Query&lt;Entity, With&lt;Player&gt;&gt;,
) {
    for entity in query.iter() {
        commands
            .entity(entity)
            // add an `Enemy` component to the entity
            .insert(Enemy)
            // remove the `Friendly` component
            .remove::&lt;Friendly&gt;();
    }
}

// åˆ é™¤æ‰€æœ‰å®ä½“çš„æ•Œäººç»„ä»¶.
fn despawn_all_enemies(mut commands: Commands, query: Query&lt;Entity, With&lt;Enemy&gt;&gt;) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}</code></pre>
<h2 id="when-do-these-actions-get-applied"><a class="header" href="#when-do-these-actions-get-applied">When do these actions get applied?</a></h2>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> do not take effect immediately, because it wouldn't be safe to
modify the data layout in memory when other <a href="programming//programming/systems.html">systems</a> could be
running in parallel. When you do anything using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, it gets queued to
be applied later when it is safe to do so.</p>
<p>Within the same <a href="programming//programming/schedules.html">schedule</a>, you can add <code>.before()</code>/<code>.after()</code>
<a href="programming//programming/system-order.html">ordering constraints</a> to your systems, and Bevy will
automatically make sure that Commands get applied in-between if necessary, so
that the second system can see the changes made by the first system.</p>
<p>Commandså¹¶ä¸ä¼šç«‹é©¬ç”Ÿæ•ˆ,å› ä¸ºsystemsä¹Ÿåœ¨å¹¶è¡Œä¿®æ”¹å†…å­˜æ•°æ®,ç«‹é©¬ç”Ÿæ•ˆä¼šå¯¼è‡´ä¸å®‰å…¨,
ç­‰å¾…å®‰å…¨æ—¶,bevyä¼šå°†å‘½ä»¤é›†åº”ç”¨åˆ°worldä¸Š.</p>
<p>åœ¨è°ƒåº¦å™¨ç»„ç»‡systemæ—¶,bevyæä¾›äº†before/afteræœºåˆ¶,åœ¨éƒ¨åˆ†è°ƒåº¦æ‰§è¡Œä¹‹å‰/ä¹‹åæ’å…¥é€»è¾‘,
bevyä¼šæ‹©æœºåº”ç”¨Commands,ä¿è¯äº†å®‰å…¨,ä¸‹ä¸€ä¸ªsystemæ‰§è¡Œæ—¶,Commandså·²ç»åº”ç”¨äº†.</p>
<p>before/afterå¤–åŠ è°ƒåº¦å™¨å†…ç½®çš„é¡ºåº,æä¾›äº†å¼ºå¤§çš„çµæ´»æ€§.</p>
<pre><code class="language-rust no_run noplayground">    app.add_systems(Update, spawn_new_enemies_if_needed);

    // This system will see any newly-spawned enemies when it runs,
    // because Bevy will make sure to apply the first system's Commands
    // (thanks to the explicit `.after()` dependency)
    app.add_systems(Update, enemy_ai.after(spawn_new_enemies_if_needed));</code></pre>
<p>If you do not have explicit ordering dependencies, it is undefined when Commands
will be applied. It is possible that some systems will only see the changes on
the next frame update!</p>
<p>Otherwise, Commands are normally applied at the end of every
<a href="programming//programming/schedules.html">schedule</a>. <a href="programming//programming/systems.html">Systems</a> that live in different schedules
will see the changes. For example, Bevy's engine systems (that live in
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>) will see the entities you spawn in your systems (that live in
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.Update.html"><code>Update</code></a>).</p>
<p>å¦‚æœæ²¡æœ‰æ˜ç¡®å‘½ä»¤åº”ç”¨é¡ºåº,é‚£ä¹ˆå‘½ä»¤å…·ä½“åº”ç”¨æ—¶é—´æ˜¯ä¸ç¡®å®šçš„,
å¯èƒ½åœ¨ä¸‹å¸§æ‰åº”ç”¨ä¸Š.</p>
<h2 id="custom-commands"><a class="header" href="#custom-commands">Custom Commands</a></h2>
<p>Commands can also serve as a convenient way to do any custom manipulations
that require <a href="programming//programming/world.html">full access</a> to the ECS <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>. You can queue up
any custom code to run in a deferred fashion, the same way as the standard
commands work.</p>
<p>For a one-off thing, you can just pass a closure:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(mut commands: Commands) {
    let x = 420;

    commands.add(move |world: &amp;mut World| {
        // do whatever you want with `world` here

        // note: it's a closure, you can use variables from
        // the parent scope/function
        eprintln!("{}", x);
    });
}</code></pre>
<p>If you want something reusable, consider <a href="programming//programming/one-shot-systems.html">one-shot systems</a>.
They are a way to write regular Bevy systems and run them on-demand.</p>
<p>åªè¦æ˜¯è®¿é—®ECSçš„world,ä½¿ç”¨Commandsæ˜¯éå¸¸ä¾¿æ·çš„æ–¹å¼.
å¯ä»¥å°†è‡ªå®šä¹‰é€»è¾‘ä»¥å»¶æ—¶çš„æ–¹å¼è¿è¡Œ,æ ‡å‡†å‘½ä»¤ä¹Ÿæ˜¯å¦‚æ­¤å·¥ä½œçš„.</p>
<p>å¯¹äºä¸€æ¬¡æ€§çš„äº‹æƒ…,å¯ä»¥ä¼ é€’ä¸€ä¸ªé—­åŒ….
å¯¹äºæƒ³é‡ç”¨çš„äº‹æƒ…,å¯ä»¥è€ƒè™‘<code>ä¸€å‡»</code>system,è¿™æ˜¯å¸¸è§„çš„bevy systm,æŒ‰éœ€è¿è¡Œ.</p>
<p>æ‰€è°“<code>ä¸€å‡»</code>system,å°±æ˜¯æƒ³è¦æ—¶æ‰è°ƒç”¨,eg:æŒ‰é’®æŒ‰ä¸‹,è§¦å‘ä¸€ä¸ªç‰¹æ®Šäº‹ä»¶ç­‰ç­‰.</p>
<h3 id="extending-the-commands-api"><a class="header" href="#extending-the-commands-api">Extending the Commands API</a></h3>
<p>If you want something more integrated, that feels like as if it was
part of Bevy's Commands API, here is how to do it.</p>
<p>Create a custom type and implement the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.Command.html"><code>Command</code></a> trait:</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::world::Command;

struct MyCustomCommand {
    // you can have some parameters
    data: u32,
}

impl Command for MyCustomCommand {
    fn apply(self, world: &amp;mut World) {
        // do whatever you want with `world` and `self.data` here
    }
}

// use it like this
fn my_other_system(mut commands: Commands) {
    commands.add(MyCustomCommand {
        data: 920, // set your value
    });
}</code></pre>
<p>And if you want to make it extra nice to use, you can create
an extension trait to add extra methods to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>:</p>
<pre><code class="language-rust no_run noplayground">pub trait MyCustomCommandsExt {
    // define a method that we will be able to call on `commands`
    fn do_custom_thing(&amp;mut self, data: u32);
}

// implement our trait for Bevy's `Commands`
impl&lt;'w, 's&gt; MyCustomCommandsExt for Commands&lt;'w, 's&gt; {
    fn do_custom_thing(&amp;mut self, data: u32) {
        self.add(MyCustomCommand { data });
    }
}

fn my_fancy_system(mut commands: Commands) {
    // now we can call our custom method just like Bevy's `spawn`, etc.
    commands.do_custom_thing(42);
}</code></pre>
<p>Note: if you want to use your custom extension method from other Rust
files, you will have to import your trait, or it will not be available:</p>
<pre><code class="language-rust no_run noplayground">use crate::thing::MyCustomCommandsExt;</code></pre>
<p>æ‰©å±•Commands API</p>
<p>å¦‚æœæœ‰æ›´å¤šäº¤äº’éœ€æ±‚,å¯æ‰©å±•Commands.</p>
<p>bevy::ecs::systemä¸‹æœ‰ä¸¤ä¸ªç±»å‹: ç‰¹å‹Commandå’Œ å®ç°äº†Commandçš„ç»“æ„ä½“Commands.</p>
<p>Commandsæ˜¯å‘½ä»¤åˆ—è¡¨,Commandæ˜¯å…·ä½“å‘½ä»¤.</p>
<p>æŒ‰ç…§æ‰©å±•çš„çº¦æŸ:åªè¦å½“å‰crateä¸­åŒ…å«ç‰¹å‹æˆ–ç±»å‹å…¶ä¸­ä¹‹ä¸€å°±å¯ä»¥è¿›è¡Œæ‰©å±•.</p>
<p>æ‰€ä»¥å…ˆå®šä¹‰ä¸€ä¸ªç±»å‹<code>MyCustomCommand</code>,è®©å…¶å®ç°Command,è¿™æ ·è‡ªå®šä¹‰å‘½ä»¤å°±å¯ä»¥æ­£å¸¸ä½¿ç”¨äº†.
å¦‚æœè¦ä¸ºè‡ªå®šä¹‰å‘½ä»¤æ·»åŠ è‡ªå®šä¹‰æ–¹æ³•,å°±éœ€è¦æ·»åŠ è‡ªå®šä¹‰ç‰¹å‹<code>MyCustomCommandsExt</code>,
æ­¤å¤„éœ€è¦æ³¨æ„:è®©Commandså®ç°è‡ªå®šä¹‰ç‰¹å‹.</p>
<p>NOTE: å¦‚æœè¦åœ¨å…¶ä»–rustæ–‡ä»¶ä¸­ä¹Ÿä½¿ç”¨è¿™ä¸ªæ‰©å±•,å°±éœ€è¦å¯¼å…¥è‡ªå®šä¹‰ç‰¹å‹.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="events-2"><a class="header" href="#events-2">Events</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/event.rs"><code>event</code></a>.</p>
<hr />
<p>Send data between systems! Let your <a href="programming//programming/systems.html">systems</a> communicate with each other!</p>
<p>Like <a href="programming//programming/res.html">resources</a> or <a href="programming//programming/ec.html#components">components</a>, events are
simple Rust <code>struct</code>s or <code>enum</code>s. When creating a new event type, derive
the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/trait.Event.html"><code>Event</code></a> trait.</p>
<p>Then, any <a href="programming//programming/systems.html">system</a> can send (broadcast) values of that type,
and any system can receive those events.</p>
<ul>
<li>To send events, use an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>.</li>
<li>To receive events, use an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>.</li>
</ul>
<p>Every reader tracks the events it has read independently, so you can handle
the same events from multiple <a href="programming//programming/systems.html">systems</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Event)]
struct LevelUpEvent(Entity);

fn player_level_up(
    mut ev_levelup: EventWriter&lt;LevelUpEvent&gt;,
    query: Query&lt;(Entity, &amp;PlayerXp)&gt;,
) {
    for (entity, xp) in query.iter() {
        if xp.0 &gt; 1000 {
            ev_levelup.send(LevelUpEvent(entity));
        }
    }
}

fn debug_levelups(
    mut ev_levelup: EventReader&lt;LevelUpEvent&gt;,
) {
    for ev in ev_levelup.read() {
        eprintln!("Entity {:?} leveled up!", ev.0);
    }
}</code></pre>
<p>You need to register your custom event types via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">app.add_event::&lt;LevelUpEvent&gt;();</code></pre>
<p>Eventç”¨äºsystemä¼ é€’æ•°æ®.deriveä¸­æŒ‡å®šEventå°±å¯ä»¥å£°æ˜äº‹ä»¶äº†.</p>
<p>ä»»ä½•systeméƒ½å¯ä»¥å‘é€äº‹ä»¶,ä»»ä½•syteméƒ½å¯ä»¥æ¥æ”¶äº‹ä»¶.
<code>EventWriter&lt;T&gt;</code>å‘é€äº‹ä»¶,<code>EventReader&lt;T&gt;</code>æ¥æ”¶äº‹ä»¶.
æ¯ä¸ªreaderéƒ½æ˜¯å•ç‹¬æ¶ˆè´¹äº‹ä»¶çš„.</p>
<p>å¦‚ä¸Šé¢çš„ä¾‹å­,äº‹ä»¶æ”¶å‘éƒ½åœ¨systemå…¥å‚ä¸­æ˜ç¡®äº†.</p>
<h2 id="usage-advice-1"><a class="header" href="#usage-advice-1">Usage Advice</a></h2>
<p>Events should be your go-to data flow tool. As events can be sent from any
<a href="programming//programming/systems.html">system</a> and received by multiple systems, they are <em>extremely</em>
versatile.</p>
<p>Events can be a very useful layer of abstraction. They allow you to decouple
things, so you can separate different functionality and more easily reason
about which <a href="programming//programming/systems.html">system</a> is responsible for what.</p>
<p>You can imagine how, even in the simple "player level up" example shown above,
using events would allow us to easily extend our hypothetical game with more
functionality. If we wanted to display a fancy level-up effect or animation,
update UI, or anything else, we can just add more systems that read the events
and do their respective things. If the <code>player_level_up</code> system had simply
checked the player XP and managed the player level directly, without going via
events, it would be unwieldy for future development of the game.</p>
<p>systemä¹‹é—´äº¤äº’çš„,æ¨èä½¿ç”¨äº‹ä»¶,åœ¨ç»å¤§éƒ¨åˆ†åœºæ™¯ä¸‹,äº‹ä»¶éƒ½æ˜¯ä¼˜å…ˆé€‰é¡¹.
å’Œæ¶ˆæ¯ç³»ç»Ÿç±»ä¼¼,bevyçš„äº‹ä»¶ç³»ç»Ÿå…·æœ‰å¼ºå¤§çš„è§£è€¦èƒ½åŠ›.</p>
<p>åªæœ‰è§£è€¦ä¹‹å,æ‰èƒ½åœ¨ä¸€ä¸ªäº‹ä»¶å‘ç”Ÿæ—¶æ‰èƒ½è§¦å‘æ›´å¤šé€»è¾‘,ä»å·¥ç¨‹åŒ–å’Œåä½œçš„è§’åº¦æ¥çœ‹,è¿™ç‚¹æ˜¯éå¸¸é‡è¦çš„.</p>
<h2 id="how-it-all-works"><a class="header" href="#how-it-all-works">How it all works</a></h2>
<p>When you register an event type, Bevy will create an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a>
<a href="programming//programming/res.html">resource</a>, which acts as the backing storage for the event queue. Bevy
also adds an "event maintenance" <a href="programming//programming/systems.html">system</a> to clear events periodically,
preventing them from accumulating and using up memory.</p>
<p>Bevy ensures that events are kept around for at least two frame update cycles,
or two <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> cycles, whichever is longer. After
that, they are silently dropped. This gives your systems enough opportunity
to handle them, assuming your systems are running all the time. Beware when
adding <a href="programming//programming/run-criteria.html">run conditions</a> to your systems, as you might miss some events
when your systems are not running!</p>
<p>If you don't like this, <a href="programming//patterns/manual-event-clear.html">you can have manual control over when events are
cleared</a> (at the risk of leaking / wasting memory if you
forget to clear them).</p>
<p>The <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a> system parameter is just syntax sugar for mutably
accessing the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a> <a href="programming//programming/res.html">resource</a> to add events to the queue. The
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a> is a little more complex: it accesses the events storage
immutably, but also stores an integer counter to keep track of how many events
you have read. This is why it also needs the <code>mut</code> keyword.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a> itself is internally implemented using simple <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a>s. Sending
events is equivalent to just pushing to a <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a>. It is very fast,
low overhead. Events are often the most performant way to implement things
in Bevy, better than using <a href="programming//programming/change-detection.html">change detection</a>.</p>
<p>å½“æˆ‘ä»¬æ³¨å†Œä¸€ä¸ªäº‹ä»¶ç±»å‹æ—¶,bevyä¼šåˆ›å»ºä¸€ä¸ª<code>Event&lt;T&gt;</code>èµ„æº,äº‹ä»¶é˜Ÿåˆ—å°±å­˜å‚¨åœ¨è¿™ä¸ªèµ„æºä¸­.
bevyè¿˜æ·»åŠ äº†ä¸€ä¸ªå®šæœŸæ¸…ç†äº‹ä»¶çš„<code>äº‹ä»¶ç»´æŠ¤system</code>,é˜²æ­¢å†…å­˜æ³„æ¼.</p>
<p>bevyä¿è¯äº‹ä»¶è‡³å°‘ä¿ç•™ä¸¤å¸§,æˆ–ä¸¤ä¸ªFixedå‘¨æœŸ(ä¸æŒ‰å¸§èµ°çš„sytem,å°±æ˜¯æŒ‰Fixed timeèµ°çš„).
ä¹‹åå°±é»˜é»˜è¢«ä¸¢å¼ƒ.å¦‚æœsystemä¸€ç›´åœ¨è¿è¡Œ,é‚£ä¹ˆæ•è·äº‹ä»¶çš„æ¦‚ç‡å°±å¾ˆé«˜äº†.
æ‰€ä»¥æŒ‡å®šsystemçš„<code>è¿è¡Œæ¡ä»¶</code>è¦éå¸¸æ³¨æ„,ä¸€ä¸å°å¿ƒå°±ä¼šé”™è¿‡äº‹ä»¶.
å½“ç„¶ä¹Ÿå¯ä»¥æ‰‹åŠ¨æ¸…é™¤äº‹ä»¶,åªæ˜¯å¦‚æœå¿˜äº†æ¸…ç†å°±ä¼šé€ æˆå†…å­˜æ³„æ¼.</p>
<p><code>EventWriter&lt;T&gt;</code>å‚æ•°æ˜¯ä¸€ä¸ªmutçš„è¯­æ³•ç³–,ç”¨äºå°†äº‹ä»¶æ·»åŠ åˆ°äº‹ä»¶é˜Ÿåˆ—;
<code>EventReader&lt;T&gt;</code>å‚æ•°è™½ç„¶ä¸ä¼šä¿®æ”¹äº‹ä»¶é˜Ÿåˆ—,ä½†ä¼šæ›´æ–°æ¥æ”¶äº‹ä»¶çš„æ•°é‡,æ‰€ä»¥åŒæ ·ä½¿ç”¨äº†mut.</p>
<p><code>Event&lt;T&gt;</code>å†…éƒ¨ä½¿ç”¨<code>Vec</code>å®ç°çš„,å‘é€äº‹ä»¶å°±æ˜¯push,æ•ˆç‡å¾ˆé«˜,æ¯”<code>å˜æ›´æ£€æµ‹</code>çš„æ•ˆç‡è¿˜é«˜.</p>
<h2 id="possible-pitfalls"><a class="header" href="#possible-pitfalls">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the
receiving system before the sending system. The receiving system will only
get a chance to receive the events the next time it runs. If you need to
ensure that events are handled on the same frame, you can use <a href="programming//programming/system-order.html">explicit
system ordering</a>.</p>
<p>If your systems have <a href="programming//programming/run-criteria.html">run conditions</a>, beware that they might miss
some events when they are not running! If your system does not check for events
at least once every other frame or <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a>, the
events will be lost.</p>
<p>If you want events to persist for longer than that, you can <a href="programming//patterns/manual-event-clear.html">implement a
custom cleanup/management strategy</a>. However, you can
only do this for your own event types. There is no solution for Bevy's
<a href="programming//builtins.html#events">built-in</a> types.</p>
<p>å¯èƒ½çš„å¤±è´¥.</p>
<p>æ³¨æ„éƒ¨åˆ†åœºæ™¯ä¸‹æ˜¯æœ‰1å¸§çš„æ»åçš„. eg:bevyå…ˆæ‰§è¡Œäº†æ¥æ”¶systemå†æ‰§è¡Œå‘é€system.
å¦‚æœè¦ç¡®ä¿åœ¨åŒå¸§ä¸­å¤„ç†äº‹ä»¶,é‚£éœ€è¦æ˜¾ç¤ºæŒ‡å®šsystemçš„æ‰§è¡Œé¡ºåº.</p>
<p>ä½¿ç”¨æ¡ä»¶è¿è¡Œçš„system,æœ‰å¯èƒ½ä¼šä¸¢å¤±äº‹ä»¶.</p>
<p>å¦‚æœæƒ³äº‹ä»¶æŒä¹…ä¸€äº›,å¯ä»¥è‡ªå·±å®ç°äº‹ä»¶æ¸…ç†ç­–ç•¥,ä½†è¿™ç§æ–¹å¼åªèƒ½ç”¨äºè‡ªå®šäº‹ä»¶,
bevyå†…ç½®çš„äº‹ä»¶æ— æ³•ä¿®æ”¹æ¸…ç†ç­–ç•¥.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/app/plugin.rs"><code>plugin</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/app/plugin_group.rs"><code>plugin_group</code></a>.</p>
<hr />
<p>As your project grows, it can be useful to make it more modular. You can
split it into "plugins".</p>
<p>Plugins are simply collections of things to be added to the <a href="programming//programming/app-builder.html">App
Builder</a>. Think of this as a way to add things to the app from
multiple places, like different Rust files/modules or crates.</p>
<p>The simplest way to create a plugin is by just writing a Rust function
that takes <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>&amp;mut App</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn my_plugin(app: &amp;mut App) {
    app.init_resource::&lt;MyCustomResource&gt;();
    app.add_systems(Update, (
        do_some_things,
        do_other_things,
    ));
}</code></pre>
<p>An alternative way is by creating a <code>struct</code> and implementing the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/trait.Plugin.html"><code>Plugin</code></a> trait:</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.init_resource::&lt;MyOtherResource&gt;();
        app.add_event::&lt;MyEvent&gt;();
        app.add_systems(Startup, plugin_init);
        app.add_systems(Update, my_system);
    }
}</code></pre>
<p>The benefit of using a <code>struct</code> is that you could extend it with configuration
parameters or generics if you want to make your plugin configurable.</p>
<p>Either way, you get <code>&amp;mut</code> access to the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a>, so you can add whatever
you want to it, just like you can do from your <code>fn main()</code>.</p>
<p>You can now add your plugins to your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> from elsewhere (most commonly
<code>fn main()</code>). Bevy will just call your plugin implementation above. In effect,
everything the plugin adds will be flattened into your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/struct.App.html"><code>App</code></a> alongside
everything that is already there.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins((
            my_plugin, // the `fn`-based plugin
            MyPlugin,  // the `struct`-based plugin
        ))
        .run();
}</code></pre>
<p>For internal organization in your own project, the main value of plugins
comes from not having to declare all your Rust types and functions as
<code>pub</code>, just so they can be accessible from <code>fn main</code> to be added to the
app builder. Plugins let you add things to your <a href="programming//programming/app-builder.html">app</a> from multiple
different places, like separate Rust files / modules.</p>
<p>You can decide how plugins fit into the architecture of your game.</p>
<p>Some suggestions:</p>
<ul>
<li>Create plugins for different <a href="programming//programming/states.html">states</a>.</li>
<li>Create plugins for various sub-systems, like physics or input handling.</li>
</ul>
<p>éšç€é¡¹ç›®çš„å¢é•¿,éœ€è¦è€ƒè™‘æ¨¡å—åŒ–,æ­¤æ—¶éœ€è¦ç”¨åˆ°<code>æ’ä»¶</code>,å°†éƒ¨åˆ†é€»è¾‘æ‹†åˆ†åˆ°æ’ä»¶ä¸­.
æœ€ç®€å•çš„æ’ä»¶å®ç°å°±æ˜¯ä¸€ä¸ªå‡½æ•°.å…¶æ¬¡æ˜¯ç”¨ç»“æ„ä½“å®ç°<code>Plugin</code>ç‰¹æ€§.</p>
<p>ä¸ºäº†è¿½æ±‚çµæ´»æ€§,structå®ç°çš„æ’ä»¶,å¯ä»¥æ¥å—ä¸€äº›é…ç½®å‚æ•°.
ä¹‹å‰å¾ˆå¤šç¯‡å¹…ä¸­éƒ½æœ‰ä½¿ç”¨åˆ°è¿™ç‚¹,eg:è®¾ç½®èƒŒæ™¯è‰²,é»˜è®¤æ’ä»¶åˆ—è¡¨ä¸­æœ‰å¤§éƒ¨åˆ†éƒ½æ˜¯å¯é…ç½®æ’ä»¶.</p>
<p>è™½ç„¶åœ¨ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥åœ¨appä¸­æ·»åŠ æ’ä»¶,ä¸è¿‡åœ¨mainä¸­å¤„ç†è¿™äº›æ˜¯ä¸»æµæ–¹æ¡ˆ.
åœ¨ç»„ç»‡é¡¹ç›®æ—¶,æ’ä»¶çš„ä¸»è¦å€¼çš„ç±»å‹éœ€è¦ç”¨pubå£°æ˜.</p>
<p>ä¸‹é¢æ˜¯ä½¿ç”¨æ’ä»¶çš„å»ºè®®:</p>
<ul>
<li>ä¸åŒçŠ¶æ€ä½¿ç”¨ä¸åŒçš„æ’ä»¶</li>
<li>ä¸åŒçš„å­systemä½¿ç”¨ä¸åŒæ’ä»¶,eg:è¾“å…¥/ç‰©ç†éƒ¨åˆ†</li>
</ul>
<h2 id="plugin-groups"><a class="header" href="#plugin-groups">Plugin Groups</a></h2>
<p>Plugin groups register multiple plugins at once.  Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a>
and <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> are examples of this.</p>
<p>To create your own plugin group, implement the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/app/trait.PluginGroup.html"><code>PluginGroup</code></a> trait:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::PluginGroupBuilder;

struct MyPluginGroup;

impl PluginGroup for MyPluginGroup {
    fn build(self) -&gt; PluginGroupBuilder {
        PluginGroupBuilder::start::&lt;Self&gt;()
            .add(FooPlugin)
            .add(BarPlugin)
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MyPluginGroup)
        .run();
}</code></pre>
<p>When adding a plugin group to the <a href="programming//programming/app-builder.html">app</a>, you can disable some
plugins while keeping the rest.</p>
<p>For example, if you want to manually set up logging (with your own <code>tracing</code>
subscriber), you can disable Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>:</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins(
        DefaultPlugins.build()
            .disable::&lt;bevy::log::LogPlugin&gt;()
    )
    .run();</code></pre>
<p>Note that this simply disables the functionality, but it cannot actually
remove the code to avoid binary bloat. The disabled plugins still have to
be compiled into your program.</p>
<p>If you want to slim down your build, you should look at disabling Bevy's
default <a href="programming//setup/bevy-config.html">cargo features</a>, or depending on the various Bevy
sub-crates individually.</p>
<p>æ’ä»¶ç»„,ä¸€æ¬¡æ€§æ³¨å†Œå¤šä¸ªæ’ä»¶.æ–¹ä¾¿ä¸åŒåœºæ™¯ä¸‹ä½¿ç”¨,å…å¾—æ¯æ–°å»ºä¸€ä¸ªé¡¹ç›®å°±éœ€è¦æ³¨å†Œå¾ˆå¤šæ’ä»¶,
è¿™æ˜¯ç”¨æˆ·å‹å¥½çš„è¡¨ç°,bevyå†…ç½®äº†ä¸¤ä¸ªå¸¸ç”¨çš„æ’ä»¶ç»„:DefaultPlugins/MinimalPlugins.</p>
<p>å¦‚æœè¦å®ç°è‡ªå·±çš„æ’ä»¶ç»„,åªéœ€è¦å®ç°PluginGroupç‰¹å‹å³å¯.è¿™åº”è¯¥æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¸¸ç”¨çš„åŠŸèƒ½.
åœ¨appå¤„æ·»åŠ æ’ä»¶ç»„æ—¶è¿˜èƒ½disableéƒ¨åˆ†æ’ä»¶(è¿™ç§æ–¹å¼åªæ˜¯å±è”½äº†ç‰¹å®šçš„æ’ä»¶,
ä¸èƒ½å‡å°‘äºŒè¿›åˆ¶å¤§å°).</p>
<p>å¦‚æœå®åœ¨è¦å‡å°‘äºŒè¿›åˆ¶å¤§å°,éœ€è¦åœ¨cargoåŠŸèƒ½å¤„åšdisable,æˆ–è€…å°†å­åŒ…ç‹¬ç«‹,ä»ä¾èµ–å‡ºç€æ‰‹.</p>
<h2 id="plugin-configuration"><a class="header" href="#plugin-configuration">Plugin Configuration</a></h2>
<p>Plugins are also a convenient place to store settings/configuration that are
used during initialization/startup. For settings that can be changed at runtime,
it is recommended that you put them in <a href="programming//programming/res.html">resources</a> instead.</p>
<pre><code class="language-rust no_run noplayground">struct MyGameplayPlugin {
    /// Should we enable dev hacks?
    enable_dev_hacks: bool,
}

impl Plugin for MyGameplayPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // add our gameplay systems
        app.add_systems(Update, (
            health_system,
            movement_system,
        ));
        // ...

        // if "dev mode" is enabled, add some hacks
        if self.enable_dev_hacks {
            app.add_systems(Update, (
                player_invincibility,
                free_camera,
            ));
        }
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MyGameplayPlugin {
            // change to true for dev testing builds
            enable_dev_hacks: false,
        })
        .run();
}</code></pre>
<p>Plugins that are added using <a href="programming//programming/plugins.html#plugin-groups">Plugin Groups</a> can also be
configured. Many of Bevy's <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> work this way.</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::WindowResolution;

App::new()
    .add_plugins(DefaultPlugins.set(
        // here we configure the main window
        WindowPlugin {
            primary_window: Some(Window {
                resolution: WindowResolution::new(800.0, 600.0),
                // ...
                ..Default::default()
            }),
            ..Default::default()
        }
    ))
    .run();</code></pre>
<p>æ’ä»¶åœ¨åˆå§‹åŒ–æˆ–å¯åŠ¨æ—¶å¯ä»¥é…ç½®(structæ’ä»¶æ‰è¡Œ,è¿™ä¹Ÿæ˜¯å¤§éƒ¨åˆ†æ’ä»¶çš„é€‰æ‹©).
è¿è¡Œæ—¶ä¹Ÿå¯ä»¥ä¿®æ”¹,ä¸è¿‡æ¨èå°†é…ç½®æ”¾åœ¨èµ„æºä¸­(è¿™ç§åœºæ™¯åº”è¯¥éå¸¸å°‘è§).</p>
<p>ps:bevyè¿˜æ˜¯æœ‰ç‚¹ç†æƒ³ä¸»ä¹‰çš„,å„ä¸ªåŒ…å’Œæœºåˆ¶éƒ½è®¾è®¡å¾—éå¸¸çµæ´»,ä½†å®é™…åœºæ™¯ä¸‹,
ç»å¤§éƒ¨åˆ†åªä½¿ç”¨åˆ°äº†å…¶ä¸­å‡ æ¡,è¿™ç‚¹åœ¨bevyçš„å¾ˆå¤šåœ°æ–¹éƒ½éƒ½ä½“ç°äº†:eg:è¿™å„¿+ecs.</p>
<h2 id="publishing-crates"><a class="header" href="#publishing-crates">Publishing Crates</a></h2>
<p>Plugins give you a nice way to publish Bevy-based libraries for other people
to easily include into their projects.</p>
<p>Bevy offers some official guidance for good practices when you develop plugins
you want to publish for other people to use. <a href="https://bevyengine.org/learn/book/plugin-development/">You can read it here.</a></p>
<p>Don't forget to submit an entry to <a href="https://bevyengine.org/assets">Bevy Assets</a> on the official
website, so that people can find your plugin more easily. You can do this
by making a PR in <a href="https://github.com/bevyengine/bevy-assets">the Github repo</a>.</p>
<p>If you are interested in supporting bleeding-edge Bevy (main), <a href="programming//setup/bevy-git.html#advice-for-plugin-authors">see here
for advice</a>.</p>
<p>æ’ä»¶ä½œä¸ºæ¨¡å—åŒ–åˆ†å‰²äº†é€»è¾‘,å°±èƒ½åˆ†äº«ç»™ä»–äºº.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="local-resources"><a class="header" href="#local-resources">Local Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.14.0-rc.2/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Local resources allow you to have per-<a href="programming//programming/systems.html">system</a> data. This data
is not stored in the ECS World, but rather together with your system.
Nothing outside of your system can access it. The value will be kept across
subsequent runs of the system.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is a system parameter similar to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, which gives
you full mutable access to a single value of the given data type, that is
independent from entities and components.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>/<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a> refer to a single global instance of the type, shared
between all systems. On the other hand, every <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> parameter is a
separate instance, exclusively for that system.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyState {
    // ...
}

fn my_system1(mut local: Local&lt;MyState&gt;) {
    // you can do anything you want with the local here
}

fn my_system2(mut local: Local&lt;MyState&gt;) {
    // the local in this system is a different instance
}</code></pre>
<p>The type must implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> or <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a>. It is automatically
initialized. It is not possible to specify a custom initial value.</p>
<p>A system can have multiple <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local</code></a>s of the same type.</p>
<p>localèµ„æº,å¯ä»¥å­˜å‚¨æ¯å¸§çš„systemæ•°æ®,èµ„æºä¸å±äºecsä¸–ç•Œ,è€Œæ˜¯è·Ÿç€systemèµ°çš„.
è¿™ä¸ªæ•°æ®åªæœ‰systemæ‰èƒ½è®¿é—®.</p>
<p><code>Local&lt;T&gt;</code>æ˜¯ä¸€ä¸ªsystemå‚æ•°,ç±»ä¼¼äº<code>ResMut&lt;T&gt;</code>,é€šè¿‡è¿™ä¸ªå‚æ•°å¯ä»¥è®¿é—®æŒ‡å®šç±»å‹çš„æ•°æ®,
å¬åˆ°è¿™å„¿,æ„Ÿè§‰local resourceå’Œæ™®é€šçš„èµ„æºæ²¡ä»€ä¹ˆå·®åˆ«.
å·®åˆ«åœ¨äºèµ„æºæ˜¯æ‰€æœ‰systeméƒ½å¯ä»¥è®¿é—®çš„,localèµ„æºåªèƒ½è¢«ç‰¹å®šçš„systemè®¿é—®.</p>
<p>localç±»å‹éœ€è¦å®ç°Defaultæˆ–FromWorldç‰¹æ€§,åˆå§‹åŒ–æ˜¯è‡ªåŠ¨çš„,ä¸èƒ½æŒ‡å®šè‡ªå®šä¹‰å€¼.</p>
<p>ä¸€ä¸ªsystemå¯ä»¥æ‹¥æœ‰å¤šä¸ªlocalå‚æ•°,è€Œä¸”è¿™äº›localå‚æ•°å¯ä»¥æ˜¯åŒä¸€ä¸ªç±»å‹çš„.</p>
<h2 id="specify-an-initial-value"><a class="header" href="#specify-an-initial-value">Specify an initial value</a></h2>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is always automatically initialized using the default value for
the type. If that doesn't work for you, there is an alternative way to pass
data into a system.</p>
<p>If you need specific data, you can use a closure instead. Rust closures that
take system parameters are valid Bevy systems, just like standalone functions.
Using a closure allows you to "move data into the function".</p>
<p>This example shows how to initialize some data to configure a system, without
using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyConfig {
    magic: usize,
}

fn my_system(
    mut cmd: Commands,
    my_res: Res&lt;MyStuff&gt;,
    // note this isn't a valid system parameter
    config: &amp;MyConfig,
) {
    // TODO: do stuff
}

fn main() {
    let config = MyConfig {
        magic: 420,
    };

    App::new()
        .add_plugins(DefaultPlugins)

        // create a "move closure", so we can use the `config`
        // variable that we created above

        // Note: we specify the regular system parameters we need.
        // The closure needs to be a valid Bevy system.
        .add_systems(Update, move |cmd: Commands, res: Res&lt;MyStuff&gt;| {
            // call our function from inside the closure,
            // passing in the system params + our custom value
            my_system(cmd, res, &amp;config);
        })
        .run();
}</code></pre>
<p>Another way to accomplish the same thing is to "return" the system from
"constructor" helper function that creates it:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyConfig {
    magic: usize,
}

// create a "constructor" function, which can initialize
// our data and move it into a closure that Bevy can run as a system
fn my_system_constructor() -&gt; impl FnMut(Commands, Res&lt;MyStuff&gt;) {
    // create the `MyConfig`
    let config = MyConfig {
        magic: 420,
    };

    // this is the actual system that bevy will run
    move |mut commands, res| {
        // we can use `config` here, the value from above will be "moved in"
        // we can also use our system params: `commands`, `res`
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // note the parentheses `()`
        // we are calling the "constructor" we made above,
        // which will return the actual system that gets added to bevy
        .add_systems(Update, my_system_constructor())

        .run();
}</code></pre>
<p>localå‚æ•°åˆå§‹åŒ–æ˜¯ä½¿ç”¨é»˜è®¤å€¼,ä¸èƒ½æŒ‡å®šè‡ªå®šä¹‰å€¼,ä½†bevyè¿˜æ˜¯æä¾›äº†å…¶ä»–æ–¹æ³•æ¥å®ç°.</p>
<p>ä¸ä½¿ç”¨<code>Local&lt;T&gt;</code>,æ”¹ä¸ºé—­åŒ….</p>
<p>åˆ©ç”¨é—­åŒ…æ•è·å±€éƒ¨å˜é‡,è€Œé—­åŒ…çš„æ˜¯å®ç°å°±æ˜¯ä¸€ä¸ªæ™®é€šsystemçš„å®ç°,ä½†åœ¨å‡½æ•°å†…éƒ¨,
å¯ä»¥ä½¿ç”¨æ•è·çš„å±€éƒ¨å˜é‡,è€Œå±€éƒ¨å˜é‡çš„å€¼æ˜¯å¯ä»¥è‡ªå®šä¹‰çš„,å˜ç›¸è¾¾åˆ°äº†è‡ªå®šä¹‰åˆå§‹åŒ–å€¼.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="exclusive-systems-1"><a class="header" href="#exclusive-systems-1">Exclusive Systems</a></h1>
<p>Exclusive systems are <a href="programming//programming/systems.html">systems</a> that Bevy will not run in parallel
with any other system. They can have <a href="programming//programming/world.html">full unrestricted access</a>
to the whole ECS <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>, by taking a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;mut World</code></a> parameter.</p>
<p>Inside of an exclusive system, you have full control over all data stored
in the ECS. You can do whatever you want.</p>
<p>Some example situations where exclusive systems are useful:</p>
<ul>
<li>Dump various entities and components to a file, to implement things like
saving and loading of game save files, or scene export from an editor</li>
<li>Directly spawn/despawn <a href="programming//programming/intro-data.html#entities--components">entities</a>, or insert/remove <a href="programming//programming/res.html">resources</a>,
immediately with no delay (unlike when using <a href="programming//programming/commands.html">Commands</a>
from a regular system)</li>
<li>Run arbitrary <a href="programming//programming/systems.html">systems</a> and <a href="programming//programming/schedules.html">schedules</a> with your
own custom control flow logic</li>
<li>â€¦</li>
</ul>
<p>See the <a href="programming//programming/world.html">direct World access page</a> to learn more about how to do
such things.</p>
<pre><code class="language-rust no_run noplayground">fn do_crazy_things(world: &amp;mut World) {
    // we can do anything with any data in the Bevy ECS here!
}</code></pre>
<p>You need to add exclusive systems to the <a href="programming//programming/app-builder.html">App</a>, just like
regular systems. All scheduling APIs (<a href="programming//programming/system-order.html">ordering</a>, <a href="programming//programming/run-criteria.html">run
conditions</a>, <a href="programming//programming/system-sets.html">sets</a>) are supported and work the same
as with regular systems.</p>
<pre><code class="language-rust no_run noplayground">    app.add_systems(
        Update,
        do_crazy_things
            .run_if(needs_crazy_things)
            .after(do_regular_things)
            .before(other_things),
    );</code></pre>
<p>ç‹¬å systemä¹Ÿæ˜¯system,åªä¸è¿‡ä¸å’Œå…¶ä»–systemå¹¶è¡Œå¤„ç†,æ­£æ˜¯å› ä¸ºè¿™ç‚¹,
ç‹¬å systemæ¯”æ™®é€šsystemå¤šäº†ä¸€ä¸ªä½¿ç”¨åœºæ™¯:æ— é™åˆ¶è®¿é—®world.
è€Œä½¿ç”¨ç‹¬å systemä¸»è¦æ˜¯ä¸ºäº†æ— é™åˆ¶è®¿é—®world,ä¸ç„¶ä½¿ç”¨æ™®é€šsystemå¾—äº†.</p>
<p>æ— é™åˆ¶è®¿é—®world,æ„å‘³ç€å¯ä»¥è®¿é—®æ•´ä¸ªECS,ä¸‹é¢æ˜¯ç‹¬å systemçš„å‡ ä¸ªå¸¸ç”¨ä½¿ç”¨åœºæ™¯:</p>
<ul>
<li>dump ECSåˆ°ä¸€ä¸ªæ–‡ä»¶,æ¸¸æˆçš„ä¿å­˜å’ŒåŠ è½½,ä»ç¼–è¾‘å™¨å¯¼å‡ºåœºæ™¯</li>
<li>ç›´æ¥å¢åˆ å®ä½“,å¢åˆ èµ„æº,è¿™æ˜¯ç«‹é©¬ç”Ÿæ•ˆçš„(Commandsä¹Ÿèƒ½åšåˆ°,åªä¸è¿‡æ˜¯å»¶æ—¶çš„)</li>
<li>æ‰§è¡Œä»»æ„system/è°ƒåº¦</li>
</ul>
<p>åœ¨appä¸­æ·»åŠ ç‹¬å systemçš„æ–¹å¼å’Œå¤„ç†æ™®é€šsystemçš„æ–¹å¼æ˜¯ä¸€æ ·çš„,
bevyå†…éƒ¨ä¼šè¯†åˆ«systemå‚æ•°,æ¥æ ‡è¯†ç‹¬å system.
äº‹æƒ…éƒ½æ˜¯bevyåšçš„,ç”¨æˆ·å‹å¥½.</p>
<h2 id="exclusive-system-parameters"><a class="header" href="#exclusive-system-parameters">Exclusive System Parameters</a></h2>
<p>There are a few other things, besides <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;mut World</code></a>, that can be used as
parameters for exclusive systems:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;mut World</code></a>:
Full <a href="programming//programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="programming//programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>&amp;mut SystemState&lt;P&gt;</code></a>:
Emulates a regular system, allowing you to easily access data from the World.
<code>P</code> are the system parameters.</li>
<li><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/query/struct.QueryState.html"><code>&amp;mut QueryState&lt;Q, F = ()&gt;</code></a>:
Allows you to perform queries on the World, similar to a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Query.html"><code>Query</code></a> in regular systems.</li>
</ul>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> can be used to emulate a normal system.  You can put regular
system parameters inside. This allows you to access the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a> as you would
from a normal system, but you can confine it to a specific scope inside your
function body, making it more flexible.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/query/struct.QueryState.html"><code>QueryState</code></a> is the same thing, but for a single query.  It is a simpler
alternative to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> for when you just need to be able to query for
some data.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::system::SystemState;

fn spawn_particles_for_enemies(
    world: &amp;mut World,
    // behaves sort of like a query in a regular system
    q_enemies: &amp;mut QueryState&lt;&amp;Transform, With&lt;Enemy&gt;&gt;,
    // emulates a regular system with an arbitrary set of parameters
    params: &amp;mut SystemState&lt;(
        ResMut&lt;MyGameSettings&gt;,
        ResMut&lt;MyParticleTracker&gt;,
        Query&lt;&amp;mut Transform, With&lt;Player&gt;&gt;,
        EventReader&lt;MyDamageEvent&gt;,
        // yes, even Commands ;)
        Commands,
    )&gt;,
    // local resource, just like in a regular system
    mut has_run_once: Local&lt;bool&gt;,
) {
    // note: unlike with a regular Query, we need to provide the world as an argument.
    // The world will only be "locked" for the duration of this loop
    for transform in q_enemies.iter(world) { // å’Œæ™®é€šsystem.queryå·®åˆ«ä¸å¤§
         // TODO: do something with the transforms
    }

    // create a scope where we can access our things like a regular system
    {
        // è¿™ä¸ªä½œç”¨åŸŸé™åˆ¶äº†å˜é‡çš„èŒƒå›´,è¿™æ ·çµæ´»æ€§æ›´é«˜ä¸€ç‚¹.
        let (mut settings, mut tracker, mut q_player, mut evr, commands) = params.get_mut(world);

        // TODO: do things with our resources, query, events, commands, ...
    }

    // because our SystemState includes Commands,
    // we must apply them when we are done
    params.apply(world);

    // we are now free to directly spawn entities
    // because the World is no longer used by anything
    // (the SystemState and the QueryState are no longer accessing it)

    world.spawn_batch(
        (0..10000) // efficiently spawn 10000 particles
            .map(|_| SpriteBundle {
                // ...
                ..Default::default()
            }),
    );

    // and, of course, we can use our Local
    *has_run_once = true;
}</code></pre>
<p>Note: if your <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> includes <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, you must call <code>.apply()</code>
after you are done! That is when the deferred operations queued via
<a href="programming//programming/commands.html">commands</a> will be applied to the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>ç‹¬å systemçš„å‚æ•°,å‡ºäº†<code>&amp;mut world</code>,è¿˜æœ‰ä»¥ä¸‹å‡ ç§:</p>
<ul>
<li><code>Local&lt;T&gt;</code></li>
<li><code>&amp;mut SystemState&lt;P&gt;</code>,æ¨¡æ‹Ÿä¸€ä¸ªæ™®é€šsystem,ç®€åŒ–worldçš„è®¿é—®</li>
<li><code>&amp;mut QueryState&lt;Q, F= ()&gt;</code> QueryState: ä»worldæ‰§è¡ŒæŸ¥è¯¢,ç±»ä¼¼æ™®é€šsystemçš„Query</li>
</ul>
<p>ä»ä¸‹é¢çš„SystemStateæ³›å‹ç±»å‹çš„å®šä¹‰æ¥çœ‹,å…·ä½“å‚æ•°æ˜¯systemå‚æ•°,
SystemStateæœ¬èº«ä¹Ÿå®ç°äº†SystemParamç‰¹æ€§,ä¹Ÿæ˜¯ä¸€ä¸ªsystemå‚æ•°,
æ‰€ä»¥è¯´SystemStateæ˜¯å¯¹æ™®é€šsystemå‚æ•°çš„ä¸€å±‚å°è£….
å› ä¸ºSystemStateèƒ½è®¿é—®æ‰€æœ‰ECSæ•°æ®,åœ¨ä½¿ç”¨æ—¶åªéœ€è¦é™åˆ¶åœ¨ç‰¹å®šèŒƒå›´å°±èƒ½å¾—åˆ°æœ€å¤§çµæ´»æ€§.</p>
<p>å¦‚æœSystemStateåŒ…å«äº†Commands,éœ€è¦è°ƒç”¨applyæ¥è®©å…¶ç”Ÿæ•ˆ.
SystemStateå¯¹åº”æ™®é€šsystemçš„å‚æ•°;QueryStateå¯¹åº”æ™®é€šsystemçš„query,æ­é…ä½¿ç”¨.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SystemState&lt;Param: SystemParam + 'static&gt; {
    meta: SystemMeta,
    param_state: Param::State,
    world_id: WorldId,
    archetype_generation: ArchetypeGeneration,
}

impl&lt;Param: SystemParam&gt; SystemState&lt;Param&gt; {...}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>Exclusive systems, by definition, limit parallelism and multi-threading, as
nothing else can access the same ECS World while they run. The whole schedule
needs to come to a stop, to accomodate the exclusive system. This can easily
introduce a performance bottleneck.</p>
<p>Generally speaking, you should avoid using exclusive systems, unless you need
to do something that is only possible with them.</p>
<p>On the other hand, if your alternative is to use <a href="programming//programming/commands.html">commands</a>,
and you need to process a huge number of entities, exclusive systems are faster.</p>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> is effectively just a way to ask Bevy do to exclusive <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>
access for you, at a later time. Going through the commands queue is much
slower than just doing the exclusive access yourself.</p>
<p>Some examples for when exclusive systems can be faster:</p>
<ul>
<li>You want to spawn/despawn a ton of entities.
<ul>
<li>Example: Setup/cleanup for your whole game map.</li>
</ul>
</li>
<li>You want to do it every frame.
<ul>
<li>Example: Managing hordes of enemies.</li>
</ul>
</li>
</ul>
<p>Some examples for when normal systems with <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> can be faster:</p>
<ul>
<li>You need to check some stuff every frame, but only use <a href="programming//programming/commands.html">commands</a> sometimes.
<ul>
<li>Example: Despawn enemies when they reach 0 HP.</li>
<li>Example: Spawn/despawn entities when <a href="programming//fundamentals/time.html#timer">timers</a> finish.</li>
<li>Example: Add/remove some UI elements depending on what is happening in-game.</li>
</ul>
</li>
</ul>
<p>ç‹¬å system,è¿è¡Œæ—¶ä¸èƒ½å¹¶è¡Œæ‰§è¡Œ,æ•ˆç‡è‚¯å®šæœ‰å¾ˆå¤§çš„å½±å“,æ€§èƒ½ç“¶é¢ˆä¸€èˆ¬å‡ºåœ¨è¿™å„¿,
åœ¨æ¸¸æˆä¸­è¦å°½é‡é¿å…ä½¿ç”¨ç‹¬å system.</p>
<p>å¦‚æœè¦å¯¹å¤§é‡å®ä½“è¿›è¡Œå¤„ç†,ä½¿ç”¨Commandså»¶æ—¶å¤„ç†,æ­¤æ˜¯æ€§èƒ½ä¸ä¸€å®šæ¯”ç‹¬å systemæ•ˆç‡é«˜,
çŸ®ä¸ªå­é‡Œæ‹”é«˜ä¸ª,ä¸¤æƒç›¸å®³å–å…¶è½».</p>
<p>Commandsæ—¶å»¶æ—¶æ‰§è¡Œ,é‡Œé¢æ¶‰åŠé˜Ÿåˆ—,å¦‚æœå®ä½“æ•°é‡å¤§äº†,æ€§èƒ½å°±å·®äº†.</p>
<p>ä»¥ä¸‹åœºæ™¯ç‹¬å systemä¼šæ›´å¿«:</p>
<ul>
<li>å®ä½“çš„æ„é€ å’Œé”€æ¯,æ¸¸æˆå¯åŠ¨æˆ–ç»“æŸæ¸…ç†æ—¶</li>
<li>æ¯å¸§éƒ½æ‰§è¡Œçš„,eg:ç®¡ç†å¤§é‡æ•Œäºº</li>
</ul>
<p>ä»¥ä¸‹åœºæ™¯æ˜¯Commandsæ›´å¿«:</p>
<ul>
<li>æ¯å¸§éƒ½éœ€è¦æ£€æŸ¥ä¸€äº›ä¸œè¥¿,Commandsåªæ˜¯æ—¶ä¸æ—¶ç”¨åˆ°</li>
</ul>
<p>eg: æ•Œäººæ²¡hpäº†,å°±è¦é”€æ¯å®ä½“;å®šæ—¶å™¨åˆ°äº†éœ€è¦æ„é€ /é”€æ¯å®ä½“;ä¾æ®æ¸¸æˆé€»è¾‘å¢åˆ UIå…ƒç´ .</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="direct-world-access"><a class="header" href="#direct-world-access">Direct World Access</a></h1>
<p>(This page is WIP)</p>
<hr />
<p>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.World.html"><code>World</code></a> is where Bevy ECS stores all data and associated metadata. It
keeps track of <a href="programming//programming/res.html">resources</a>, <a href="programming//programming/intro-data.html#entities--components">entities and components</a>.</p>
<p>Typically, the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.App.html"><code>App</code></a>'s runner will run all <a href="programming//programming/schedules.html">schedules</a> (which,
in turn, run their <a href="programming//programming/systems.html">systems</a>) on the main world. Regular
<a href="programming//programming/systems.html">systems</a> are limited in what data they can access from the world,
by their <a href="programming//builtins.html#systemparams">system parameter types</a>.  Operations that
manipulate the world itself are only done indirectly using
<a href="programming//programming/commands.html"><code>Commands</code></a>. This is how most typical Bevy user code behaves.</p>
<p>However, there are also ways you can get full direct access to the world, which
gives you full control and freedom to do anything with any data stored in the
Bevy ECS:</p>
<ul>
<li><a href="programming//programming/exclusive.html">Exclusive systems</a></li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impls</li>
<li>Via the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.App.html"><code>App</code></a> <a href="programming//programming/app-builder.html">builder</a></li>
<li>Manually created <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.World.html"><code>World</code></a>s for purposes like <a href="programming//patterns/system-tests.html">tests</a> or scenes</li>
<li><a href="programming//programming/commands.html#custom-commands">Custom Commands</a></li>
</ul>
<p>Direct world access lets you do things like:</p>
<ul>
<li>Freely spawn/despawn entities, insert/remove resources, etc., taking effect immediately
(no delay like when using <a href="programming//programming/commands.html"><code>Commands</code></a> from a regular <a href="programming//programming/systems.html">system</a>)</li>
<li>Access any component, entities, and resources you want</li>
<li>Manually run arbitrary systems or schedules</li>
</ul>
<p>This is especially useful if you want to do things that do not fit within
Bevy's typical execution model/flow of just running systems once every frame.</p>
<p>With direct world access, you can implement custom control flow, like
looping some systems multiple times, selecting different systems to run in
different circumstances, exporting/importing data from files like scenes or
game saves, â€¦</p>
<p>bevyå°†ECSçš„æ•°æ®å­˜å‚¨åœ¨worldä¸­,åŒ…æ‹¬:èµ„æº/å®ä½“/ç»„ä»¶.</p>
<p>é€šå¸¸appçš„æ‰€æœ‰è°ƒåº¦éƒ½è·‘åœ¨ä¸»worldä¸­,æ™®é€šsystemé€šè¿‡systemå‚æ•°ç±»å‹è·‘åœ¨æŒ‡å®šworldä¸­,
å¤§éƒ¨åˆ†ä»£ç éƒ½æ˜¯é€šè¿‡Commandsé—´æ¥ç»´æŠ¤world.</p>
<p>ç›´æ¥ç»´æŠ¤worldçš„å‡ ç§é€”å¾„å¦‚ä¸‹:</p>
<ul>
<li>ç‹¬å system</li>
<li>FromWorldçš„å®ç°</li>
<li>app</li>
<li>ä¸ºç‰¹æ®Šç›®çš„æ‰‹åŠ¨åˆ›å»ºçš„world(eg:æµ‹è¯•/åœºæ™¯)</li>
<li>è‡ªå®šä¹‰Commands</li>
</ul>
<p>ç›´æ¥è®¿é—®worldå¯ä»¥åšä»¥ä¸‹å‡ ç§äº‹:</p>
<ul>
<li>è‡ªç”±çš„æ„é€ /é”€æ¯å®ä½“;è‡ªç”±çš„å¢åˆ èµ„æºç­‰,éƒ½æ˜¯ç«‹é©¬ç”Ÿæ•ˆ</li>
<li>è®¿é—®ä»»æ„ç»„ä»¶/å®ä½“/èµ„æº</li>
<li>æ‰‹åŠ¨æ‰§è¡Œä»»æ„system/è°ƒåº¦</li>
</ul>
<p>å¦‚æœåœ¨æ¯å¸§çš„æ‰§è¡Œè°ƒåº¦ä¸Š,bevyå†…ç½®çš„è°ƒåº¦æœºåˆ¶ä¸æ»¡è¶³éœ€æ±‚,é‚£ä¹ˆç›´æ¥è®¿é—®worldæ˜¯ä¸€ç§é€‰æ‹©.</p>
<p>ç›´æ¥è®¿é—®worldæ„å‘³ç€å¯ä»¥å®ç°è‡ªå®šä¹‰é€»è¾‘æµ,eg:å¾ªç¯systemå¤šæ¬¡,
ä¸åŒçš„ç¯å¢ƒé€‰æ‹©ä¸åŒçš„system,æ¸¸æˆæˆ–åœºæ™¯çš„å¯¼å…¥/å¯¼å‡º.</p>
<h2 id="working-with-the-world"><a class="header" href="#working-with-the-world">Working with the <code>World</code></a></h2>
<p>Here are some ways that you can make use of the direct world access APIs.</p>
<h3 id="systemstate"><a class="header" href="#systemstate"><code>SystemState</code></a></h3>
<p>The easiest way to do things is using a <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>.</p>
<p>This is a type that "imitates a system", behaving the same way as a
<a href="programming//programming/systems.html">system</a> with various parameters would. All the same behaviors like
<a href="programming//programming/queries.html">queries</a>, <a href="programming//programming/change-detection.html">change detection</a>, and even
<a href="programming//programming/commands.html"><code>Commands</code></a> are available. You can use any <a href="programming//builtins.html#systemparams">system
params</a>.</p>
<p>It also tracks any persistent state, used for things like <a href="programming//programming/change-detection.html">change
detection</a> or caching to improve performance. Therefore,
if you plan on reusing the same <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> multiple times, you should store
it somewhere, rather than creating a new one every time. Every time you call
<code>.get(world)</code>, it behaves like another "run" of a system.</p>
<p>If you are using <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, you can choose when you want to apply them to the
world. You need to manually call <code>.apply(world)</code> on the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>, to
apply them.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<p>è®¿é—®worldæœ€å¸¸è§çš„æ‰‹æ³•æ˜¯<code>SystemState</code>,ç”¨æ³•å’Œæ™®é€šçš„systemç±»ä¼¼,èƒ½å®ç°çš„åŠŸèƒ½ä¹Ÿç±»ä¼¼.</p>
<p>å¯ä»¥è·Ÿè¸ªæŒä¹…åŒ–çš„çŠ¶æ€,è¿™ç‚¹å¯ç”¨äº<code>å˜æ›´æ£€æµ‹</code>æˆ–ç¼“å­˜(æé«˜æ€§èƒ½).
å¦‚æœè¦å¤šæ¬¡é‡ç”¨åŒä¸€SystemState,å°±åº”è¯¥è€ƒè™‘æŒä¹…åŒ–,é¿å…æ¯æ¬¡æ‰§è¡Œéƒ½ç”Ÿæˆä¸€ä¸ªæ–°çš„.</p>
<h3 id="running-a-system"><a class="header" href="#running-a-system">Running a System</a></h3>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<h3 id="running-a-schedule"><a class="header" href="#running-a-schedule">Running a Schedule</a></h3>
<p>If you want to run many systems (a common use-case is
<a href="programming//patterns/system-tests.html">testing</a>), the easiest way is to construct an impromptu
<a href="programming//programming/schedules.html">schedule</a>. This way you reuse all the scheduling logic that Bevy
normally does when running systems. They will run with multithreading, etc.</p>
<p>This is also useful if you want custom control flow. For example, Bevy's
<a href="programming//programming/states.html">states</a> and <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> abstractions
are implemented just like this! There is an exclusive system that can contain
loops, if/else branching, etc. to implement fancy algorithms and run entire
schedules of systems as appropriate!</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<p>å¦‚æœè¦è¿è¡Œå¤šä¸ªsystem(eg:æµ‹è¯•ç”¨ä¾‹),æœ€ç®€å•çš„æ–¹å¼æ˜¯æ„é€ ä¸€ä¸ªè°ƒåº¦,å…¶ä»–åœ°æ–¹èƒ½é‡ç”¨.</p>
<p>è‹¥è¦å®ç°è‡ªå®šä¹‰æ§åˆ¶æµ,è°ƒåº¦ä¹Ÿæ˜¯éå¸¸æœ‰ç”¨çš„,bevyçš„å›ºå®šæ—¶é—´æˆ³å°±æ˜¯è¿™æ ·å®ç°çš„.</p>
<h3 id="navigating-by-metadata"><a class="header" href="#navigating-by-metadata">Navigating by Metadata</a></h3>
<p>The world contains a lot of metadata that allows navigating all the data
efficiently, such as information about all the stored components, entities,
archeypes.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<p>worldåŒ…å«äº†å¾ˆå¤šå…ƒæ•°æ®,è¿™ä¸ªå…ƒæ•°æ®ä¹‹é—´æœ‰å…³è”,å¯ä»¥æ–¹ä¾¿åšåˆ°å¯¼èˆª,
eg:å­˜å‚¨æ‰€æœ‰å®ä½“/ç»„ä»¶/åŸå‹çš„ä¿¡æ¯.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="schedules-2"><a class="header" href="#schedules-2">Schedules</a></h1>
<p>See also: <a href="programming//programming/intro-code.html">ECS Intro: Your Code</a>, for a general overview
of Bevy's scheduling framework.</p>
<hr />
<p>All <a href="programming//programming/systems.html">systems</a> to be run by Bevy are contained and organized using
schedules. A schedule is a collection of systems, with metadata for how they
should run, and an associated executor algorithm to run the systems.</p>
<p>A Bevy app has many different schedules for different purposes, to run them
in different situations.</p>
<p>bevyè¿è¡Œçš„systemæ˜¯æ”¾åœ¨å®¹å™¨ä¸­çš„(è°ƒåº¦schedule),ä¹Ÿæ˜¯ç”±è°ƒåº¦ç»„ç»‡çš„.
è°ƒåº¦è¿˜åŒ…å«systemçš„å…ƒæ•°æ®(è¿è¡Œæ¡ä»¶/é¡ºåºçº¦æŸ,systemé›†åˆ).</p>
<h2 id="scheduling-systems"><a class="header" href="#scheduling-systems">Scheduling Systems</a></h2>
<p>If you want a <a href="programming//programming/systems.html">system</a> to be run by Bevy, you need to add it to a
schedule via the <a href="programming//programming/app-builder.html">app builder</a>. Writing a new Rust function and
forgetting to add it / register it with Bevy is a common mistake.</p>
<p>Whenever you add a system, you specify what schedule to put it in:</p>
<pre><code class="language-rust no_run noplayground">// add something to the Update schedule (runs every frame)
app.add_systems(Update, camera_movement);

// add something to the Startup schedule (runs once at app startup)
app.add_systems(Startup, setup_camera);</code></pre>
<p>appæ·»åŠ systeméƒ½æ˜¯å°†systemä¸¢åˆ°æŸä¸ªè°ƒåº¦ä¸­,å¦‚æœå¿˜äº†å°±ä¼šå‡ºç°systemæ— æ•ˆæœçš„ç°è±¡.</p>
<h3 id="per-system-configuration"><a class="header" href="#per-system-configuration">Per-System Configuration</a></h3>
<p>You can add metadata to your systems, to affect how they will be run.</p>
<p>This can include:</p>
<ul>
<li><a href="programming//programming/run-criteria.html">Run Conditions</a> to control if a system should run</li>
<li><a href="programming//programming/system-order.html">Ordering Dependencies</a>, if a system should run before/after specific other systems in the same schedule</li>
<li><a href="programming//programming/system-sets.html">System Sets</a> to group systems together, so common configuration can be applied to all of them</li>
</ul>
<p>When the schedule runs, the executor algorithm will honor all of this
configuration when determining if a system is ready to run. A system is ready
when all of the following is true:</p>
<ul>
<li>No other currently-running system is accessing any of the same data mutably (as per the <a href="programming//builtins.html#systemparams">system parameters</a>)</li>
<li>All of the systems <a href="programming//programming/system-order.html">ordered</a> "before" have finished or have been skipped due to run conditions</li>
<li>The system's <a href="programming//programming/run-criteria.html">run conditions</a> all return true</li>
</ul>
<p>When a system becomes ready, it will be run on an available CPU thread. Systems
run in a non-deterministic order by default! A system might run at different
times every frame. If you care about its relationship to other systems, add
<a href="programming//programming/system-order.html">ordering dependencies</a>.</p>
<p>æ¯ä¸ªsysteméƒ½å¯ä»¥è¿›è¡Œé…ç½®,åŒ…æ‹¬(è¿è¡Œæ¡ä»¶/é¡ºåºçº¦æŸ/systemé›†åˆ).
å…¶ä¸­systemé›†åˆæ˜¯systemç»„,ä¸€äº›é€šç”¨é…ç½®éƒ½å¯ä»¥åº”ç”¨åˆ°ç»„å†…æ¯ä¸ªsystem.</p>
<p>bevyæ‰§è¡Œä¸€ä¸ªsystemçš„å‰ææ¡ä»¶:</p>
<ul>
<li>systemè¦†ç›–çš„mutæ•°æ®,æ²¡æœ‰ä¾èµ–åŒæ ·æ•°æ®çš„systemæ­£åœ¨è¿è¡Œ</li>
<li>beforeé¡ºåºçš„systeméƒ½è¿è¡Œå®Œäº†æˆ–å› ä¸ºè¿è¡Œæ¡ä»¶è·³è¿‡äº†</li>
<li>è¿è¡Œæ¡ä»¶ä¸ºtrue</li>
</ul>
<p>å¹¶è¡Œæ‰§è¡Œçš„systemçš„ä¹‹é—´çš„é¡ºåºä¸æ˜¯ç¡®å®šçš„,æ¯å¸§éƒ½å¯èƒ½ä¸ä¸€æ ·.</p>
<h3 id="dynamically-addingremoving-systems"><a class="header" href="#dynamically-addingremoving-systems">Dynamically Adding/Removing Systems</a></h3>
<p>Bevy's schedules do not (yet?) support adding and removing systems at runtime.
You need to configure everything ahead of time.</p>
<p>You should add all systems you might want to run, and then control them using
<a href="programming//programming/run-criteria.html">run conditions</a>. That is the mechanism for disabling them if they
shouldn't run.</p>
<p>systemçš„åŠ¨æ€å¢åˆ ,ç›®å‰è¿˜ä¸æ”¯æŒ.</p>
<h2 id="bevys-app-structure"><a class="header" href="#bevys-app-structure">Bevy's App Structure</a></h2>
<p>Bevy has three primary/foundational schedules: <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a>.
There are also other schedules, which are managed and run within <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>.</p>
<p>In a normal Bevy app, the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>+<a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a>+<a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a> schedules are run repeatedly
in a loop. Together, they produce one frame of your game. Every time <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>
runs, it runs a sequence of other schedules. On its first run, it also first
runs a sequence of "startup" schedules.</p>
<p>Most Bevy users only have to deal with the sub-schedules of <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>.
<a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a> are only relevant to graphics developers who want to
develop new/custom rendering features for the engine. This page is only focused
on <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>. If you want to learn more about <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Extract.html"><code>Extract</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/render/struct.Render.html"><code>Render</code></a>, <a href="programming//gpu/intro.html">see
this page about Bevy's rendering architecture</a>.</p>
<p>bevyçš„ä¸‰ä¸ªåŸºç¡€è°ƒåº¦:Main/Extract/Render,åˆ†åˆ«æ˜¯ä¸»è°ƒåº¦/å¤–éƒ¨è°ƒåº¦/æ¸²æŸ“è°ƒåº¦.
å¤–éƒ¨è°ƒåº¦è´Ÿè´£å°†worldæ•°æ®æ‹·è´åˆ°æ¸²æŸ“è°ƒåº¦ä¸­.æ¸²æŸ“è°ƒåº¦å’Œä¸‹å¸§çš„ä¸»è°ƒåº¦å¹¶è¡Œæ‰§è¡Œ.</p>
<p>å¤§éƒ¨åˆ†æ¸¸æˆåªéœ€è¦åœ¨Mainè°ƒåº¦ä¸­æ·»åŠ systemé€»è¾‘å³å¯.</p>
<h2 id="the-main-schedule"><a class="header" href="#the-main-schedule">The Main Schedule</a></h2>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> is where all the application logic runs. It is a sort of meta-schedule,
whose job is to run other schedules in a specific order. You should not add any
custom systems directly to <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>. You should add your systems to the various
schedules managed by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a>.</p>
<p>Bevy provides the following schedules, to organize all the systems:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.First.html"><code>First</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.RunFixedMainLoop.html"><code>RunFixedMainLoop</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Last.html"><code>Last</code></a>
<ul>
<li>These schedules are run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> every time it runs</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreStartup.html"><code>PreStartup</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Startup.html"><code>Startup</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostStartup.html"><code>PostStartup</code></a>
<ul>
<li>These schedules are run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> once, the first time it runs</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a>
<ul>
<li>The <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> equivalent of the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> schedule.</li>
<li>Run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.RunFixedMainLoop.html"><code>RunFixedMainLoop</code></a> as many times as needed, to catch up to the fixed timestep interval.</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedFirst.html"><code>FixedFirst</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPreUpdate.html"><code>FixedPreUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedPostUpdate.html"><code>FixedPostUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedLast.html"><code>FixedLast</code></a>
<ul>
<li>The <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> equivalents of the <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> sub-schedules.</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter(â€¦)</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit(â€¦)</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition(â€¦)</code></a>
<ul>
<li>These schedules are run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a> on <a href="programming//programming/states.html">state</a> changes</li>
</ul>
</li>
</ul>
<p>The intended places for most user systems (your game logic) are <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>,
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Startup.html"><code>Startup</code></a>, and the <a href="programming//programming/states.html">state</a> transition schedules.</p>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> is for your usual game logic that should run every frame. <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Startup.html"><code>Startup</code></a> is
useful to perform initialization tasks, before the first normal frame update
loop. <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> is if you want to use a <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<p>The other schedules are intended for engine-internal functionality. Splitting
them like that ensures that Bevy's internal engine systems will run correctly
with respect to your systems, without any configuration on your part.
Remember: Bevy's internals are implemented using ordinary systems
and ECS, just like your own stuff!</p>
<p>If you are developing plugins to be used by other people, you might be
interested in adding functionality to <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> (or the <code>Fixed</code>
equivalents), so it can run alongside other "engine systems". Also consider
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreStartup.html"><code>PreStartup</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostStartup.html"><code>PostStartup</code></a> if you have startup systems that should be
separated from your users' startup systems.</p>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.First.html"><code>First</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Last.html"><code>Last</code></a> exist only for special edge cases, if you really need to
ensure something runs before/after <em>everything</em> else, including all the normal
"engine-internal" code.</p>
<p>Mainè°ƒåº¦æ˜¯å…¥å£,ä¼šç®¡ç†å…¶ä»–è°ƒåº¦,æˆ‘ä»¬æ·»åŠ çš„systemåªèƒ½æ·»åŠ åˆ°å…¶ç®¡ç†çš„è°ƒåº¦ä¸­.
è°ƒåº¦é¡ºåºå’Œç»„ç»‡æ–¹å¼å¯ä»¥å‚çœ‹(0),éƒ½æ˜¯ä¸€æ ·çš„å†…å®¹.</p>
<p>Startupåšåˆå§‹åŒ–,Updateåšæ¯å¸§é€»è¾‘,FixedUpdateé€‚åˆè‡ªå®šä¹‰é—´éš”çš„é€»è¾‘.</p>
<p>å…¶ä»–è°ƒåº¦æ˜¯å¼•æ“å†…éƒ¨çš„åŠŸèƒ½,bevyç»´æŠ¤,æˆ‘ä»¬ä¸éœ€è¦é…ç½®,
bevyåœ¨å®ç°å†…éƒ¨è°ƒåº¦æ—¶,ç”¨çš„æ˜¯ECS+systemçš„é¡ºåºçº¦æŸ,æˆ‘ä»¬è‡ªå®šä¹‰é€»è¾‘ä¹Ÿæ˜¯è¿™ä¸ªå¥—è·¯.</p>
<p>å¦‚æœè¦å¼€å‘æ’ä»¶,PreUpdate/PostUpdateå°±èƒ½ç”¨ä¸Šäº†.</p>
<p>First/Lastå°±æ˜¯ç‰¹æ®Šåœºæ™¯ä¸‹æ‰ä½¿ç”¨,eg:åœ¨Updateä¹‹å‰/ä¹‹åè¦ç¡®ä¿æŸä¸ªå¯¹è±¡çš„çŠ¶æ€.
å¼•æ“å†…éƒ¨çš„ä»£ç å°±ç”¨åˆ°äº†è¿™ä¸¤ä¸ªè°ƒåº¦.</p>
<h2 id="configuring-schedules"><a class="header" href="#configuring-schedules">Configuring Schedules</a></h2>
<p>Bevy also offers some features that can be configured at the schedule level.</p>
<h3 id="single-threaded-schedules"><a class="header" href="#single-threaded-schedules">Single-Threaded Schedules</a></h3>
<p>If you consider multi-threading to not be working well for you, for whatever reason,
you can disable it per-schedule.</p>
<p>In a single-threaded schedule, systems will run one at a time, on the main
thread.  However, the same "readiness" algorithm is still applied and so
systems can run in an undefined order. You should still specify <a href="programming//programming/system-order.html">ordering
dependencies</a> where you need determinism.</p>
<pre><code class="language-rust no_run noplayground">// Make FixedUpdate run single-threaded
app.edit_schedule(FixedUpdate, |schedule| {
    schedule.set_executor_kind(ExecutorKind::SingleThreaded);

    // or alternatively: Simple will apply Commands after every system
    schedule.set_executor_kind(ExecutorKind::Simple);
});</code></pre>
<p>å¦‚æœå¤šçº¿ç¨‹ä¸åˆé€‚,å¯ä»¥è€ƒè™‘å•çº¿ç¨‹,åœ¨ä¸»çº¿ç¨‹ä¸€æ¬¡åªè¿è¡Œä¸€ä¸ªsystem.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExecutorKind {
    SingleThreaded, // é€‚åˆwasm.
    Simple, // å’Œå•çº¿ç¨‹ç±»ä¼¼,åªä¸è¿‡ä¼šåœ¨æ¯ä¸ªsystemæ‰§è¡Œå®Œåç«‹é©¬æ‰§è¡Œå»¶æ—¶ä»»åŠ¡(eg:Commands).
    MultiThreaded, // å¸¦çº¿ç¨‹æ± çš„.
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ambiguity-detection"><a class="header" href="#ambiguity-detection">Ambiguity Detection</a></h3>
<p>The Ambiguity Detector is an optional Bevy feature that can help you debug issues
related to non-determinism.</p>
<pre><code class="language-rust no_run noplayground">// Enable ambiguity warnings for the Update schedule
app.edit_schedule(Update, |schedule| {
    schedule.set_build_settings(ScheduleBuildSettings {
        ambiguity_detection: LogLevel::Warn,
        ..default()
    });
});</code></pre>
<p>It will print warnings for any combination of systems where at least one of
them accesses some piece of data (<a href="programming//programming/res.html">resource</a> or
<a href="programming//programming/ec.html#components">component</a>) mutably, but the others don't have explicit
<a href="programming//programming/system-order.html">ordering dependencies</a> on that system.</p>
<p>Such situations might indicate a bug, because you don't know if the systems that
read the data would run before or after the system that mutates the data.</p>
<p>It is up to you to decide if you care about this, on a case-by-case basis.</p>
<p>äºŒä¹‰æ€§æ£€æŸ¥,è¿™æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼€å…³,å¼€å¯åå¯å¯¹ä¸ç¡®å®šçš„æ‰§è¡Œé¡ºåºè¿›è¡ŒäºŒä¹‰æ€§æ£€æŸ¥,
å¸¸ç”¨åœ¨debugæ¨¡å¼.å¦‚æœæœ‰æ•°æ®ç«äº‰,è¿™ä¸ªå°±å¯ä»¥å¾ˆå¥½æ£€æµ‹å‡ºæ¥,æ·»åŠ é¡ºåºçº¦æŸå³å¯.
è¿™ä¸ªæ£€æŸ¥å¯èƒ½ä¼šè¯¯æŠ¥,å› ä¸ºå®é™…ä¸Šçš„æ¸¸æˆé€»è¾‘å¯èƒ½ä¼šç¡®ä¿ä¸¤ä¸ªsystemä¸ä¼šäº§ç”Ÿç«äº‰.</p>
<hr />
<p>ä¸ºå•¥rustç¼–è¯‘å™¨è¦åšçš„äº‹éœ€è¦bevyæ¥åš,å› ä¸ºbevyçš„systemè°ƒåº¦æ˜¯è‡ªå®šä¹‰çš„,
rustç¼–è¯‘å™¨å¹¶ä¸èƒ½å¾ˆå¥½çš„å‘æŒ¥ä½œç”¨.</p>
<h3 id="deferred-application"><a class="header" href="#deferred-application">Deferred Application</a></h3>
<p>Normally, Bevy will automatically manage where <a href="programming//programming/commands.html">Commands</a>
and other deferred operations get applied. If <a href="programming//programming/systems.html">systems</a> have
<a href="programming//programming/system-order.html">ordering dependencies</a> on one another, Bevy will make
sure to apply any pending deferred operations from the first system before
the second system runs.</p>
<p>If you would like to disable this automatic behavior and manually manage
the sync points, you can do that.</p>
<pre><code class="language-rust no_run noplayground">app.edit_schedule(Update, |schedule| {
    schedule.set_build_settings(ScheduleBuildSettings {
        auto_insert_apply_deferred: false,
        ..default()
    });
});</code></pre>
<p>Now, to manually create sync points, add special [<code>apply_deferred</code>] systems
where you like them:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(
    Update,
    apply_deferred
        .after(MyGameplaySet)
        .before(MyUiSet)
);
app.add_systems(Update, (
    (
        system_a,
        apply_deferred,
        system_b,
    ).chain(),
));</code></pre>
<p>bevyä¼šè‡ªåŠ¨ç®¡ç†å¦‚Commandsä¹‹ç±»çš„å»¶æ—¶æ“ä½œ,å¦‚æœä¸¤ä¸ªsystemä¹‹é—´æœ‰é¡ºåºä¾èµ–,
ç¬¬ä¸€ä¸ªsystemæ‰§è¡Œå®Œåä¼šç«‹é©¬æ‰§è¡Œå»¶æ—¶æ“ä½œ,å†æ‰§è¡Œç¬¬äºŒä¸ªsystem.</p>
<p>å½“ç„¶ä¹Ÿå¯ä»¥ç¦æ­¢è¿™ç§è‡ªåŠ¨è¡Œä¸º,æ”¹ä¸ºæ‰‹åŠ¨ç®¡ç†åŒæ­¥æœºåˆ¶.
<code>auto_insert_apply_deferred = false</code>,å¹¶ä¸”ä½¿ç”¨<code>apply_deferred</code>æ‰‹åŠ¨ç®¡ç†åŒæ­¥æœºåˆ¶.</p>
<h2 id="main-schedule-configuration"><a class="header" href="#main-schedule-configuration">Main Schedule Configuration</a></h2>
<p>The order of schedules to be run by <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Main.html"><code>Main</code></a> every frame is configured in the
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> <a href="programming//programming/res.html">resource</a>. For advanced use cases, if Bevy's
predefined schedules don't work for your needs, you can change it.</p>
<p>Mainè°ƒåº¦çš„é¡ºåºä¹Ÿå¯ä»¥ä¿®æ”¹.éœ€è¦ç”¨åˆ°è¿™ç§åœºæ™¯çš„åº”è¯¥æ˜¯éå¸¸å°‘,
ä½†bevyè¿˜æ˜¯æä¾›äº†å„ç§æ‰©å±•æ¥ä¸°å¯Œå…¶çµæ´»æ€§,ç†æƒ³ä¸»ä¹‰åˆæŠ¬å¤´äº†.</p>
<h3 id="creating-a-new-custom-schedule"><a class="header" href="#creating-a-new-custom-schedule">Creating a New Custom Schedule</a></h3>
<p>As an example, let's say we want to add an additional schedule, that runs every
frame (like <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>), but runs before <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<p>First, we need to create a name/label for our new schedule, by creating a Rust
type (a <code>struct</code> or <code>enum</code>) and deriving <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/trait.ScheduleLabel.html"><code>ScheduleLabel</code></a> + an assortment of
required standard Rust traits.</p>
<pre><code class="language-rust no_run noplayground">#[derive(ScheduleLabel, Debug, Clone, PartialEq, Eq, Hash)]
struct PrepareUpdate;</code></pre>
<p>Now, we can init the schedule in the <a href="programming//programming/app-builder.html">app</a>, add it to
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> to make it run every frame where we like it, and add some
systems to it!</p>
<pre><code class="language-rust no_run noplayground">// Ensure the schedule has been created
// (this is technically optional; Bevy will auto-init
// the schedule the first time it is used)
app.init_schedule(PrepareUpdate);

// Add it to the MainScheduleOrder so it runs every frame
// as part of the Main schedule. We want our PrepareUpdate
// schedule to run after StateTransition.
app.world.resource_mut::&lt;MainScheduleOrder&gt;()
    .insert_after(StateTransition, PrepareUpdate);

// Now we can add some systems to our new schedule!
app.add_systems(PrepareUpdate, (
    my_weird_custom_stuff,
));</code></pre>
<p>bevyæä¾›çš„é»˜è®¤è°ƒåº¦é¡ºåºå¤§éƒ¨åˆ†åœºåˆæ˜¯å¤Ÿç”¨äº†,å¦‚æœä¸å¤Ÿå¯ä»¥æ–°å»ºè°ƒåº¦,
å¹¶æ’åˆ°æŸä¸ªè°ƒåº¦çš„å‰å.</p>
<p>Mainè°ƒåº¦é¡ºåºæ˜¯å­˜åœ¨ä¸€ä¸ªèµ„æºä¸­çš„,<code>MainScheduleOrder</code>,
æ‰€æœ‰è°ƒåº¦çš„é¡ºåºå…¶å®æ˜¯æ”¾åœ¨Vecä¸­çš„,æ’å…¥ä¸€ä¸ªæ–°çš„å¹¶ä¸éš¾.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MainScheduleOrder {
    pub labels: Vec&lt;Interned&lt;dyn ScheduleLabel&gt;&gt;,
    pub startup_labels: Vec&lt;Interned&lt;dyn ScheduleLabel&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="system-order-of-execution"><a class="header" href="#system-order-of-execution">System Order of Execution</a></h1>
<p>Bevy's scheduling algorithm is designed to deliver maximum performance by
running as many <a href="programming//programming/systems.html">systems</a> as possible in parallel across the
available CPU threads.</p>
<p>This is possible when the systems do not conflict over the data they need
to access. However, when a system needs to have mutable (exclusive) access
to a piece of data, other systems that need to access the same data cannot
be run at the same time. Bevy determines all of this information from the
system's function signature (the types of the parameters it takes).</p>
<p>In such situations, the order is <em>nondeterministic</em> by default. Bevy takes
no regard for when each system will run, and the order could even change
every frame!</p>
<p>systemçš„æ‰§è¡Œé¡ºåº</p>
<p>bevyçš„è°ƒåº¦ç®—æ³•è®¾è®¡çš„ç›®æ ‡æ˜¯æœ€é«˜æ€§èƒ½,åšæ³•æ˜¯è®©æ¯ä¸ªCPUçº¿ç¨‹éƒ½è¿è¡Œä¸€ä¸ªsystem.
å¦‚æœsystemè®¿é—®çš„æ•°æ®ä¸å­˜åœ¨å†²çª,é‚£ä¹ˆè°ƒåº¦ç®—æ³•å°±è¾¾åˆ°äº†ç›®çš„.
å¦‚æœä¸€ä¸ªsystemå¯¹æŸä¸ªæ•°æ®æ˜¯å¯å˜è®¿é—®æ—¶(ç‹¬å ),é‚£ä¹ˆå…¶ä»–ä¾èµ–æ­¤æ•°æ®çš„systemå°±ä¸èƒ½å¹¶è¡Œæ‰§è¡Œ,
è‡³äºsystemè¦è®¿é—®å“ªäº›æ•°æ®,bevyå¯ä»¥ä»å‡½æ•°ç­¾åä¸­äº†è§£ä¿¡æ¯.</p>
<p>é»˜è®¤æƒ…å†µä¸‹(æœªæŒ‡å®šé¡ºåº),é¡ºåºæ˜¯ä¸ç¡®å®šçš„,bevyä¹Ÿä¸ä¼šä¸»åŠ¨å¹²é¢„,æ¯å¸§systemçš„æ‰§è¡Œé¡ºåºéƒ½å¯èƒ½ä¸åŒ.</p>
<p>å³è¦æé«˜æ€§èƒ½,åˆè¦é¿å…æ•°æ®ç«äº‰å¯¼è‡´çš„æ€§èƒ½æŸå¤±,æœ€å¥½çš„æ–¹å¼å°±æ˜¯æ˜ç¡®systemçš„æ‰§è¡Œé¡ºåº.</p>
<h2 id="explicit-system-ordering"><a class="header" href="#explicit-system-ordering">Explicit System Ordering</a></h2>
<p>If a specific system must always run before or after some other systems,
you can add ordering constraints:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
let mut app = App::new();
app.add_systems(Update, (
    enemy_movement,
    input_handling,

    player_movement
        // `player_movement` must always run before `enemy_movement`
        .before(enemy_movement)
        // `player_movement` must always run after `input_handling`
        .after(input_handling),

    // order doesn't matter for some systems:
    particle_effects,
    npc_behaviors,

    // we can apply ordering to multiple systems at once:
    (
        spawn_monsters,
        spawn_zombies,
        spawn_spiders,
    ).before(enemy_movement),

    // to run a sequence of systems in order, use `.chain()`
    // (this is just syntax sugar to automatically add
    // before/after dependencies between the systems in the tuple)
    (
        spawn_particles,
        animate_particles,
        debug_particle_statistics,
    ).chain()
));</code></pre>
<p>When you have a lot of systems that you need to configure, it can start to
get unwieldy. Consider using <a href="programming//programming/system-sets.html">system sets</a> to organize and
manage your systems.</p>
<p>æ˜¾ç¤ºæŒ‡å®šsystemä¹‹é—´çš„é¡ºåº.
æœ‰æ—¶æœ‰å¾ˆå¤šsystemè¦é…ç½®é¡ºåº,å°±å¯ä»¥ä½¿ç”¨systemé›†åˆæ¥ç»„ç»‡å’Œç®¡ç†.</p>
<h2 id="does-it-even-matter"><a class="header" href="#does-it-even-matter">Does it even matter?</a></h2>
<p>In many cases, you don't need to worry about this.</p>
<p>However, sometimes you need to rely on specific systems to run in a particular
order. For example:</p>
<ul>
<li>Maybe the logic you wrote in one of your systems needs any modifications
done to that data by another system to always happen first?</li>
<li>One system needs to receive <a href="programming//programming/events.html">events</a> sent by another system.</li>
<li>You are using <a href="programming//programming/change-detection.html">change detection</a>.</li>
</ul>
<p>In such situations, systems running in the wrong order typically causes
their behavior to be delayed until the next frame. In rare cases, depending
on your game logic, it may even result in more serious logic bugs!</p>
<p>It is up to you to decide if this is important.</p>
<p>With many things in typical games, such as juicy visual effects, it probably
doesn't matter if they get delayed by a frame. It might not be worthwhile
to bother with it. If you don't care, leaving the order ambiguous may also
result in better performance.</p>
<p>On the other hand, for things like handling the player input controls,
this would result in annoying lag or worse, so you should probably fix it.</p>
<p>å¤§éƒ¨åˆ†åœºæ™¯ä¸‹éƒ½ä¸éœ€è¦å…³å¿ƒé¡ºåº,å°‘éƒ¨åˆ†åœºæ™¯ä¸‹æ‰éœ€è¦é¡ºåºçº¦æŸ:</p>
<ul>
<li>ä¸€ä¸ªsystemä¿®æ”¹æ•°æ®,å¦ä¸€ä¸ªsystemä½¿ç”¨,ä¸”æœ‰å…ˆåé¡ºåº</li>
<li>ä¸€ä¸ªsystemæ¥æ”¶çš„äº‹ä»¶æ˜¯å¦ä¸€ä¸ªsystemå‘å‡ºçš„</li>
<li>å˜æ›´æ£€æµ‹</li>
</ul>
<p>ä¸Šé¢è¿™äº›éƒ½æ˜¯å®é™…çš„æ¸¸æˆé€»è¾‘å†³å®šçš„,å‡ºç°å¼‚å¸¸å°±æ„å‘³ç€bug.</p>
<p>å¤§éƒ¨åˆ†è§†è§‰ç‰¹æ•ˆéƒ½ä¸å…³å¿ƒä¸€å¸§ä¸­çš„å»¶æ—¶,å¹¶å‘æ‰§è¡Œç”šè‡³è¿˜èƒ½æå‡æ€§èƒ½.</p>
<h2 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h2>
<p>If you have multiple systems mutually depending on each other, then it is
clearly impossible to resolve the situation completely like that.</p>
<p>You should try to redesign your game to avoid such situations, or just accept
the consequences. You can at least make it behave predictably, using explicit
ordering to specify the order you prefer.</p>
<p>å¾ªç¯ä¾èµ–.éœ€è¦é‡æ–°æ¶‰åŠæ¸¸æˆé€»è¾‘,æˆ–ç›´æ¥ä¸ç®¡.
ä¸è¿‡æ¸¸æˆå¼€å‘çš„åº•çº¿æ˜¯è¿è¡Œç»“æœå¯é¢„æµ‹.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="run-conditions-4"><a class="header" href="#run-conditions-4">Run Conditions</a></h1>
<p>Run Conditions (RC) are a mechanism for controlling if Bevy should run specific
<a href="programming//programming/systems.html">systems</a>, at runtime. This allows you to enable/disable systems
on-demand, so that they only run sometimes.</p>
<p>RCs are Rust functions that return a value of type <code>bool</code>. They can accept
any <a href="programming//builtins.html#systemparams">system parameters</a>, like a normal system, but
they must all be read-only (immutable).</p>
<pre><code class="language-rust no_run noplayground">fn run_if_player_alive(
    q_player: Query&lt;&amp;Health, With&lt;Player&gt;&gt;,
) -&gt; bool {
    let health = q_player.single();
    health.hp &gt; 0.0
}

fn run_if_connected(
    mode: Res&lt;MyMultiplayerMode&gt;,
    session: Res&lt;MyNetworkSession&gt;,
) -&gt; bool
{
    *mode != MyMultiplayerMode::Local &amp;&amp; session.is_connected()
}

fn run_if_enemies_present(
    q_enemies: Query&lt;(), With&lt;Enemy&gt;&gt;,
) -&gt; bool {
    !q_enemies.is_empty()
}</code></pre>
<p>RCs can be applied to individual <a href="programming//programming/systems.html">systems</a> or to entire <a href="programming//programming/system-sets.html">system
sets</a>.</p>
<pre><code class="language-rust no_run noplayground">app.configure_sets(Update,
    MyPlayerSet
        .run_if(run_if_player_alive)
);

app.add_systems(Update, (
    player_input,
    player_movement,
    player_alert_enemies
        .run_if(run_if_enemies_present)
).in_set(MyPlayerSet));

app.add_systems(Update,
    manage_multiplayer_server
        .run_if(run_if_connected)
);</code></pre>
<p>When applied to a single <a href="programming//programming/systems.html">system</a>, Bevy will evaluate the RC at
the last moment, right before the system would otherwise be ready to run. If
you add the same RC to multiple systems, Bevy will evaluate it separately
for each one.</p>
<p>When applied to a <a href="programming//programming/system-sets.html">set</a>, the run condition will only be
evaluated once, before Bevy runs any system from the set, and if it returns
false, the entire set will be skipped.</p>
<p>Any given system can be governed by any number of RCs. You can add multiple RCs
to one system, and it will also inherit the RCs of any <a href="programming//programming/system-sets.html">sets</a>
it belongs to. Bevy will evaluate all the RCs, and the system will only run
if all of them return <code>true</code>.</p>
<p>è¿è¡Œæ¡ä»¶,æ˜¯è¿”å›boolçš„ä¸€ä¸ªå‡½æ•°,å…¥å‚å¯ä»¥æ˜¯systemå‚æ•°(åªè¯»).</p>
<p>è¿è¡Œæ¡ä»¶åº”ç”¨å¯¹è±¡å¯ä»¥æ˜¯å•ä¸ªsystem,æˆ–systemé›†åˆ.</p>
<p>å•systemæœ‰è¿è¡Œæ¡ä»¶æ—¶,è¿è¡Œæ¡ä»¶åœ¨systemä¹‹å‰æ‰§è¡Œ.å¦‚æœå¤šä¸ªsysteméƒ½æœ‰åŒæ ·çš„è¿è¡Œæ¡ä»¶,
bevyä¼šå•ç‹¬è®¡ç®—è¿è¡Œæ¡ä»¶.</p>
<p>systemé›†åˆæœ‰è¿è¡Œæ¡ä»¶æ—¶,è¿è¡Œæ¡ä»¶åªä¼šè®¡ç®—ä¸€æ¬¡.</p>
<p>systemå¯ä»¥æœ‰å¤šä¸ªè¿è¡Œæ¡ä»¶,è¿˜å¯ä»¥ä»ä»»ä½•systemé›†åˆä¸­ç»§æ‰¿è¿è¡Œæ¡ä»¶.</p>
<h2 id="common-conditions"><a class="header" href="#common-conditions">Common Conditions</a></h2>
<p>Bevy provides some built-in RCs for some common scenarios, that you can just
apply to your systems:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/common_conditions/index.html">ECS common conditions</a>:
<ul>
<li>For checking <a href="programming//programming/states.html">states</a>, <a href="programming//programming/res.html">resource</a> values and <a href="programming//programming/change-detection.html">changes</a>, <a href="programming//programming/events.html">events</a>, if <a href="programming//programming/intro-data.html">entities</a> with specific <a href="programming//programming/ec.html#components">components</a> exist, etc...</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/input/common_conditions/index.html">Input common conditions</a>:
<ul>
<li>For <a href="programming//input.html">input handling</a>: running on key/button press/release.</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/time/common_conditions/index.html">Time common conditions</a>:
<ul>
<li>For controlling systems based on <a href="programming//fundamentals/time.html">time</a>: repeating on a timer, running after a delay, etc...</li>
</ul>
</li>
</ul>
<p>bevyå†…ç½®äº†ä¸€äº›å¸¸ç”¨çš„æ¡ä»¶:</p>
<ul>
<li>ECSå¸¸ç”¨æ¡ä»¶,çŠ¶æ€,èµ„æºå€¼(çš„å˜åŒ–),äº‹ä»¶,å®ä½“æ˜¯å¦åŒ…å«æŒ‡å®šç»„ä»¶ç­‰ç­‰</li>
<li>è¾“å…¥å¸¸ç”¨æ¡ä»¶,æŸé”®æ˜¯å¦æŒ‰ä¸‹/é‡Šæ”¾</li>
<li>æ—¶é—´å¸¸ç”¨æ¡ä»¶,åŸºäºå®šæ—¶å™¨çš„æ§åˆ¶,å®šæ—¶å™¨/å»¶æ—¶åˆ°è¾¾</li>
</ul>
<h2 id="known-pitfalls-1"><a class="header" href="#known-pitfalls-1">Known Pitfalls</a></h2>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run every frame
update, you can miss some events that are sent while the receiving systems
are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<p>å·²çŸ¥é™·é˜±.äº‹ä»¶æ¥æ”¶+æ¡ä»¶è¿è¡Œå¯èƒ½ä¼šå¯¼è‡´é—æ¼äº‹ä»¶,åº”å¯¹æ–¹æ³•æ˜¯è‡ªå®šä¹‰äº‹ä»¶æ¶ˆæ¯æ¸…ç†ç­–ç•¥.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="system-sets"><a class="header" href="#system-sets">System Sets</a></h1>
<p>System Sets allow you to easily apply common properties to multiple systems,
such as <a href="programming//programming/system-order.html">ordering</a> and <a href="programming//programming/run-criteria.html">run conditions</a>.</p>
<p>Anything you add to the set will automatically be applied to all systems
belonging to the set.</p>
<p>A system can belong to multiple different sets, and will inherit all the
properties from all of them. You can also add additional properties to
individual systems.</p>
<p>All of this combined gives you a lot of flexibility and control over how your systems run.</p>
<p>åœ¨é¡ºåºçº¦æŸå’Œæ¡ä»¶è¿è¡Œä¸­éƒ½æ¶‰åŠåˆ°systemé›†åˆ,è¿™ä¸ªé›†åˆæ˜¯ç»„ç»‡systemçš„ä¸€ç§åº•å±‚æ¬¡æ–¹å¼.</p>
<p>ä»»ä½•æ–°å¢åˆ°é›†åˆä¸­çš„systeméƒ½ä¼šè‡ªåŠ¨åº”ç”¨é›†åˆçš„çº¦æŸ.</p>
<p>ä¸€ä¸ªsystemå¯ä»¥å±äºå¤šä¸ªset,ç»§æ‰¿æ‰€æœ‰setçš„çº¦æŸ.ä¹Ÿå¯å•ç‹¬ä¸ºsystemæ·»åŠ å±æ€§.</p>
<h2 id="anonymous-sets"><a class="header" href="#anonymous-sets">Anonymous Sets</a></h2>
<p>The simplest kind of system set is when you just <a href="programming//programming/app-builder.html">add</a> a tuple of
multiple <a href="programming//programming/systems.html">systems</a> using <code>.add_systems</code>.</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(
    Update,
    (
        system_a,
        system_b,
        system_c
    )
    .run_if(common_run_condition)
    .after(some_system)
);</code></pre>
<p>This syntax is useful when you just want to apply some common configuration to
multiple systems.</p>
<p>åŒ¿åé›†åˆ,ç”¨å…ƒç»„.</p>
<h2 id="named-sets"><a class="header" href="#named-sets">Named Sets</a></h2>
<p>This is the more formal and powerful way to use system sets.</p>
<p>You can create a Rust type (<code>struct</code> or <code>enum</code>) to serve as a label/identifier,
so you can refer to the set from different places.</p>
<p>For a single set, create an empty <code>struct</code>. If you need to create multiple
related sets, create an <code>enum</code>. Every variant of the <code>enum</code> is a separate system
set.</p>
<p>You need to derive <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/trait.SystemSet.html"><code>SystemSet</code></a> + an assortment of required standard Rust traits:</p>
<pre><code class="language-rust no_run noplayground">#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
struct MyAudioSet;

#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
struct MyInputSet;

#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
enum MyInputKindSet {
    Touch,
    Mouse,
    Gamepad,
}

#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
enum MyGameplaySet {
    Player,
    Enemies,
}</code></pre>
<p>Now, you can apply the set to your systems using <code>.in_set()</code>:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(Update, (
    (
        play_music
            .run_if(music_enabled),
        play_ui_sounds,
    ).in_set(MyAudioSet),
    (
        player_movement,
        player_animation
            .after(player_movement),
        player_level_up,
        player_footsteps
            .in_set(MyAudioSet),
    ).in_set(MyGameplaySet::Player),
    (
        enemy_movement,
        enemy_ai
            .after(MyGameplaySet::Player),
        enemy_footsteps
            .in_set(MyAudioSet),
    ).in_set(MyGameplaySet::Enemies),
    (
        (
            mouse_cursor_tracking,
            mouse_clicks,
        ).in_set(MyInputKindSet::Mouse),
        (
            gamepad_cursor_tracking,
            gamepad_buttons,
        ).in_set(MyInputKindSet::Gamepad),
        (
            touch_gestures,
        ).in_set(MyInputKindSet::Touch),
    ).in_set(MyInputSet),
));</code></pre>
<p>You can add <a href="programming//programming/run-criteria.html">run conditions</a> and <a href="programming//programming/system-order.html">ordering
dependencies</a> on your set using <code>.configure_sets</code>:</p>
<pre><code class="language-rust no_run noplayground">app.configure_sets(Update, (
    MyAudioSet
        .run_if(audio_enabled),
    MyGameplaySet::Player
        .after(MyInputSet)
        .run_if(player_is_alive),
    MyGameplaySet::Enemies
        .run_if(enemies_present),
    MyInputKindSet::Touch
        .run_if(touchscreen_enabled),
    MyInputKindSet::Mouse
        .run_if(mouse_enabled),
    MyInputKindSet::Gamepad
        .run_if(gamepad_connected),
));</code></pre>
<p>The main use case of named system sets is for logical organization, so that you
can manage your systems and refer to the whole group.</p>
<p>Some examples:</p>
<ul>
<li>A set for all your audio-related systems, so you can disable them all if sound is muted.</li>
<li>A set for all your touchscreen input systems, so you can disable them all if there is no touchscreen.</li>
<li>A set for all your input handling systems, so you can order them to run before gameplay systems.</li>
<li>A set for all your gameplay systems, so that they only run during the in-game <a href="programming//programming/states.html">state</a>.</li>
</ul>
<p>å…·åé›†åˆ.ä½¿ç”¨SystemSetç‰¹å‹æŒ‡æ˜,å…·ä½“ç±»å‹å¯ä»¥æ˜¯struct/enum.
æšä¸¾çš„å•ä¸ªç±»å‹éƒ½æ˜¯ä¸€ä¸ªæ–°çš„systemé›†åˆ.</p>
<p><code>in_set</code>å°†systemé›†åˆçš„systemæå–å‡ºæ¥,æ‰å¹³åŒ–å¤„ç†åæ·»åŠ åˆ°æŸä¸ªåœ°æ–¹.
è¿è¡Œæ¡ä»¶å’Œé¡ºåºçº¦æŸçš„åº”ç”¨å’Œæ™®é€šsystemæ²¡å•¥åŒºåˆ«.</p>
<p>å…·åé›†åˆçš„ä¸»è¦ç”¨é€”æ˜¯ç»„ç»‡.ä¸‹é¢éƒ½æ˜¯ä½¿ç”¨ä¾‹å­:</p>
<ul>
<li>æ‰€æœ‰audioç›¸å…³çš„systemæ”¾ä¸€èµ·,è¿™æ ·æ–¹ä¾¿å®ç°mute</li>
<li>è§¦æ‘¸å±è¾“å…¥çš„sytemæ”¾ä¸€èµ·,æ–¹ä¾¿å¯¹è§¦æ‘¸å±è¾“å…¥åŠŸèƒ½è¿›è¡Œå¼€å…³</li>
<li>æ‰€æœ‰çš„è¾“å…¥å¤„ç†systemæ”¾ä¸€èµ·,è¿™æ ·å¯ä»¥è®©å¥¹ä»¬åœ¨æ¸¸æˆé€»è¾‘å‰é¢è¿è¡Œ</li>
<li>æ‰€æœ‰æ¸¸æˆé€»è¾‘æ”¾åœ¨ä¸€èµ·,è¿™æ ·å¯ä»¥ç¡®ä¿åªåœ¨æŸä¸ªæ¸¸æˆçŠ¶æ€æ—¶è¿è¡Œ</li>
</ul>
<h3 id="with-plugins"><a class="header" href="#with-plugins">With Plugins</a></h3>
<p>Named sets are also very useful together with <a href="programming//programming/plugins.html">plugins</a>. When you are writing
a plugin, you can expose (make <code>pub</code>) some system set types, to allow users of your
plugin to control how things in your plugin run, or how their things run in relation to
your plugin. This way, you don't have to expose any of your individual systems.</p>
<p>Some examples:</p>
<ul>
<li>You are making a physics plugin. Make a set for your whole plugin, so your users can
easily order their systems to run before/after physics. They can also easily control
whether your physics runs at all, by adding an extra run condition to your set.</li>
<li>You are using plugins for internal organization in your project. You have an UI plugin.
Create a system set for the systems that need to update UI state from gameplay state,
so that you can easily add ordering dependencies between UI and gameplay. Other plugins
/ places in your code now don't need to know about the internals of your UI plugin.</li>
</ul>
<p>å…·åé›†åˆå’Œæ’ä»¶é…åˆä½¿ç”¨.å¯¹äºæŸä¸ªæ’ä»¶åŒ…çš„æä¾›è€…æ¥è¯´,
å¯¹å¤–æš´éœ²systemé›†åˆå¥½è¿‡å•ç‹¬æš´éœ²å¤šä¸ªsytem.</p>
<h2 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h2>
<p>WARNING! System set configuration is stored <em>per-<a href="programming//programming/schedules.html">schedule</a>!</em> Notice how
we had to specify <code>.configure_sets(Update, ...)</code>. It can be very easy to configure your
sets once and then just assume you can use them anywhere, but that is not true.</p>
<p>If you try to use them in a <a href="programming//programming/schedules.html">schedule</a> other than the one
where you configured them, your code will compile and run (Bevy silently
initializes the sets in each schedule), but will not work correctly, as they
will not have any of your configurations.</p>
<p>Some common scenarios where this can occur:</p>
<ul>
<li>You configure your set in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> and try to also use it in <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a>, or vice versa.</li>
<li>You try to use your sets in the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit</code></a> schedules of various <a href="programming//programming/states.html">app states</a>.</li>
<li>You add a system to <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a> or <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>.</li>
</ul>
<p>å¸¸è§é™·é˜±.</p>
<p>é…ç½®çš„systemé›†åˆå­˜å‚¨åœ¨è°ƒåº¦ä¸­,è¿™ä¸ªé›†åˆå¯ä»¥ç”¨åœ¨å¤šä¸ªè°ƒåº¦ä¸­,
è¦æ³¨æ„:æ¯ä¸ªè°ƒåº¦ä¸­çš„é›†åˆéƒ½éœ€è¦é…ç½®,ä¸ç„¶å°±æ˜¯é»˜è®¤é…ç½®.</p>
<p>å¦‚æœé›†åˆç”¨åœ¨Updateä¸­,åˆç”¨åœ¨FixedUpdateä¸­,è®°ä½ä¸¤ä¸ªåœ°æ–¹éƒ½éœ€è¦é…ç½®.
å¦‚æœOnEnter/OnExitè°ƒåº¦ä¸­éƒ½ç”¨åˆ°æŸä¸ªé›†åˆ,è®°ä½ä¸¤ä¸ªåœ°æ–¹éƒ½éœ€è¦é…ç½®.
ä¸€ä¸ªsystemæ·»åŠ åˆ°PostUpdate/PreUpdateè°ƒåº¦ä¸­,è®°ä½ä¸¤ä¸ªåœ°æ–¹éƒ½éœ€è¦é…ç½®.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="states"><a class="header" href="#states">States</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/state.rs"><code>state</code></a>.</p>
<hr />
<p>States allow you to structure the runtime "flow" of your app.</p>
<p>This is how you can implement things like:</p>
<ul>
<li>A menu screen or a loading screen</li>
<li>Pausing / unpausing the game</li>
<li>Different game modes</li>
<li>â€¦</li>
</ul>
<p>In every state, you can have different <a href="programming//programming/systems.html">systems</a> running. You
can also add setup and cleanup systems to run when entering or exiting a state.</p>
<hr />
<p>To use states, first define an <code>enum</code> type. You need to derive
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/trait.States.html"><code>States</code></a> + an assortment of required standard Rust traits:</p>
<pre><code class="language-rust no_run noplayground">#[derive(States, Debug, Clone, PartialEq, Eq, Hash)]
enum MyAppState {
    LoadingScreen,
    MainMenu,
    InGame,
}

#[derive(States, Default, Debug, Clone, PartialEq, Eq, Hash)]
enum MyGameModeState {
    #[default]
    NotInGame,
    Singleplayer,
    Multiplayer,
}

#[derive(States, Default, Debug, Clone, PartialEq, Eq, Hash)]
enum MyPausedState {
    #[default]
    Paused,
    Running,
}</code></pre>
<p>Note: you can have multiple orthogonal states! Create multiple types
if you want to track multiple things independently!</p>
<p>You then need to register the state type(s) in the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">// Specify the initial value:
app.insert_state(MyAppState::LoadingScreen);

// Or use the default (if the type impls Default):
app.init_state::&lt;MyGameModeState&gt;();
app.init_state::&lt;MyPausedState&gt;();</code></pre>
<p>åœ¨Bevyæ¸¸æˆå¼•æ“ä¸­,Statesæ˜¯ä¸€ä¸ªå…³é”®æ¦‚å¿µ,ç”¨äºç®¡ç†æ¸¸æˆçš„ä¸åŒé˜¶æ®µæˆ–æ¨¡å¼.
ä¾‹å¦‚,ä¸€ä¸ªæ¸¸æˆå¯èƒ½æœ‰ä¸»èœå•/æ¸¸æˆè¿›è¡Œä¸­/æš‚åœç­‰ä¸åŒçŠ¶æ€.
Bevyä¸­çš„çŠ¶æ€ç®¡ç†ç³»ç»Ÿå…è®¸å¼€å‘è€…åœ¨è¿™äº›ä¸åŒçŠ¶æ€ä¹‹é—´è¿›è¡Œåˆ‡æ¢,
å¹¶å®šä¹‰åœ¨æ¯ä¸ªçŠ¶æ€ä¸‹åº”æ‰§è¡Œå“ªäº›ç³»ç»Ÿå’Œé€»è¾‘.</p>
<p>æ¯ä¸ªçŠ¶æ€éƒ½å¯ä»¥åˆ’åˆ†ä¸åŒçš„systemè¿›è¡Œè¿è¡Œ(è¿™ä¸ªå¾ˆå®¹æ˜“åŠåˆ°,
åªéœ€è¦åœ¨systemå…¥å£åˆ¤æ–­æ˜¯ä¸æ˜¯åŒ¹é…çš„çŠ¶æ€å³å¯,ä¸åŒ¹é…å°±ç»“æŸ).</p>
<p>çŠ¶æ€éœ€è¦ç”±enumå®šä¹‰,æŒ‡å®šå®ç°äº†Statesç‰¹å‹.</p>
<p>å¯ä»¥ä½¿ç”¨å¤šä¸ªæ­£äº¤çŠ¶æ€,å¯å®Œæˆæ›´åŠ ä¸°å¯Œçš„éœ€æ±‚.
çŠ¶æ€éœ€è¦åœ¨appä¸­æ³¨å†Œ.</p>
<h2 id="running-different-systems-for-different-states"><a class="header" href="#running-different-systems-for-different-states">Running Different Systems for Different States</a></h2>
<p>If you want some <a href="programming//programming/systems.html">systems</a> to only run in specific states,
Bevy offers an <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/common_conditions/fn.in_state.html"><code>in_state</code></a> <a href="programming//programming/run-criteria.html">run condition</a>. Add it
to your systems. You probably want to create <a href="programming//programming/system-sets.html">system sets</a>
to help you group many systems and control them at once.</p>
<pre><code class="language-rust no_run noplayground">// configure some system sets to help us manage our systems
// (note: it is per-schedule, so we also need it for FixedUpdate
// if we plan to use fixed timestep)
app.configure_sets(Update, (
    MyMainMenuSet
        .run_if(in_state(MyAppState::MainMenu)),
    MyGameplaySet
        // note: you can check for a combination of different states
        .run_if(in_state(MyAppState::InGame))
        .run_if(in_state(MyPausedState::Running)),
));
app.configure_sets(FixedUpdate, (
    // configure the same set here, so we can use it in both
    // FixedUpdate and Update
    MyGameplaySet
        .run_if(in_state(MyAppState::InGame))
        .run_if(in_state(MyPausedState::Running)),
    // configure a bunch of different sets only for FixedUpdate
    MySingleplayerSet
        // inherit configuration from MyGameplaySet and add extras
        .in_set(MyGameplaySet)
        .run_if(in_state(MyGameModeState::Singleplayer)),
    MyMultiplayerSet
        .in_set(MyGameplaySet)
        .run_if(in_state(MyGameModeState::Multiplayer)),
));

// now we can easily add our different systems
app.add_systems(Update, (
    update_loading_progress_bar
        .run_if(in_state(MyAppState::LoadingScreen)),
    (
        handle_main_menu_ui_input,
        play_main_menu_sounds,
    ).in_set(MyMainMenuSet),
    (
        camera_movement,
        play_game_music,
    ).in_set(MyGameplaySet),
));
app.add_systems(FixedUpdate, (
    (
        player_movement,
        enemy_ai,
    ).in_set(MySingleplayerSet),
    (
        player_net_sync,
        enemy_net_sync,
    ).in_set(MyMultiplayerSet),
));

// of course, if we need some global (state-independent)
// setup to run on app startup, we can still use Startup as usual
app.add_systems(Startup, (
    load_settings,
    setup_window_icon,
));</code></pre>
<p>Bevy also creates special <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter</code></a>, <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit</code></a>,
and <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition</code></a> <a href="programming//programming/schedules.html">schedules</a> for each
possible value of your state type. Use them to perform setup and cleanup for
specific states. Any systems you add to them will run once every time the state
is changed to/from the respective values.</p>
<pre><code class="language-rust no_run noplayground">// do the respective setup and cleanup on state transitions
app.add_systems(OnEnter(MyAppState::LoadingScreen), (
    start_load_assets,
    spawn_progress_bar,
));
app.add_systems(OnExit(MyAppState::LoadingScreen), (
    despawn_loading_screen,
));
app.add_systems(OnEnter(MyAppState::MainMenu), (
    setup_main_menu_ui,
    setup_main_menu_camera,
));
app.add_systems(OnExit(MyAppState::MainMenu), (
    despawn_main_menu,
));
app.add_systems(OnEnter(MyAppState::InGame), (
    spawn_game_map,
    setup_game_camera,
    spawn_enemies,
));
app.add_systems(OnEnter(MyGameModeState::Singleplayer), (
    setup_singleplayer,
));
app.add_systems(OnEnter(MyGameModeState::Multiplayer), (
    setup_multiplayer,
));
// ...</code></pre>
<p>å“ªäº›systemåœ¨å“ªäº›çŠ¶æ€ä¸‹è¿è¡Œ,å‡ºäº†ä¸Šé¢æåˆ°çš„ç®€å•æ–¹æ³•,è¿˜å¯ä»¥ä½¿ç”¨è¿è¡Œæ¡ä»¶å®ç°.
bevyæä¾›äº†ä¸€ä¸ª<code>in_state</code>çš„è¿è¡Œæ¡ä»¶.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn in_state&lt;S: States&gt;(state: S) -&gt; impl FnMut(Option&lt;Res&lt;State&lt;S&gt;&gt;&gt;) -&gt; bool + Clone {
    move |current_state: Option&lt;Res&lt;State&lt;S&gt;&gt;&gt;| match current_state {
        Some(current_state) =&gt; *current_state == state,
        None =&gt; false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>çœ‹ä¸Šé¢çš„æºç ,å®ç°åŸç†å’Œä¸Šé¢æåˆ°çš„ç®€å•æ–¹æ³•æ˜¯ä¸€æ ·çš„,è¿™é‡Œæ˜¯è¿è¡Œæ¡ä»¶å®ç°çš„.</p>
<p>å¯¹æ¯”çœ‹ä¸Šé¢çš„ä¾‹å­, systemé›†åˆå’ŒçŠ¶æ€ç»“åˆ,å¨åŠ›éå¸¸å·¨å¤§.</p>
<p>OnEnter/OnExit/OnTransition, æ˜¯çŠ¶æ€è¿›å…¥/é€€å‡º/æ”¹å˜æ—¶çš„è°ƒåº¦.
åˆ©ç”¨è¿™å‡ ä¸ªè°ƒåº¦å¯ä»¥è·Ÿè¸ªçŠ¶æ€çš„åˆ‡æ¢.</p>
<h3 id="with-plugins-1"><a class="header" href="#with-plugins-1">With Plugins</a></h3>
<p>This can also be useful with <a href="programming//programming/plugins.html">Plugins</a>. You can set up all the state
types for your project in one place, and then your different plugins can just add
their systems to the relevant states.</p>
<p>You can also make plugins that are configurable, so that it is possible to specify
what state they should add their systems to:</p>
<pre><code class="language-rust no_run noplayground">pub struct MyPlugin&lt;S: States&gt; {
    pub state: S,
}

impl&lt;S: States&gt; Plugin for MyPlugin&lt;S&gt; {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_systems(Update, (
            my_plugin_system1,
            my_plugin_system2,
            // ...
        ).run_if(in_state(self.state.clone())));
    }
}</code></pre>
<p>Now you can configure the plugin when adding it to the app:</p>
<pre><code class="language-rust no_run noplayground">app.add_plugins(MyPlugin {
    state: MyAppState::InGame,
});</code></pre>
<p>When you are just using <a href="programming//programming/plugins.html">plugins</a> to help with internal
organization of your project, and you know what systems should go into each
state, you probably don't need to bother with making the plugin configurable
as shown above. Just hardcode the states / add things to the correct states
directly.</p>
<p>æ’ä»¶ä¹Ÿå¯ä»¥æ ¹æ®çŠ¶æ€æ¥åˆ†ç±»,eg:æ’ä»¶ä¸­æ·»åŠ çš„systemåªç»‘å®šåˆ°æŸå‡ ä¸ªçŠ¶æ€.
å¦‚æœåªç”¨æ’ä»¶æ¥ç»„ç»‡é¡¹ç›®,åœ¨æ’ä»¶ä¸­å¯¹çŠ¶æ€è¿›è¡Œç¡¬ç¼–ç ä¼šæ›´åŠ ç®€å•.
è¿™é‡Œçš„ç¡¬ç¼–ç æ˜¯ç›¸å¯¹äºä¸Šé¢çš„ä¾‹å­æ¥è¯´çš„(ä¸Šé¢çš„ä¾‹å­æ˜¯é€šè¿‡å‚æ•°ä¼ é€’çŠ¶æ€).</p>
<p>æ€»çš„æ¥è¯´,ç»„ç»‡é¡¹ç›®çš„æœ‰:</p>
<ul>
<li>æ’ä»¶</li>
<li>è°ƒåº¦</li>
<li>system é›†åˆ</li>
<li>çŠ¶æ€</li>
</ul>
<h2 id="controlling-states"><a class="header" href="#controlling-states">Controlling States</a></h2>
<p>Inside of systems, you can check the current state using the
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.State.html"><code>State&lt;T&gt;</code></a> <a href="programming//programming/res.html">resource</a>:</p>
<pre><code class="language-rust no_run noplayground">fn debug_current_gamemode_state(state: Res&lt;State&lt;MyGameModeState&gt;&gt;) {
    eprintln!("Current state: {:?}", state.get());
}</code></pre>
<p>To change to another state, you can use the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.NextState.html"><code>NextState&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn toggle_pause_game(
    state: Res&lt;State&lt;MyPausedState&gt;&gt;,
    mut next_state: ResMut&lt;NextState&lt;MyPausedState&gt;&gt;,
) {
    match state.get() {
        MyPausedState::Paused =&gt; next_state.set(MyPausedState::Running),
        MyPausedState::Running =&gt; next_state.set(MyPausedState::Paused),
    }
}

// if you have multiple states that must be set correctly,
// don't forget to manage them all
fn new_game_multiplayer(
    mut next_app: ResMut&lt;NextState&lt;MyAppState&gt;&gt;,
    mut next_mode: ResMut&lt;NextState&lt;MyGameModeState&gt;&gt;,
) {
    next_app.set(MyAppState::InGame);
    next_mode.set(MyGameModeState::Multiplayer);
}</code></pre>
<p>This will queue up state transitions to be performed during the next frame
update cycle.</p>
<p>çŠ¶æ€åœ¨è¿è¡Œé€»è¾‘ä¸­ä¼šå˜åŒ–,ä¹Ÿå°±æ˜¯è¯´systemä¸­ä¼šæ”¹å˜çŠ¶æ€.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait States: 'static + Send + Sync + Clone + PartialEq + Eq + Hash + Debug {
    const DEPENDENCY_DEPTH: usize = 1usize;
}

#[derive(Resource, Debug)]
#[cfg_attr(
    feature = "bevy_reflect",
    derive(bevy_reflect::Reflect),
    reflect(Resource)
)]
pub struct State&lt;S: States&gt;(pub(crate) S);
<span class="boring">}</span></code></pre></pre>
<p>å¯¹çŠ¶æ€çš„æ§åˆ¶:</p>
<ul>
<li><code>Res&lt;State&lt;MyGameModeState&gt;&gt;.get()</code>è·å–çŠ¶æ€</li>
<li><code>ResMut&lt;NextState&lt;MyPausedState&gt;&gt;.set()</code>è®¾ç½®çŠ¶æ€</li>
</ul>
<p>å¯¹çŠ¶æ€çš„å˜æ›´,ä¼šæ”¾åœ¨é˜Ÿåˆ—ä¸­,åœ¨ä¸‹å¸§çš„æ›´æ–°å¾ªç¯(StateTransitionè°ƒåº¦)ä¸­è¿›è¡Œæ›´æ–°.</p>
<h2 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h2>
<p>Every frame update, a <a href="programming//programming/schedules.html">schedule</a> called
<a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a> runs. There, Bevy will check if
any new state is queued up in <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.NextState.html"><code>NextState&lt;T&gt;</code></a> and perform
the transition for you.</p>
<p>The transition involves several steps:</p>
<ul>
<li>A <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.StateTransitionEvent.html"><code>StateTransitionEvent</code></a> <a href="programming//programming/events.html">event</a> is sent.</li>
<li>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit(old_state)</code></a> <a href="programming//programming/schedules.html">schedule</a> is run.</li>
<li>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition { from: old_state, to: new_state }</code></a> <a href="programming//programming/schedules.html">schedule</a> is run.</li>
<li>The <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter(new_state)</code></a> <a href="programming//programming/schedules.html">schedule</a> is run.</li>
</ul>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.StateTransitionEvent.html"><code>StateTransitionEvent</code></a> is useful in any <a href="programming//programming/systems.html">systems</a> that run
regardless of state, but want to know if a transition has occurred. You can use
it to detect state transitions.</p>
<p>The <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a> <a href="programming//programming/schedules.html">schedule</a> runs after <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a> (which
contains Bevy engine internals), but before <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedMain.html"><code>FixedMain</code></a> (<a href="programming//fundamentals/fixed-timestep.html">fixed
timestep</a>) and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a>, where your game's
<a href="programming//programming/systems.html">systems</a> usually live.</p>
<p>Therefore, state transitions happen before your game logic for the current frame.</p>
<p>If doing state transitions once per frame is not enough for you, you can add
additional transition points, by adding Bevy's <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/fn.apply_state_transition.html"><code>apply_state_transition</code></a>
<a href="programming//programming/systems.html">system</a> wherever you like.</p>
<pre><code class="language-rust no_run noplayground">// Example: also do state transitions for MyPausedState
// before MyGameplaySet on each fixed timestep run
app.add_systems(
    FixedUpdate,
    apply_state_transition::&lt;MyPausedState&gt;
        .before(MyGameplaySet)
);</code></pre>
<p>çŠ¶æ€å˜æ›´: åœ¨å½“å‰å¸§çš„StateTransitionä¸­æ‰§è¡Œä¸Šå¸§<code>NextState&lt;T&gt;</code>çš„çŠ¶æ€å˜æ›´,å…·ä½“ä¸º:</p>
<ul>
<li>å‘é€StateTransitionEventäº‹ä»¶</li>
<li>OnExit(æ—§çŠ¶æ€)è°ƒåº¦è¿è¡Œ</li>
<li>OnTransition(from:æ—§çŠ¶æ€,to:æ–°çŠ¶æ€)è°ƒåº¦æ‰§è¡Œ</li>
<li>OnEnter(æ–°çŠ¶æ€)è°ƒåº¦è¿è¡Œ</li>
</ul>
<p>StateTransitionè°ƒåº¦åœ¨PreUpdateä¹‹åæ‰§è¡Œ(PreUpdateæ˜¯bevyå†…éƒ¨å¼•æ“åŒ…å«çš„),
åœ¨FixedMainå’ŒUpdateä¹‹å‰.å› æ­¤çŠ¶æ€å˜æ›´æ˜¯åœ¨å½“å‰å¸§é€»è¾‘ä¹‹å‰å‘ç”Ÿçš„.</p>
<p>å¦‚æœæ¯å¸§å‘ç”Ÿä¸€æ¬¡çŠ¶æ€å˜æ›´è¿˜ä¸å¤Ÿ,å¯ä»¥ä½¿ç”¨<code>apply_state_transition</code> system
æ·»åŠ å˜æ›´ç‚¹.</p>
<h2 id="known-pitfalls-2"><a class="header" href="#known-pitfalls-2">Known Pitfalls</a></h2>
<h3 id="system-set-configuration-is-per-schedule"><a class="header" href="#system-set-configuration-is-per-schedule">System set configuration is per-schedule!</a></h3>
<p>This is the same general caveat that applies any time you configure <a href="programming//programming/system-sets.html">system sets</a>.</p>
<p>Note that <code>app.configure_sets()</code> is <em>per-<a href="programming//programming/schedules.html">schedule</a>!</em> If you configure some sets
in one <a href="programming//programming/schedules.html">schedule</a>, that configuration does not carry over to other schedules.</p>
<p>Because states are so schedule-heavy, you have to be especially careful. Don't assume
that just because you configured a set, you can use it anywhere.</p>
<p>For example, your sets from <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.Update.html"><code>Update</code></a> and <a href="https://docs.rs/bevy/0.13.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> will not work in
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit</code></a> for your various state transitions.</p>
<p>systemé›†åˆè¦å¯¹æ¯ä¸ªè°ƒåº¦éƒ½åšé…ç½®,å°‘äº†é…ç½®å°±ä¼šå‡ºé—®é¢˜.</p>
<h3 id="events-3"><a class="header" href="#events-3">Events</a></h3>
<p>This is the same general caveat that applies to any <a href="programming//programming/systems.html">systems</a> with
<a href="programming//programming/run-criteria.html">run conditions</a> that want to receive <a href="programming//programming/events.html">events</a>.</p>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run all the time, such
as during a pause state, you will miss any events that are sent while when
the receiving systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<p>æ¥æ”¶äº‹ä»¶+è¿è¡Œæ¡ä»¶,ä¼šå¯¼è‡´æ¼äº‹ä»¶,è§£å†³æ–¹æ³•æ˜¯è‡ªå®šä¹‰äº‹ä»¶æ¸…ç†ç­–ç•¥,
æ‰‹åŠ¨ç»´æŠ¤ç›¸å…³äº‹ä»¶çš„ç”Ÿå‘½å‘¨æœŸ.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/component_change_detection.rs"><code>component_change_detection</code></a>.</p>
<hr />
<p>Bevy allows you to easily detect when data is changed. You can use this to
perform actions in response to changes.</p>
<p>One of the main use cases is optimization â€“ avoiding unnecessary work by
only doing it if the relevant data has changed. Another use case is triggering
special actions to occur on changes, like configuring something or sending
the data somewhere.</p>
<p>bevyæä¾›äº†å˜æ›´æ£€æµ‹,ä»¥ä¸‹åœºæ™¯ä¸‹ä¼šç”¨ä¸Š:</p>
<ul>
<li>ä¼˜åŒ–,åªåšå’Œå˜æ›´æ•°æ®ç›¸å…³çš„äº‹,ä¸åšæ— æ„ä¹‰çš„äº‹</li>
<li>å˜æ›´è§¦å‘æŸä¸ªåŠ¨ä½œ,eg:é…ç½®å˜æ›´</li>
</ul>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<p>You can make a <a href="programming//programming/queries.html">query</a> that only yields entities if specific
<a href="programming//programming/ec.html#components">components</a> on them have been modified.</p>
<p>Use <a href="programming//programming/queries.html#query-filters">query filters</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Added.html"><code>Added&lt;T&gt;</code></a>: detect new component instances
<ul>
<li>if the component was added to an existing entity</li>
<li>if a new entity with the component was spawned</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Changed.html"><code>Changed&lt;T&gt;</code></a>: detect component instances that have been changed
<ul>
<li>triggers when the component is mutated</li>
<li>also triggers if the component is newly-added (as per <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Added.html"><code>Added</code></a>)</li>
</ul>
</li>
</ul>
<p>(If you want to react to removals, see <a href="programming//programming/change-detection.html#removal-detection">removal
detection</a>. It works differently.)</p>
<pre><code class="language-rust no_run noplayground">/// Print the stats of friendly players when they change
fn debug_stats_change(
    query: Query&lt;
        // components
        (&amp;Health, &amp;PlayerXp),
        // filters
        (Without&lt;Enemy&gt;, Or&lt;(Changed&lt;Health&gt;, Changed&lt;PlayerXp&gt;)&gt;), 
    &gt;,
) {
    for (health, xp) in query.iter() {
        eprintln!(
            "hp: {}+{}, xp: {}",
            health.hp, health.extra, xp.0
        );
    }
}

/// detect new enemies and print their health
fn debug_new_hostiles(
    query: Query&lt;(Entity, &amp;Health), Added&lt;Enemy&gt;&gt;,
) {
    for (entity, health) in query.iter() {
        eprintln!("Entity {:?} is now an enemy! HP: {}", entity, health.hp);
    }
}</code></pre>
<p>ç»„ä»¶è¿‡æ»¤,èƒ½å°†æŸäº›ç»„ä»¶å˜æ›´äº†çš„å®ä½“å…¨éƒ¨queryå‡ºæ¥.</p>
<ul>
<li><code>Added&lt;T&gt;</code> æ£€æµ‹æ–°ç»„ä»¶å®ä¾‹
<ul>
<li>å·²æœ‰å®ä½“æ–°å¢ç»„ä»¶</li>
<li>æ„é€ ä¸€ä¸ªåŒ…å«ç»„ä»¶çš„å®ä½“</li>
</ul>
</li>
<li><code>Changed&lt;T&gt;</code> æ£€æµ‹ç»„ä»¶å®ä½“æ˜¯å¦æœ‰å˜æ›´
<ul>
<li>ç»„ä»¶è¢«ä¿®æ”¹è§¦å‘</li>
<li>ç»„ä»¶æ–°å¢è§¦å‘(è¿™æ¡ç­‰ä»·äºAdded<T>)</li>
</ul>
</li>
</ul>
<p>ç»„ä»¶åˆ é™¤è¿˜æœ‰<code>åˆ é™¤æ£€æµ‹</code>,å’Œå˜æ›´æ£€æµ‹çš„å®ç°æ–¹å¼æœ‰ç‚¹ä¸åŒ.</p>
<h3 id="checking"><a class="header" href="#checking">Checking</a></h3>
<p>If you want to access all the entities, as normal, regardless of if they have
been modified, but you just want to know if a component has been changed,
you can use special [<code>Ref&lt;T&gt;</code>] query parameters instead of <code>&amp;</code> for immutable access.</p>
<p>For mutable access, the change detection methods are always available (because
Bevy queries actually return a special <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/world/struct.Mut.html"><code>Mut&lt;T&gt;</code></a> type whenever you have <code>&amp;mut</code>
in the query).</p>
<pre><code class="language-rust no_run noplayground">/// Make sprites flash red on frames when the Health changes
fn debug_damage(
    mut query: Query&lt;(&amp;mut Sprite, Ref&lt;Health&gt;)&gt;,
) {
    for (mut sprite, health) in query.iter_mut() {
        // detect if the Health changed this frame
        if health.is_changed() {
            eprintln!("HP is: {}", health.hp);
            // we can also check if the sprite has been changed
            if !sprite.is_changed() {
                sprite.color = Color::RED;
            }
        }
    }
}</code></pre>
<p>bevyè¿˜æä¾›äº†ä¸€ç§æ–¹æ³•æ¥åˆ¤æ–­æŸä¸ªç»„ä»¶æ˜¯å¦æœ‰æ”¹å˜</p>
<ul>
<li>åªæŸ¥æ˜¯å¦æœ‰æ”¹å˜,æœ¬æ¬¡systemæ‰§è¡Œä¸æ”¹å˜ç»„ä»¶å€¼. <code>Ref&lt;T&gt;.is_changed()</code></li>
<li>æŸ¥æ˜¯å¦æœ‰æ”¹å˜,å¹¶åœ¨æœ¬æ¬¡systemè¿˜æ”¯æŒå˜æ›´ç»„ä»¶å€¼. <code>(&amp;mut T).is_changed()</code></li>
</ul>
<h2 id="resources-3"><a class="header" href="#resources-3">Resources</a></h2>
<p>For <a href="programming//programming/res.html">resources</a>, change detection is provided via methods on the
<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>/<a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a> system parameters.</p>
<pre><code class="language-rust no_run noplayground">fn check_res_changed(
    my_res: Res&lt;MyResource&gt;,
) {
    if my_res.is_changed() {
        // do something
    }
}

fn check_res_added(
    // use Option, not to panic if the resource doesn't exist yet
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists

        if my_res.is_added() {
            // it was just added
            // do something
        }
    }
}</code></pre>
<p>èµ„æºä¹Ÿæ”¯æŒå¢æ”¹æ£€æµ‹.<code>Res&lt;T&gt;.is_changed()</code>, <code>Option&lt;Res&lt;T&gt;&gt;.is_added()</code>.</p>
<h2 id="what-gets-detected"><a class="header" href="#what-gets-detected">What gets detected?</a></h2>
<p><a href="https://docs.rs/bevy/0.13.0/bevy/ecs/query/struct.Changed.html"><code>Changed</code></a> detection is triggered by <a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>. Simply accessing
<a href="programming//programming/ec.html#components">components</a> via a mutable <a href="programming//programming/queries.html">query</a>, or
<a href="programming//programming/res.html">resources</a> via <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>, without actually performing a <code>&amp;mut</code>
access, will <em>not</em> trigger it. This makes change detection quite accurate.</p>
<p>Note: if you call a Rust function that takes a <code>&amp;mut T</code> (mutable borrow),
that counts! It will trigger change detection even if the function does
not actually do any mutation. Be careful with helper functions!</p>
<p>Also, when you mutate a component, Bevy does not check if the new value
is actually different from the old value. It will always trigger the change
detection. If you want to avoid that, simply check it yourself:</p>
<pre><code class="language-rust no_run noplayground">fn update_player_xp(
    mut query: Query&lt;&amp;mut PlayerXp&gt;,
) {
    for mut xp in query.iter_mut() {
        let new_xp = maybe_lvl_up(&amp;xp);

        // avoid triggering change detection if the value is the same
        if new_xp != *xp {
            *xp = new_xp;
        }
    }
}</code></pre>
<p>Change detection works on a per-<a href="programming//programming/systems.html">system</a> granularity, and is
reliable. A system will detect changes only if it has not seen them before
(the changes happened since the last time it ran).</p>
<p>Unlike <a href="programming//programming/events.html">events</a>, you do <em>not</em> have to worry about missing changes
If your system only runs sometimes (such as when using <a href="programming//programming/states.html">states</a>
or <a href="programming//programming/run-criteria.html">run conditions</a>).</p>
<p><code>å˜æ›´æ£€æµ‹</code>æ˜¯ç”±<code>DerefMut</code>è§¦å‘çš„.</p>
<p>ç®€å•çš„è·å–å¯å˜ç»„ä»¶/èµ„æºå¹¶ä¸æ‰§è¡Œ&amp;mut è®¿é—®,æ˜¯ä¸ä¼šè§¦å‘å˜æ›´æ£€æµ‹çš„.</p>
<p>å¦‚æœæ˜¯rustå‡½æ•°æœ‰ä¸ª<code>&amp;mut T</code>å‚æ•°,è¿™ä¼šè§¦å‘å¯å˜æ£€æµ‹(ä¼°è®¡bevyå¯¹systemå‡½æ•°æœ‰ç‰¹æ®Šå¤„ç†),
æ‰€ä»¥è¦è­¦æƒ•è¾…åŠ©å‡½æ•°.</p>
<p>å¦‚æœä¿®æ”¹ç»„ä»¶äº†,bevyä¸ä¼šæ£€æŸ¥å‰åä¸¤æ¬¡çš„å€¼æ˜¯å¦ç›¸ç­‰,è€Œæ˜¯ç›´æ¥è§¦å‘<code>å˜æ›´æ£€æµ‹</code>,
è¿™ä¸ªé¿å…çš„æ–¹å¼æ˜¯åœ¨ä¿®æ”¹ç»„ä»¶ä¹‹å‰,å…ˆåšå‰åå€¼æ¯”è¾ƒ,å¦‚æœç›¸ç­‰å°±ä¸ä¿®æ”¹äº†.</p>
<p>å˜æ›´æ£€æµ‹ä»¥æ¯ä¸ªç³»ç»Ÿä¸ºç²’åº¦è¿›è¡Œå·¥ä½œ,å¹¶ä¸”æ˜¯å¯é çš„.
ä»…å½“ç³»ç»Ÿä»¥å‰æœªè§è¿‡æ›´æ”¹(è‡ªä¸Šæ¬¡è¿è¡Œä»¥æ¥å‘ç”Ÿçš„æ›´æ”¹)æ—¶,ç³»ç»Ÿæ‰ä¼šæ£€æµ‹åˆ°æ›´æ”¹.</p>
<p>è¿™ä¸ªå˜æ›´æ£€æµ‹ä¸åƒäº‹ä»¶,å˜æ›´æ£€æµ‹æ˜¯å¯é çš„;äº‹ä»¶å åŠ çŠ¶æ€å’Œè¿è¡Œæ¡ä»¶,å¯èƒ½ä¼šæ¼æ‰.</p>
<h2 id="possible-pitfalls-1"><a class="header" href="#possible-pitfalls-1">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the detecting
system before the changing system. The detecting system will see the change
the next time it runs, typically on the next frame update.</p>
<p>If you need to ensure that changes are handled immediately / during the same
frame, you can use <a href="programming//programming/system-order.html">explicit system ordering</a>.</p>
<p>å˜æ›´æ£€æµ‹çš„é€»è¾‘æ˜¯æ”¾åœ¨systemä¸­çš„,æ‰€ä»¥æ£€æµ‹å’Œå®é™…çš„å˜æ›´æ˜¯å¯èƒ½å­˜åœ¨ä¸ç¡®å®šé¡ºåºçš„,
å¦‚æœå…ˆæ£€æµ‹å†å˜æ›´,åªèƒ½å†ä¸‹å¸§æ‰ä¼šæ”¶é›†åˆ°å˜æ›´ä¿¡æ¯.</p>
<p>å¦‚æœæƒ³è¦é¡ºåºå¿…é¡»æ­£ç¡®,å°±ä½¿ç”¨systemçš„é¡ºåºçº¦æŸæ¥ä¿è¯.</p>
<hr />
<h1 id="removal-detection"><a class="header" href="#removal-detection">Removal Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/removal_detection.rs"><code>removal_detection</code></a>.</p>
<hr />
<p>Removal detection is special. This is because, unlike with <a href="programming//programming/change-detection.html">change
detection</a>, the data does not exist in the ECS anymore
(obviously), so Bevy cannot keep tracking metadata for it.</p>
<p>Nevertheless, being able to respond to removals is important for some
applications, so Bevy offers a limited form of it.</p>
<p>åˆ é™¤æ£€æµ‹,åˆ é™¤æ„å‘³ç€ECSéƒ½åˆ é™¤äº†,å°±æ²¡æ³•è·Ÿè¸ªäº†(å…¶å®æ˜¯å…ƒæ•°æ®è¢«åˆ æ‰äº†).
bevyè¿˜æ˜¯æä¾›äº†ä¸€ç§å¸¦é™åˆ¶çš„æ–¹å¼.</p>
<h2 id="components-3"><a class="header" href="#components-3">Components</a></h2>
<p>You can check for <a href="programming//programming/ec.html#components">components</a> that have been removed during the
current frame. The data is cleared at the end of every frame update. You must
make sure your detecting <a href="programming//programming/systems.html">system</a> <a href="programming//programming/system-order.html">is ordered after</a>
(or is in another <a href="programming//programming/schedules.html">schedule</a> that runs after) the system that
does the removing.</p>
<p>Note: removal detection also includes despawned entities!</p>
<p>Use the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/removal_detection/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a> special system parameter type. Internally, it
is implemented using <a href="programming//programming/events.html">events</a> and behaves like an <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader</code></a>,
but it gives you the <a href="https://docs.rs/bevy/0.13.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> IDs of entities whose component <code>T</code> was removed.</p>
<pre><code class="language-rust no_run noplayground">fn detect_removals(
    mut removals: RemovedComponents&lt;EnemyIsTrackingPlayer&gt;,
    // ... (maybe Commands or a Query ?) ...
) {
    for entity in removals.read() {
        // do something with the entity
        eprintln!("Entity {:?} had the component removed.", entity);
    }
}</code></pre>
<p>(To do things with these entities, you can just use the <code>Entity</code> IDs with
<a href="programming//programming/commands.html"><code>Commands::entity()</code></a> or <a href="programming//programming/queries.html"><code>Query::get()</code></a>.)</p>
<p>åˆ é™¤ç»„ä»¶,å…¶å…ƒæ•°æ®çš„åˆ é™¤æ˜¯åœ¨æ¯å¸§æ›´æ–°çš„æœ€åæ‰§è¡Œçš„,é‚£ä¹ˆåˆ é™¤æ£€æµ‹å°±éœ€è¦åœ¨åˆ é™¤systemä¹‹åå°±è¡Œ.</p>
<p>å®ä½“åˆ é™¤ç»„ä»¶;åˆ é™¤å®ä½“éƒ½ä¼šè§¦å‘<code>åˆ é™¤å˜æ›´</code>.</p>
<p><code>RemovedComponents&lt;T&gt;</code>æ˜¯åˆ é™¤ç»„ä»¶äº‹ä»¶æ¥æ”¶å™¨,å’Œ<code>EventReader</code>å¾ˆåƒ, ä¼šæä¾›å®ä½“ID.</p>
<h2 id="resources-4"><a class="header" href="#resources-4">Resources</a></h2>
<p>Bevy does not provide any API for detecting when <a href="programming//programming/res.html">resources</a> are removed.</p>
<p>You can work around this using <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> and a separate <a href="programming//programming/local.html"><code>Local</code></a>
system parameter, effectively implementing your own detection.</p>
<pre><code class="language-rust no_run noplayground">fn detect_removed_res(
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
    mut my_res_existed: Local&lt;bool&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists!

        // remember that!
        *my_res_existed = true;

        // (... you can do something with the resource here if you want ...)
    } else if *my_res_existed {
        // the resource does not exist, but we remember it existed!
        // (it was removed)

        // forget about it!
        *my_res_existed = false;

        // ... do something now that it is gone ...
    }
}</code></pre>
<p>Note that, since this detection is local to your system, it does not have
to happen during the same frame update.</p>
<p>bevyæ²¡æœ‰æä¾›èµ„æºåˆ é™¤æ£€æµ‹çš„api.ä½†å¯ä»¥é€šè¿‡Optionæ¥è·Ÿè¸ªèµ„æº,é€šè¿‡Localæ¥è®°å½•èµ„æºæ˜¯å¦å­˜åœ¨.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="one-shot-systems-1"><a class="header" href="#one-shot-systems-1">One-Shot Systems</a></h1>
<p>One-Shot Systems are <a href="programming//programming/systems.html">systems</a> that you intend to call yourself,
whenever you want. For example: on a button press, upon triggering a special
item or ability in your game, etcâ€¦</p>
<pre><code class="language-rust no_run noplayground">fn item_handler_health(
    mut q_player: Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
) {
    let mut health = q_player.single_mut();
    health.hp += 25.0;
}

fn item_handler_magic_potion(
    mut evw_magic: EventWriter&lt;MyMagicEvent&gt;,
    mut commands: Commands,
) {
    evw_magic.send(MyMagicEvent::Sparkles);
    commands.spawn(MySparklesBundle::default());
}</code></pre>
<p>å•å‡»system,uiæ“ä½œ,æ¸¸æˆä¸­çš„è¡¥è“ç­‰.</p>
<h2 id="registration"><a class="header" href="#registration">Registration</a></h2>
<p>You should not add these systems to a <a href="programming//programming/schedules.html">schedule</a>.</p>
<p>Instead, you can register them into the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a>, to get a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemId.html"><code>SystemId</code></a>.
You can then store that <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemId.html"><code>SystemId</code></a> somewhere and use it to run the
system later.</p>
<p>The most convenient way is probably to use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> and put your
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.SystemId.html"><code>SystemId</code></a>s in a <a href="programming//programming/res.html">resource</a>:</p>
<pre><code class="language-rust no_run noplayground">/// For this simple example, we will just organize our systems
/// using string keys in a hash map.
#[derive(Resource)]
struct MyItemSystems(HashMap&lt;String, SystemId&gt;);

impl FromWorld for MyItemSystems {
    fn from_world(world: &amp;mut World) -&gt; Self {
        let mut my_item_systems = MyItemSystems(HashMap::new());

        my_item_systems.0.insert(
            "health".into(),
            world.register_system(item_handler_health)
        );
        my_item_systems.0.insert(
            "magic".into(),
            world.register_system(item_handler_magic_potion)
        );

        my_item_systems
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyItemSystems&gt;();</code></pre>
<p>Alternative: register from an <a href="programming//programming/exclusive.html">exclusive system</a>:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">fn register_item_handler_systems(world: &amp;mut World) {
    let mut my_item_systems = MyItemSystems(HashMap::new());

    my_item_systems.0.insert(
        "health".into(),
        world.register_system(item_handler_health)
    );
    my_item_systems.0.insert(
        "magic".into(),
        world.register_system(item_handler_magic_potion)
    );

    world.insert_resource(my_item_systems);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, register_item_handler_systems);</code></pre>
</details>
<p>Or from the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<details>
  <summary>Code:</summary>
<pre><code class="language-rust no_run noplayground">fn my_plugin(app: &amp;mut App) {
    let mut my_item_systems = MyItemSystems(HashMap::new());

    my_item_systems.0.insert(
        "health".into(),
        app.register_system(item_handler_health)
    );
    my_item_systems.0.insert(
        "magic".into(),
        app.register_system(item_handler_magic_potion)
    );

    app.insert_resource(my_item_systems);
}</code></pre>
</details>
<p>å•å‡»systemä¸å±äºè°ƒåº¦,è€Œæ˜¯å±äºworld.ä½¿ç”¨<code>register_system</code>æ¥æ³¨å†Œsystem.
(add_systemæ˜¯ecsæ·»åŠ system).</p>
<p>è¿™é‡Œæœ‰ä¸ªæ¦‚å¿µ,worldä¸­çš„å•å‡»systemæ˜¯æœ‰systemIDçš„,ç±»ä¼¼äºå®ä½“idä¸€æ ·,æ˜¯ä¸ªå¼•ç”¨.
register_systemæ³¨å†Œåä¼šè¿”å›systemID,åç»­è°ƒç”¨éœ€è¦è¿™ä¸ªID.</p>
<p>è¿™ä¸ªIDå¯ä»¥ä¿å­˜èµ·æ¥,æ˜¯çš„,æ¨èä½¿ç”¨èµ„æºå°†IDä¿å­˜èµ·æ¥,ä¸ºäº†æ–¹ä¾¿åŒºåˆ†,è¿˜å¯ä»¥ä½¿ç”¨hashå­˜å‚¨èµ·æ¥.</p>
<p>å¦‚ä¸Šå›¾æ‰€ç¤º,å®šä¸€ä¸ªèµ„æºæ¥å­˜å‚¨hash.å®ç°FromWorldç‰¹å‹(è‡ªåŠ¨å¡«å……èµ„æº).
æˆ–è€…ç›´æ¥æ“çºµworldæ¥æ·»åŠ èµ„æº,æˆ–è€…é€šè¿‡appæ¥æ·»åŠ èµ„æº.
(æ¨èä½¿ç”¨FromWorldç‰¹å‹).</p>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<p>The easiest way is using <a href="programming//programming/commands.html">Commands</a> (<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>):</p>
<pre><code class="language-rust no_run noplayground">fn trigger_health_item(
    mut commands: Commands,
    systems: Res&lt;MyItemSystems&gt;,
) {
    // TODO: do some logic to implement picking up the health item

    let id = systems.0["health"];
    commands.run_system(id);
}</code></pre>
<p>This queues up the system to be run later, whenever Bevy decides to
apply the <a href="programming//programming/commands.html">Commands</a>.</p>
<p>If you want to run a one-shot system immediately, like a normal function
call, you need <a href="programming//programming/world.html">direct <code>World</code> access</a>. Do it from an <a href="programming//programming/exclusive.html">exclusive
system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn trigger_magic_item(world: &amp;mut World) {
    // TODO: do some logic to implement picking up the magic item

    let id = world.resource::&lt;MyItemSystems&gt;().0["magic"];
    world.run_system(id).expect("Error Running Oneshot System");

    // Since we are in an exclusive system, we can expect
    // the magic potion to now be in effect!
}</code></pre>
<p>Either way, the one-shot system's <a href="programming//programming/commands.html">Commands</a>
are automatically applied immediately when it runs.</p>
<p>è¿è¡Œ,é€šè¿‡<code>Commands.run_system(systemID)</code>å®ç°.è¿™æ ·æ˜¯å»¶æ—¶æ‰§è¡Œçš„.
å¦‚æœè¦ç«‹é©¬ç”Ÿæ•ˆ,ç”¨ç‹¬å systemæ¥ç›´æ¥è®¿é—®world.</p>
<h3 id="without-registration"><a class="header" href="#without-registration">Without Registration</a></h3>
<p>It is possible to also run one-shot systems without <a href="programming/one-shot-systems.html#registration">registering</a>
them beforehand:</p>
<pre><code class="language-rust no_run noplayground">world.run_system_once(my_oneshot_system_fn);</code></pre>
<p>If you do this, Bevy is unable to store any data related to the system:</p>
<ul>
<li><a href="programming//programming/local.html">Locals</a> will not retain their value from a previous run.</li>
<li><a href="programming//programming/queries.html">Queries</a> will not be able to cache their lookups, leading to slower performance.</li>
<li>etcâ€¦</li>
</ul>
<p>It is therefore recommended to register your one-shot systems, unless
you really only intend to run them once.</p>
<p>bevyè¿˜å…è®¸ä¸æ³¨å†Œç›´æ¥è¿è¡Œå•å‡»system.<code>world.run_system_once(my_oneshot_system_fn);</code>
åªæ˜¯è¿™æ ·bevyå°±ä¸èƒ½ç¼“å­˜systemç›¸å…³æ•°æ®äº†:</p>
<ul>
<li>Local</li>
<li>Query</li>
</ul>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<p>To run a one-shot system, exclusive <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>World</code></a> access is required. The
system can have arbitrary parameters, and Bevy cannot validate its data
access against other systems, like it does when the system is part of a
<a href="programming//programming/schedules.html">schedule</a>. So, no multi-threading allowed.</p>
<p>In practice, this isn't usually a problem, because the use cases for
one-shot systems are things that happen rarely.</p>
<p>But maybe don't overuse them! If something happens regularly, consider
doing it from a normal system that is part of a <a href="programming//programming/schedules.html">schedule</a>,
and controlling it with <a href="programming//programming/run-criteria.html">run conditions</a> instead.</p>
<p>å¦‚æœä½¿ç”¨ç‹¬å systemæ¥è¿è¡Œå•å‡»system,æ­¤æ—¶ä¼šç‹¬å world,æ€§èƒ½å°±æ˜¯ä¸€ä¸ªå¤§é—®é¢˜.</p>
<p>è¿™ä¸ªæœºåˆ¶å­˜åœ¨çš„ç†ç”±æ˜¯:å®é™…åœºæ™¯ä¸‹å¿…é¡»ä½¿ç”¨ç‹¬å systemæ¥è¿è¡Œå•å‡»systemçš„åœºæ™¯éå¸¸å°‘.</p>
<p>åªè¦ä¸è¿‡æ¸¡ä½¿ç”¨å³å¯.å¦‚æœå•å‡»systemå‘ç”Ÿçš„éå¸¸é¢‘ç¹,éœ€è€ƒè™‘è½¬æ¢æˆæ™®é€šsystem.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="internal-parallelism"><a class="header" href="#internal-parallelism">Internal Parallelism</a></h1>
<p>Internal parallelism is multithreading <em>within</em> a <a href="programming//programming/systems.html">system</a>.</p>
<p>The usual multithreading in Bevy is to run each <a href="programming//programming/systems.html">system</a> in
parallel when possible (when there is no conflicting data access with other
systems). This is called "external parallelism".</p>
<p>However, sometimes, you need to write a <a href="programming//programming/systems.html">system</a> that
has to process a huge number of <a href="programming//programming/intro-data.html">entities</a> or
<a href="programming//programming/events.html">events</a>. In that case, simple <a href="programming//programming/queries.html">query</a> or
<a href="programming//programming/events.html">event</a> iteration would not scale to make good use of the CPU.</p>
<p>Bevy offers a solution: parallel iteration. Bevy will automatically split
all the entities/events into appropriately-sized batches, and iterate
each batch on a separate CPU thread for you, calling a function/closure
you provide.</p>
<p>If there are only a few entities/events, Bevy will automatically fall back
to single-threaded iteration, and it will behave the same way as if you
had just iterated normally. With a few entities/events, that is faster than
multi-threading.</p>
<p>Even through parallel iteration should automatically make a good decision
regardless of the number of entities/events, it is more awkward to use and
not always suitable, as you have to do everything from inside a closure
and there are other limitations.</p>
<p>Also, if your <a href="programming//programming/systems.html">system</a> is unlikely to ever encounter huge
numbers of entities/events, don't bother with it and just iterate your
<a href="programming//programming/queries.html">queries</a> and <a href="programming//programming/events.html">events</a> normally.</p>
<p>å†…éƒ¨å¹¶è¡Œæ˜¯æŒ‡systemå†…éƒ¨çš„å¤šçº¿ç¨‹.<br />
å¤–éƒ¨å¹¶è¡Œæ˜¯æŒ‡bevyå¯ç”¨å¤šçº¿ç¨‹è®©systemå¹¶è¡Œæ‰§è¡Œ.</p>
<p>æŸäº›æ—¶å€™,åœ¨ä¸€ä¸ªsystemå†…å¯èƒ½è¦éå†å¤§é‡å®ä½“æˆ–äº‹ä»¶,
æ­¤æ—¶ç®€å•çš„queryæˆ–äº‹ä»¶è¿­ä»£å°±æ— æ³•æœ‰æ•ˆåˆ©ç”¨CPUäº†.</p>
<p>bevyæå‡ºäº†å†…éƒ¨å¹¶è¡Œçš„æ–¹æ¡ˆ:bevyè‡ªåŠ¨å°†å®ä½“åˆ—è¡¨/äº‹ä»¶åˆ—è¡¨æ‹†åˆ†æˆåˆé€‚å¤§å°,
æ¯å—ä½¿ç”¨ä¸€ä¸ªCPUçº¿ç¨‹æ¥è¿è¡Œ.å¦‚æœå—æ•°å¾ˆå°‘,bevyä¼šè‡ªåŠ¨åˆå¹¶åˆ°ä¸€ä¸ªçº¿ç¨‹ä¸­è·‘.</p>
<p>å³ä½¿å¼€å¯äº†å†…éƒ¨å¹¶è¡Œ,ä½†bevyå†…éƒ¨çš„è‡ªåŠ¨æœºåˆ¶ä¹Ÿä¸ä¸€å®šåˆé€‚,å› ä¸ºé—­åŒ…å†…éƒ¨è¿˜æœ‰å…¶ä»–é™åˆ¶.</p>
<p><strong>å¦‚æœé¡¹ç›®ä¸æ˜¯é‡åˆ°å·¨é‡å®ä½“/äº‹ä»¶,ä½¿ç”¨æ­£å¸¸çš„queryå¾ªç¯/äº‹ä»¶è¿­ä»£å°±å¤Ÿç”¨äº†.</strong></p>
<h2 id="parallel-query-iteration"><a class="header" href="#parallel-query-iteration">Parallel Query Iteration</a></h2>
<p><a href="programming//programming/queries.html">Queries</a> support parallel iteration to let you process many
entities across multiple CPU threads.</p>
<pre><code class="language-rust no_run noplayground">fn my_particle_physics(
    mut q_particles: Query&lt;(&amp;mut Transform, &amp;MyParticleState), With&lt;MyParticle&gt;&gt;,
) {
    q_particles.par_iter_mut().for_each(|(mut transform, my_state)| {
        my_state.move_particle(&amp;mut transform);
    });
}</code></pre>
<p>One limitation of parallel iteration is that safe Rust does not allow you to
share <code>&amp;mut</code> access across CPU threads. Therefore, it is not possible to mutate
any data outside of the current entity's own <a href="programming//programming/ec.html#components">components</a>.</p>
<p>If you need to mutate shared data, you could use something like <a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code>Mutex</code></a>,
but beware of the added overhead. It could easily drown out any benefits
you get from parallel iteration.</p>
<h2 id="parallel-commands"><a class="header" href="#parallel-commands">Parallel Commands</a></h2>
<p>If you need to use <a href="programming//programming/commands.html">commands</a>, there is the <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ParallelCommands.html"><code>ParallelCommands</code></a>
system parameter. It allows you to get access to <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> from within
the parallel iteration closure.</p>
<pre><code class="language-rust no_run noplayground">fn my_particle_timers(
    time: Res&lt;Time&gt;,
    mut q_particles: Query&lt;(Entity, &amp;mut MyParticleState), With&lt;MyParticle&gt;&gt;,
    par_commands: ParallelCommands,
) {
    q_particles.par_iter_mut().for_each(|(e_particle, mut my_state)| {
        my_state.timer.tick(time.delta());

        if my_state.timer.finished() {
            par_commands.command_scope(|mut commands| {
                commands.entity(e_particle).despawn();
            })
        }
    });
}</code></pre>
<p>However, generally speaking, <a href="programming//programming/commands.html">commands</a> are an inefficient way to
do things in Bevy, and they do not scale well to huge numbers of entities. If
you need to spawn/despawn or insert/remove <a href="programming//programming/ec.html#components">components</a>
on huge numbers of entities, you should probably do it from an <a href="programming//programming/exclusive.html">exclusive
system</a>, instead of using <a href="programming//programming/commands.html">commands</a>.</p>
<p>In the above example, we update <a href="programming//fundamentals/time.html#timer">timers</a> stored across many
entities, and use <a href="programming//programming/commands.html">commands</a> to despawn any entities whose
time has elapsed. It is a good use of <a href="programming//programming/commands.html">commands</a>, because the
timers need to be ticked for all entities, but only a few entities are likely
to need despawning at once.</p>
<h2 id="parallel-event-iteration"><a class="header" href="#parallel-event-iteration">Parallel Event Iteration</a></h2>
<p><a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a> offers parallel iteration for <a href="programming//programming/events.html">events</a>,
allowing you to process a huge number of events across multiple CPU threads.</p>
<pre><code class="language-rust no_run noplayground">fn handle_many_events(
    mut evr: EventReader&lt;MyEvent&gt;,
) {
    evr.par_read().for_each(|ev| {
        // TODO: do something with `ev`
    });
}</code></pre>
<p>However, one downside is that you cannot use it for events that need to be
handled in order. With parallel iteration, the order becomes undefined.</p>
<p>Though, if you use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventParIter.html"><code>.for_each_with_id</code></a>, your closure will
be given an <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/event/struct.EventId.html"><code>EventId</code></a>, which is a sequential index to indicate which event
you are currently processing. That can help you know where you are in the
event queue, even though you are still processing events in an undefined order.</p>
<p>Another downside is that typically you need to be able to mutate some data in
response to events, but, in safe Rust, it is not possible to share mutable
access to anything across CPU threads. Thus, parallel event handling is
impossible for most use cases.</p>
<p>If you were to use something like <a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code>Mutex</code></a> for shared access to data, the
synchronization overhead would probably kill performance, and you'd have
been better off with regular single-threaded event iteration.</p>
<h2 id="controlling-the-batch-size"><a class="header" href="#controlling-the-batch-size">Controlling the Batch Size</a></h2>
<p>The batch size and number of parallel tasks are chosen automatically using
smart algorithms, based on how many entities/events need to be processed,
and how Bevy ECS has stored/organized the entity/component data in memory.
However, it assumes that the amount of work/computation you do for each
entity is roughly the same.</p>
<p>If you find that you want to manually control the batch size, you can specify
a minimum and maximum using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/batching/struct.BatchingStrategy.html"><code>BatchingStrategy</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn par_iter_custom_batch_size(
    q: Query&lt;&amp;MyComponent&gt;,
) {
    q.par_iter().batching_strategy(
        BatchingStrategy::new()
            // whatever fine-tuned values you come up with ;)
            .min_batch_size(256)
            .max_batch_size(4096)
    ).for_each(|my_component| {
        // TODO: do some heavy work
    });

    q.par_iter().batching_strategy(
        // fixed batch size
        BatchingStrategy::fixed(1024)
    ).for_each(|my_component| {
        // TODO: do some heavy work
    });
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-13">0.13</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="system-piping"><a class="header" href="#system-piping">System Piping</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.13.0/examples/ecs/system_piping.rs"><code>system_piping</code></a>.</p>
<hr />
<p>You can compose a single Bevy <a href="programming//programming/systems.html">system</a> from multiple Rust functions.</p>
<p>You can make functions that can take an input and produce an output, and be
connected together to run as a single larger system. This is called "system piping".</p>
<p>You can think of it as creating "modular" systems made up of multiple building
blocks. This way, you can reuse some common code/logic in multiple systems.</p>
<p>Note that system piping is <em>not</em> a way of communicating between systems.
If you want to pass data between systems, you should use <a href="programming//programming/events.html">Events</a>
instead.</p>
<p>Your functions will be combined and Bevy will treat them as if they were a
single big <a href="programming//programming/systems.html">system</a> with all the combined system parameters for
data access.</p>
<p>å°†å¤šä¸ªrustå‡½æ•°ç»„åˆæˆå•ä¸ªsystem,åœ¨è¿™ä¸ªsystemä¸­,å‡½æ•°æœ‰input/output,
æœ€ç»ˆç»„åˆæˆä¸€ä¸ªç®¡é“,è¿™å°±æ˜¯systemç®¡é“.</p>
<p>bevyä¸­systemä¹‹é—´é€šä¿¡çš„æœºåˆ¶æ˜¯äº‹ä»¶.systemç®¡é“çš„æå‡ºä¸æ˜¯ä¸ºäº†è§£å†³systemä¹‹é—´çš„é€šä¿¡.</p>
<h2 id="example-handling-results"><a class="header" href="#example-handling-results">Example: Handling <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>s</a></h2>
<p>One useful application of system piping is to be able to return errors (allowing
the use of Rust's <code>?</code> operator) and then have a separate function for handling
them:</p>
<pre><code class="language-rust no_run noplayground">fn net_receive(mut netcode: ResMut&lt;MyNetProto&gt;) -&gt; std::io::Result&lt;()&gt; {
    netcode.send_updates(/* ... */)?;
    netcode.receive_updates(/* ... */)?;

    Ok(())
}

fn handle_io_errors(
    In(result): In&lt;std::io::Result&lt;()&gt;&gt;,
    // we can also have regular system parameters
    mut commands: Commands,
) {
    if let Err(e) = result {
        eprintln!("I/O error occurred: {}", e);
        // Maybe spawn some error UI or something?
        commands.spawn((/* ... */));
    }
}</code></pre>
<p>Such functions cannot be <a href="programming//programming/app-builder.html">added</a> individually as systems (Bevy
doesn't know what to do with the input/output). By "piping" them together,
we create a valid system that we can add:</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(FixedUpdate, net_receive.pipe(handle_io_errors));</code></pre>
<p>systemç®¡é“çš„å…¸å‹åº”ç”¨åœºæ™¯æ˜¯è¿”å›é”™è¯¯(åˆ©ç”¨rustçš„?æ“ä½œç¬¦),ç„¶åä½¿ç”¨ä¸€ä¸ªå•ç‹¬å‡½æ•°æ¥å¤„ç†é”™è¯¯.
è¿™ä¸ªåœ¨æŸäº›åœºæ™¯éå¸¸æœ‰ç”¨.</p>
<h2 id="performance-warning"><a class="header" href="#performance-warning">Performance Warning</a></h2>
<p>Beware that Bevy treats the whole chain as if it was a single big system, with
all the combined system parameters and their respective data access
requirements. This implies that parallelism could be limited, affecting
performance.</p>
<p>If you create multiple "piped systems" that all contain a common function which
contains any mutable access, that prevents all of them from running in parallel!</p>
<p>å› ä¸ºsystemç»„åˆäº†å¾ˆå¤šå‡½æ•°,å¯¼è‡´å‚æ•°å¤šäº†å¾ˆå¤š,æ¯ä¸ªå‚æ•°éƒ½è¦è®¡ç®—,æ€§èƒ½å°±å¾ˆå·®.</p>
<p>å¦‚æœå¤šä¸ªsystemç®¡é“éƒ½åŒ…å«äº†ä¸€ä¸ªå…¬å…±å‡½æ•°,è€Œè¿™ä¸ªå…¬å…±å‡½æ•°æ˜¯mutè®¿é—®æ•°æ®,
é‚£ä¹ˆè¿™äº›systemä¸èƒ½å¹¶è¡Œæ‰§è¡Œ.æ€§èƒ½å°±ä¼šæ›´å·®.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="param-sets"><a class="header" href="#param-sets">Param Sets</a></h1>
<p>For safety reasons, a <a href="programming//programming/systems.html">system</a> cannot have multiple parameters
whose data access might have a chance of mutability conflicts over the
same data.</p>
<p>Some examples:</p>
<ul>
<li>Multiple incompatible <a href="programming//programming/queries.html">queries</a>.</li>
<li>Using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a> while also having other system parameters to access specific data.</li>
<li>â€¦</li>
</ul>
<p>Consider this example <a href="programming//programming/systems.html">system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    mut q_player: Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
    mut q_enemy: Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
) {
    // ...
}</code></pre>
<p>The two <a href="programming//programming/queries.html">queries</a> are both trying to mutably access <code>Health</code>. They
have different <a href="programming//programming/queries.html#query-filters">filters</a>, but what if there are entities that
have both <code>Player</code> and <code>Enemy</code> components? If we know that shouldn't happen, we
can add <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/query/struct.Without.html"><code>Without</code></a> filters, but what if it is actually valid for our game?</p>
<p>Such code will compile (Rust cannot know about Bevy ECS semantics), but will
result in a runtime panic. When Bevy tries to run the system, it will panic with
a message about conflicting system parameters:</p>
<pre><code>thread 'main' panicked at bevy_ecs/src/system/system_param.rs:225:5:
error[B0001]: Query&lt;&amp;mut game::Health, bevy_ecs::query::filter::With&lt;game::Enemy&gt;&gt; in
system game::reset_health accesses component(s) game::Health in a way that conflicts
with a previous system parameter. Consider using `Without&lt;T&gt;` to create disjoint Queries
or merging conflicting Queries into a `ParamSet`.
</code></pre>
<p>Bevy provides a solution: wrap any incompatible parameters in a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    // access the health of enemies and the health of players
    // (note: some entities could be both!)
    mut set: ParamSet&lt;(
        Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
        Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
        // also access the whole world ... why not
        &amp;World,
    )&gt;,
) {
    // set health of enemies (use the 1st param in the set)
    for mut health in set.p0().iter_mut() {
        health.hp = 50.0;
    }

    // set health of players (use the 2nd param in the set))
    for mut health in set.p1().iter_mut() {
        health.hp = 100.0;
    }

    // read some data from the world (use the 3rd param in the set)
    let my_resource = set.p2().resource::&lt;MyResource&gt;();
}</code></pre>
<p>This ensures only one of the conflicting parameters can be used at the same time.
Bevy will now happily run our system.</p>
<p>The maximum number of parameters in a param set is 8.</p>
<p>systemçš„å¤šä¸ªå…¥å‚ä¸èƒ½å¯¹åŒä¸€æ•°æ®æœ‰ç«äº‰è®¿é—®.<br />
å¤šä¸ªä¸å…¼å®¹çš„query;åŒæ—¶æ‹¥æœ‰&amp;world(ç‹¬å ä¸–ç•Œ)å’Œå…¶ä»–æ•°æ®çš„è®¿é—®.</p>
<p>rustæ˜¯ä¸çŸ¥é“çš„bevyçš„ECSè¯­ä¹‰çš„,æ‰€ä»¥systemå…¥å‚ç«äº‰æ˜¯æ— æ³•é€šè¿‡ç¼–è¯‘å™¨æŠ¥å‘Šå‡ºæ¥çš„,
è¿è¡Œæ—¶ä¼šå¯¼è‡´panic.</p>
<p>bevyæä¾›äº†ä¸€ä¸ªæ–¹æ³•: ä½¿ç”¨ParamSetå°†ä¸å…¼å®¹çš„å…¥å‚å°è£…ä¸€ä¸‹.
è¿™æ ·bevyä¼šä¿è¯åœ¨åŒä¸€æ—¶é—´åªä¼šæœ‰ä¸ªä¸€ä¸ªç«äº‰å‚æ•°åœ¨ä½¿ç”¨.</p>
<p>ParamSetæœ€å¤§å‚æ•°ä¸ªæ•°ä¸º8.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th>0.14</th><th>(upcoming / release candidate)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="non-send-resources"><a class="header" href="#non-send-resources">Non-Send Resources</a></h1>
<p>"Non-send" refers to data types that must only be accessed from the "main
thread" of the application. Such data is marked by Rust as <code>!Send</code> (lacking
the <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> trait).</p>
<p>Some (often system) libraries have interfaces that cannot be safely used from
other threads. A common example of this are various low-level OS interfaces
for things like windowing, graphics, or audio. If you are doing advanced
things like creating a Bevy plugin for interfacing with such things, you
may encounter the need for this.</p>
<p>Normally, Bevy works by running all your <a href="programming//programming/systems.html">systems</a> on a
thread-pool, making use of many CPU cores. However, you might need to ensure
that some code always runs on the "main thread", or access data that is not
safe to access in a multithreaded way.</p>
<p>Non-Sendèµ„æº,æ„å‘³åªèƒ½ä»ä¸»çº¿ç¨‹è®¿é—®æŒ‡å®šç±»å‹çš„æ•°æ®.rustä¼šå°†è¿™äº›æ•°æ®æ ‡è®°ä¸º<code>!Send</code>.</p>
<p>å¾ˆå¤šåº•å±‚OSæ¥å£éƒ½ä¸èƒ½åœ¨å¤šçº¿ç¨‹ä¸­å®‰å…¨åˆ‡æ¢,eg:çª—å£,å›¾åƒ,éŸ³é¢‘.</p>
<p>é€šå¸¸bevyè¿è¡Œsystemæ˜¯åˆ©ç”¨çº¿ç¨‹æ± æ¥è¿è¡Œ,ä»¥æé«˜å¤šæ ¸CPUçš„åˆ©ç”¨ç‡.</p>
<p>éƒ¨åˆ†åœºæ™¯ä¸‹,éƒ¨åˆ†ä»£ç æ˜¯éœ€è¦ä¸€ç›´è·‘åœ¨ä¸»çº¿ç¨‹ä¸­çš„,è¿˜æœ‰å¤šçº¿ç¨‹è®¿é—®æ•°æ®æ˜¯ä¸å®‰å…¨çš„.</p>
<h2 id="non-send-systems-and-data-access"><a class="header" href="#non-send-systems-and-data-access">Non-Send Systems and Data Access</a></h2>
<p>To do this, you can use a <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a> system parameter.
This behaves just like <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, letting you access an ECS
<a href="programming//programming/res.html">resource</a> (single global instance of some data), except that the
presence of such a parameter forces the Bevy scheduler to always run the
<a href="programming//programming/systems.html">system</a> on the main thread. This ensures that data never has to be
sent between threads or accessed from different threads.</p>
<p>One example of such a resource is <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> in Bevy.  This is the
low-level layer behind the <a href="programming//window/props.html">window entities</a> that you typically use
for window management. It gives you more direct access to OS window management
functionality.</p>
<pre><code class="language-rust no_run noplayground">fn setup_raw_window(
    q_primary: Query&lt;Entity, With&lt;PrimaryWindow&gt;&gt;,
    mut windows: NonSend&lt;WinitWindows&gt;
) {
    let raw_window = windows.get_window(q_primary.single());
    // do some special things using `winit` APIs
}</code></pre>
<pre><code class="language-rust no_run noplayground">// just add it as a normal system;
// Bevy will notice the NonSend parameter
// and ensure it runs on the main thread
app.add_systems(Startup, setup_raw_window);</code></pre>
<p>Non-Send systemå’Œæ•°æ®è®¿é—®.<code>NonSend&lt;T&gt;, NonSendMut&lt;T&gt;</code>è¿™æ˜¯è®¿é—®èµ„æºçš„å‡çº§ç‰ˆ,
æ·»åŠ çš„çº¦æŸæ˜¯systemåªåœ¨ä¸»å‡½æ•°ä¸­è¿è¡Œ.</p>
<p>å¦ä¸€ä¸ªå¸¸è§çš„å°±æ˜¯WinitWindowsèµ„æº,æ˜¯çª—å£å®ä½“èƒŒåçª—å£ç®¡ç†å™¨çš„åç«¯,
åªèƒ½åœ¨ä¸»çº¿ç¨‹è®¿é—®.</p>
<p>åªéœ€è¦æŒ‡å®šNonSend,bevyåœ¨æ£€æŸ¥systemå‚æ•°æ—¶å°±ä¼šæ˜ç™½è¿™ä¸ªsystemæ˜¯ä¸»çº¿ç¨‹è·‘çš„.</p>
<h2 id="custom-non-send-resources"><a class="header" href="#custom-non-send-resources">Custom Non-Send Resources</a></h2>
<p>Normally, to insert <a href="programming//programming/res.html">resources</a>, their types must be <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a>.</p>
<p>Bevy tracks non-Send resources separately, to ensure that they can only be
accessed using <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>.</p>
<p>It is not possible to insert non-send resources using
<a href="programming//programming/commands.html"><code>Commands</code></a>, only using <a href="programming//programming/world.html">direct World access</a>. This
means that you have to initialize them in an <a href="programming//programming/exclusive.html">exclusive system</a>,
<a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impl, or from the <a href="programming//programming/app-builder.html">app builder</a>.</p>
<pre><code class="language-rust no_run noplayground">fn setup_platform_audio(world: &amp;mut World) {
    // assuming `OSAudioMagic` is some primitive that is not thread-safe
    let instance = OSAudioMagic::init();

    world.insert_non_send_resource(instance);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_platform_audio);</code></pre>
<p>Or, for simple things, if you don't need a full-blown system:</p>
<pre><code class="language-rust no_run noplayground">app.insert_non_send_resource(OSAudioMagic::init());</code></pre>
<p>If you just need to write a <a href="programming//programming/systems.html">system</a> that must run on
the main thread, but you don't actually have any data to store,
you can use <a href="https://docs.rs/bevy/0.14.0-rc.2/bevy/core/struct.NonSendMarker.html"><code>NonSendMarker</code></a> as a dummy.</p>
<pre><code class="language-rust no_run noplayground">fn my_main_thread_system(
    marker: NonSend&lt;NonSendMarker&gt;,
    // ...
) {
    // TODO: do stuff ...
}</code></pre>
<p>è‡ªå®šä¹‰Non-Sendèµ„æº.</p>
<p>ä¸€èˆ¬æ·»åŠ çš„èµ„æºéƒ½æ˜¯Sendçš„(å¯åœ¨å¤šçº¿ç¨‹è®¿é—®çš„).</p>
<p>è‡ªå®šä¹‰çš„Non-Sendèµ„æºåªèƒ½é€šè¿‡worldç›´æ¥è®¿é—®,Commandsæ˜¯æ— æ³•æ·»åŠ è¿™ç±»èµ„æºçš„.</p>
<p>worldç›´æ¥è®¿é—®æ„å‘³ç€:ç‹¬å system/FromWorld/appä¸‰ç§é€”å¾„å¯ä»¥å®ç°.
<code>world.insert_non_send_resource()</code>.</p>
<p>è¿˜æœ‰ä¸€ç§æƒ…å†µ,systemæ²¡æœ‰ç‰¹åˆ«çš„å…¥å‚,å¯ä½¿ç”¨<code>NonSend&lt;NonSendMarker&gt;</code>æ¥å‘Šè¯‰bevy,
systemè¿è¡Œåœ¨ä¸»çº¿ç¨‹ä¸Š.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-render-gpu-framework"><a class="header" href="#bevy-render-gpu-framework">Bevy Render (GPU) Framework</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>This chapter covers Bevy's rendering framework and how to work with the GPU.</p>
<p>Make sure you are well familiar with <a href="/programming.html">Bevy's Core Programming
Framework</a>. Everything here builds on top of it.</p>
<p>Here you will learn how to write custom rendering code. If you are simply
interested in using the existing graphical features provided by Bevy, check
out the chapters about <a href="/graphics.html">General Graphics Features</a>,
<a href="/2d.html">2D</a>, and <a href="/3d.html">3D</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="gpu//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="render-architecture-overview"><a class="header" href="#render-architecture-overview">Render Architecture Overview</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>The current Bevy render architecture premiered in Bevy 0.6. The <a href="https://bevyengine.org/news/bevy-0-6">news blog
post</a> is another place you can learn about it. :)</p>
<p>It was inspired by the Destiny Render Architecture (from the Destiny game).</p>
<h2 id="pipelined-rendering-1"><a class="header" href="#pipelined-rendering-1">Pipelined Rendering</a></h2>
<p>Bevy's renderer is architected in a way that operates independently from all
the normal app logic. It operates in its own separate <a href="gpu//programming/world.html">ECS World</a>
and has its own <a href="gpu//programming/app-builder.html">schedule</a>, with <a href="gpu//gpu/stages.html">stages</a> and
<a href="gpu//programming/systems.html">systems</a>.</p>
<p>The plan is that, in a future Bevy version, the renderer will run in parallel
with all the normal app logic, allowing for greater performance. This is
called "pipelined rendering": rendering the previous frame at the same time
as the app is processing the next frame update.</p>
<p>Every frame, the two parts are synchronized in a special <a href="gpu//programming/schedules.html">stage</a>
called "Extract". The Extract stage has access to both <a href="gpu//programming/world.html">ECS Worlds</a>,
allowing it to copy data from the main World into the render World.</p>
<p>From then on, the renderer only has access to the render World, and can only
use data that is stored there.</p>
<p>Every frame, all <a href="gpu//programming/intro-data.html#entities--components">entities</a> in the render World are erased, but
<a href="gpu//programming/res.html">resources</a> are kept. If you need to persist data from frame to
frame, store it in resources. Dynamic data that could change every frame
should be copied into the render world in the Extract stage, and typically
stored using entities and components.</p>
<p><img src="gpu/../img/pipelined-rendering.png" alt="Diagram of pipelined rendering timings in app-bound and render-bound cases" /></p>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<p>The renderer operates in multiple <a href="gpu//gpu/stages.html">render stages</a>. This
is how the work that needs to be performed on the CPU is managed.</p>
<p>The ordering of the workloads to be performed on the GPU is controlled
using the <a href="gpu//TODO.html">render graph</a>. The graph consists of
<a href="gpu//TODO.html">nodes</a>, each representing a workload for the GPU,
typically a <a href="gpu//TODO.html">render pass</a>. The nodes are connected using
<a href="gpu//TODO.html">edges</a>, representing their ordering/dependencies
with regard to one another.</p>
<h2 id="layers-of-abstraction"><a class="header" href="#layers-of-abstraction">Layers of Abstraction</a></h2>
<p>The Bevy rendering framework can accomodate you working at various different
levels of abstraction, depending on how much you want to integrate with the
Bevy ecosystem and built-in features, vs. have more direct control over the GPU.</p>
<p>For most things, you would be best served by the "high-level" or "mid-level" APIs.</p>
<h3 id="low-level"><a class="header" href="#low-level">Low-Level</a></h3>
<p>Bevy works directly with <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a>, a Rust-based cross-platform
graphics API. It is the abstraction layer over the GPU APIs of the underlying
<a href="gpu//platforms.html">platform</a>. This way, the same GPU code can work on all
supported platforms. The API design of <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> is based on
the WebGPU standard, but with extensions to support native platform features,
going beyond the limitations of the web platform.</p>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Backends (in order of priority)</th></tr></thead><tbody>
<tr><td>Linux</td><td>Vulkan, GLES3</td></tr>
<tr><td>Windows</td><td>DirectX 12, Vulkan, GLES3</td></tr>
<tr><td>macOS</td><td>Metal</td></tr>
<tr><td>iOS</td><td>Metal</td></tr>
<tr><td>Android</td><td>Vulkan, GLES3</td></tr>
<tr><td>Web</td><td>WebGPU, WebGL2</td></tr>
</tbody></table>
</div>
<p>On GLES3 and WebGL2, some renderer features are unsupported and performance is worse.</p>
<p>WebGPU is experimental and few browsers support it.</p>
<p><code>wgpu</code>æ˜¯rustç¼–å†™çš„å›¾å½¢åº“,å®ç°äº†WebGPUè§„èŒƒ,ä¸ºwebå’ŒåŸç”Ÿåº”ç”¨æä¾›äº†è·¨å¹³å°ä¸€è‡´çš„api,
æ€§èƒ½å¾ˆé«˜,ç›¸æ¯”WebGL,WebGPUæ›´åŠ åº•å±‚,å¯¹äºGPUæ˜¯ç›´æ¥è®¿é—®,æ€§èƒ½å’Œçµæ´»æ€§éƒ½é«˜å¾ˆå¤š.
è·¨å¹³å°æ˜¯wgpuçš„ç‰¹ç‚¹,ç›®å‰å®‰å“åˆ°linux/web/macOS/windowséƒ½æ˜¯æ”¯æŒçš„.
æ˜¯ä¸‹ä¸€ä»£å›¾å½¢å¤„ç†æŠ€æœ¯.å¤æ‚å›¾å½¢æ¸²æŸ“/ä¸‰ç»´å®æ—¶å¯è§†åŒ–åœºæ™¯ä¸‹æ˜¯å¼ºé¡¹,
é€‚ç”¨äºæ¸¸æˆå¼€å‘/æ•°æ®å¯è§†åŒ–/ç§‘å­¦è®¡ç®—.<code>å¯ä»¥è¯´bevyèƒ½èµ·é£,wgpuå°±æ˜¯æ ¸å¿ƒåŸºçŸ³ä¹‹ä¸€</code>.
wgpuè·¨å¹³å°,Vulkan(é€šç”¨è·¨å¹³å°å›¾åƒåº“,ä¸‹ä¸€ä»£çš„æŠ€æœ¯)/Metal(Apple)/D3D12(windows)/
OpenGL/WebGL2å’ŒWebGPU(wasm),æ‰€ä»¥å¯ä»¥è·¨å¹³å°.</p>
<p>ä»ä¸Šé¢çš„è¡¨æ ¼ä¸Šçœ‹å„ä¸ªå¹³å°éƒ½æœ‰äº†æ”¯æŒ.æœªæ¥ä¸çŸ¥é“æ˜¯å¦å¯ä»¥æ”¯æŒä¸»æœºå¹³å°.</p>
<p><code>wgpu</code> forms the "lowest level" of Bevy rendering. If you really need the
most direct control over the GPU, you can pretty much use <code>wgpu</code> directly,
from within the Bevy render framework.</p>
<h3 id="mid-level"><a class="header" href="#mid-level">Mid-Level</a></h3>
<p>On top of <code>wgpu</code>, Bevy provides some abstractions that can help you, and
integrate better with the rest of Bevy.</p>
<p>The first is <a href="gpu//TODO.html">pipeline caching</a> and
<a href="gpu//TODO.html">specialization</a>. If you create your
<a href="gpu//TODO.html">render pipelines</a> via this interface, Bevy can manage
them efficiently for you, creating them when they are first used, and then
caching and reusing them, for optimal performance.</p>
<p>Caching and specialization are, analogously, also available for <a href="gpu//TODO.html">GPU Compute
pipelines</a>.</p>
<p>Similar to the <a href="gpu//TODO.html">pipeline cache</a>, there is a <a href="gpu//TODO.html">texture
cache</a>. This is what you use for rendering-internal
<a href="gpu//TODO.html">textures</a> (for example: shadow maps, reflection maps,
â€¦), that do not originate from <a href="gpu//assets.html">assets</a>. It will manage and
reuse the GPU memory allocation, and free it when it becomes unused.</p>
<p>For using data from <a href="gpu//assets.html">assets</a>, Bevy provides the <a href="gpu//TODO.html">Render
Asset</a> abstraction to help with extracting the data from
different <a href="gpu//builtins.html#assets">asset types</a>.</p>
<p>Bevy can manage all the "objects to draw" using <a href="gpu//TODO.html">phases</a>,
which sort and draw <a href="gpu//TODO.html">phase items</a>. This way, Bevy
can sort each object to render, relative to everything else in the scene,
for optimal performance and correct transparency (if any).</p>
<p>Phase Items are defined using <a href="gpu//TODO.html">render commands</a>
and/or <a href="gpu//TODO.html">draw functions</a>. These are, conceputally,
the rendering equivalents of ECS <a href="gpu//programming/systems.html">systems</a> and <a href="gpu//programming/exclusive.html">exclusive
systems</a>, fetching data from the ECS World and generating
<a href="gpu//TODO.html">draw calls</a> for the GPU.</p>
<p>All of these things fit into the core architecture of the Bevy <a href="gpu//TODO.html">render
graph</a> and <a href="gpu//gpu/stages.html">render stages</a>. During
the Render stage, <a href="gpu//TODO.html">graph nodes</a> will execute <a href="gpu//TODO.html">render
passes</a> with the <a href="gpu//TODO.html">render phases</a>,
to draw everything as it was set up in the Prepare/Queue/PhaseSort stages.</p>
<p>The <code>bevy_core_pipeline</code> crate defines a set of <a href="gpu//TODO.html">standard
phase/item</a> and main pass types. If you can, you
should work with them, for best compatibility with the Bevy ecosystem.</p>
<h3 id="high-level"><a class="header" href="#high-level">High-Level</a></h3>
<p>On top of all the mid-level APIs, Bevy provides abstractions to make many
common kinds of workloads easier.</p>
<p>The most notable higher-level features are <a href="gpu//TODO.html">meshes</a> and
<a href="gpu//TODO.html">materials</a>.</p>
<p>Meshes are the source of per-vertex data (<a href="gpu//TODO.html">vertex
attributes</a>) to be fed into
your <a href="gpu//TODO.html">shaders</a>. The material specifies what
<a href="gpu//TODO.html">shaders</a> to use and any other data that needs to be
fed into it, like <a href="gpu//TODO.html">textures</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="gpu//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="render-stages"><a class="header" href="#render-stages">Render Stages</a></h1>
<p>Everything on the CPU side (the whole process of driving the GPU workloads)
is structured in a sequence of "render stages":</p>
<p>è¿™é‡Œçš„æ¸²æŸ“é˜¶æ®µéƒ½æ˜¯æŒ‡åœ¨CPUç«¯å‘ç”Ÿçš„,ç”¨äºé©±åŠ¨GPUå·¥ä½œä»»åŠ¡.</p>
<h2 id="timings"><a class="header" href="#timings">Timings</a></h2>
<p>Note: Pipelined rendering is not yet actually enabled in Bevy 0.9. This section
explains the intended behavior, which will land in a future Bevy version. You
have to understand it, because any custom rendering code you write will have to
work with it in mind.</p>
<p><img src="gpu/../img/pipelined-rendering.png" alt="Diagram of pipelined rendering timings in app-bound and render-bound cases" /></p>
<p>Every frame, <a href="gpu/stages.html#extract">Extract</a> serves as the synchronization point.</p>
<p>When the Render Schedule completes, it will start again, but Extract will
wait for the App Schedule, if it has not completed yet. The App Schedule
will start again as soon as Extract has completed.</p>
<p>Therefore:</p>
<ul>
<li>in an App-bound scenario (if app takes longer than render):
<ul>
<li>The start of Extract is waiting for App to finish</li>
</ul>
</li>
<li>in a Render-bound scenario (if render takes longer than app):
<ul>
<li>The start of App is waiting for Extract to finish</li>
</ul>
</li>
</ul>
<p>If <a href="gpu//window/props.html#vsync">vsync</a> is enabled, the wait for the next refresh of the
screen will happen in the <a href="gpu/stages.html#prepare">Prepare</a> stage. This has the effect of
prolonging the Prepare stage in the Render schedule. Therefore, in practice,
your game will behave like the "Render-bound" scenario shown above.</p>
<p>The final render (the framebuffer with the pixels to show in the
<a href="gpu//window/props.html">window</a>) is <em>presented</em> to the OS/driver at the end of the
<a href="gpu/stages.html#render">Render</a> stage.</p>
<p>Bevy updates its <a href="gpu//fundamentals/time.html">timing information</a> (in <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a>)
at the start of the First stage in the main App schedule. The value to
use is measured at "presentation time", in the render world, and the
<a href="https://doc.rust-lang.org/stable/std/time/struct.Instant.html"><code>Instant</code></a> is sent over a channel, to be applied on the
next frame.</p>
<p>æœ¬ç¯‡å†™çš„æ˜¯bevy v0.9æ—¶ä»£,é‚£æ—¶ç®¡é“æ¸²æŸ“è¿˜æ²¡æœ‰enable,åç»­ç‰ˆæœ¬ä¼šå¯ç”¨.
åªè¦æ˜¯å†™è‡ªå®šä¹‰æ¸²æŸ“çš„,éœ€è¦æ˜ç™½æœ¬æ–‡çš„å…¨éƒ¨.</p>
<p>åŒæ­¥ç‚¹:åœ¨æ¯å¸§ä¸­,ä¸ç®¡æ˜¯app worldå’Œrender worldå“ªä¸ªè¿è¡Œæ—¶é—´é•¿,ä»¥é•¿çš„ä¸ºå•ä½,
ç»“æŸåéƒ½ä¼šæ‰§è¡Œ<code>å¤–éƒ¨è°ƒåº¦</code>,åœ¨å¤–éƒ¨è°ƒåº¦é˜¶æ®µä¼šå°†appæ•°æ®åŒæ­¥åˆ°renderä¸­,è¿™ä¸ªç‚¹å°±æ˜¯åŒæ­¥ç‚¹.</p>
<p>åŒæ­¥ç‚¹ä¹‹å‰æ˜¯æ¸¸æˆé€»è¾‘æ‰§è¡Œ;ä¹‹åæ˜¯æ¸²æŸ“.ä¸¤ä¸ªåŒæ­¥ç‚¹é—´æ˜¯appé€»è¾‘å’Œä¸Šå¸§çš„æ¸²æŸ“é€»è¾‘å¹¶è¡Œæ‰§è¡Œ.</p>
<p>å¦‚æœå¯ç”¨äº†å‚ç›´åŒæ­¥,åˆ™ç­‰å¾…å±å¹•çš„ä¸‹ä¸€æ¬¡åˆ·æ–°å°†å‘ç”Ÿåœ¨å‡†å¤‡é˜¶æ®µ.
è¿™ä¼šå»¶é•¿æ¸²æŸ“è®¡åˆ’ä¸­çš„å‡†å¤‡é˜¶æ®µ.å®é™…çœ‹èµ·æ¥renderæ—¶é•¿(æ¯å¸§è¿è¡ŒèŠ±è´¹æ—¶é—´)ä¼šè¢«appæ—¶é•¿è¦é•¿.</p>
<p>æœ€ç»ˆçš„æ¸²æŸ“æ˜¯è®©OS/æ˜¾å¡é©±åŠ¨æ¥å‘ˆç°çš„.</p>
<p>å‚ä¸åˆ°<code>æ¸²æŸ“</code>çš„é˜¶æ®µå¾ˆå¤š,ç¬¬ä¸€æ­¥å°±æ˜¯è®¡ç®—renderæ—¶é•¿å’Œappæ—¶é•¿,
bevyä¼šå°†æ¯å¸§çš„æ—¶é—´ä¿¡æ¯æ”¾åˆ°<code>Time</code>èµ„æºä¸­,è¿™ä¸ªåŠ¨ä½œæ˜¯åœ¨appçš„Mainè°ƒåº¦ä¸­å®Œæˆçš„.
åœ¨render worldä¸­,è¿™ä¸ªå€¼ç”¨äºè®¡ç®—æ¯å¸§æ¸²æŸ“æ—¶é•¿,
è¿™ä¸ªä¿¡æ¯æ”¾åœ¨Instant(å¯¹å•è°ƒéé€’å‡æ—¶é’Ÿçš„æµ‹é‡)ä¸­, é€šè¿‡é€šé“å‘ç»™bevy,åº”ç”¨åœ¨ä¸‹ä¸€å¸§.</p>
<h2 id="adding-systems-to-render-stages"><a class="header" href="#adding-systems-to-render-stages">Adding Systems to Render Stages</a></h2>
<p>If you are implementing custom rendering functionality in Bevy, you will likely
need to add some of your own systems to at least some of the render stages:</p>
<ul>
<li>
<p>Anything that needs data from your main App World will need a system in
<a href="gpu/stages.html#extract">Extract</a> to copy that data. In practice, this is almost everything,
unless it is fully contained on the GPU, or only uses renderer-internal
generated data.</p>
</li>
<li>
<p>Most use cases will need to do some setup of GPU resources
in <a href="gpu/stages.html#prepare">Prepare</a> and/or <a href="gpu/stages.html#queue">Queue</a>.</p>
</li>
<li>
<p>In <a href="gpu/stages.html#cleanup">Cleanup</a>, all <a href="gpu//programming/intro-data.html#entities--components">entities</a> are cleared automatically.
If you have some custom data stored in <a href="gpu//programming/res.html">resources</a>, you can let it
stay for the next frame, or add a system to clear it, if you want.</p>
</li>
</ul>
<p>The way Bevy is set up, you shouldn't need to do anything in <a href="gpu/stages.html#render">Render</a>
or <a href="gpu/stages.html#phasesort">PhaseSort</a>. If your custom rendering is part of the Bevy
<a href="gpu//TODO.html">render graph</a>, it will just be handled automatically
when Bevy executes the render graph in the <a href="gpu/stages.html#render">Render</a> stage. If you
are implementing custom <a href="gpu//TODO.html">phase items</a>, the Main Pass
render graph node will render them together with everything else.</p>
<p>You can add your rendering systems to the respective stages, using the render
<a href="gpu//programming/app-builder.html#sub-apps">sub-app</a>:</p>
<pre><code>// TODO: code example
</code></pre>
<p>bevyé»˜è®¤çš„æ¸²æŸ“å·²ç»å°†è¯¥æœ‰çš„systemæ·»åŠ åˆ°äº†å¯¹åº”çš„è°ƒåº¦ä¸­,
å¦‚æœæœ‰è‡ªå®šä¹‰æ¸²æŸ“çš„åŠŸèƒ½,éœ€è¦å°†è¿™äº›systemæ·»åŠ åˆ°å¦‚ä¸‹è°ƒåº¦ä¸­:</p>
<ul>
<li>è¦ä»appä¼ æ•°æ®åˆ°renderçš„,éœ€è¦åœ¨å¤–éƒ¨è°ƒåº¦ä¸­æ·»åŠ æ‹·è´æ•°æ®çš„system</li>
<li>éƒ¨åˆ†åœºæ™¯è¿˜éœ€è¦åœ¨æ¸²æŸ“çš„Prepareå‡†å¤‡é˜¶æ®µæˆ–æ¸²æŸ“ä»»åŠ¡é˜Ÿåˆ—é˜¶æ®µæ„é€ GPUèµ„æº</li>
<li>åœ¨æ¸²æŸ“æ¸…ç†é˜¶æ®µ,æ‰€æœ‰å®ä½“ä¼šè‡ªåŠ¨æ¸…ç†æ‰.å¦‚æœæœ‰è‡ªå®šä¹‰æ•°æ®å­˜å‚¨åœ¨èµ„æºä¸­,æŒ‰éœ€æ¸…é™¤</li>
</ul>
<p>åœ¨å®é™…çš„æ¸²æŸ“Renderé˜¶æ®µå’Œæ’åºPhaseSorté˜¶æ®µ,ä¸éœ€è¦æˆ‘ä»¬ä»‹å…¥.</p>
<h2 id="extract"><a class="header" href="#extract">Extract</a></h2>
<p>Extract is a very important and special stage. It is the synchronization
point that links the two ECS Worlds. This is where the data required for
rendering is copied ("extracted") from the main App World into the Render
World, allowing for pipelined rendering.</p>
<p>During the Extract stage, nothing else can run in parallel, on either the
main App World or the Render World. Hence, Extract should be kept minimal
and complete its work as quickly as possible.</p>
<p>It is recommended that you avoid doing any computations in Extract, if
possible. Just copy data.</p>
<p>It is recommended that you only copy the data you actually need for rendering.
Create new <a href="gpu//programming/ec.html#components">component types</a> and <a href="gpu//programming/res.html">resources</a> just
for use within the render World, with only the data you need.</p>
<p>For example, Bevy's 2D sprites uses a <a href="https://docs.rs/bevy/0.9.1/bevy/sprite/struct.ExtractedSprite.html"><code>struct ExtractedSprite</code></a>, where it copies the relevant data
from the "user-facing" components of sprite and spritesheet entities in the
main World.</p>
<p>Bevy <strong>reserves Entity IDs</strong> in the render World, matching all the Entities
existing in the main World. In most cases, you do not need to <em>spawn</em>
new entities in the render World. You can just <a href="gpu//programming/commands.html">insert components with
Commands</a> on the same Entity IDs as from the main World.</p>
<pre><code>// TODO: code example
</code></pre>
<p>å¤–éƒ¨è°ƒåº¦è´Ÿè´£åŒæ­¥æ•°æ®åˆ°render world.</p>
<h2 id="prepare"><a class="header" href="#prepare">Prepare</a></h2>
<p>Prepare is the stage to use if you need to set up any data on the
GPU. This is where you can create GPU <a href="gpu//TODO.html">buffers</a>,
<a href="gpu//TODO.html">textures</a>, and <a href="gpu//TODO.html">bind groups</a>.</p>
<p>// TODO: elaborate on different ways Bevy is using it internally</p>
<pre><code>// TODO: code example
</code></pre>
<p>å‡†å¤‡é˜¶æ®µ,å¯ä»¥æ„é€ GPUè¦ä½¿ç”¨çš„æ•°æ®.</p>
<h2 id="queue"><a class="header" href="#queue">Queue</a></h2>
<p>Queue is the stage where you can set up the "rendering jobs" you will need to
execute.</p>
<p>Typically, this means creating <a href="gpu//TODO.html">phase items</a>
with the correct <a href="gpu//TODO.html">render pipeline</a> and <a href="gpu//TODO.html">draw
function</a>, for everything that you need to draw.</p>
<p>For other things, analogously, Queue is where you would set up the workloads
(like compute or draw calls) that the GPU would need to perform.</p>
<p>// TODO: elaborate on different ways Bevy is using it internally</p>
<pre><code>// TODO: code example
</code></pre>
<p>å…¥é˜Ÿé˜¶æ®µ,å¯ä»¥æ„é€ è¦æ‰§è¡Œçš„æ¸²æŸ“ä»»åŠ¡.</p>
<h2 id="phasesort"><a class="header" href="#phasesort">PhaseSort</a></h2>
<p>This stage exists for Bevy to sort all of the <a href="gpu//TODO.html">phase
items</a> that were set up during the <a href="gpu/stages.html#queue">Queue</a>
stage, before rendering in the <a href="gpu/stages.html#render">Render</a> stage.</p>
<p>It is unlikely that you will need to add anything custom here. I'm not aware
of use cases. <a href="gpu//contact.html">Let me know</a> if you know of any.</p>
<p>æ’åºé˜¶æ®µ:å¯¹æ‰€æœ‰å·²è§£æçš„æ¸²æŸ“ä»»åŠ¡(å…¥é˜Ÿé˜¶æ®µæ·»åŠ çš„æ¸²æŸ“ä»»åŠ¡)è¿›è¡Œæ’åº.</p>
<h2 id="render"><a class="header" href="#render">Render</a></h2>
<p>Render is the stage where Bevy executes the <a href="gpu//TODO.html">Render Graph</a>.</p>
<p>The built-in behavior is configured using Cameras. For each active Camera,
Bevy will execute its associated render graph, configured to output to its
associated render target.</p>
<p>If you are using any of the <a href="gpu//TODO.html">standard render phases</a>,
you don't need to do anything. Your custom <a href="gpu//TODO.html">phase items</a>
will be rendered automatically as part of the Main Pass built-in render graph
<a href="gpu//TODO.html">nodes</a>, alongside everything else.</p>
<p>If you are implementing a rendering feature that needs a separate step, you
can add it as a <a href="gpu//TODO.html">render graph node</a>, and it will be
rendered automatically.</p>
<p>The only time you might need to do something custom here is if you really
want to sidestep Bevy's frameworks and reach for low-level <code>wgpu</code> access.
You could place it in the Render stage.</p>
<p>å®é™…æ¸²æŸ“é˜¶æ®µ,ç”±bevyæŒ‰æ¸²æŸ“å›¾æ‰§è¡Œ.</p>
<p>è¿™é‡Œä¼šæ ¹æ®ç›¸æœºé…ç½®æ¥è¿›è¡Œæ¸²æŸ“,æ¯ä¸ªç›¸æœºéƒ½æœ‰è‡ªå·±çš„æ¸²æŸ“å›¾,
bevyä¼šå¯¹æ¯ä¸ªæ¸²æŸ“å›¾è¿›è¡Œæ“ä½œ,ä¹‹åå°†ç»“æœè¾“å‡ºåˆ°ç›¸æœºé…ç½®çš„æ¸²æŸ“ç›®æ ‡ä¸Š.</p>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>Bevy has a built-in system in Cleanup that clears all <a href="gpu//programming/intro-data.html#entities--components">entities</a> in
the render World. Therefore, all data stored in components will be lost.
It is expected that fresh data will be obtained in the next frame's
<a href="gpu/stages.html#extract">Extract</a> stage.</p>
<p>To persist rendering data over multiple frames, you should store it in
<a href="gpu//programming/res.html">resources</a>. That way you have control over it.</p>
<p>If you need to clear some data from your resources sometimes, you could
add a custom system to the Cleanup stage to do it.</p>
<pre><code>// TODO: code example
</code></pre>
<p>æ¸…ç†é˜¶æ®µ. æœ‰è‡ªå®šæ•°æ®å­˜åœ¨èµ„æºä¸­è¦æ¸…ç†çš„,åœ¨è¿™ä¸ªé˜¶æ®µæ¸…ç†.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="programming-patterns"><a class="header" href="#programming-patterns">Programming Patterns</a></h1>
<p>This chapter is about any non-obvious tricks, programming techniques,
patterns and idioms, that may be useful when programming with Bevy.</p>
<p>These topics are an extension of the topics covered in the <a href="/programming.html">Bevy Programming
Framework</a> chapter. See that chapter to learn the
foundational concepts.</p>
<p>Some of the things covered in this chapter might be controversial or only useful
to specific use cases. Don't take this chapter as teaching "general best
practice".</p>
<p>è¿™é‡Œä»‹ç»çš„æ˜¯ä¸€äº›bevyå¸¸ç”¨çš„èŠ±æ‹›/ç¼–ç¨‹æŠ€æœ¯/æ³›å¼/ä¹ æƒ¯.
è¿™ä¸æ˜¯é€‚åˆæ¯ä¸ªåœºæ™¯çš„,éƒ½æ˜¯é’ˆå¯¹ç‰¹æ®Šåœºæ™¯çš„ä¸€äº›ä¼˜è§£,åœ¨å…¶ä»–åœºæ™¯å¯èƒ½å°±ä¸è¡Œäº†.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="generic-systems"><a class="header" href="#generic-systems">Generic Systems</a></h1>
<p>Bevy <a href="patterns//programming/systems.html">systems</a> are just plain rust functions, which means they
can be generic. You can add the same system multiple times, parametrized to
work on different Rust types or values.</p>
<p>bevyçš„systemæ˜¯å‡½æ•°,å¯ä»¥è¿›è¡Œæ³›åŒ–,è¿™æ ·å¯ä»¥å¤šæ¬¡æ·»åŠ system,æ”¯æŒå…·ä½“ç±»å‹æœ‰å·®å¼‚è€Œå·².</p>
<h2 id="generic-over-component-types"><a class="header" href="#generic-over-component-types">Generic over Component types</a></h2>
<p>You can use the generic type parameter to specify what
<a href="patterns//programming/ec.html#components">component</a> types (and hence what <a href="patterns//programming/ecs-intro.html">entities</a>)
your <a href="patterns//programming/systems.html">system</a> should operate on.</p>
<p>This can be useful when combined with Bevy <a href="patterns//programming/states.html">states</a>.
You can do the same thing to different sets of entities depending on state.</p>
<p>ç»„ä»¶ç±»å‹æ³›åŒ–,å‰ææ˜¯systemèƒ½æ”¯æŒæ³›åŒ–çš„ç»„ä»¶.</p>
<p>ç»“åˆstate,å¯å¯¹ä¸åŒstateçš„å®ä½“åšåŒæ ·çš„äº‹.</p>
<h3 id="example-cleanup"><a class="header" href="#example-cleanup">Example: Cleanup</a></h3>
<p>One straightforward use-case is for cleanup. We can make a generic cleanup
system that just despawns all entities that have a certain component
type. Then, trivially run it on exiting different states.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::component::Component;

fn cleanup_system&lt;T: Component&gt;(
    mut commands: Commands,
    q: Query&lt;Entity, With&lt;T&gt;&gt;,
) {
    for e in q.iter() {
        commands.entity(e).despawn_recursive();
    }
}</code></pre>
<p>Menu entities can be tagged with <code>cleanup::MenuExit</code>, entities from the game
map can be tagged with <code>cleanup::LevelUnload</code>.</p>
<p>We can add the generic cleanup system to our state transitions, to take care
of the respective entities:</p>
<pre><code class="language-rust no_run noplayground">/// Marker components to group entities for cleanup
mod cleanup {
    use bevy::prelude::*;
    #[derive(Component)]
    pub struct LevelUnload;
    #[derive(Component)]
    pub struct MenuClose;
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_state(AppState::MainMenu)
        // add the cleanup systems
        .add_system_set(SystemSet::on_exit(AppState::MainMenu)
            .with_system(cleanup_system::&lt;cleanup::MenuClose&gt;))
        .add_system_set(SystemSet::on_exit(AppState::InGame)
            .with_system(cleanup_system::&lt;cleanup::LevelUnload&gt;))
        .run();
}</code></pre>
<h2 id="using-traits"><a class="header" href="#using-traits">Using Traits</a></h2>
<p>You can use this in combination with Traits, for when you need some sort of
varying implementation/functionality for each type.</p>
<p>æ³›å‹systemå¯ä»¥ç»“åˆç‰¹å‹.</p>
<h3 id="example-bevys-camera-projections"><a class="header" href="#example-bevys-camera-projections">Example: Bevy's Camera Projections</a></h3>
<p>(this is a use-case within Bevy itself)</p>
<p>Bevy has a <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/trait.CameraProjection.html"><code>CameraProjection</code></a> trait. Different
projection types like <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>
and <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> implement that
trait, providing the correct logic for how to respond to resizing the window,
calculating the projection matrix, etc.</p>
<p>There is a generic system <code>fn camera_system::&lt;T: CameraProjection + Component&gt;</code>, which handles all the cameras with a given projection type. It
will call the trait methods when appropriate (like on window resize events).</p>
<p>The <a href="patterns//cookbook/custom-projection.html">Bevy Cookbook Custom Camera Projection
Example</a> shows this API in action.</p>
<p>ç›¸æœºæŠ•å½±æ˜¯ç‰¹å‹,æ­£äº¤/é€è§†æ˜¯ä¸¤ä¸ªå®ç°,systemçš„æ³›åŒ–å‚æ•°å¯ä»¥æŒ‡å®šä¸ºç‰¹å‹,
è°ƒåº¦æ·»åŠ systemæ—¶å†å†³å®šå…·ä½“ç±»å‹,æå¤§æé«˜äº†çµæ´»æ€§.</p>
<h2 id="using-const-generics"><a class="header" href="#using-const-generics">Using Const Generics</a></h2>
<p>Now that Rust has support for Const Generics, functions can also be
parametrized by values, not just types.</p>
<pre><code class="language-rust no_run noplayground">fn process_layer&lt;const LAYER_ID: usize&gt;(
    // system params
) {
    // do something for this `LAYER_ID`
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(process_layer::&lt;1&gt;)
        .add_system(process_layer::&lt;2&gt;)
        .add_system(process_layer::&lt;3&gt;)
        .run();
}</code></pre>
<p>Note that these values are static / constant at compile-time. This can be
a severe limitation. In some cases, when you might suspect that you could
use const generics, you might realize that you actually want a runtime value.</p>
<p>If you need to "configure" your system by passing in some data, you could,
instead, use a <a href="patterns//programming/res.html">Resource</a> or <a href="patterns//programming/local.html">Local</a>.</p>
<p>Note: As of Rust 1.65, support for using <code>enum</code> values as const generics is
not yet stable. To use <code>enum</code>s, you need Rust Nightly, and to enable the
experimental/unstable feature (put this at the top of your <code>main.rs</code> or
<code>lib.rs</code>):</p>
<pre><code class="language-rust no_run noplayground">#![feature(adt_const_params)]</code></pre>
<p>å¸¸é‡æ³›åŒ–,ä½¿ç”¨constä¿®é¥°,ç¼–è¯‘æœŸä¼šå°†å¸¸é‡å’Œsystemç»‘å®šåœ¨ä¸€èµ·.
å’Œé…ç½®ä¸åŒ,å¸¸é‡æ³›åŒ–æ˜¯ä»£ç ä¸­çš„ç¡¬ç¼–ç ,å› ä¸ºæ˜¯å¸¸é‡æ‰€ä»¥è¿è¡ŒæœŸä¸èƒ½ä¿®æ”¹.</p>
<p>å¦‚æœæ˜¯é…ç½®,ä¸€æ ·å¯ä»¥å°†æ•°æ®ä¼ é€’ç»™system,ä¸åŒçš„åœºæ™¯å¯ä»¥ä½¿ç”¨ä¸åŒçš„å®ç°æ–¹æ¡ˆ.
é…ç½®å¯ä»¥å­˜æ”¾åœ¨èµ„æºæˆ–localä¸­.</p>
<p>ä»rust v1.65å¼€å§‹å°±æ”¯æŒäº†enum,è¿™ä¹Ÿæ˜¯ä¸ªéå¸¸çµæ´»çš„ç‹ è§’è‰²,
ç”¨enumä½œä¸ºå¸¸é‡æ³›åŒ–è¿˜ä¸ç¨³å®š,ä½†ç°åœ¨bevyéƒ½æ˜¯v0.14äº†,å¤§å¤šä¾‹å­éƒ½æ˜¯enum.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="component-storage-tablesparse-set"><a class="header" href="#component-storage-tablesparse-set">Component Storage (Table/Sparse-Set)</a></h1>
<p>Bevy ECS provides two different ways of storing data: tables and sparse sets.
The two storage kinds offer different performance characteristics.</p>
<p>The kind of storage to be used can be chosen per <a href="patterns//programming/ec.html#components">component</a>
type.  When you derive the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait, you can
specify it. The default, if unspecified, is table storage. You can have
components with a mixture of different storage kinds on the same entity.</p>
<p>The rest of this page is dedicated to explaining the performance trade-offs
and why you might want to choose one storage kind vs. the other.</p>
<pre><code class="language-rust no_run noplayground">/// Component for entities that can cast magic spells
#[derive(Component)] // Use the default table storage
struct Mana {
    mana: f32,
}

/// Component for enemies that currently "see" the player
/// Every frame, add/remove to entities based on visibility
/// (use sparse-set storage due to frequent add/remove)
#[derive(Component)]
#[component(storage = "SparseSet")]
struct CanSeePlayer;

/// Component for entities that are currently taking bleed damage
/// Add to entities to apply bleed effect, remove when done
/// (use sparse-set storage to not fragment tables,
/// as this is a "temporary effect")
#[derive(Component)]
#[component(storage = "SparseSet")]
struct Bleeding {
    damage_rate: f32,
}</code></pre>
<p>bevyçš„ecsæ”¯æŒä¸¤ç§ä¸åŒçš„å­˜å‚¨:è¡¨æ ¼å’Œç¨€ç–é›†.
æ¯ç§ç»„ä»¶ç±»å‹éƒ½å¯ä»¥é€‰æ‹©è‡ªå·±çš„å­˜å‚¨ç±»å‹.é»˜è®¤æ˜¯è¡¨æ ¼.
åŒä¸€ä¸ªå®ä½“æ˜¯å¯ä»¥åŒæ—¶ä½¿ç”¨ä¸åŒå­˜å‚¨çš„.</p>
<h2 id="table-storage"><a class="header" href="#table-storage">Table Storage</a></h2>
<p>Table storage is optimized for fast <a href="patterns//programming/queries.html">query</a> iteration. If the
way you usually use a specific component type is to iterate over its data
across many entities, this will offer the best performance.</p>
<p>However, adding/removing table components to existing entities is a relatively
slow operation. It requires copying the data of all table components for
the entity to a different location in memory.</p>
<p>It's OK if you have to do this sometimes, but if you are likely to add/remove
a component very frequently, you might want to switch that component type
to sparse-set storage.</p>
<p>You can see why table storage was chosen as Bevy's default. Most component
types are rarely added/removed in practice. You typically spawn entities with
all the components they should have, and then access the data via queries,
usually every frame. Sometimes you might add or remove a component to change
an entity's behavior, but probably not nearly as often, or every frame.</p>
<p>è¡¨æ ¼å­˜å‚¨çš„ç‰¹ç‚¹æ˜¯è¿­ä»£æŸ¥è¯¢éå¸¸å¿«.è¿™ç§æ¨¡å¼ä¸‹å¢åˆ å¾ˆæ…¢,å› ä¸ºæ¶‰åŠåˆ°æ‰€æœ‰è¡¨æ ¼æ•°æ®çš„ç§»åŠ¨.
é¢‘ç¹å¢åˆ ä½¿ç”¨è¡¨æ ¼å­˜å‚¨å°±æ˜¯ç¾éš¾.</p>
<p>é»˜è®¤å°±æ˜¯è¡¨æ ¼å­˜å‚¨,å› ä¸ºå¤§å¤šæ•°åœºæ™¯ä¸‹,åŠ¨æ€å¢åˆ æ˜¯ä¸€ä¸ªä½é¢‘æ“ä½œ.</p>
<h2 id="sparse-set-storage"><a class="header" href="#sparse-set-storage">Sparse-Set Storage</a></h2>
<p>Sparse-Set storage is optimized for fast adding/removing of a component to
existing entities, at the cost of slower querying. It can be more efficient
for components that you would like to add/remove very frequently.</p>
<p>An example of this might be a <a href="patterns//programming/ec.html#marker-components">marker component</a>
indicating whether an enemy is currently aware of the player. You might
want to have such a component type, so that you can easily use a <a href="patterns//programming/queries.html#query-filters">query
filter</a> to find all the enemies that are currently
tracking the player. However, this is something that can change every frame,
as enemies or the player move around the game level. If you add/remove this
component every time the visibility status changed, that's a lot of additions
and removals.</p>
<p>You can see that situations like these are more niche and do not apply
to most typical component types. Treat sparse-set storage as a potential
optimization you could try in specific circumstances.</p>
<p>Even in situations like the example above, it might not be a performance win.
Everything depends on your application's unique usage patterns. You have to
measure and try.</p>
<p>ç¨€ç–é›†å­˜å‚¨å°±æ˜¯å¢åˆ éå¸¸å¿«,queryæ…¢.</p>
<p>å¦‚æœç»„ä»¶å°±æ˜¯ä¸´æ—¶æ€§çš„,é¢‘ç¹å¢åˆ ,å°±ä½¿ç”¨è¿™ä¸ª.</p>
<p>ä½¿ç”¨å­˜å‚¨æ¥æé«˜æ€§èƒ½,è¿˜ä¸å¦‚ä¼˜åŒ–æ¸¸æˆé€»è¾‘æ¥å¾—å¿«.</p>
<h2 id="table-fragmentation"><a class="header" href="#table-fragmentation">Table Fragmentation</a></h2>
<p>Furthermore, the actual memory layout of the "tables" depends on the set of
all table components that each of your entities has.</p>
<p>ECS queries perform best when many of the entities they match have the same
overall set of components.</p>
<p>Having a large number of entities, that all have the same component types, is
very efficient in terms of data access performance. Having diverse entities
with a varied mixture of different component types, means that their data
will be fragmented in memory and be less efficient to access.</p>
<p>Sparse-Set components do not affect the memory layout of tables. Hence,
components that are only used on a few entities or as a "temporary effect",
might also be good candidates for sparse-set storage. That way they don't
fragment the memory of the other (table) components. Systems that do not
care about these components will be completely unaffected by them existing.</p>
<p>å¦‚æœå¤§é‡å®ä½“éƒ½æœ‰æŸä¸ªç»„ä»¶,æŒ‰è¿™ä¸ªç»„ä»¶æŸ¥è¯¢,æ•ˆç‡ä¼šéå¸¸é«˜.</p>
<p>å¤§é‡ä¸è¿ç»­çš„å®ä½“,æ€§èƒ½å°±åªèƒ½é€€åŒ–ä¸ºæ™®é€šçš„äº†.</p>
<h2 id="overall-advice"><a class="header" href="#overall-advice">Overall Advice</a></h2>
<p>While this page describes the general performance characteristics and gives
some guidelines, you often cannot know if something improves performance
without benchmarking.</p>
<p>When your game grows complex enough and you have something to benchmark,
you could try to apply sparse-set storage to situations where it might make
sense, as described above, and see how it affects your results.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="manual-event-clearing"><a class="header" href="#manual-event-clearing">Manual Event Clearing</a></h1>
<p>The <a href="patterns//programming/events.html">event</a> queue needs to be cleared periodically,
so that it does not grow indefinitely and waste unbounded memory.</p>
<p>Bevy's default cleanup strategy is to clear events every frame, but with double
buffering, so that events from the previous frame update stay available. This
means that you can handle the events only until the end of the next frame
after the one when they are sent.</p>
<p>This default works well for systems that run every frame and check for events
every time, which is the typical usage pattern.</p>
<p>However, if you have systems that do not read events every frame, they might
miss some events. Some common scenarios where this occurs are:</p>
<ul>
<li>systems with an early-return, that don't read events every time they run</li>
<li>when using <a href="patterns//fundamentals/fixed-timestep.html">fixed timestep</a></li>
<li>systems that only run in specific <a href="patterns//programming/states.html">states</a>,
such as if your game has a pause state</li>
<li>when using custom <a href="patterns//programming/run-criteria.html">run criteria</a> to control
your systems</li>
</ul>
<p>To be able to reliably manage events in such circumstances, you might want
to have manual control over how long the events are held in memory.</p>
<p>You can replace Bevy's default cleanup strategy with your own.</p>
<p>To do this, simply add your event type (wrapped as <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a>)
to the <a href="patterns//programming/app-builder.html">app builder</a> using <code>.init_resource</code>, instead of <code>.add_event</code>.</p>
<p>(<code>.add_event</code> is actually just a convenience method that initializes the
<a href="patterns//programming/res.html">resource</a> and adds Bevy's built-in system (<a href="patterns//patterns/generic-systems.html">generic</a>
over your event type) for the default cleanup strategy)</p>
<p>You must then clear the events at your discretion. If you don't do this often
enough, your events might pile up and waste memory.</p>
<p>æ‰‹åŠ¨æ¸…ç†äº‹ä»¶,äº‹ä»¶é˜Ÿåˆ—ä¼šå®šæ—¶æ¸…ç†,æ‰€ä»¥ä¸ç”¨æ‹…å¿ƒå†…å­˜æ³„æ¼.</p>
<p>bevyæ˜¯é»˜è®¤æ¯å¸§éƒ½æ¸…ç†äº‹ä»¶,å•å› ä¸ºæ‰§è¡Œé¡ºåº,å¯èƒ½éƒ¨åˆ†äº‹ä»¶ä¼šè·¨ä¸¤å¸§.
è¦å¤„ç†äº‹ä»¶å°±å¿…é¡»åœ¨ä¸‹å¸§ç»“æŸä¹‹å‰å¤„ç†.</p>
<p>åŒç†,å¤„ç†äº‹ä»¶æœ€å¥½æ¯å¸§éƒ½æ‰§è¡Œ,ä½†å¾ˆå¤šåœºæ™¯ä¸‹å¹¶ä¸æ˜¯æ¯å¸§éƒ½æ‰§è¡Œæ£€æµ‹.</p>
<ul>
<li>å›ºå®šæ—¶é—´æˆ³</li>
<li>systemåœ¨æ£€æµ‹é€»è¾‘ä¹‹å‰æå‰è¿”å›äº†</li>
<li>systemåªåœ¨ç‰¹å®šstateè¿è¡Œ</li>
<li>systemæœ‰è¿è¡Œæ¡ä»¶</li>
</ul>
<p>åœ¨ä¸Šé¢çš„åœºæ™¯ä¸­,éœ€è¦æ‰‹åŠ¨æ§åˆ¶äº‹ä»¶çš„æ¸…ç†.bevyæä¾›äº†ä¾¿æ·çš„æ–¹æ³•:
åœ¨appä¸­ç”¨åˆå§‹åŒ–èµ„æºä»£æ›¿æ·»åŠ äº‹ä»¶,å‚æ•°ä¸ºèµ„æº(å…·ä½“ç±»å‹æ˜¯äº‹ä»¶),
bevyè¯†åˆ«åˆ°å,çŸ¥é“é‡åˆ°è¿™ä¸ªäº‹ä»¶å°±ä¸¢åˆ°å¯¹åº”çš„èµ„æºä¸­.</p>
<p>ä¹‹åéœ€è¦æ‰‹åŠ¨æ¸…ç†äº‹ä»¶,ä¸ç„¶å°±ä¼šå‡ºç°å†…å­˜æ³„æ¼.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We can create <a href="patterns//patterns/generic-systems.html">generic systems</a> for this. Implement
the custom cleanup strategy, and then add that <a href="patterns//programming/systems.html">system</a> to your
<a href="https://docs.rs/bevy/0.9.1/bevy/app/struct.App.html"><code>App</code></a> as many times as you need, for each <a href="patterns//programming/events.html">event</a> type
where you want to use your custom behavior.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::event::Events;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // add the `Events&lt;T&gt;` resource manually
        // these events will not have automatic cleanup
        .init_resource::&lt;Events&lt;MySpecialEvent&gt;&gt;() // åˆå§‹åŒ–èµ„æº,å…¥å‚ä¸ºäº‹ä»¶
        // this is a regular event type with automatic cleanup
        .add_event::&lt;MyRegularEvent&gt;()
        // add the cleanup systems
        .add_system(my_event_manager::&lt;MySpecialEvent&gt;) // äº‹ä»¶å¤„ç†
        .run();
}

/// Custom cleanup strategy for events
///
/// Generic to allow using for any custom event type
fn my_event_manager&lt;T: 'static + Send + Sync&gt;(mut events: ResMut&lt;Events&lt;T&gt;&gt;) {
    // TODO: implement your custom logic
    // for deciding when to clear the events

    // ä¸‹é¢æ˜¯äº‹ä»¶å¤„ç†
    // clear all events like this:
    events.clear();

    // or with double-buffering
    // (this is what Bevy's default strategy does)
    events.update();

    // or drain them, if you want to iterate,
    // to access the values:
    for event in events.drain() {
        // TODO: do something with each event
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-9-to-0-10/">0.9 to 0.10</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-10-to-0-11/">0.10 to 0.11</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-11-to-0-12/">0.11 to 0.12</a>,
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="writing-tests-for-systems"><a class="header" href="#writing-tests-for-systems">Writing Tests for Systems</a></h1>
<p>You might want to write and run automated tests for your <a href="patterns//programming/systems.html">systems</a>.</p>
<p>You can use the regular Rust testing features (<code>cargo test</code>) with Bevy.</p>
<p>To do this, you can create an empty ECS <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a> in your
tests, and then, using <a href="patterns//programming/world.html">direct World access</a>, insert whatever
<a href="patterns//programming/ec.html#entities">entities</a> and <a href="patterns//programming/res.html">resources</a> you need for testing. Create
a standalone <a href="patterns//programming/schedules.html">stage</a> with the <a href="patterns//programming/systems.html">systems</a> you want to
run, and manually run it on the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>Bevy's official repository has a fantastic <a href="https://github.com/bevyengine/bevy/blob/main/tests/how_to_test_systems.rs">example of how to do
this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="bevy-on-different-platforms"><a class="header" href="#bevy-on-different-platforms">Bevy on Different Platforms</a></h1>
<p>This chapter is a collection of platform-specific information, about using
Bevy with different operating systems or environments.</p>
<p>Feel free to suggest things to add.</p>
<p>æœ¬ç« ä»‹ç»ä¸€äº›ä¸åŒå¹³å°çš„ä¿¡æ¯.</p>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h2>
<p>Bevy aims to also make it easy to target different platforms, such as the
various desktop operating systems, web browsers (via WebAssembly), mobile
(Android and iOS), and game consoles. Your Bevy code can be the same for all
platforms, with differences only in the build process and environment setup.</p>
<p>However, that vision is not fully met yet. Currently, support for non-desktop
platforms is limited, and requires more complex configuration.</p>
<p>Bevyçš„ç›®çš„æ˜¯é’ˆå¯¹ä¸åŒçš„å¹³å°,è®©å…¶æ“ä½œç®€å•,
æ¯”å¦‚ä¸åŒçš„å°å¼æ“ä½œç³»ç»Ÿ/webæµè§ˆå™¨(é€šè¿‡WebAssembly)/ç§»åŠ¨ç«¯(Androidå’ŒiOS)/ä»¥åŠæ¸¸æˆæ§åˆ¶å°.</p>
<p>æ‰€æœ‰çš„å¹³å°ä¸Š,ä½ çš„Bevyä»£ç å¯ä»¥æ˜¯ä¸€æ ·çš„,é™¤äº†æ„å»ºè¿‡ç¨‹åŠç¯å¢ƒå¯åŠ¨æ—¶çš„å·®å¼‚.
ç„¶è€Œ, ç›®å‰ç‰ˆæœ¬è¿˜æ²¡æœ‰å®Œå…¨æ»¡è¶³ä¸Šé¢æƒ…å†µ.ç°åœ¨å¯¹éå°å¼æœºå¹³å°çš„æ”¯æŒæ—¶æœ‰é™çš„,
å¹¶ä¸”è¿˜è¦æ±‚æ›´å¤æ‚çš„é…ç½®.</p>
<h3 id="desktop"><a class="header" href="#desktop">Desktop</a></h3>
<p>Bevy trivially works out-of-the-box on the three major desktop operating
systems: Linux, macOS, Windows. No special configuration is required.</p>
<p>Bevyå·¥ä½œåœ¨ä¸‰ç§ä¸»æµçš„å°å¼æœºæ“ä½œç³»ç»Ÿ: Linux, macOS, Windows. ä¸éœ€è¦ç‰¹åˆ«çš„é…ç½®.</p>
<p>See the following pages for specific tips/advice when developing for the
desktop platforms:</p>
<ul>
<li><a href="/platforms/linux.html">Linux</a></li>
<li><a href="/platforms/macos.html">macOS</a></li>
<li><a href="/platforms/windows.html">Windows</a></li>
</ul>
<p>All Bevy features are fully supported on each of the above.</p>
<p>You can also build Windows EXEs for your Windows users, if you are working
in <a href="/setup/cross/linux-windows.html">Linux</a> or <a href="/setup/cross/macos-windows.html">macOS</a>.</p>
<p>æ¡Œé¢ç³»ç»Ÿ, Bevyçš„å…¨éƒ¨ç‰¹æ€§å‡è¢«æ”¯æŒ.
å¦‚æœä½ å·¥ä½œåœ¨linuxæˆ–MacOSä¸Š,ä½ ä¹Ÿå¯ä»¥ä¸ºWindowsç”¨æˆ·æ„å»ºWindows EXEs.</p>
<h3 id="web"><a class="header" href="#web">Web</a></h3>
<p>Bevy works quite well on the <a href="/platforms/wasm.html">web (using WebAssembly)</a>,
but with some limitations.</p>
<p>Multithreading is not supported, so you will have limited performance and
possible audio glitches. Rendering is limited to the features of the WebGL2
API, meaning worse performance and limitations like only supporting a maximum
of 256 lights in 3D scenes. These limitations can be lifted by enabling the
new WebGPU support, but then you will have limited browser compatibility.</p>
<p>For inspiration, check out the entries in the Bevy Game Jams
(<a href="https://itch.io/jam/bevy-jam-3/entries">third</a>, <a href="https://itch.io/jam/bevy-jam-2/entries">second</a>, <a href="https://itch.io/jam/bevy-jam-1/entries">first</a>). Many
of them have web builds you can play in your browser.</p>
<p>Bevyåœ¨webå¹³å°ä½¿ç”¨WebAssemblyè¿è¡Œå¾—å¾ˆå¥½,ä½†æ˜¯ä¹Ÿæœ‰ä¸€äº›é™åˆ¶.</p>
<p>ä¸æ”¯æŒå¤šçº¿ç¨‹,æ‰€ä»¥ä½ åªæœ‰é™å®šçš„æ€§èƒ½,å’Œå¯èƒ½çš„audio glitches(
éŸ³é¢‘æ•…éšœaudio glitché€šå¸¸æŒ‡éŸ³é¢‘æ’­æ”¾æˆ–å½•åˆ¶è¿‡ç¨‹ä¸­å‡ºç°çš„çŸ­æš‚/ä¸æ­£å¸¸çš„å£°éŸ³å¹²æ‰°).</p>
<p>æ¸²æŸ“å—é™äºWebGL2 APIçš„ç‰¹æ€§,è¿™æ„å‘³ç€æ›´ç³Ÿçš„æ€§èƒ½å’Œé™åˆ¶,æ¯”å¦‚åœ¨3Dåœºæ™¯ä¸­,
æœ€å¤§åªæ”¯æŒ256 lights.å¯ç”¨æ–°çš„WebGPUæ”¯æŒå,è¿™äº›é™åˆ¶èƒ½è¢«æ”¹å–„,
ä½†è¿™ä¹Ÿæ„å‘³ç€ä½ å°†æ‹¥æœ‰æœ‰é™çš„æµè§ˆå™¨å…¼å®¹æ€§.</p>
<h3 id="mobile"><a class="header" href="#mobile">Mobile</a></h3>
<p>Apple iOS is well-supported and most features work well. There are developers
in the Bevy community that have successfully shipped Bevy-based apps to the
App Store.</p>
<p>Android support is not as good as iOS, but very usable (as of Bevy 0.12). If
you find bugs, broken features, or other issues, please report them.</p>
<p>Bevy has been known to have issues with emulator devices. It is recommended
you test your app on real hardware.</p>
<p>å¾ˆå¥½åœ°æ”¯æŒApple iOS,å¾ˆå¤šç‰¹æ€§è¿è¡Œå¾—ä¸é”™.
Bevyç¤¾åŒºæœ‰äº›å¼€å‘è€…å·²ç»æˆåŠŸåœ°å°†åŸºäºBevyçš„appså‘å¸ƒåˆ°App Storeä¸Š.</p>
<p>Androidæ”¯æŒæ²¡æœ‰IOSé‚£ä¹ˆå¥½, ä½†ä¹Ÿæ˜¯å¯ç”¨çš„(å¦‚Bevy0.12)
æ®ç§°, Bevyåœ¨æ¨¡æ‹Ÿè®¾å¤‡ä¸Šæœ‰äº›é—®é¢˜. å»ºè®®ä½ åœ¨çœŸå®ç¡¬ä»¶ä¸Šæµ‹è¯•ä½ çš„app.</p>
<h3 id="game-consoles"><a class="header" href="#game-consoles">Game Consoles</a></h3>
<p>Unfortunately, due to NDA requirements, developing for consoles is inaccessible
to most community developers who work in the open, and Bevy support is still
mostly nonexistent.</p>
<p>At some point, there was someone in the community working on PlayStation
support. I do not know if they are still around, or anything about the
status of that work. If you are interested, join <a href="https://discord.gg/bevy">Discord</a>
and ask around. Maybe you can find each other and work together.</p>
<p>The Rust Programming Language aims to make Nintendo Switch a supported target,
but that work is in its early days and has not progressed enough to be useful
for Bevy yet. It should be possible to work on Nintendo Switch support in
the open, without NDAs, using emulators.</p>
<p>The Steam Deck, and other such "handheld PCs", are well supported. Such
devices run special versions of standard Desktop OSs (Linux, Windows) and are
designed to support PC games out of the box. To develop for these devices,
just make regular Linux/Windows builds of your game and ideally try them on
an actual device, so you can see how the handheld experience is like and make
sure your game feels good on such a device.</p>
<p>ä¸å¹¸çš„æ˜¯,ç”±äºNDAéœ€æ±‚(ä¿å¯†åè®®,Non-Disclosure Agreement),
å¯¹äºå¾ˆå¤šå¼€æ”¾ç¤¾åŒºçš„å¼€å‘è€…è€Œè¨€,åŸºäºæ§åˆ¶å°çš„ç ”å‘æ˜¯ä¸å¯è·å¾—çš„.</p>
<p>Rustç¼–ç¨‹è¯­è¨€è‡´åŠ›äºæ”¯æŒNintendo Switch,ä½†æ˜¯å·¥ä½œè¿›å±•ä»ç„¶åœç•™åœ¨æ—©æœŸé˜¶æ®µ,
å¹¶æ²¡æœ‰å¤ªå¤šçš„è¿›å±•,ä½¿å…¶å¯ç”¨äºBevy.</p>
<p>Steam Deckå’Œå…¶ä»–çš„ä¸€äº›æ‰‹æŸ„PCs,è¢«å¾ˆå¥½åœ°æ”¯æŒ.
è¿™äº›è®¾å¤‡è¿è¡Œåœ¨ç‰¹å®šç‰ˆæœ¬çš„æ¡Œé¢OSså†….</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="linux-desktop"><a class="header" href="#linux-desktop">Linux Desktop</a></h1>
<p>If you have any additional Linux-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Desktop Linux is one of the best-supported platforms by Bevy.</p>
<p>There are some development dependencies you may need to setup, depending on your
distribution. <a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">See instructions in official Bevy repo.</a></p>
<p><a href="platforms//setup/cross/linux-windows.html">See here if you also want to build Windows EXEs from Linux</a>.</p>
<p>linuxæ¡Œé¢æ˜¯bevyæ”¯æŒæœ€å¥½çš„.ä¸åŒçš„å‘è¡Œç‰ˆæœ¬åªéœ€è¦å®‰è£…ä¸€äº›å¿…è¦çš„ä»¥æ¥å°±å¯ä»¥æ„‰å¿«ç©è€äº†.</p>
<h2 id="gpu-drivers-1"><a class="header" href="#gpu-drivers-1">GPU Drivers</a></h2>
<p>Bevy apps need support for the Vulkan graphics API to run best. There is a
fallback on OpenGL ES 3 for systems where Vulkan is unsupported, but it might not
work and will have limited features and performance.</p>
<p>You (and your users) must ensure that you have compatible hardware and drivers
installed. On most modern distributions and computers, this should be no problem.</p>
<p>If Bevy apps refuse to run and print an error to the console about not being
able to find a compatible GPU, the problem is most likely with the Vulkan
components of your graphics driver not being installed correctly. You may
need to install some extra packages or reinstall your graphics drivers. Check
with your Linux distribution for what to do.</p>
<p>To confirm that Vulkan is working, you can try to run this command (found in
a package called <code>vulkan-tools</code> on most distributions):</p>
<pre><code class="language-sh">vulkaninfo
</code></pre>
<p>bevyå¯¹vulkanå›¾å½¢apiæ”¯æŒçš„æœ€å¥½.(vulkanæ˜¯ä¸€ä¸ªç»„ç»‡ç»´æŠ¤çš„æ ‡å‡†,wgpu/ç­‰å¤šä¸ªæ ‡å‡†éƒ½æ˜¯å¥¹ç»´æŠ¤çš„).
å…¶æ¬¡æ˜¯OpenGl ES3, è¿™ä¸ªæ˜¯æ€§èƒ½å’ŒåŠŸèƒ½ä¸Šæ¯”vulkanå·®äº†ä¸€æˆª.</p>
<p>ä¸€èˆ¬åªè¦å®‰è£…å¥½é©±åŠ¨,åŸºæœ¬æ²¡å•¥å¤§é—®é¢˜.
å¦‚æœappè¿è¡ŒæŠ¥é”™è¯´æ²¡æœ‰æ‰¾åˆ°å…¼å®¹çš„GPU,ä¸€èˆ¬æ˜¯vulkané©±åŠ¨æ²¡æœ‰æ­£ç¡®å®‰è£….
é‡æ–°å®‰è£…vulkané©±åŠ¨.ä½¿ç”¨<code>vulkaninfo</code>å‘½ä»¤æ¥æ£€æŸ¥vulkançš„è¿è¡ŒçŠ¶æ€.</p>
<h2 id="x11-and-wayland"><a class="header" href="#x11-and-wayland">X11 and Wayland</a></h2>
<p>As of the year 2023, the Linux desktop ecosystem is fragmented between
the legacy X11 stack and the modern Wayland stack. Many distributions are
switching to Wayland-based desktop environments by default.</p>
<p>Bevy supports both, but only X11 support is enabled by default. If you are
running a Wayland-based desktop, this means your Bevy app will run in the
XWayland compatibility layer.</p>
<p>To enable native Wayland support for Bevy, enable the <code>wayland</code> cargo feature:</p>
<pre><code class="language-toml">[dependencies]
bevy = { version = "0.12", features = ["wayland"] }
</code></pre>
<p>Now your app will be built with support for both X11 and Wayland.</p>
<p>If you want to remove X11 support for whatever reason, you will have to disable
the default features and re-enable everything you need, without the <code>x11</code>
feature. <a href="platforms//setup/bevy-config.html">See here to learn how to configure Bevy features.</a></p>
<p>If both are enabled, you can override which display protocol to use at runtime,
using an environment variable:</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=x11
</code></pre>
<p>(to run using X11/XWayland on a Wayland desktop)</p>
<p>or</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=wayland
</code></pre>
<p>(to require the use of Wayland)</p>
<p>x11å’Œwaylandæ˜¯linuxçš„æ¡Œé¢åç«¯,x11å‡ åå¹´äº†,ç¨³å®š; waylandæ˜¯æ–°æ ‡å‡†,æ›´åŠ ç°ä»£åŒ–å’Œé«˜æ•ˆ.
bevyé»˜è®¤æ˜¯æ”¯æŒx11çš„,å› ä¸ºä½¿ç”¨x11çš„å¤š.</p>
<p>å¦‚æœä¸¤ä¸ªéƒ½å¯ç”¨äº†,é‚£ä¹ˆä½¿ç”¨ç¯å¢ƒå˜é‡æ¥é€‰æ‹©æ¡Œé¢åç«¯,å¦‚ä¸Šé¢çš„ä¾‹å­.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="macos-desktop"><a class="header" href="#macos-desktop">macOS Desktop</a></h1>
<p>If you have any additional macOS-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p><a href="platforms//setup/cross/macos-windows.html">See here if you also want to build Windows EXEs from macOS</a>.</p>
<h2 id="known-pitfalls-3"><a class="header" href="#known-pitfalls-3">Known Pitfalls</a></h2>
<h3 id="input-peculiarities"><a class="header" href="#input-peculiarities">Input Peculiarities</a></h3>
<p><a href="platforms//input/mouse.html#mouse-scrolling--wheel">Mouse wheel scrolling</a> behaves in a peculiar manner,
because macOS does "scroll acceleration" at the OS level. Other OSs, with
regular PC mice, provide <code>Line</code> scroll events with whole number values, where
1.0 corresponds to one step on the scroll wheel. macOS scales the value
depending on how fast the user is spinning the wheel. You do not get whole
numbers. They can range anywhere from tiny values &lt;0.1 (for the starting event,
before the scroll speed ramps up), up to values as big as &gt;10.0 (say, for a fast
flick of the wheel), per event.</p>
<p>macOS provides <a href="platforms//input/mouse.html#touchpad-gestures">special events for touchpad gestures</a>
for zooming and rotation, which you can handle in Bevy.</p>
<p>Some keyboard keys have a somewhat-unintuitive mapping:</p>
<ul>
<li>The Command (âŒ˜) key is <code>KeyCode::{SuperLeft, SuperRight}</code>.</li>
<li>The Option (âŒ¥) key is <code>KeyCode::{AltLeft, AltRight}</code>.</li>
</ul>
<p>Other key codes have their intuitive names.</p>
<h3 id="window-management-apps-compatability"><a class="header" href="#window-management-apps-compatability">Window Management Apps Compatability</a></h3>
<p>Bevy apps can encounter performance issues (such as lag when dragging the window
around the screen) when window management apps like "Magnet" are used. This is a
bug in <code>winit</code> (the OS window management library that Bevy uses). This issue can
be tracked <a href="https://github.com/rust-windowing/winit/issues/1737">here</a>.</p>
<p>Until that bug is fixed, advise closing the window management apps, if
encountering performance issues.</p>
<h2 id="creating-an-application-bundle"><a class="header" href="#creating-an-application-bundle">Creating an Application Bundle</a></h2>
<p>When you build your Bevy project normally, cargo/Rust will produce a bare
executable file, similar to other operating systems. However, this is not how
"normal" macOS apps look and behave. You probably want to create a proper
native-feeling Mac app for distribution to your users.</p>
<p>You need to do this, to have your app play nicely with the Mac desktop GUI, such
as to have a nice icon appear in the dock.</p>
<p>macOS applications are typically stored on the filesystem as "bundles" â€“ special
directories/folders that end in <code>.app</code>, that the OS displays to the user as one
item. macOS expects to find a special hieararchy of subfolders and files inside.</p>
<p>A minimal app bundle might have the following files:</p>
<ul>
<li><code>MyGame.app/Contents/MacOS/MyGame</code>: the actual executable file</li>
<li><code>MyGame.app/Contents/MacOS/assets/</code>: your Bevy assets folder</li>
<li><code>MyGame.app/Contents/Info.plist</code>: metadata (see below)</li>
<li><code>MyGame.app/Contents/Resources/AppIcon.icns</code>: the app's icon</li>
</ul>
<p>Only the executable file is technically mandatory. If you have nothing else, the
app will run, as long as the executable file name matches the app bundle file
name. You should, however, follow the below instructions, if you want to make a
proper nice Mac app. :)</p>
<h3 id="executable-file"><a class="header" href="#executable-file">Executable File</a></h3>
<p>The executable file produced by the Rust compiler (in the <code>target</code> directory) is
a single-architecture binary for your current development machine. You could
just copy this file into the app bundle, but then you will not support all Mac
hardware natively.</p>
<p>If you want to support both machines with Intel CPUs and with Apple Silicon
(Arm) CPUs, you need to compile for both of them, and then combine them into a
single executable using Apple's <code>lipo</code> tool.</p>
<p>First, make sure you have Rust toolchain support for both architectures installed:</p>
<pre><code class="language-sh">rustup target add x86_64-apple-darwin
rustup target add aarch64-apple-darwin
</code></pre>
<p>Now, you can compile for both architectures:</p>
<pre><code class="language-sh">cargo build --release --target x86_64-apple-darwin
cargo build --release --target aarch64-apple-darwin
</code></pre>
<p>Now, you can combine the two executables into one, for your app bundle.</p>
<pre><code class="language-sh">lipo "target/x86_64-apple-darwin/release/my_game" \
     "target/aarch64-apple-darwin/release/my_game" \
     -create -output "MyGame.app/Contents/MacOS/MyGame"
</code></pre>
<p>Note: please ensure the Bevy <code>dynamic_linking</code> cargo feature is <em><strong>not</strong></em> enabled.</p>
<h3 id="game-assets"><a class="header" href="#game-assets">Game Assets</a></h3>
<p>Your Bevy <code>assets</code> folder needs to be placed alongside the executable file,
for Bevy to find it and be able to load your assets. Just copy it into
<code>Contents/MacOS</code> in your app bundle.</p>
<p>Note: This is not the standard conventional location as prescribed by Apple.
Typically, macOS apps store their data files in <code>Contents/Resources</code>. However,
Bevy will not find them there. Thankfully, Apple does not enforce this, so we
are free to do something unusual when we have to.</p>
<h3 id="infoplist"><a class="header" href="#infoplist"><code>Info.plist</code></a></h3>
<p>This file contains all the metadata that macOS wants.</p>
<p>If you do not create this file, or if it is missing some of the fields, macOS
will try to guess them, so your app can still run. Ideally, you want to create a
proper <code>Info.plist</code> file, to prevent issues.</p>
<p><a href="platforms//dl/Info.plist">Download an example file as a starting point.</a></p>
<p>You can edit this file using Apple XCode or a text editor. Check that all the
values make sense for your app. Pay special attention to these values:</p>
<ul>
<li><code>CFBundleName</code> (Bundle name)
<ul>
<li>Short user-visible name of your app</li>
</ul>
</li>
<li><code>CFBundleDisplayName</code> (Bundle display name)
<ul>
<li>Optional: You can set a longer user-visible name here, if you want</li>
</ul>
</li>
<li><code>CFBundleExecutable</code> (Executable file)
<ul>
<li>The name of the executable file</li>
</ul>
</li>
<li><code>CFIconFile</code> (Icon file)
<ul>
<li>The name of the icon file</li>
</ul>
</li>
<li><code>CFBundleIdentifier</code> (Bundle identifier)
<ul>
<li>Apple wants an ID for your app, in domain format, like: <code>com.mycompany.mygame</code></li>
</ul>
</li>
<li><code>CFBundleShortVersionString</code> (Bundle version string (short))
<ul>
<li>The version of your app, like <code>0.1.0</code>.</li>
</ul>
</li>
</ul>
<h3 id="app-icon"><a class="header" href="#app-icon">App Icon</a></h3>
<p>The icon file needs to be in a special Apple format.</p>
<p>Such a file can be created from a collection of PNGs of different standard sizes
(powers of two). If you want your app to look nice at all sizes, you can
hand-craft an image for each size, following <a href="https://developer.apple.com/design/human-interface-guidelines/app-icons">Apple Design
Guidelines</a>. If you don't care, you can just take one image
(ideally 1024x1024, the biggest size used by macOS) and scale it to different sizes.</p>
<p>Here is a script that does that:</p>
<pre><code class="language-sh">SOURCE_IMAGE="myicon1024.png"
mkdir -p AppIcon.iconset
sips -z 16 16     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_16x16.png
sips -z 32 32     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_16x16@2x.png
sips -z 32 32     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_32x32.png
sips -z 64 64     "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_32x32@2x.png
sips -z 128 128   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_128x128.png
sips -z 256 256   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_128x128@2x.png
sips -z 256 256   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_256x256.png
sips -z 512 512   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_256x256@2x.png
sips -z 512 512   "${SOURCE_IMAGE}" --out AppIcon.iconset/icon_512x512.png
cp "${SOURCE_IMAGE}" AppIcon.iconset/icon_512x512@2x.png
iconutil -c icns AppIcon.iconset
## move it into the app bundle
mv AppIcon.icns MyGame.app/Contents/Resources
</code></pre>
<p>It works by creating a special <code>iconset</code> folder, with all the PNG files at different
sizes, created by resizing your source image. Then, it uses <code>iconutil</code> to produce
the final Apple ICNS file for your app bundle.</p>
<p>If you want hand-crafted icons for each size, you could use a similar process.
Create an <code>iconset</code> folder with your PNGs, and run <code>iconutil -c icns</code> on it.</p>
<p>Alternatively, Apple XCode has GUI tools for creating and editing app icons.</p>
<h3 id="putting-everything-together"><a class="header" href="#putting-everything-together">Putting Everything Together</a></h3>
<p>Here is a simple shell script to build a Mac app. It follows the recommendations
on this page. Adjust everything as necessary for your project.</p>
<pre><code class="language-sh"># set the name of the Mac App
APP_NAME="MyGame"
# set the name of your rust crate
RUST_CRATE_NAME="my_game"
# create the folder structure
mkdir -p "${APP_NAME}.app/Contents/MacOS"
mkdir -p "${APP_NAME}.app/Contents/Resources"
# copy Info.plist
cp Info.plist "${APP_NAME}.app/Contents/Info.plist"
# copy the icon (assuming you already have it in Apple ICNS format)
cp AppIcon.icns "${APP_NAME}.app/Contents/Resources/AppIcon.icns"
# copy your Bevy game assets
cp -a assets "${APP_NAME}.app/Contents/MacOS/"
# compile the executables for each architecture
cargo build --release --target x86_64-apple-darwin # build for Intel
cargo build --release --target aarch64-apple-darwin # build for Apple Silicon
# combine the executables into a single file and put it in the bundle
lipo "target/x86_64-apple-darwin/release/${RUST_CRATE_NAME}" \
     "target/aarch64-apple-darwin/release/${RUST_CRATE_NAME}" \
     -create -output "${APP_NAME}.app/Contents/MacOS/${APP_NAME}"
</code></pre>
<p>Note: please ensure the Bevy <code>dynamic_linking</code> cargo feature is <em><strong>not</strong></em> enabled.</p>
<h2 id="creating-a-dmg-file"><a class="header" href="#creating-a-dmg-file">Creating a DMG file</a></h2>
<p>It is common for Mac apps downloadable from the internet to be distributed as
DMG files â€“ Apple's "disk image" format. Users can drag-and-drop the app bundle
inside into their <code>Applications</code> folder on their system.</p>
<h3 id="create-dmg"><a class="header" href="#create-dmg"><code>create-dmg</code></a></h3>
<p>If you want to create a fancy DMG file, you can install and use the
<a href="https://github.com/create-dmg/create-dmg"><code>create-dmg</code> tool</a>.</p>
<p>If you are using Homebrew, you can install it easily from there:</p>
<pre><code class="language-sh">brew install create-dmg
</code></pre>
<p>Then, you can use it as follows:</p>
<pre><code class="language-sh">create-dmg \
  --volname "My Bevy Game" \
  --volicon "AppIcon.icns" \
  --background "DMG-background.png" \
  --window-size 800 400 \
  --icon-size 128 \
  --icon "MyGame.app" 200 200 \
  --hide-extension "MyGame.app" \
  --app-drop-link 600 200 \
  "mybevygame_release_mac.dmg" \
  "build/mac/"
</code></pre>
<p>The options are:</p>
<ul>
<li><code>--volname</code>: the name of the device when the user opens the DMG file</li>
<li><code>--volicon</code>: the icon of the device when the user opens the DMG file</li>
<li><code>--background</code>: the background image for the Finder window</li>
<li><code>--window-size</code>: the size of the Finder window</li>
<li><code>--icon-size</code>: the default zoom level (how big the icons should look)</li>
<li><code>--icon</code>: specify the X/Y coordinates where to display a specific file</li>
<li><code>--hide-extension</code>: do not display the file extension for this file</li>
<li><code>--app-drop-link</code>: create a shortcut to Applications for easy drag-and-drop; place at given X/Y coordinates</li>
<li>the name of the DMG file to create</li>
<li>the name of the folder where you have the files to be added to the DMG (your app + anything else you want to add)</li>
</ul>
<h3 id="hdiutil"><a class="header" href="#hdiutil"><code>hdiutil</code></a></h3>
<p>If you don't want to install any special tools, you can create a very simple
DMG file using <code>hdiutil</code>, which comes with macOS:</p>
<pre><code class="language-sh">hdiutil create -fs HFS+ \
  -volname "My Bevy Game" \
  -srcfolder "MyGame.app" \
  "mybevygame_release_mac.dmg"
</code></pre>
<p>Specify the Volume Name (how it appears when opened), the name of your app
bundle, and the name of the output DMG file, respectively. You can use
<code>-srcfolder</code> multiple times, if you want to add more files and folders to the
DMG image.</p>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<p>If you want to create a DMG file using a GUI, you can use Apple's "Disk
Utility" app that comes preinstalled with macOS. Then, just use Finder to
set up everything inside how you like it.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="windows-desktop"><a class="header" href="#windows-desktop">Windows Desktop</a></h1>
<p>If you have any additional Windows-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Windows is one of the best-supported platforms by Bevy.</p>
<p>Both the MSVC and the GNU compiler toolchains should work.</p>
<p>You can also build Windows EXEs while working in <a href="platforms//setup/cross/linux-windows.html">Linux</a>
or <a href="platforms//setup/cross/macos-windows.html">macOS</a>.</p>
<p>If you want to work inside WSL2, see <a href="platforms//platforms/windows/wsl2.html">this guide</a>.</p>
<h2 id="distributing-your-app"><a class="header" href="#distributing-your-app">Distributing Your App</a></h2>
<p>The EXE built with <code>cargo build</code> can work standalone without any extra files or DLLs.</p>
<p>Your <code>assets</code> folder needs be distributed alongside it. Bevy will search for it in
the same directory as the EXE on the user's computer.</p>
<p>The easiest way to give your game to other people to play is to put them
together in a ZIP file. If you use some other method of installation,
install the <code>assets</code> folder and the EXE to the same path.</p>
<p>If built with the MSVC toolchain, your users may need the Microsoft C/C++
Runtime Redistributables installed.</p>
<h3 id="dxc-compiler-support"><a class="header" href="#dxc-compiler-support">DXC Compiler Support</a></h3>
<p>Bevy (technically <code>wgpu</code>) supports using the Microsoft DXC compiler for
improved shader compilation when using DirectX 12.</p>
<p>To do this, you need to <a href="https://github.com/microsoft/DirectXShaderCompiler/releases/latest">download it from Microsoft's
repo</a> and put <code>dxcompiler.dll</code> and <code>dxil.dll</code>
alongside your game's EXE.</p>
<p>Bevy should detect these DLL files automatically and use them.</p>
<h2 id="disabling-the-windows-console"><a class="header" href="#disabling-the-windows-console">Disabling the Windows Console</a></h2>
<p>By default, when you run a Bevy app (or any Rust program for that matter)
on Windows, a Console window also shows up. To disable this,
place this Rust attribute at the top of your <code>main.rs</code>:</p>
<pre><code class="language-rust no_run noplayground">#![windows_subsystem = "windows"]</code></pre>
<p>This tells Windows that your executable is a graphical application, not a
command-line program. Windows will know not display a console.</p>
<p>However, the console can be useful for development, to see log messages.
You can disable it only for release builds, and leave it enabled in debug
builds, like this:</p>
<pre><code class="language-rust no_run noplayground">#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]</code></pre>
<h2 id="creating-an-icon-for-your-app"><a class="header" href="#creating-an-icon-for-your-app">Creating an icon for your app</a></h2>
<p>There are two places where you might want to put your application icon:</p>
<ul>
<li>The EXE file (how it looks in the file explorer)</li>
<li>The window at runtime (how it looks in the taskbar and the window title bar)</li>
</ul>
<h3 id="setting-the-exe-icon"><a class="header" href="#setting-the-exe-icon">Setting the EXE icon</a></h3>
<p>(adapted from <a href="https://github.com/NiklasEi/bevy_game_template">here</a>)</p>
<p>The EXE icon can be set using a cargo build script.</p>
<p>Add a build dependency of <code>embed_resources</code> to your <code>Cargo.toml</code> allow embedding assets into your compiled executables</p>
<pre><code class="language-toml">[build-dependencies]
embed-resource = "1.6.3"
</code></pre>
<p>Create a <code>build.rs</code> file in your project folder:</p>
<pre><code class="language-rust no_run noplayground">extern crate embed_resource;

fn main() {
    let target = std::env::var("TARGET").unwrap();
    if target.contains("windows") {
        embed_resource::compile("icon.rc");
    }
}</code></pre>
<p>Create a <code>icon.rc</code> file in your project folder:</p>
<pre><code>app_icon ICON "icon.ico"
</code></pre>
<p>Create your icon as <code>icon.ico</code> in your project folder.</p>
<h3 id="setting-the-window-icon-1"><a class="header" href="#setting-the-window-icon-1">Setting the Window Icon</a></h3>
<p>See: <a href="platforms//window/icon.html">Setting the Window Icon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/windows//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h2 id="working-in-wsl2"><a class="header" href="#working-in-wsl2">Working in WSL2</a></h2>
<p>If you prefer to have a more Linux-centric development workflow, you might want
to work inside of WSL2 and build your project there. Another reason to do it is
compile times; they are often much faster in WSL2 than on the Windows host
system. Linux has faster I/O and filesystem than Windows, and that makes a big
difference to compile times.</p>
<h3 id="cross-compiling-to-run-windows-native"><a class="header" href="#cross-compiling-to-run-windows-native">Cross-compiling to run Windows Native</a></h3>
<p>The recommended way to run your Bevy app from WSL is to <a href="platforms/windows//setup/cross/linux-windows.html">cross-compile for
Windows</a>. The Windows EXE you build inside of WSL2 can
be run just fine from the Linux commandline, and it will seamlessly run on the
host system! This way, you don't need any GPU drivers or GUI support inside
your WSL2 Linux environment. Also, you will be running and testing the Windows
build of your game, so you can see how it will really perform on Windows.
It will run with full performance and use your host Windows GPU drivers.</p>
<p>Note that when you run Windows binaries from WSL2, they don't get the Linux
environment variables. <code>cargo run</code> does not just work, because your Bevy game
will look for its <code>assets</code> folder in the path where the EXE is (which would be
in the <code>target</code> build output folder). My simple solution is to just copy the
EXE into the project folder after building, and run it directly from there.
For non-Bevy Rust projects, this would be unnecessary.</p>
<p>The process can be automated with a little script, to use instead of <code>cargo run</code>:</p>
<pre><code class="language-sh">#!/bin/sh
cargo build --target x86_64-pc-windows-gnu &amp;&amp;
cp target/x86_64-pc-windows-gnu/debug/mygame.exe . &amp;&amp;
exec ./mygame.exe "$@"
</code></pre>
<p>This way you also don't have to type the cross-compilation target every time
(and you can also add any other options you want there).</p>
<p>Just save the script (you can call it something like <code>win.sh</code>) and run your
game as:</p>
<pre><code class="language-sh">./win.sh
</code></pre>
<h3 id="running-linux-builds-using-wslg"><a class="header" href="#running-linux-builds-using-wslg">Running Linux builds using WSLg</a></h3>
<p>This is an alternative way of running your Bevy game from WSL. It does not
require cross-compilation, but is likely to have other issues and limitations.</p>
<p>Newer installs of WSL2 should have support for WSLg: Microsoft's Linux GUI
support. It should allow you to simply compile your Bevy game in Linux and
run it. WSLg will do the dark magic needed to forward graphics and audio to
the Windows host.</p>
<p>Your game will run locked to 60 FPS, and there will be other performance
problems. WSLg is effectively RDP (Remote Desktop) under the hood. It's
like streaming video from the VM to the host. Some functionality might be
broken/unsupported.</p>
<p>Both Wayland and X11 should work. Wayland is recommended, so be sure to
enable the <code>"wayland"</code> <a href="platforms/windows//setup/bevy-config.html">cargo feature in Bevy</a>.</p>
<p>There are many dependencies (such as graphics drivers) needed for GUI support
in Linux, which are likely missing if you have never used any other GUI app
from your WSL environment. The easiest way to make sure you have everything installed,
is to just install some random Linux GUI app. For example:</p>
<pre><code class="language-sh">sudo apt install gucharmap # the GNOME Character Map app
</code></pre>
<p>It will pull in everything needed for a Linux GUI environment. Bevy should then
also be able to work.</p>
<p>This will be sufficient for OpenGL support. However, to use all features of
Bevy, you need Vulkan. For Vulkan in WSL, it is recommended that you use
a PPA (unofficial repository) to get an updated version of Mesa (graphics
drivers). Here is how to install everything:</p>
<pre><code class="language-sh">sudo add-apt-repository ppa:kisak/kisak-mesa
sudo apt update
sudo apt upgrade
sudo apt install vulkan-tools
</code></pre>
<p>(<code>dzn</code>, Microsoft's Vulkan driver for WSL2, is technically non-conformant,
so there may be bugs and other issues, but it seems to work fine)</p>
<p>Now, you can simply run your Bevy project in Linux in the usual way:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="browser-webassembly"><a class="header" href="#browser-webassembly">Browser (WebAssembly)</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>You can make web browser games using Bevy. This chapter will help you with
the things you need to know to do it. This page gives an overview of Bevy's
Web support.</p>
<p>Your Bevy app will be compiled for WebAssembly (WASM), which allows it to
be embedded in a web page and run inside the browser.</p>
<p>Performance will be limited, as WebAssembly is slower than native code and
does not currently support multithreading.</p>
<p>Not all 3rd-party plugins are compatible. If you need extra unofficial plugins,
you will have to check if they are compatible with WASM.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The same Bevy project, without any special code modifications, can be built
for either web or desktop/native.</p>
<p>However, you will need a "website" with some HTML and JavaScript to contain the
game, so that the browser can load, run, and display it.</p>
<p>For development and testing, this can just be a minimal shim.
It can be easily autogenerated.</p>
<p>To deploy, you will need a server to host your website for other people to
access. You could use GitHub's hosting service: <a href="platforms//platforms/wasm/gh-pages.html">GitHub Pages</a>.
You can also host your game on <a href="platforms//platforms/wasm/itch.html">itch.io</a>.</p>
<h2 id="additional-caveats"><a class="header" href="#additional-caveats">Additional Caveats</a></h2>
<p>When users want to play your game, their browser will need to download the
files. <a href="platforms//platforms/wasm/size-opt.html">Optimizing for size</a> is important, so that your game can
start faster and not waste data bandwidth.</p>
<p>Note: the <code>dynamic_linking</code> <a href="platforms//setup/bevy-config.html">feature flag</a> is not supported for
WASM builds. You cannot use it.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>First, add WASM support to your Rust installation. Using Rustup:</p>
<pre><code class="language-sh">rustup target install wasm32-unknown-unknown
</code></pre>
<h3 id="wasm-server-runner"><a class="header" href="#wasm-server-runner"><code>wasm-server-runner</code></a></h3>
<p>The easiest and most automatic way to get started is the
<a href="https://github.com/jakobhellermann/wasm-server-runner"><code>wasm-server-runner</code></a> tool.
It is great for testing during development.</p>
<p>Install it:</p>
<pre><code class="language-sh">cargo install wasm-server-runner
</code></pre>
<p>Set up <code>cargo</code> to use it, in <code>.cargo/config.toml</code> (in your project folder,
or globally in your user home folder):</p>
<pre><code class="language-toml">[target.wasm32-unknown-unknown]
runner = "wasm-server-runner"
</code></pre>
<p>Alternatively, you can also set the runner using an environment variable:</p>
<pre><code>export CARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER=wasm-server-runner
</code></pre>
<p>Now you can just run your game with:</p>
<pre><code class="language-sh">cargo run --target wasm32-unknown-unknown
</code></pre>
<p>It will automatically run a minimal local webserver and open your game in your browser.</p>
<h3 id="higher-level-tools"><a class="header" href="#higher-level-tools">Higher-level Tools</a></h3>
<p>Here are some higher-level alternatives. These are feature-rich tools that can
do more for you and automate much of your workflow, but are opinionated in how
they work.</p>
<ul>
<li><a href="https://trunkrs.dev">Trunk</a></li>
<li><a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a></li>
</ul>
<h3 id="custom-web-page"><a class="header" href="#custom-web-page">Custom Web Page</a></h3>
<p>If you are a web developer and you want to make your own website where you embed
your Bevy game, <a href="platforms//platforms/wasm/webpage.html">see here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="optimize-for-size"><a class="header" href="#optimize-for-size">Optimize for Size</a></h1>
<p>When serving a WASM binary, the smaller it is, the faster the browser can
download it. Faster downloads means faster page load times and less data
bandwidth use, and that means happier users and happier server hosts. ;)</p>
<p>This page gives some suggestions for how to make your WASM files smaller for
deployment / release builds. You probably don't need small WASM files during
development, and many of these techniques can get in the way of your workflow!
They come at the cost of longer compile times and less debuggability.</p>
<p>Depending on the nature of your application, your mileage may vary, and
performing measurements of binary size and execution speed is recommended.</p>
<p><a href="https://github.com/rustwasm/twiggy">Twiggy</a> is a code size profiler for WASM binaries, which
you can use to make measurements.</p>
<p>For additional information and more techniques, refer to the Code Size
chapter in the <a href="https://rustwasm.github.io/docs/book/reference/code-size.html">Rust WASM book</a>.</p>
<p>Do you know of more WASM size-optimization techniques? Post about them in the
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub Issue Tracker</a> so that they can be added to this page!</p>
<h2 id="compiling-for-size-instead-of-speed"><a class="header" href="#compiling-for-size-instead-of-speed">Compiling for size instead of speed</a></h2>
<p>You can change the optimization profile of the compiler, to tell it to
prioritize small output size, rather than performance.</p>
<p>(although in some rare cases, optimizing for size can actually improve speed)</p>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>These are two different profiles for size optimization. Usually, <code>z</code> produces
smaller files than <code>s</code>, but sometimes it can be the opposite. Measure to
confirm which one works better for you.</p>
<h2 id="link-time-optimization-lto"><a class="header" href="#link-time-optimization-lto">Link-Time Optimization (LTO)</a></h2>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<p>For some big improvements with moderate slowdown to compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = "thin"
</code></pre>
<p>For the biggest improvements at the cost of the slowest compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = true
codegen-units = 1
</code></pre>
<p>LTO tells the compiler to optimize all code together, considering all crates as
if they were one. It may be able to inline and prune functions much more
aggressively. This typically results in smaller size <em>and</em> better performance,
but do measure to confirm. Sometimes, the size can actually be larger.</p>
<h2 id="use-the-wasm-opt-tool"><a class="header" href="#use-the-wasm-opt-tool">Use the <code>wasm-opt</code> tool</a></h2>
<p>The <a href="https://github.com/WebAssembly/binaryen">binaryen</a> toolkit is a set of extra tools for working
with WASM. One of them is <code>wasm-opt</code>. It goes much further than what the
compiler can do, and can be used to further optimize for either speed or size:</p>
<pre><code class="language-shell"># Optimize for size (z profile).
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for size (s profile).
wasm-opt -Os -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O3 -o output.wasm input.wasm

# Optimize for both size and speed.
wasm-opt -O -ol 100 -s 100 -o output.wasm input.wasm
</code></pre>
<p>You should run this command on the final WASM file you deploy to your website,
after <code>wasm-bindgen</code> or other tools. If you run it before, <code>wasm-bindgen</code> can
get confused and panic.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="create-a-custom-web-page"><a class="header" href="#create-a-custom-web-page">Create a Custom Web Page</a></h1>
<p>If you want full control over your website, such as if you are a web developer
and you want to embed your Bevy game into a nice website you made, this page
will offer some tips.</p>
<h2 id="wasm-bindgen"><a class="header" href="#wasm-bindgen"><code>wasm-bindgen</code></a></h2>
<p>This is the "low level" tool for exporting/preparing a Rust WASM binary, so
it can be integrated into HTML/JS. It generates the bridge to JavaScript,
so that Rust/Bevy can work with the browser.</p>
<p>You will need to run it whenever you rebuild your game, to process the WASM
binaries generated by <code>cargo</code>.</p>
<p>You can install it using <code>cargo</code>:</p>
<pre><code class="language-sh">cargo install wasm-bindgen-cli
</code></pre>
<p>Now, to build your game, run:</p>
<pre><code class="language-sh">cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --no-typescript --target web \
    --out-dir ./out/ \
    --out-name "mygame" \
    ./target/wasm32-unknown-unknown/release/mygame.wasm
</code></pre>
<p>You need to provide the path to the compiled WASM binary in cargo's target directory.
It will be renamed according to the <code>--out-name</code> parameter.</p>
<p><code>./out/</code> is the directory where it will place the processed files. You will be
uploading these files to your server. You need to also put the <code>assets</code> folder
there. Bevy will expect to find it alongside the WASM file.</p>
<p>The final list of files for a minimal website will look something like this:</p>
<pre><code>assets/ index.html mygame.js mygame_bg.wasm
</code></pre>
<p>In a more compex website, you might want to have the game files be in a
subdirectory somewhere, and load them from a HTML file elsewhere.</p>
<p>For the HTML file, you can use this as a starting point:</p>
<details>
  <summary>
  <code>index.html</code>
  </summary>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;body style="margin: 0px;"&gt;
  &lt;script type="module"&gt;
    import init from './mygame.js'

    init().catch((error) =&gt; {
      if (!error.message.startsWith("Using exceptions for control flow, don't mind me. This isn't actually an error!")) {
        throw error;
      }
    });
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>Note: change <code>mygame.js</code> above to the actual name of the file outputted by <code>wasm-bindgen</code>.
It will match the <code>--out-name</code> parameter you provided on the commandline.</p>
<p>This minimal <code>index.html</code> will just display the Bevy game, without giving you
much control over the presentation. By default, Bevy will create its own HTML
canvas element to render in.</p>
</details>
<p>You can optionally run tools like <code>wasm-opt</code> on the final WASM file, to
<a href="platforms/wasm//platforms/wasm/size-opt.html">optimize the WASM further for size</a>. Run such tools <em>after</em>
<code>wasm-bindgen</code>, not on the original WASM file. Otherwise, <code>wasm-bindgen</code> will
panic with an error if you give it a file processed with <code>wasm-opt</code>.</p>
<h2 id="embedding-into-a-complex-web-page"><a class="header" href="#embedding-into-a-complex-web-page">Embedding into a complex web page</a></h2>
<p>You probably want control over how/where the game is displayed, so you can place
it on a fancier web page, alongside other content.</p>
<h3 id="iframe"><a class="header" href="#iframe">IFrame</a></h3>
<p>A simple/hacky way is using an IFrame. The advantage is that you don't need any
modifications to the Rust code.</p>
<p>You can create a minimal <code>index.html</code> as was shown previously.</p>
<p>You can then embed that into your larger webpage using a HTML IFrame element:</p>
<pre><code class="language-html">&lt;iframe id="mygame-iframe" src="wasm/index.html" width="1280" height="720"&gt;&lt;/iframe&gt;
</code></pre>
<p>You can place it wherever you like on your web page and style it however you
like using CSS. It is recommended to explicitly specify its dimensions.</p>
<p>Make sure to use the correct path to the HTML file in <code>src</code>. You might want to
rename/move it according to your website's needs.</p>
<h3 id="custom-canvas"><a class="header" href="#custom-canvas">Custom Canvas</a></h3>
<p>A more elegant way to accomplish this is by using your own canvas element. You
don't need a separate HTML file.</p>
<p>Create a HTML canvas and give it an ID string of your choice.</p>
<pre><code class="language-html">&lt;canvas id="mygame-canvas" width="1280" height="720"&gt;&lt;/canvas&gt;
</code></pre>
<p>You can place it wherever you like on your web page and style it however you
like using CSS. It is recommended to explicitly specify its dimensions.</p>
<p>On the Rust side, we need to tell Bevy the ID of the canvas element, so it can
use our canvas instead of trying to create its own.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let mut app = App::new();
    app.add_plugins(DefaultPlugins.set(WindowPlugin {
        primary_window: Some(Window {
            // provide the ID selector string here
            canvas: Some("#mygame-canvas".into()),
            // ... any other window properties ...
            ..default()
        }),
        ..default()
    }));
    // ...
    app.run();
}</code></pre>
<p>Unfortunately, this means if you want to rename the ID of the canvas, you will
have to make sure to update the Rust code and rebuild/redeploy the game.</p>
<h2 id="general-advice"><a class="header" href="#general-advice">General Advice</a></h2>
<p>Bevy WASM binaries are big. Even when [optimized for size][wasm::opt-size], they can be
upwards of 30MB (reduced down to 15MB with <code>wasm-opt</code>).</p>
<p>To make your page fast to load, you might want to delay the loading of the WASM.
Let the user see and interact with the page before you trigger it.</p>
<p>You could use some JavaScript to detect when the user clicks on the canvas, or
have a special button or link to trigger it.</p>
<p>Further, after the WASM loads and your Bevy game is running, your game will
probably want to load assets at runtime. Make sure your assets are
well-compressed/optimized, so they can load quickly. Try to design your game so
that it isn't unresponsive or making the user suffer annoying waits.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div><p style="text-align: center;">
As this page is outdated, please refer to Bevy's official migration guides while reading,
to cover the differences:
<a href="https://bevyengine.org/learn/migration-guides/0-12-to-0-13/">0.12 to 0.13</a>.
</p>
<p style="text-align: center;">
I apologize for the inconvenience. I will update the page as soon as I find the time.
</p>
<hr />
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="hosting-on-github-pages"><a class="header" href="#hosting-on-github-pages">Hosting on GitHub Pages</a></h1>
<p>GitHub Pages is a hosting service that allows you to publish your website
on GitHub's servers.</p>
<p>For more details, visit the official <a href="https://docs.github.com/en/pages">GitHub Pages
documentation</a>.</p>
<p>Deploying a website (like your WASM game) to GitHub pages is done by
putting the files in a special branch in a GitHub repository. You could
create a separate repository for this, but you could also do it from the
same repository as your source code.</p>
<p>You will need the final website files for deployment.</p>
<hr />
<p>Create an empty branch in your git repository:</p>
<pre><code class="language-shell">git checkout --orphan web
git reset --hard
</code></pre>
<p>You should now be in an empty working directory.</p>
<p>Put all files necessary for hosting, including your HTML, WASM, JavaScript,
and <code>assets</code> files, and commit them into git:</p>
<pre><code class="language-shell">git add *
git commit
</code></pre>
<p>(or better, manually list your files in the above command, in place of the <code>*</code> wildcard)</p>
<p>Push your new branch to GitHub:</p>
<pre><code class="language-shell">git push -u origin web --force
</code></pre>
<p>In the GitHub Web UI, go to the repository settings, go to the "GitHub Pages"
section, then under "Source" pick the branch "web" and the <code>/</code> (root) folder.
Then click "Save".</p>
<p>Wait a little bit, and your site should become available at
<code>https://your-name.github.io/your-repo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h1>
<p>This sub-chapter covers how to set up a Rust toolchain to allow you to build
for a different Operating System than the one you are working on.</p>
<ul>
<li><a href="setup//setup/cross/linux-windows.html">Create Windows EXEs from Linux</a></li>
<li><a href="setup//setup/cross/macos-windows.html">Create Windows EXEs from macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/cross//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="build-windows-exes-from-linux"><a class="header" href="#build-windows-exes-from-linux">Build Windows EXEs from Linux</a></h1>
<p>(also check out the <a href="setup/cross//platforms/windows.html">Windows Platform page</a> for info
about developing for Windows generally)</p>
<p>If you are working in WSL2, please also see <a href="setup/cross//platforms/windows/wsl2.html">this page for additional instructions</a>.</p>
<hr />
<p>Rust offers two different toolchains for building for Windows:</p>
<ul>
<li><a href="setup/cross/linux-windows.html#first-time-setup-msvc">MSVC</a></li>
<li><a href="setup/cross/linux-windows.html#first-time-setup-gnu">GNU</a></li>
</ul>
<p>The instructions on this page use the <code>x86_64</code> architecture, but you could also
set up a toolchain to target <code>i686</code> (32-bit) or <code>aarch64</code> (Windows-on-Arm) the
same way.</p>
<h2 id="first-time-setup-gnu"><a class="header" href="#first-time-setup-gnu">First-Time Setup (GNU)</a></h2>
<p>On many Linux distros, the GNU/MINGW toolchain is the easier option. Your
distro likely provides packages that you can easily install. Also, you do
not need to accept any Microsoft licenses.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-gnu"><a class="header" href="#rust-toolchain-gnu">Rust Toolchain (GNU)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="mingw"><a class="header" href="#mingw">MINGW</a></h3>
<p>The GNU toolchain requires the MINGW environment to be installed. Your distro likely
provides a package for it. Search your distro for a cross-compilation mingw package.</p>
<p>It might be called something like: <code>mingw-w64-x86-64-dev</code>, <code>cross-x86_64-w64-mingw32</code>, etc.,
the name varies in different distros.</p>
<p>You don't need any files from Microsoft.</p>
</details>
<h2 id="first-time-setup-msvc"><a class="header" href="#first-time-setup-msvc">First-Time Setup (MSVC)</a></h2>
<p>The MSVC toolchain is the native Microsoft way to target Windows. It is what
the Rust community usually recommends for targetting the Windows platform. It
may provide better compatibility with Windows DLLs / libraries and tooling.</p>
<p>Even though it is meant to be used on Windows, you can actually set it up
and use it on Linux (and other UNIX-like systems). It requires downloading
the Windows SDKs and accepting the Microsoft license. There is a script to
automate that for you.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-msvc"><a class="header" href="#rust-toolchain-msvc">Rust Toolchain (MSVC)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-msvc
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="microsoft-windows-sdks"><a class="header" href="#microsoft-windows-sdks">Microsoft Windows SDKs</a></h3>
<p>You need to install the Microsoft Windows SDKs, just like when working on
Windows. On Linux, this can be done with an easy script called <code>xwin</code>. You
need to accept Microsoft's proprietary license.</p>
<p>Install <code>xwin</code>:</p>
<pre><code class="language-sh">cargo install xwin
</code></pre>
<p>Now, use <code>xwin</code> to accept the Microsoft license, download all the files
from Microsoft servers, and install them to a directory of your choosing.</p>
<p>(The <code>--accept-license</code> option is to not prompt you, assuming you have already
seen the license. To read the license and be prompted to accept it, omit that
option.)</p>
<p>To install to <code>.xwin/</code> in your home folder:</p>
<pre><code class="language-sh">xwin --accept-license splat --output /home/me/.xwin
</code></pre>
<h3 id="linking-msvc"><a class="header" href="#linking-msvc">Linking (MSVC)</a></h3>
<p>Rust needs to know how to link the final EXE file.</p>
<p>The default Microsoft linker (<code>link.exe</code>) is only available on Windows. Instead,
we need to use the LLD linker (this is also recommended when working on Windows
anyway). Just install the <code>lld</code> package from your Linux distro.</p>
<p>We also need to tell Rust the location of the Microsoft Windows SDK libraries
(that were installed with <code>xwin</code> in <a href="setup/cross/linux-windows.html#microsoft-windows-sdks">the previous step</a>).</p>
<p>Add this to <code>.cargo/config.toml</code> (in your home folder or in your bevy project):</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = "lld"
rustflags = [
  "-Lnative=/home/me/.xwin/crt/lib/x86_64",
  "-Lnative=/home/me/.xwin/sdk/lib/um/x86_64",
  "-Lnative=/home/me/.xwin/sdk/lib/ucrt/x86_64"
]
</code></pre>
<p>Note: you need to specify the correct full absolute paths to the SDK files,
wherever you installed them.</p>
</details>
<h2 id="building-your-project"><a class="header" href="#building-your-project">Building Your Project</a></h2>
<p>Finally, with all the setup done, you can just build your Rust/Bevy projects
for Windows:</p>
<p>GNU:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-gnu --release
</code></pre>
<p>MSVC:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<h2 id="bevy-caveats"><a class="header" href="#bevy-caveats">Bevy Caveats</a></h2>
<p>As of Bevy 0.12, a workaround is needed for building with MSVC. If you
use the MSVC toolchain, the <code>blake3</code> dependency assumes you are building
on Windows and tries to run some EXEs during its build process, which do
not exist in the Linux cross-compilation environment. The solution is
to tell it to not do that and use pure Rust code instead.</p>
<p>Set an environment variable when building:</p>
<pre><code class="language-sh">export CARGO_FEATURE_PURE=1
cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<p>Or add <code>blake3</code> to your <code>Cargo.toml</code> if you want to persist the configuration:</p>
<pre><code class="language-toml">[dependencies]
blake3 = { version = "1.5", features = [ "pure" ] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/cross//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="build-windows-exes-from-macos"><a class="header" href="#build-windows-exes-from-macos">Build Windows EXEs from macOS</a></h1>
<p>(also check out the <a href="setup/cross//platforms/windows.html">Windows Platform page</a> for info
about developing for Windows generally)</p>
<hr />
<p>Rust offers two different toolchains for building for Windows:</p>
<ul>
<li><a href="setup/cross/macos-windows.html#first-time-setup-msvc">MSVC</a></li>
<li><a href="setup/cross/macos-windows.html#first-time-setup-gnu">GNU</a></li>
</ul>
<p>The instructions on this page use the <code>x86_64</code> architecture, but you could also
set up a toolchain to target <code>i686</code> (32-bit) or <code>aarch64</code> (Windows-on-Arm) the
same way.</p>
<h2 id="first-time-setup-gnu-1"><a class="header" href="#first-time-setup-gnu-1">First-Time Setup (GNU)</a></h2>
<p>The GNU/MINGW toolchain is the easier option. It does not need much in terms of
special configuration. Also, you do not need to accept any Microsoft licenses.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-gnu-1"><a class="header" href="#rust-toolchain-gnu-1">Rust Toolchain (GNU)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="mingw-1"><a class="header" href="#mingw-1">MINGW</a></h3>
<p>The GNU toolchain requires the MINGW environment to be installed.</p>
<p>There is a package for it conveniently available in Homebrew. You can
just install it from there:</p>
<pre><code class="language-sh">brew install mingw-w64
</code></pre>
<p>You don't need any files from Microsoft.</p>
</details>
<h2 id="first-time-setup-msvc-1"><a class="header" href="#first-time-setup-msvc-1">First-Time Setup (MSVC)</a></h2>
<p>The MSVC toolchain is the native Microsoft way to target Windows. It is what
the Rust community usually recommends for targetting the Windows platform. It
may provide better compatibility with Windows DLLs / libraries and tooling.</p>
<p>Even though it is meant to be used on Windows, you can actually set it up and
use it on macOS (and Linux, and others). It requires downloading the Windows
SDKs and accepting the Microsoft license. There is a script to automate that for
you.</p>
<details>
  <summary>
  Setup Instructions:
  </summary>
<h3 id="rust-toolchain-msvc-1"><a class="header" href="#rust-toolchain-msvc-1">Rust Toolchain (MSVC)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-msvc
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="microsoft-windows-sdks-1"><a class="header" href="#microsoft-windows-sdks-1">Microsoft Windows SDKs</a></h3>
<p>You need to install the Microsoft Windows SDKs, just like when working on
Windows. This can be done with an easy script called <code>xwin</code>. You need to accept
Microsoft's proprietary license.</p>
<p>Install <code>xwin</code>:</p>
<pre><code class="language-sh">cargo install xwin
</code></pre>
<p>Now, use <code>xwin</code> to accept the Microsoft license, download all the files
from Microsoft servers, and install them to a directory of your choosing.</p>
<p>(The <code>--accept-license</code> option is to not prompt you, assuming you have already
seen the license. To read the license and be prompted to accept it, omit that
option.)</p>
<p>To install to <code>.xwin/</code> in your home folder:</p>
<pre><code class="language-sh">xwin --accept-license splat --disable-symlinks --output /Users/me/.xwin
</code></pre>
<p>On Windows and macOS, the filesystem is case-insensitive. On Linux and BSD, the
filesystem is case-sensitive. <code>xwin</code> was made for Linux, so it tries to work
around this by default, by creating symlinks. On macOS, we need to tell <code>xwin</code>
not to do this, using the <code>--disable-symlinks</code> option.</p>
<h3 id="linking-msvc-1"><a class="header" href="#linking-msvc-1">Linking (MSVC)</a></h3>
<p>Rust needs to know how to link the final EXE file.</p>
<p>The default Microsoft linker (<code>link.exe</code>) is only available on Windows. Instead,
we need to use the LLD linker (this is also recommended when working on Windows
anyway).</p>
<h4 id="installing-lld"><a class="header" href="#installing-lld">Installing LLD</a></h4>
<p>Unfortunately, last I checked, neither <code>brew</code> nor <code>macports</code> offer packages (LLD
is not commonly used when developing for macOS).</p>
<p>We can, however, build it ourselves from source. You need a C++ compiler and
CMake. You probably already have the C++ toolchain installed, if you have
installed Apple XCode development tools.</p>
<p>CMake can be installed from <code>brew</code> (<a href="https://brew.sh">Homebrew</a>):</p>
<pre><code class="language-sh">brew install cmake
</code></pre>
<p>Now, we are ready to compile LLD from the LLVM project:</p>
<p>Note: the <code>--depth=1</code> option to <code>git clone</code> allows us to save a lot of disk
space and download bandwidth, because the LLVM respository is <em>huge</em>.</p>
<pre><code class="language-sh">git clone --depth=1 https://github.com/llvm/llvm-project
cd llvm-project
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=lld -DCMAKE_INSTALL_PREFIX=/usr/local ../llvm
sudo make -j10 install # adjust `-j10` based on your number of CPU cores
cd ../../; rm -rf llvm-project # delete the git repo and build files to free disk space
</code></pre>
<p>This will install it to <code>/usr/local</code>. Change the path above if you would rather
have it somewhere else, to not pollute your macOS or need <code>sudo</code> / root privileges.</p>
<h4 id="using-lld"><a class="header" href="#using-lld">Using LLD</a></h4>
<p>We also need to tell Rust to use our linker, and the location of the Microsoft
Windows SDK libraries (that were installed with <code>xwin</code> in <a href="setup/cross/macos-windows.html#microsoft-windows-sdks">the previous
step</a>).</p>
<p>Add this to <code>.cargo/config.toml</code> (in your home folder or in your bevy project):</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = "/usr/local/bin/lld"
rustflags = [
  "-Lnative=/Users/me/.xwin/crt/lib/x86_64",
  "-Lnative=/Users/me/.xwin/sdk/lib/um/x86_64",
  "-Lnative=/Users/me/.xwin/sdk/lib/ucrt/x86_64"
]
</code></pre>
<p>Note: you need to specify the correct full absolute paths to the SDK files,
wherever you installed them.</p>
</details>
<h2 id="building-your-project-1"><a class="header" href="#building-your-project-1">Building Your Project</a></h2>
<p>Finally, with all the setup done, you can just build your Rust/Bevy projects
for Windows:</p>
<p>GNU:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-gnu --release
</code></pre>
<p>MSVC:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<h2 id="bevy-caveats-1"><a class="header" href="#bevy-caveats-1">Bevy Caveats</a></h2>
<p>As of Bevy 0.12, a workaround is needed for building with MSVC. If you
use the MSVC toolchain, the <code>blake3</code> dependency assumes you are building
on Windows and tries to run some EXEs during its build process, which do
not exist in the Linux cross-compilation environment. The solution is
to tell it to not do that and use pure Rust code instead.</p>
<p>Set an environment variable when building:</p>
<pre><code class="language-sh">export CARGO_FEATURE_PURE=1
cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<p>Or add <code>blake3</code> to your <code>Cargo.toml</code> if you want to persist the configuration:</p>
<pre><code class="language-toml">[dependencies]
blake3 = { version = "1.5", features = [ "pure" ] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="credits"><a class="header" href="#credits">Credits</a></h1>
<p>While the majority of this book was authored by me, Ida Iyes (<code>@inodentry</code>), a
number of folks have made large contributions to help! Thank you all so much! â¤ï¸</p>
<hr />
<ul>
<li>Alice I. Cecile <code>@alice-i-cecile</code>: review, advice, reporting lots of good suggestions</li>
<li>nile <code>@TheRawMeatball</code>: review, useful issue reports</li>
<li><code>@Zaszi</code>: writing the initial draft of the WASM chapter</li>
<li><code>@skairunner</code> and <code>@mirenbharta</code>: developing the Pan+Orbit camera example</li>
</ul>
<p>Thanks to everyone who has submitted <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub issues</a>!</p>
<hr />
<p>Big thanks to all <a href="https://github.com/sponsors/inodentry">sponsors</a>! â¤ï¸</p>
<p>Thanks to you, I can actually keep working on this book, improving and maintaining it!</p>
<hr />
<p>And of course, the biggest thanks goes to the <a href="https://github.com/bevyengine/bevy">Bevy project</a>
itself and its founder, <code>@cart</code>, for creating this awesome community and
game engine in the first place! It makes all of this possible. You literally
changed my life! â¤ï¸</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="contact-me"><a class="header" href="#contact-me">Contact Me</a></h1>
<p>You can find me in the following places:</p>
<ul>
<li>Discord: <code>@iyesgames</code>, old: <code>Ida Iyes#0981</code></li>
<li>Mastodon: <a href="https://mastodon.gamedev.place/@iyes"><code>@iyes@mastodon.gamedev.place</code></a></li>
<li>GitHub: <a href="https://github.com/inodentry"><code>@inodentry</code></a></li>
<li>Reddit: <a href="https://reddit.com/u/iyesgames"><code>iyesgames</code></a></li>
<li>E-mail: iyesgames dot social at gmail (sorry, i'm writing it out like this to avoid spam bots)</li>
</ul>
<p>For improvements or fixes to this book, please file an issue
on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub</a>.</p>
<hr />
<p>If you need help with Bevy or Rust, I offer private tutoring.
Reach out if you are interested, to discuss rates and how I
could best help you. :)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="contributing-to-bevy"><a class="header" href="#contributing-to-bevy">Contributing to Bevy</a></h1>
<p>If you want to help out the Bevy Game Engine project, check out Bevy's
<a href="https://github.com/bevyengine/bevy/blob/main/CONTRIBUTING.md">official contributing guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<p><code>å½“å‰åŒè¯­ç‰ˆæœ¬å¯¹åº”çš„æ˜¯: 3d540e7, æ—¥æœŸ: 2024/06/13, ç­‰åŒè¯­ç‰ˆæœ¬æ•´ä¸ªç¿»è¯‘å®Œä¹‹å,å†å¤„ç†åŸå§‹ä»“åº“çš„æ›´æ–°</code></p>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Be civil. If you need a code of conduct, have a look at Bevy's.</p>
<p>If you have any suggestions for the book, such as ideas for new content, or
if you notice anything that is incorrect or misleading, please file issues in
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">the GitHub repository</a>!</p>
<h2 id="github-issues"><a class="header" href="#github-issues">GitHub Issues</a></h2>
<p>If you want something to be added or changed in the book, <em>file an issue!</em> Tell
me what you want, and I will figure out how to present it in the book. If you
have some code snippet or other thing you want to include, you can
put it in the issue.</p>
<p>That sort of workflow works much better for me, compared to Pull Requests. I am
quite opinionated and meticulous about how everything is presented in the book,
so I often can't just merge/accept things as written by someone else.</p>
<h2 id="github-pull-requests"><a class="header" href="#github-pull-requests">GitHub Pull Requests</a></h2>
<p><strong>PLEASE DO NOT CREATE PULL REQUESTS FOR BOOK CONTENT.</strong></p>
<p>The only exception to this might be trivial fixes. If you are just fixing
a typo or small mistake, or a bug in some code example, that's fine.</p>
<p>If you are adding or changing any of the book content, your PR will probably be
ignored or closed. I will probably treat it like I do issues: go do the thing
myself eventually, and then close your PR.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<p>To avoid complications with copyright and licensing, you agree to provide
any contributions you make to the project under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 No Attribution
License</a>.</p>
<p>Note that this allows your work to be relicensed without preserving your
copyright.</p>
<p>As described previously, the actual published content in the book will be my
own derivative work based on your contributions. I will license it consistently
with the rest of the book; see: <a href="./introduction.html#license">License</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="nagbar.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
